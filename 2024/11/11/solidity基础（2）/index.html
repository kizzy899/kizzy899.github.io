<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>solidity基础002 | EIGHTJIU</title><meta name="author" content="kizy"><meta name="copyright" content="kizy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关键词：constructor&amp;Modifier  event 继承 接口 异常 重载 库合约 引用 回调 构造函数constructor和修饰器Modifierconstructor  定义：是一种特殊函数 每个合约可以定义一个，并且在部署合约时自动运行一次。 可用于初始化合约参数： 123456789101112131415161718&#x2F;&#x2F; SPDX-License-Identifie">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity基础002">
<meta property="og:url" content="https://kizzy899.github.io/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/index.html">
<meta property="og:site_name" content="EIGHTJIU">
<meta property="og:description" content="关键词：constructor&amp;Modifier  event 继承 接口 异常 重载 库合约 引用 回调 构造函数constructor和修饰器Modifierconstructor  定义：是一种特殊函数 每个合约可以定义一个，并且在部署合约时自动运行一次。 可用于初始化合约参数： 123456789101112131415161718&#x2F;&#x2F; SPDX-License-Identifie">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kizzy899.github.io/img/touxiang.png">
<meta property="article:published_time" content="2024-11-11T15:50:03.000Z">
<meta property="article:modified_time" content="2024-11-20T03:05:59.367Z">
<meta property="article:author" content="kizy">
<meta property="article:tag" content="solidity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kizzy899.github.io/img/touxiang.png"><link rel="shortcut icon" href="/img/tubiao.png"><link rel="canonical" href="https://kizzy899.github.io/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'solidity基础002',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-20 11:05:59'
}</script><link rel="stylesheet" href="/css/_custom/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/page.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><span class="site-page group"><span> Search</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/search.xml"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-search"><span> icon</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover9.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">EIGHTJIU</span></a><a class="nav-page-title" href="/"><span class="site-name">solidity基础002</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><span class="site-page group"><span> Search</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/search.xml"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-search"><span> icon</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">solidity基础002</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-11T15:50:03.000Z" title="发表于 2024-11-11 23:50:03">2024-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-20T03:05:59.367Z" title="更新于 2024-11-20 11:05:59">2024-11-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>关键词：constructor&amp;Modifier  event 继承 接口 异常 重载 库合约 引用 回调</p>
<h3 id="构造函数constructor和修饰器Modifier"><a href="#构造函数constructor和修饰器Modifier" class="headerlink" title="构造函数constructor和修饰器Modifier"></a>构造函数constructor和修饰器Modifier</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>  定义：<strong>是一种特殊函数 每个合约可以定义一个，并且在部署合约时自动运行一次。</strong></p>
<p>可用于初始化合约参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    //带参数的构造函数用于初始化状态变量</span><br><span class="line">    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) &#123;</span><br><span class="line">        name = _name;            // Token name</span><br><span class="line">        symbol = _symbol;        // Token symbol</span><br><span class="line">        totalSupply = _initialSupply;  // 设置初始代币供应量</span><br><span class="line">        owner = msg.sender;      // 将部署者设置为合约的拥有者owner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h4><p>定义：<strong>类似于decorator，声明函数拥有的特性，并减少代码冗余</strong></p>
<p>主要使用场景： <strong>运行函数前的检查，例如地址，变量，余额等。</strong></p>
<p>定义一个叫做onlyOwner的modifier：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义modifier</span><br><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == owner);//检查调用者是否为owner地址</span><br><span class="line">  _;// 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>带有onlyOwner修饰符的函数只能被owner地址调用</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//改变owner</span><br><span class="line">function changeOwner(address_newOwner) external onlyOwner&#123;</span><br><span class="line">  owner = _newOwner;// 只能owner地址运行这个函数，并改变owner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在以上函数中，由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>
<h3 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h3><ol>
<li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li>
</ol>
<ul>
<li>响应： 应用程序（ether.js)可以通过RPC接口订阅和监听这些事件，并在前端做响应。</li>
<li>经济：事件是<strong>EVM</strong>上比较经济的存储数据的方式，每个大概消耗2,000 <strong>gas</strong>；相比之下，链上存储一个新变量至少需要20,000 <strong>gas</strong>。</li>
</ul>
<ol start="2">
<li><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>日志记录</strong>：事件在链上作为日志记录保存，不能被智能合约读取，但可供外部观察。</li>
<li><strong>通知机制</strong>：前端应用、DApp 等可以监听事件来响应合约的变化，如更新用户余额、确认交易等。</li>
<li><strong>优化 Gas 消耗</strong>：事件的存储成本低于状态变量的修改，因此在某些应用场景下，使用事件记录是更高效的选择。</li>
</ul>
</li>
<li><h4 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h4></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Event + 事件名称 + (变量类型 变量名,变量类型 变量名,...)</span><br></pre></td></tr></table></figure>



<p>​	以REC20代币合约的Transfer事件为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from,address indexed to,uint256 value);</span><br><span class="line">//from:转账地址</span><br><span class="line">//to:接收地址</span><br><span class="line">//value:转账数量</span><br><span class="line">//其中from&amp;to前面带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><h4 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h4></li>
</ol>
<p>释放事件（Emit Event）是指在区块链上发布特定事件通知的操作。</p>
<p>通过释放事件，合约可以在发生某些操作（如状态改变、资金转移等）时，向链上日志系统发送记录。</p>
<p>事件通常用于通知外部应用程序，如前端应用或监听工具，便于监控合约状态的变化</p>
<p><strong>关键字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Emit</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义_transfer函数，执行转账逻辑</span><br><span class="line">function_tranfer(</span><br><span class="line">	address from,</span><br><span class="line">	address to;</span><br><span class="line">	uint256 amount</span><br><span class="line">)external&#123;</span><br><span class="line"></span><br><span class="line">    _balance[from] = 10000000;//给转账地址一些初始代币</span><br><span class="line">    _balances[from] -=  amount; // from地址减去转账数量</span><br><span class="line">    _balances[to] += amount; // to地址加上转账数量</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //释放事件</span><br><span class="line">    emit Transfer(from,to,amount);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><h4 id="EVM日志"><a href="#EVM日志" class="headerlink" title="EVM日志"></a>EVM日志</h4></li>
</ol>
<p>​     <strong>EVM用日志log来存储solidity事件，每条日志记录包括主题topics和数据data两部分</strong></p>
<p>​	5.1 <strong>主题topics</strong>（？)</p>
<p>​		<span style = "color: red;"><strong>用于描述事件，长度不能超过4。它的第一个元素是事件的签名（哈希）</strong></span></p>
<p>​     eg: 例如对于上面的transfer事件，它的事件哈希：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;Transfer(address,address,unit256)&quot;)</span><br><span class="line"></span><br><span class="line">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></pre></td></tr></table></figure>



<p>​		<strong>除了事件哈希，主题还可以包含<span style = "color: red;">至多3个indexed参数</span>，也就是Transfer事件中的from和to。</strong></p>
<p>​    5.2 <strong>数据data</strong></p>
<p>​			<strong>事件中不带 indexed的参数会被存储在 data 部分中</strong>，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topics 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topics 更少。</p>
<p>​	5.3 <strong>在Etherscan上查询事件</strong></p>
<p>当尝试用**_transfer()<strong>函数在</strong>Sepolia<strong>测试网络上转账100代币，可以在</strong>Etherscan<strong>上查询到相应的</strong>tx**：<a target="_blank" rel="noopener" href="https://sepolia.etherscan.io/tx/0xb07dcd9943662e2e8b17c7add370f046401962ce24d0690a61bb249a385dc8c9#eventlog">网址</a>。</p>
<p>​	点击<strong>Logs</strong>按钮，就能看到事件明细</p>
<p>​	Topics里面有三个元素，[0]是这个事件的哈希，[1]和[2]是我们定义的两个indexed变量的信息，即转账的转出地址和接收地址。Data里面是剩下的不带indexed的变量，也就是转账数量。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4></li>
</ol>
<p>1.1  <strong>virtual</strong></p>
<p>​	父合约中的函数，如果希望子合约重写，需要加上<strong>virtual</strong>关键字。</p>
<p>1.2 <strong>override</strong>：</p>
<p>​	子合约重写了父合约中的函数，需要加上<strong>override</strong>关键字。</p>
<p><strong>注意</strong>：用<strong>override</strong>修饰<strong>public</strong>变量，会重写与变量同名的<strong>getter</strong>函数</p>
<ol start="2">
<li><h4 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h4></li>
</ol>
<p>​	先写一个简单的A合约</p>
<p>​	再定义一个B合约，让他继承A合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract B is A</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4></li>
</ol>
<p>​		规则：</p>
<ol>
<li><p><strong>继承时要按辈分最高到最低的顺序排</strong>。</p>
<p>eg:比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract Erzi is Yeye, Baba</span><br></pre></td></tr></table></figure>

<p>而不能写成contract Erzi is Baba, Yeye，不然就会报错。</p>
</li>
<li><p><strong>如果某一个函数在多个继承的合约里都存在，在子合约里必须重写，不然会报错</strong></p>
</li>
<li><p><strong>重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override(Yeye, Baba)</span><br></pre></td></tr></table></figure>

<h4 id="4-修饰器的继承"><a href="#4-修饰器的继承" class="headerlink" title="4. 修饰器的继承"></a>4. <strong>修饰器的继承</strong></h4><p>​		用法与函数继承类似，在相应的地方加virtual和override关键字即可。</p>
<h4 id="5-构造函数的继承"><a href="#5-构造函数的继承" class="headerlink" title="5. 构造函数的继承"></a>5. 构造函数的继承</h4><p>​	子合约有两种方法继承父合约的构造函数:</p>
<pre><code>1. **在继承时声明父构造函数的参数**
</code></pre>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract B is A(1)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在子合约的构造函数中声明构造函数的参数</strong></li>
</ol>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C is A &#123;</span><br><span class="line">    constructor(uint _c) A(_c * _c) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="6">
<li><h4 id="调用父合约的继承"><a href="#调用父合约的继承" class="headerlink" title="调用父合约的继承"></a>调用父合约的继承</h4></li>
</ol>
<p>​	子合约有两种方式调用父合约的函数：</p>
<ol>
<li><strong>直接调用</strong></li>
</ol>
<p>​		子合约直接用<strong>父合约名.函数名（）</strong>的方式来调用父合约函数</p>
<p>eg: Yeye.pop()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callParent() public&#123;</span><br><span class="line">		Yeye.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>Super关键字</strong></li>
</ol>
<p>​	子合约可以利用**super.函数名()**来调用最近的父合约函数。</p>
<p>eg:</p>
<p>​	当Solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callParentSuper() public&#123;</span><br><span class="line">	super.pop();</span><br><span class="line">	//此处调用的是Baba.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li><h4 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a><strong>钻石继承</strong></h4></li>
</ol>
<p>​	指一个派生类同时有两个或两个以上的基类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	yeye</span><br><span class="line">	/  \</span><br><span class="line">baba	mama</span><br><span class="line">	\  /</span><br><span class="line">	 me</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">contract Yeye&#123;</span><br><span class="line"></span><br><span class="line">	event Log(string message);</span><br><span class="line">	</span><br><span class="line">	function foo() public virtual&#123;</span><br><span class="line">		emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	function bar() public virtual&#123;</span><br><span class="line">		emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//baba继承yeye</span><br><span class="line">contract Baba is Yeye&#123;</span><br><span class="line">	function foo() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">		super.foo();</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	function bar() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">		super.bar();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">//mama继承yeye</span><br><span class="line">contract Mama is Yeye&#123;</span><br><span class="line">	function foo() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">		super.foo();</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	function bar() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Mama.bar called&quot;);</span><br><span class="line">		super.bar();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">//me继承mama baba</span><br><span class="line">contract me is Baba,mama&#123;</span><br><span class="line">	function foo() public override(Baba,Mama)&#123;</span><br><span class="line">		super.foo();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function bar() public override(Baba,Mama)&#123;</span><br><span class="line">		super.bar();</span><br><span class="line">		//此处Super.bar会依次调用baba,mama最后是god合约</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(当然现实辈分关系具体不是这样，只是代指三个层次)</p>
<p>所谓钻石，即<strong>虽然Baba,Mama都是Yeye的子合约，但整个过程中，God合约只会被调用一次</strong></p>
<p>(因为solidity强制一个由基类构成的DAG（有向无环图）使其保证一个特定的顺序)</p>
<h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a><strong>抽象合约</strong></h3><p>​	如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体**{}<strong>中的内容，则必须将该合约标为</strong>abstract**，不然编译会报错。</p>
<p>未实现的函数需要加<strong>virtual</strong>，以便子合约重写。拿插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<strong>abstract</strong>，之后让别人补写上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">constract Sort&#123;</span><br><span class="line"></span><br><span class="line">abstract constract Insertsort&#123;</span><br><span class="line">	function insertionSort(uint[] memory a)public pure virtual returns(uint[] memory)&#123;</span><br><span class="line">	/*for(uint i = 0; i &lt; a.length;i++)&#123;</span><br><span class="line">	uint temp = a[i];</span><br><span class="line">	uint j = i;</span><br><span class="line">	while(j &gt; 0 &amp;&amp; temp &lt;a[j - 1])&#123;</span><br><span class="line">		a[j] = a[j - 1];</span><br><span class="line">		j--;</span><br><span class="line">			&#125;</span><br><span class="line">			a[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">		*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。这里，我们需要把j加1，让它无法取到负值。*/</span><br></pre></td></tr></table></figure>





<h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a><strong>接口</strong>（interface）</h3><p><strong>规则</strong>：</p>
<pre><code>1. 接口不能包含状态变量
1. 不能包含构造函数
1. 不能继承除接口外的其他合约
1. 所有函数都必须是external且不能有函数体
1. 继承接口的非抽象合约必须实现接口定义的所有功能
</code></pre>
<p>接口提供了两个重要的信息：</p>
<ol>
<li>合约里每个函数的<strong>bytes4</strong>选择器，以及函数签名<strong>函数名(每个参数类型）</strong>。</li>
<li>接口id（更多信息见<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-165">EIP165</a>）</li>
</ol>
<p>另外，接口与合约<strong>ABI</strong>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<strong>ABI</strong>，利用<a target="_blank" rel="noopener" href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>，也可以将<strong>ABI json</strong>文件转换为<strong>接口sol</strong>文件。</p>
<p><strong>接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。</strong></p>
<p>什么时候使用接口：</p>
<p>我们不需要知道它的源代码，只需知道它的合约地址，用对应的接口就可以与它交互。都可以写模版并且减少代码冗余。</p>
<h3 id="三种抛出异常"><a href="#三种抛出异常" class="headerlink" title="三种抛出异常"></a><strong>三种抛出异常</strong></h3><h4 id="1-error"><a href="#1-error" class="headerlink" title="1. error"></a><strong>1. error</strong></h4><p>​	可以在contract之外定义异常。</p>
<p>Eg : 我们定义一个<strong>TransferNotOwner</strong>异常，当用户不是代币<strong>owner</strong>的时候尝试转账，会抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(); *//* *自定义error*</span><br></pre></td></tr></table></figure>



<p>我们也可以定义一个<strong>携带参数的异常</strong>，来提示尝试转账的账户地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(address sender); // 自定义的带参数的error</span><br></pre></td></tr></table></figure>

<p><strong>在执行当中，error必须搭配revert（回退）命令使用</strong></p>
<h4 id="2-Require"><a href="#2-Require" class="headerlink" title="2. Require"></a>2. Require</h4><p>​		它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(检查条件，“异常的描述”)</span><br></pre></td></tr></table></figure>

<p>​	当检查条件不成立的时候，就会抛出异常</p>
<h4 id="3-Assert"><a href="#3-Assert" class="headerlink" title="3. Assert"></a>3. Assert</h4><p>比require少个字符串，即不能抛出异常的原因</p>
<p>assert命令一般用于程序员写程序debug，它的用法很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(检查条件）</span><br></pre></td></tr></table></figure>

<p>当检查条件不成立的时候，就会抛出异常。</p>
<h4 id="三种方法的gas比较"><a href="#三种方法的gas比较" class="headerlink" title="三种方法的gas比较"></a>三种方法的gas比较</h4><p><span style = "color: blue;">error方法gas最少，其次是assert，require方法消耗gas最多</span></p>
<p>因此，error既可以告知用户抛出异常的原因，又能省gas要多用！</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>实参匹配：调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。</p>
<p> 如果出现多个匹配的重载函数，则会报错</p>
<p><strong>overloading</strong>:即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。</p>
<p><strong>solidity不允许修饰器（modifier）重载</strong></p>
<h3 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约</h3><p>​	库合约是一系列的函数合集，用于提升solidity代码的复用性和减少gas而存在</p>
<p>​	他和普通合约主要有以下几点不同：</p>
<ol>
<li>不能存在状态变量</li>
<li>不能够继承或被继承</li>
<li>不能接收以太币</li>
<li>不可以被销毁</li>
</ol>
<p>​	库合约中的函数可见性如果被设置为public或者external，则在调用函数时会触发一次delegatecall。而如果被设置为internal，则不会引起。对于设置为private可见性的函数来说，其仅能在库合约中可见，在其他合约中不可用。</p>
<p><strong>delegatecall</strong>: </p>
<p><code>delegatecall</code> 是一种特殊的低级函数调用，用于将当前合约的上下文（包括<code>msg.sender</code>和<code>msg.value</code>等）传递给另一个合约的函数执行。<code>delegatecall</code> 允许合约在不改变调用者上下文的情况下执行另一个合约的代码。</p>
<p><strong><code>delegatecall</code> 的作用</strong></p>
<ul>
<li><strong>共享存储</strong>：<code>delegatecall</code> 是调用另一个合约的代码，并在调用者合约的存储上下文中执行。这意味着被调用合约的代码会对调用合约的存储变量进行读写。</li>
<li><strong>保持调用者上下文</strong>：<code>msg.sender</code> 和 <code>msg.value</code> 等上下文信息保持不变，依旧指向调用者，这和普通的合约调用不同。</li>
<li><strong>代码重用</strong>：使用 <code>delegatecall</code> 可以使多个合约共享同一段逻辑代码，通过代理模式实现合约的代码复用。</li>
</ul>
<h4 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a><strong>Strings库合约</strong></h4><p>Strings库合约是将uint256类型转换为相应的string类型的代码库</p>
<p><strong>如何利用</strong>：</p>
<p>​	用using for 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using A for B</span><br></pre></td></tr></table></figure>



<p>​	用于附加库合约（从库A）到任何类型（B)。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。</p>
<p>注意： 在调用的时候，这个变量会被当作第一个参数传递给函数</p>
<p><strong>直接通过库合约名称调用函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//利用using for指令</span><br><span class="line"></span><br><span class="line">using String for uint256;</span><br><span class="line">function getString1(uint256_number)public pure returns(string memory)&#123;</span><br><span class="line">	</span><br><span class="line">	//库合约中的函数会自动添加为uint256型变量的成员</span><br><span class="line">	</span><br><span class="line">	return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>常用库合约</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>**uint256**</code>转换为<code>**String**</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</p>
<p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>**Create2 EVM opcode**</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库合约</p>
<h3 id="引用Import"><a href="#引用Import" class="headerlink" title="引用Import"></a>引用Import</h3><p>​	引用（import）在代码中的<strong>位置为： 在声明版本号之后，在其余代码之前</strong></p>
<p>​	import语句可以帮助我们在一个文件中引用另一个文件的内容</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol>
<li>通过源文件相对位置导入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过文件相对位置import</span><br><span class="line">import &#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过源文件网址导入网上的合约的全局符号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过网址引用</span><br><span class="line">import&#x27;url&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>通过npm的目录导入</p>
</li>
<li><p>通过指定全局符号导入合约特定的全局符号</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;name&#125; from&#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure>

<p>​	其中的 <code>name</code> 就是一个 <em>全局符号</em>。它可以是一个具体的合约、库、结构体、枚举或函数的名称。通过 <code>import</code> 语句，可以从指定的文件（例如 <code>name.sol</code>）中导入该符号，以便在当前文件中直接使用。</p>
<h3 id="回调函数receive-fallback"><a href="#回调函数receive-fallback" class="headerlink" title="回调函数receive&amp;fallback"></a>回调函数receive&amp;fallback</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><pre><code>1. 接受ETH
1. 处理合约中不存在的函数调用（代理合约proxy contract）
</code></pre>
<p>（所以：fallback 和 receive 函数<strong>无法在合约内部直接调用</strong>。这些特殊函数只能通过外部调用触发，通常在接收以太币或处理未知的函数调用时<strong>自动执行</strong></p>
<h4 id="接收ETH函数receive"><a href="#接收ETH函数receive" class="headerlink" title="接收ETH函数receive"></a>接收ETH函数receive</h4><p>a. 在合约收到ETH转账时被调用</p>
<p>b. 一个合约最多有一个receive()函数</p>
<p>c. 声明方式: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123; ... &#125; [不需要function关键字]</span><br></pre></td></tr></table></figure>

<p>d.  receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable</p>
<p>receive()最好不要执行太多的逻辑，receive()太复杂可能会触发Out of Gas报错</p>
<h4 id="回退函数fallback"><a href="#回退函数fallback" class="headerlink" title="回退函数fallback"></a>回退函数fallback</h4><p>a.   在调用合约不存在的函数时被触发</p>
<p>b.   可用于接收ETH，也可以用于代理合约proxy contract</p>
<p>c.   声明时不需要function关键字，必须由external修饰，一般也会用payable修饰</p>
<p>Eg: 用于接收ETH:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallback() external payable &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ol>
<li><p>合约接收ETH时，msg.data为空且存在Receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable</p>
</li>
<li><p>receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错</p>
<p>（你仍可以通过带有payable的函数向合约发送ETH）</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/18/9GL52VTyYbe8xsH.png" alt="1.png">	</p>
<p>​	在这个场景中，vitalik 向合约 ReceiveETH 发起了一笔带有 msg.data（0xaa）的低级交互，同时设置了 value 为 100 Wei。让我们分析代码：</p>
<ul>
<li>合约 ReceiveETH 中定义了一个 receive() 函数，该函数是 external 和 payable 的，但 receive() 函数只能在没有 msg.data 的情况下被调用。</li>
<li>由于 msg.data 不为空（0xaa），这次调用不会触发 receive() 函数。</li>
<li>合约也没有定义 fallback 函数，所以任何带有 msg.data 且没有匹配函数签名的调用将会导致交易失败。</li>
</ul>
<p><strong>结论</strong></p>
<p>这次调用将失败，并抛出错误，因为合约没有 fallback 函数来处理包含 msg.data 的调用。</p>
<p>所以会出现报错：error:’Fallback’ function is not defined, value和msg.data均发送失败</p>
<h3 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h3><ol>
<li><p><strong>transfer()</strong></p>
</li>
<li><p><strong>send()</strong></p>
</li>
<li><p><strong>call()，其中call()是被鼓励的用法。</strong></p>
</li>
</ol>
<p>首先构造发送ETH合约SendETH，并在其中实现payable的构造函数和receive()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract SendETH&#123;</span><br><span class="line"></span><br><span class="line">	//构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    //receive方法 接受eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-transfer"><a href="#1-transfer" class="headerlink" title="1. transfer"></a>1. transfer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.transfer(发送eth的数额)</span><br></pre></td></tr></table></figure>

<p>·    <strong>transfer()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p>
<p>·    <strong>transfer()<strong>如果转账失败（eg: amount&gt;value），会自动</strong>revert</strong>（回滚交易）。</p>
<p> amount：通常表示用户或合约希望发送的 ETH 的数量。这里 amount 是一个变量，表示转账时指定的具体金额（单位为 wei）。</p>
<p>value：指交易中随附的 ETH 数量，通常由 msg.value 表示。这是调用合约时由发送方附加的 ETH 数量，通常用于支付给其他地址或完成购买。value 只能在 payable 函数中被使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用transfer()发送ETH,_to填reveive合约地址，amount填ETH转账金额</span><br><span class="line">function transferETH(address payable _to,uint256 amount) external payable&#123;</span><br><span class="line">	_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-send"><a href="#2-send" class="headerlink" title="2. send"></a>2. send</h4><p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.send(发送ETH数额)</span><br></pre></td></tr></table></figure>

<p>·    <strong>send()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p>
<p>·    <strong>send()<strong>如果转账失败，不会</strong>revert</strong>。</p>
<p>·    <strong>send()<strong>的返回值是</strong>bool</strong>，代表着转账成功或失败，需要额外代码处理一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error SendFailed(); // 用send发送ETH失败error</span><br><span class="line">// send()发送ETH</span><br><span class="line">function sendETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下send的返回值，如果失败，revert交易并发送error</span><br><span class="line">    bool success = _to.send(amount);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert SendFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-Call"><a href="#3-Call" class="headerlink" title="3.Call"></a><strong>3.Call</strong></h4><p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>·    <strong>call()<strong>没有</strong>gas</strong>限制，可以支持对方合约**fallback()<strong>或</strong>receive()**函数实现复杂逻辑。</p>
<p>·    <strong>call()<strong>如果转账失败，不会</strong>revert</strong>。</p>
<p>·    <strong>call()<strong>的返回值是</strong>(bool, bytes)<strong>，其中</strong>bool</strong>代表着转账成功或失败，需要额外代码处理一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error CallFAiled()// 用call发送ETH失败error</span><br><span class="line"></span><br><span class="line">// call()发送ETH</span><br><span class="line">function callETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下call的返回值，如果失败，revert交易并发送error</span><br><span class="line">    (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert CallFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>·    <strong>call</strong>没有<strong>gas</strong>限制，最为灵活，是最提倡的方法；</p>
<p>·    <strong>transfer</strong>有<strong>2300 gas</strong>限制，但是发送失败会自动<strong>revert</strong>交易，是次优选择；</p>
<p>·    <strong>send</strong>有<strong>2300 gas</strong>限制，而且发送失败不会自动<strong>revert</strong>交易，几乎没有人用它。</p>
<h3 id="调用其他合约"><a href="#调用其他合约" class="headerlink" title="调用其他合约"></a>调用其他合约</h3><p><strong>如何调用</strong></p>
<p>​	可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，应与合约代码（或接口）中标注的合约名保持一致，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。</p>
<h4 id="1-传入合约地址"><a href="#1-传入合约地址" class="headerlink" title="1.传入合约地址"></a>1.传入合约地址</h4><p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。</p>
<p>以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，</p>
<p>传入已部署好的OtherContract合约地址_Address和setX的参数x：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address _address,uint256 x)external&#123;</span><br><span class="line">	OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123</p>
<h4 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2.传入合约变量"></a>2.传入合约变量</h4><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<strong>address类型改为目标合约名</strong></p>
<p>比如上述的OtherContract</p>
<p>(ps: 该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型)</p>
<p>例子： </p>
<p>通过传入合约变量调用目标合约的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">	x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值</p>
<h4 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uint x)&#123;</span><br><span class="line"></span><br><span class="line">	//创建变量</span><br><span class="line">	OtherContract oc = OtherContract(_Address);//oc为OtherContract别名</span><br><span class="line">	x = oc.getX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值</p>
<h4 id="4-调用合约并发送ETH"><a href="#4-调用合约并发送ETH" class="headerlink" title="4.调用合约并发送ETH"></a>4.调用合约并发送ETH</h4><p>如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Name(_Address).f&#123;value: _Value&#125;()</span><br></pre></td></tr></table></figure>



<p>其中**_Name<strong>是合约名，</strong>_Address<strong>是合约地址，</strong>f<strong>是目标函数名，</strong>_Value<strong>是要转的</strong>ETH<strong>数额（以</strong>wei**为单位）。</p>
<p><strong>OtherContract</strong>合约的<strong>setX</strong>函数是<strong>payable</strong>的，在下面这个例子中我们通过调用<strong>setX</strong>来往目标合约转账。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setXTransferETH(address otherContract, uint256 x) payable external&#123;</span><br><span class="line">   OtherContract(otherContract).setX&#123;value: msg.value&#125;(x);</span><br><span class="line"> &#125;	</span><br></pre></td></tr></table></figure>



<h3 id="利用call调用合约"><a href="#利用call调用合约" class="headerlink" title="利用call调用合约"></a>利用call调用合约</h3><p>call 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, bytes memory)</code>，分别对应call是否成功以及目标函数的返回值。</p>
<p>不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数</p>
<p>当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数</p>
<p><strong>使用规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call(字节码);</span><br></pre></td></tr></table></figure>



<p>（其中字节码利用结构化编码函数abi.encodeWithSignature获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>



<p><strong>函数签名为”函数名（逗号分隔的参数类型）”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</span><br></pre></td></tr></table></figure>



<p>另外<code>call</code>在调用合约时可以指定交易发送的<strong>ETH</strong>数额和<strong>gas</strong>数额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(字节码);</span><br></pre></td></tr></table></figure>



<p>利用Call调用合约举例</p>
<ol>
<li><strong>Response事件</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义Response事件，输出call返回的结果success和data,方便观察返回值</span><br><span class="line">event Response(bool success, bytes data);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p><strong>调用setX函数</strong></p>
<p>定义<strong>callSetX</strong>函数来调用目标合约的<strong>setX()<strong>，转入</strong>msg.value</strong>数额的<strong>ETH</strong>，并释放<strong>Response</strong>事件输出<strong>success</strong>和<strong>data</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address payable _addr,uint256 x)public payable&#123;</span><br><span class="line"></span><br><span class="line">//同时还可发送eth,_addr是目标合约的地址</span><br><span class="line">(bool success,bytes memory data) = _addr&#123;value:msg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emit Response(success,data);//释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	当我们此时调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。</p>
<ol start="3">
<li><p><strong>调用getX函数</strong></p>
<p>所以我们还需要调用getX()函数用于返回目标合约X(uint256)的值</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _addr) external returns(uint256)&#123;</span><br><span class="line">	(bool success, bytes memory data) = _addr.call(</span><br><span class="line">	//可以利用abi.decode来解码call的返回值data，并读出数值。</span><br><span class="line">        abi.encodeWithSignature(&quot;getX()&quot;));</span><br><span class="line">        </span><br><span class="line">        emit Response(success,data);</span><br><span class="line">        return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>Response</code>事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过<code>abi.decode</code>，最终返回值为5。</p>
<ol start="4">
<li><strong>调用不存在的函数</strong></li>
</ol>
<p>如果给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<strong>fallback</strong>函数会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callNonExist(address _addr)external&#123;</span><br><span class="line"></span><br><span class="line">//call不存在的foo()函数</span><br><span class="line">(bool success, bytes memory data)=_addr.call(</span><br><span class="line">abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	emit Response(success,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数</p>
<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><ul>
<li>​	下列关于事件的说法中，错误的是</li>
</ul>
<p>（选择一个答案） </p>
<p>A. Solidity中的事件（event）是EVM上日志的抽象。</p>
<p>B. 事件的声明由event关键字开头，然后跟事件名称。</p>
<p>C. 链上存储数据比存储事件的成本低。</p>
<p>D. 应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。</p>
<p><strong>解析：</strong></p>
<ul>
<li><strong>选项 A：正确。事件在 Solidity 中是 EVM 上日志的抽象，事件记录在链上日志中，但不直接参与合约逻辑。</strong></li>
<li><strong>选项 B：正确。事件的声明确实是通过 event 关键字定义的。</strong></li>
<li><strong>选项 C：错误。实际上，存储事件的成本比直接在链上存储数据要低，因为事件被存储在交易日志中，而不占用合约的存储空间，这降低了成本。</strong></li>
<li><strong>选项 D：正确。应用程序（如 ethers.js）可以通过 RPC 接口监听这些事件，并在前端作出相应的反应。</strong></li>
</ul>
<p>正确答案是：</p>
<p>C. 链上存储数据比存储事件的成本低。</p>
<p>​	</p>
<ul>
<li>indexed关键字可以修饰任意类型的变量 选择一个答案 A. 正确 B. 错误</li>
</ul>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，indexed 关键字不能修饰任意类型的变量。最多只能对事件中的三个参数使用 indexed 修饰，并且它只适用于某些基本类型，例如 address、uint、int 和 bytes 等。复杂的结构体或数组类型无法被 indexed 修饰。</strong>所以错误。</p>
<ul>
<li>如果合约B继承了合约A，合约C要继承A和B，要怎么写？</li>
</ul>
<p> 选择一个答案</p>
<p> A. contract C is A, B</p>
<p> B. contract C is B, A</p>
<p> C. contract C is B</p>
<p><strong>父合约在子合约之前,A为正确选项</strong></p>
<p>合约B继承了合约A，两个合约都有pop()函数，下面选项中，正确调用父合约函数的是：</p>
<p> 选择一个答案 </p>
<p> A. A.pop();</p>
<p> B. super.pop();</p>
<p> C. 都正确</p>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，当子合约 B 继承了父合约 A，并且两个合约中都存在同名函数 pop() 时，可以通过以下两种方式调用父合约的 pop() 函数：</strong></p>
<p>·    <strong>A.pop();：直接通过父合约的名称调用父合约的 pop()。</strong></p>
<p>·    <strong>super.pop();：使用 super 关键字调用父合约的 pop()，特别适合在多重继承的情况下调用父类函数。</strong></p>
<p><strong>因此，两种方式都可以正确调用父合约的 pop() 函数,选C</strong></p>
<ul>
<li>function a() public override{} 意思是</li>
</ul>
<p>​	选择一个答案 </p>
<p>​	A. 希望子合约重写函数a()</p>
<p>​	B. 函数a()重写了父合约中的同名函数</p>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，override 关键字表示该函数是对父合约中同名函数的重写。因此，function a() public override {} 的意思是 该函数 a() 重写了父合约中的同名函数。</strong></p>
<ul>
<li>合约B继承了合约A，下面选项中，正确调用父合约构造函数的是：</li>
</ul>
<p>​		A. constructor(uint _num) { A(_num);} </p>
<p>​		B. constructor(uint _num) { A.constructor(_num);}</p>
<p>​		C. constructor(uint _num) A(_num){}</p>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，如果合约 B 继承了合约 A，并且需要在合约 B 的构造函数中调用合约 A 的构造函数，正确的写法是 constructor(uint _num) A(_num){}。</strong></p>
<ul>
<li>被导入文件中的全局符号想要被其他合约单独导入，应该怎么编写？</li>
</ul>
<p>（选择一个答案<strong>）</strong></p>
<p>​	A. 将合约结构包含</p>
<p>​	B. 包含在合约结构中</p>
<p>​	C. 与合约并列在文件结构中</p>
<p><strong>解析</strong></p>
<p><strong>当文件中的全局符号（例如函数、结构体、枚举等）希望被其他合约单独导入时，需要将这些符号定义在合约之外，即与合约并列在文件结构中，而不是包含在特定合约的内部。</strong></p>
<p><strong>这样一来，这些符号就在文件的全局作用域中，便于其他文件或合约通过 import 语句直接导入和使用，选C。</strong></p>
<ul>
<li><p>Solidity中import的作用是：</p>
<p> A. 导入其他合约中的接口</p>
<p>B. 导入其他合约中的私有变量 </p>
<p>C. 导入其他合约中的全局符号 </p>
<p>D. 导入其他合约中的内部变量</p>
</li>
</ul>
<p><strong>解析</strong></p>
<p><strong>在 Solidity 中，import 关键字用于导入其他文件中定义的全局符号，如合约、库、结构体、枚举等。这使得开发者可以在当前文件中使用其他文件中的符号。</strong></p>
<p><strong>选项分析：</strong></p>
<p>·    <strong>A. 导入其他合约中的接口：虽然可以导入接口，但 import 并不限于接口。</strong></p>
<p><strong>·    B. 导入其他合约中的私有变量：私有变量不能在其他合约中直接访问，import 不能导入私有变量。</strong></p>
<p><strong>·    C. 导入其他合约中的全局符号：这是正确答案，因为 import 可以导入各种全局符号。</strong></p>
<p><strong>·    D. 导入其他合约中的内部变量：import 不能直接导入内部变量（internal 变量），但可以通过继承的方式访问。</strong></p>
<p><strong>因此，正确答案是 C。</strong></p>
<ul>
<li>以下import写法错误的是：</li>
</ul>
<p>​	 A. import from “.&#x2F;Yeye.sol”;</p>
<pre><code> B. import &#123;Yeye&#125; from &quot;./Yeye.sol&quot;;
 
 C. import &#123;Yeye as Wowo&#125; from &quot;./Yeye.sol&quot;; 
 
 D. import * as Wowo from &quot;./Yeye.sol&quot;;
</code></pre>
<p><strong>解析</strong></p>
<p>*<em>在 Solidity 中，import 语句需要指定导入内容或者使用通配符 * 进行导入。选项 A 缺少导入的具体内容，这是错误的写法。正确的写法应当明确指定要导入的符号或使用通配符 <em>。</em></em></p>
<p><strong>选项分析：</strong></p>
<p><strong>·    A. import from “.&#x2F;Yeye.sol”;：错误。未指定导入的内容，语法不完整。</strong></p>
<p><strong>·    B. import {Yeye} from “.&#x2F;Yeye.sol”;：正确。导入了 Yeye 合约。</strong></p>
<p><strong>·    C. import {Yeye as Wowo} from “.&#x2F;Yeye.sol”;：正确。导入并将 Yeye 别名为 Wowo。</strong></p>
<p><strong>·    D. import * as Wowo from “.&#x2F;Yeye.sol”;：正确。导入 Yeye.sol 中所有符号，并以 Wowo 作为命名空间。</strong></p>
<p>  什么是命名空间？</p>
<p>​	命名空间帮助开发者将相关的功能或数据组织在一起，使得代码逻辑更加清晰。</p>
<p>​	通过命名空间的前缀，开发者可以快速了解某个标识符的来源和用途。</p>
<p><strong>因此，A 是错误的导入写法。</strong></p>
<ul>
<li><p>import导入文件中的全局符号可以单独指定其中的： </p>
<p> A. 合约</p>
<p> B. 纯函数</p>
<p> C. 结构体类型</p>
<p> D. 以上都可以</p>
</li>
</ul>
<p><strong>解析</strong></p>
<p>​	 <strong>在 Solidity 中，import 语句可以单独指定要导入的符号，包括合约、函数、结构体等。例如：</strong></p>
<p><strong>·    合约：可以通过 import { ContractName } from “file.sol”; 来导入文件中的特定合约。</strong></p>
<p><strong>·    纯函数：如果文件中定义了 pure 或 view 的全局函数（从 Solidity 0.6.0 开始支持的功能），也可以通过 import { functionName } from “file.sol”; 来单独导入。</strong></p>
<p><strong>·    结构体类型：可以使用 import { StructName } from “file.sol”; 来单独导入结构体定义。</strong></p>
<p><strong>因此，D. 以上都可以 是正确答案。</strong></p>
<p>* </p>
<p><img src="https://s2.loli.net/2024/11/18/BycbYiXFE24tvnG.png" alt="2.png"></p>
<p><strong>解析</strong></p>
<p>假设 SendETH 合约中 callETH 函数的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callETH(address payable _to) external payable &#123;</span><br><span class="line"></span><br><span class="line">  // 假设发送 1ETH 给 ReceiveETH 合约</span><br><span class="line"></span><br><span class="line">  (bool success, ) = _to.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这种情况下，以下是执行步骤和各合约的 ETH 余额变化：</p>
<p> <strong>交易初始化</strong>：Vitalik 调用 SendETH 合约的 callETH 函数，没有设置 msg.value。SendETH 合约接收到 2 ETH。</p>
<p> <strong>转账执行</strong>：callETH 函数内部使用了 call{value: 1 ether}(“”)，向 ReceiveETH 合约发送 1 ETH。因此，ReceiveETH 合约将接收到 1 ETH，SendETH 合约的余额减少 1 ETH。</p>
<p><strong>最终余额</strong>：</p>
<p>o  SendETH 合约：2 ETH（初始接收） - 1 ETH（发送） &#x3D; 1 ETH</p>
<p>o  ReceiveETH 合约：接收 1 ETH</p>
<p>由于没有设置msg.value，执行完交易后，SendETH 合约的余额为 <strong>1 ETH</strong>，而 ReceiveETH 合约的余额为 <strong>1 ETH</strong>。</p>
<p><strong>如果设置了msg.value，则SendETH为0ETH，</strong></p>
<p>这是因为 msg.value 是直接随交易发送到 SendETH 合约的，以支付调用 callETH 函数的资金。这笔 2 ETH 会被发送到 SendETH 合约，但 SendETH 合约并不保留这 2 ETH，而是立即在 callETH 函数中使用其中的 1 ETH 进行转账，剩余的 1 ETH 也不被 SendETH 合约保留。</p>
<p>以下是更详细的解释：</p>
<ol>
<li><p><strong>初始交易的 2 ETH</strong>：Vitalik 发送的 msg.value 是 2 ETH，这笔资金在调用 SendETH 合约的 callETH 函数时传入。</p>
</li>
<li><p><strong>发送 1 ETH 给 ReceiveETH</strong>：callETH 函数中使用了 call{value: 1 ether}(“”) 向 ReceiveETH 合约转账 1 ETH。</p>
</li>
<li><p><strong>剩余的 1 ETH</strong>：由于 callETH 函数中并没有将剩余的 1 ETH 存入 SendETH 合约的余额（例如未将 msg.value - 1 ether 显式存入），交易结束时，这部分 1 ETH 会被直接退还给调用者（Vitalik），因为 Solidity 中的函数执行完毕后未被使用的 msg.value 会被退还。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p>因此，交易完成后：</p>
<p>·    SendETH 合约没有余额，余额为 <strong>0 ETH</strong></p>
<p>·    ReceiveETH 合约收到并保留了 1 ETH</p>
<ul>
<li><p>下列关于智能合约调用其他智能合约的说法，正确的一项是：</p>
<p> 选择一个答案</p>
<p> A. 智能合约调用其他智能合约这一功能，主要起到了方便代码复用的作用</p>
<p> B. 在智能合约A中调用智能合约B，比起从EOA直接调用智能合约B，要更节省gas </p>
<p> C. 智能合约B中可见性为internal的函数也可以被智能合约A调用</p>
</li>
</ul>
<p><strong>解析</strong></p>
<p>· <strong>选项 A 是正确的。智能合约调用其他智能合约确实可以方便代码复用。这样可以减少重复代码并提高合约的模块化，使开发更加灵活和高效。</strong></p>
<p><strong>· 选项 B 是不正确的。在智能合约 A 中调用智能合约 B 实际上比直接从外部账户（EOA）调用智能合约 B 消耗更多的 Gas，因为这涉及到更多的操作步骤（合约 A 需要发起外部调用），并没有节省 Gas 的效果。</strong></p>
<p><strong>· 选项 C 是不正确的。internal 可见性表示函数只能在同一个合约或继承的合约中调用，不能被其他合约直接调用。因此，合约 A 无法直接调用合约 B 中 internal 的函数。</strong></p>
<ul>
<li>下面哪种使用方式不正确？</li>
</ul>
<p>​	A. address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, 	“MyName”)); </p>
<p>​	B. address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, 		“MyName”)); </p>
<p>​	C. address.call{gas: 1000000, value: 1 ether} </p>
<p>​	D. address(nameReg).call{gas: 1000000, value: 1 ether}</p>
<p>​	</p>
<p><strong>解析</strong></p>
<p>逐一分析</p>
<p> <strong>选项 A：address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p>
<p>o 这是正确的写法，使用了 .call{gas: …} 发送指定的 gas 量，并通过 abi.encodeWithSignature 来对函数调用参数进行编码。此调用会尝试在 nameReg 地址处调用 register(string) 函数，提供字符串 “MyName” 作为参数。</p>
<p><strong>选项 B：address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p>
<p>o 这是正确的写法，使用了 .call{value: …} 发送指定的 value（即 1 ether），并且使用了 abi.encodeWithSignature 对函数和参数进行编码。</p>
<p>o 该调用会在发送 1 ether 的情况下，尝试调用 nameReg 地址上的 register(string) 函数。</p>
<p> <strong>选项 C：address.call{gas: 1000000, value: 1 ether}</strong></p>
<p>o 这是不正确的写法。address.call{…} 的语法要求提供被调用的目标地址，而这里没有指定有效地址和编码的数据。正确写法应为 address(target).call{gas: …, value: …}(data)。</p>
<p>o 这里 address 作为数据类型使用是不对的，应该是一个具体的地址实例，比如 address(target)。</p>
<p> <strong>选项 D：address(nameReg).call{gas: 1000000, value: 1 ether}</strong></p>
<p>o 这是正确的写法，因为 address(nameReg).call{gas: …, value: …}(data) 提供了 gas 和 value，并调用 nameReg 这个合约地址。</p>
<p><strong>因此，C 是错误的使用方式，因为它缺少了有效的地址实例（目标地址）和调用的数据。</strong></p>
<p><img src="https://s2.loli.net/2024/11/18/EYM5s4byNx2dROt.png" alt="3.png"></p>
<p><strong>解析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OtherContract other = OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure>



<p>o 这种写法直接实例化了 OtherContract 合约。因为 OtherContract 合约实现了 IOtherContract 接口，这种写法允许我们调用 OtherContract 中的所有公共函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOtherContract other = IOtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure>



<p>o 这种写法使用了 IOtherContract 接口进行实例化，可以用来调用 IOtherContract 中声明的函数。只要 OtherContract 实现了 IOtherContract 接口，这种方式也是正确的。</p>
<p>因此，**(1) 和 (2) 均是正确的调用方式**，可以使用任意一种方法来调用合约。</p>
<p><img src="https://s2.loli.net/2024/11/18/lPv1sNgO5QoMCUn.png" alt="4.png"></p>
<p><strong>解析</strong></p>
<p><strong>· 选项 A：MyContract 是 OtherContract 的子类</strong></p>
<p><strong>o 不正确。MyContract 并没有继承 OtherContract，它只是实例化了 OtherContract 并通过地址直接调用它的函数，因此不构成继承关系。</strong></p>
<p><strong>· 选项 B：MyContract 是 IOtherContract 的一个实现</strong></p>
<p><strong>o 不正确。MyContract 也没有实现 IOtherContract 接口。它只是定义了与 OtherContract 交互的函数，而不是实现 IOtherContract 中的所有接口。</strong></p>
<p><strong>· 选项 C：MyContract 需要 0xd9145CCE52D386f254917e481eB44e9943F39138 的某种许可，才可以调用其中的函数</strong></p>
<p><strong>o 不正确。只要 OtherContract 中的函数是 external 或 public 且无访问权限限制，任何合约或外部账户都可以调用它。OtherContract 中的 setX 和 getX 都没有额外的权限控制。</strong></p>
<p><strong>· 选项 D：MyContract 的函数 call_setX 可以实现，这意味着 OtherContract 中 setX 的权限没有门槛，存在安全隐患</strong></p>
<p><strong>o 正确。OtherContract 的 setX 函数是 external 并且没有权限控制，因此任何合约或账户都可以调用并修改 _x 的值。这确实可能带来安全隐患，尤其是在 _x 变量值的更改可能影响合约逻辑的情况下。如果不希望外部随意调用，应该在 setX 函数中添加访问控制。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io">kizy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/">https://kizzy899.github.io/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kizzy899.github.io" target="_blank">EIGHTJIU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/solidity/">solidity</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E5%BF%B5/" title="区块链原理——区块链概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">区块链原理——区块链概念</div></div><div class="info-2"><div class="info-item-1">区块链的基本概念基本定义 从字面上理解，区块链就是由多个记录数据的区块构成的链式数据结构。  从技术角度来看，区块链是一种基于P2P网络架构的分布式账本技术系统：    以“块-链”式数据结构来验证与存储账本数据 使用密码学方法保证数据传输和访问的安全   从应用角度来看，区块链是一种新型的无中介陌生人信任服务应用支撑平台系统。   面向由陌生主体构成的开放网络环境 提供分布式账本记账服务  特点 去&#x2F;弱中心化 可溯源 不可篡改 数字价值唯一性（采用共识机制和密码学方法实现） 智能合约 开放性 去信任  类型 公有链 公有链（Public Blockchain），任何人（任何个体与组织）都可以参与区块链数据的维护和读取，数据完全开放透明，免费开放 目前全球最有影响力的公有链是比特币和以太坊系统。  联盟链 联盟链（Consortium...</div></div></div></a><a class="pagination-related" href="/2024/11/10/%E9%93%BE%E5%AE%89%E5%9F%BA%E7%A1%802/" title="区块链安全基础二"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">区块链安全基础二</div></div><div class="info-2"><div class="info-item-1">四.数字签名与认证技术消息摘要算法：消息摘要是保证明文无法篡改、完整性的一种算法，消息摘要不是加密明文，也不是加密算法  无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。 消息摘要看起来是“随机的”。 一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同 消息摘要函数是无陷门的单向函数，即只能进行正向的消息摘要而无法从摘要中恢复出任何的消息 好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。  Hash函数：Hash函数特点：（令h表示哈希函数，h满足以下条件）  输入可以是任意长度的消息或文件M；  输出长度是固定的；  给定h和M，计算h(M)是容易的；  给定h的描述，找两个不同的消息M1和M2，使得h(M1)&#x3D;h(M2)在计算上是不可行的。...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/" title="solidity基础001"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-07</div><div class="info-item-2">solidity基础001</div></div><div class="info-2"><div class="info-item-1">关键词：变量 数值类型 函数 数组 印射仅个人学习使用（WTF学习笔记） 数值类型初始值bytes1 是固定大小的字节类型，表示一个 1 字节的值（8 位）。它的初始值（默认值）是 0x00，即所有位都为 0。 具体解释：  在 Solidity 中，任何未赋值的变量都会有一个默认值。对于 bytes1 类型，它的默认值是一个长度为 1 字节的值，所有的位都被初始化为 0，用十六进制表示为 0x00。 如果用二进制表示，它是 00000000。  值类型初始值  boolean: false  string: “”  int: 0  uint: 0  enum: 枚举中的第一个元素  address: 0x0000000000000000000000000000000000000000 (或 address(0))  function   internal: 空白函数 external: 空白函数    引用类型初始值  映射mapping: 所有元素都为其默认值的mapping  结构体struct: 所有成员设为其默认值的结构体  数组array   动态数组:...</div></div></div></a><a class="pagination-related" href="/2024/11/19/solidity%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/" title="solidity基础003"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">solidity基础003</div></div><div class="info-2"><div class="info-item-1">关键词：ABI  delegatecall create&#x2F;create2  selector try catch ABI编码解码ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。 ABI编码： 1.   abi.encode 用于和合约交互，并将每个参数填充为32字节的数据，并拼接在一起 12345function encode() public view returns(bytes memory result) &#123;  result = abi.encode(x, addr, name,...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="giscus-comments"><script src="https://giscus.app/client.js" data-repo="kizzy899/kizzy899.github.io" data-repo-id="R_kgDONCC1iQ" data-category="General" data-category-id="DIC_kwDONCC1ic4CtwTu" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kizy</div><div class="author-info-description">rainbow</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kizzy899"><i class="fab fa-github"></i><span>my github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kizzy899" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Sampre avanti</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0constructor%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8Modifier"><span class="toc-number">1.</span> <span class="toc-text">构造函数constructor和修饰器Modifier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">1.1.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Modifier"><span class="toc-number">1.2.</span> <span class="toc-text">Modifier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6event"><span class="toc-number">2.</span> <span class="toc-text">事件event</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">声明事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">释放事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EVM%E6%97%A5%E5%BF%97"><span class="toc-number">2.5.</span> <span class="toc-text">EVM日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.</span> <span class="toc-text">简单继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">4. 修饰器的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.</span> <span class="toc-text">5. 构造函数的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E5%90%88%E7%BA%A6%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.6.</span> <span class="toc-text">调用父合约的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3%E7%BB%A7%E6%89%BF"><span class="toc-number">3.7.</span> <span class="toc-text">钻石继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">抽象合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">接口（interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">6.</span> <span class="toc-text">三种抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-error"><span class="toc-number">6.1.</span> <span class="toc-text">1. error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Require"><span class="toc-number">6.2.</span> <span class="toc-text">2. Require</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Assert"><span class="toc-number">6.3.</span> <span class="toc-text">3. Assert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84gas%E6%AF%94%E8%BE%83"><span class="toc-number">6.4.</span> <span class="toc-text">三种方法的gas比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">7.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">8.</span> <span class="toc-text">库合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Strings%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">8.1.</span> <span class="toc-text">Strings库合约</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8Import"><span class="toc-number">9.</span> <span class="toc-text">引用Import</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0receive-fallback"><span class="toc-number">10.</span> <span class="toc-text">回调函数receive&amp;fallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">10.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6ETH%E5%87%BD%E6%95%B0receive"><span class="toc-number">10.2.</span> <span class="toc-text">接收ETH函数receive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0fallback"><span class="toc-number">10.3.</span> <span class="toc-text">回退函数fallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">10.4.</span> <span class="toc-text">二者区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81ETH"><span class="toc-number">11.</span> <span class="toc-text">发送ETH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-transfer"><span class="toc-number">11.1.</span> <span class="toc-text">1. transfer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-send"><span class="toc-number">11.2.</span> <span class="toc-text">2. send</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Call"><span class="toc-number">11.3.</span> <span class="toc-text">3.Call</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6"><span class="toc-number">12.</span> <span class="toc-text">调用其他合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80"><span class="toc-number">12.1.</span> <span class="toc-text">1.传入合约地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F"><span class="toc-number">12.2.</span> <span class="toc-text">2.传入合约变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F"><span class="toc-number">12.3.</span> <span class="toc-text">3. 创建合约变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6%E5%B9%B6%E5%8F%91%E9%80%81ETH"><span class="toc-number">12.4.</span> <span class="toc-text">4.调用合约并发送ETH</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8call%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6"><span class="toc-number">13.</span> <span class="toc-text">利用call调用合约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">题：</span></a></div></div></div></div></main><footer id="footer" style="background-image: url(/img/title.png);"><div id="footer-wrap"><div class="footer_custom_text">-899</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'kizzy899/kizzy899.github.io',
      'data-repo-id': 'R_kgDONCC1iQ',
      'data-category-id': 'DIC_kwDONCC1ic4CtwTu',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="8,9,小,金" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>