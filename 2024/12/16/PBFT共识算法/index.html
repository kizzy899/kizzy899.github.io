<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PBFT共识算法 | EIGHTJIU</title><meta name="author" content="kizy"><meta name="copyright" content="kizy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PBFT共识算法PBFT算法概述定义与介绍定义Practical Byzantine Fault Tolerance（PBFT）是一种用于分布式计算和分布式系统中的共识算法，旨在解决拜占庭容错问题。（拜占庭容错问题涉及到在分布式系统中存在故障或恶意节点的情况下，如何确保系统能够维持一致性）。 介绍PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。">
<meta property="og:type" content="article">
<meta property="og:title" content="PBFT共识算法">
<meta property="og:url" content="https://kizzy899.github.io/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="EIGHTJIU">
<meta property="og:description" content="PBFT共识算法PBFT算法概述定义与介绍定义Practical Byzantine Fault Tolerance（PBFT）是一种用于分布式计算和分布式系统中的共识算法，旨在解决拜占庭容错问题。（拜占庭容错问题涉及到在分布式系统中存在故障或恶意节点的情况下，如何确保系统能够维持一致性）。 介绍PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kizzy899.github.io/cover/cover4.jpg">
<meta property="article:published_time" content="2024-12-16T10:21:00.000Z">
<meta property="article:modified_time" content="2024-12-16T09:28:47.944Z">
<meta property="article:author" content="kizy">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kizzy899.github.io/cover/cover4.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PBFT共识算法",
  "url": "https://kizzy899.github.io/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/",
  "image": "https://kizzy899.github.io/cover/cover4.jpg",
  "datePublished": "2024-12-16T10:21:00.000Z",
  "dateModified": "2024-12-16T09:28:47.944Z",
  "author": [
    {
      "@type": "Person",
      "name": "kizy",
      "url": "https://kizzy899.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/tubiao.png"><link rel="canonical" href="https://kizzy899.github.io/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PBFT共识算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/_custom/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/aaaset/page.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/aaaset/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> Search</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/cover/cover4.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">EIGHTJIU</span></a><a class="nav-page-title" href="/"><span class="site-name">PBFT共识算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> Search</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PBFT共识算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-16T10:21:00.000Z" title="发表于 2024-12-16 18:21:00">2024-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-16T09:28:47.944Z" title="更新于 2024-12-16 17:28:47">2024-12-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="PBFT共识算法"><a href="#PBFT共识算法" class="headerlink" title="PBFT共识算法"></a>PBFT共识算法</h1><h2 id="PBFT算法概述"><a href="#PBFT算法概述" class="headerlink" title="PBFT算法概述"></a>PBFT算法概述</h2><h3 id="定义与介绍"><a href="#定义与介绍" class="headerlink" title="定义与介绍"></a>定义与介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Practical Byzantine Fault Tolerance（PBFT）是一种用于分布式计算和分布式系统中的共识算法，旨在解决拜占庭容错问题。（拜占庭容错问题涉及到在分布式系统中存在故障或恶意节点的情况下，如何确保系统能够维持一致性）。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PBFT是一种<strong>状态机副本复制算法</strong>，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|&#x3D;3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p>
<p><code>PBFT</code>算法中节点只有两种角色，<code>主节点（primary）</code>和<code>副本（replica）</code>，两种角色之间可以相互转换。两者之间的转换又引入了<code>视图（view）</code>的概念，<code>视图</code>在<code>PBFT</code>算法中起到逻辑时钟的作用。</p>
<p>  </p>
<h3 id="特点与工作原理"><a href="#特点与工作原理" class="headerlink" title="特点与工作原理"></a>特点与工作原理</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>拜占庭容错：</strong> PBFT旨在解决拜占庭容错问题，这意味着系统可以继续正常运行，即使有一些节点是恶意的或出现了故障。</li>
<li><strong>节点投票：</strong> 在PBFT中，网络中的节点会相互交流以达成共识。每个节点会对提出的交易或区块进行投票，表达自己的意见。</li>
<li><strong>三阶段协议：</strong> PBFT采用了一种三阶段的协议，包括预备（pre-prepare）、准备（prepare）和提交（commit）阶段。在每个阶段，节点都会按照协议的规则发送消息，以便其他节点验证并最终达成共识。</li>
<li><strong>多数原则：</strong> PBFT要求绝大多数节点达成一致意见，才能够执行交易或添加区块。这有助于防止恶意节点或错误导致的不一致性。</li>
<li><strong>较高性能：</strong> PBFT通常具有较高的性能，因为节点之间的通信和共识是快速的，不需要执行复杂的计算难题（如PoW）。</li>
<li><strong>可扩展性：</strong> 尽管PBFT对于确保一致性非常有效，但它的可扩展性在大型网络中可能受到限制。</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p> 其核心工作原理是在存在拜占庭错误的情况下，通过多个节点协作完成共识，保证系统的一致性和可靠性。</p>
<p><strong>具体：</strong></p>
<h5 id="1-请求阶段（Request）"><a href="#1-请求阶段（Request）" class="headerlink" title="1. 请求阶段（Request）"></a><strong>1. 请求阶段（Request）</strong></h5><ul>
<li>客户端（Client）向主节点发送请求，内容包括操作类型和参数。</li>
<li>请求格式为：<code>&lt;请求ID, 操作, 客户端ID&gt;</code>，通过消息认证机制确保其来源可信。</li>
</ul>
<hr>
<h5 id="2-预准备阶段（Pre-Prepare）"><a href="#2-预准备阶段（Pre-Prepare）" class="headerlink" title="2. 预准备阶段（Pre-Prepare）"></a><strong>2. 预准备阶段（Pre-Prepare）</strong></h5><ul>
<li>主节点接收到客户端请求后，为该请求分配序列号（Sequence Number）。</li>
<li>主节点将请求与序列号组成的消息广播给所有备节点，格式为：<br><code>&lt;视图号, 序列号, 请求内容&gt;</code>。</li>
<li>备节点验证：<ol>
<li>消息的完整性和合法性。</li>
<li>主节点是否按照请求的顺序分配序列号。</li>
</ol>
</li>
<li>若验证通过，备节点记录该消息并进入下一阶段。</li>
</ul>
<hr>
<h5 id="3-准备阶段（Prepare）"><a href="#3-准备阶段（Prepare）" class="headerlink" title="3. 准备阶段（Prepare）"></a><strong>3. 准备阶段（Prepare）</strong></h5><ul>
<li>每个备节点将自己接收到的 <code>Pre-Prepare</code> 消息广播给其他节点，形成 <code>Prepare</code> 消息。</li>
<li>节点收到至少 2f+1条来自不同节点的 <code>Prepare</code> 消息（包括自身）后，确认该请求在网络中达成了一致性，记录状态并进入下一阶段。</li>
</ul>
<hr>
<h5 id="4-提交阶段（Commit）"><a href="#4-提交阶段（Commit）" class="headerlink" title="4. 提交阶段（Commit）"></a><strong>4. 提交阶段（Commit）</strong></h5><ul>
<li>每个节点将 <code>Prepare</code> 消息汇总并广播一个 <code>Commit</code> 消息。</li>
<li>当一个节点收到至少 2f+1条 <code>Commit</code>消息后：<ol>
<li>确认请求已被网络中大多数节点接受。</li>
<li>执行操作，并记录操作结果。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-回复阶段（Reply）"><a href="#5-回复阶段（Reply）" class="headerlink" title="5. 回复阶段（Reply）"></a><strong>5. 回复阶段（Reply）</strong></h5><ul>
<li>节点将执行结果发送给客户端。</li>
<li>客户端接收到来自至少 f+1 个不同节点的相同回复后，确认操作成功完成。</li>
</ul>
<hr>
<h2 id="PBFT算法流程"><a href="#PBFT算法流程" class="headerlink" title="PBFT算法流程"></a>PBFT算法流程</h2><p>  在算法开始阶段，<code>主节点</code>由 <code>p = v mod n</code>计算得出，随着<code>v</code>的增长可以看到<code>p</code>不断变化。</p>
<p>  首先客户端发送消息<code>m</code>给主节点<code>p</code>，主节点就开始了<code>PBFT</code>三阶段协议，其中<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，<code>prepare</code>和<code>commit</code>阶段最重要的任务是保证请求在不同<code>视图</code>之间的顺序是一致的。</p>
<ul>
<li>主节点收到客户端发送来的消息后，构造<code>pre-prepare</code>消息结构体<code>&lt; &lt;PRE-PREPARE, v, n, d&gt;, m &gt;</code>广播到集群中的其它节点。<ol>
<li><code>PRE-PREPARE</code>标识当前消息所处的协议阶段。</li>
<li><code>v</code>标识当前视图编号。</li>
<li><code>n</code>为主节点广播消息的一个唯一递增序号。</li>
<li><code>d</code>为<code>m</code>的消息摘要。</li>
<li><code>m</code>为客户端发来的消息。</li>
</ol>
</li>
<li><code>副本(backup)</code>收到主节点请求后，会对消息进行检查，检查通过会存储在本节点。当节点收到<code>2f+1</code>（包括自己）个相同的消息后，会进入<code>PREPARE</code>状态，广播消息<code>&lt; &lt;PREPARA, v, n, d, i&gt; &gt;</code>，其中<code>i</code>是本节点的编号。对消息的有效性有如下检查：<ol>
<li>检查收到的消息体中摘要<code>d</code>，是否和自己对<code>m</code>生成的摘要一致，确保消息的完整性。</li>
<li>检查<code>v</code>是否和当前视图<code>v</code>一致。</li>
<li>检查序号<code>n</code>是否在水线<code>h</code>和<code>H</code>之间，避免快速消耗可用序号。</li>
<li>检查之前是否接收过相同序号<code>n</code>和<code>v</code>，但是不同摘要<code>d</code>的消息。</li>
</ol>
</li>
<li><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>PREPARE</code>消息后，会进入<code>COMMIT</code>阶段，并且广播消息<code>&lt; COMMIT, v, n, D(m), i &gt;</code>给集群中的其它节点。在收到<code>PREPARE</code>消息后，副本同样也会对消息进行有效性检查，检查的内容是上文<code>1, 2, 3</code>。</li>
<li><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>COMMIT</code>个消息后执行<code>m</code>中包含的操作，其中，如果有多个<code>m</code>则按照序号<code>n</code>从小到大执行，执行完毕后发送执行成功的消息给客户端。</li>
</ul>
<p>算法的流程图：</p>
<p><img src="https://s2.loli.net/2024/12/16/Uu7bC3d2PieGyQq.webp" alt="1.webp"></p>
<p><strong>Pbft算法的时间复杂度？</strong><br>A：Pbft算法的时间复杂度O(n^2)，在<code>prepare</code>和<code>commit</code>阶段会将消息广播两次，一般而言，Pbft集群中的节点都不会超过100。</p>
<h2 id="PBFT-算法的优势与挑战"><a href="#PBFT-算法的优势与挑战" class="headerlink" title="PBFT 算法的优势与挑战"></a>PBFT 算法的优势与挑战</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>PBFT是一种可行的共识算法，特别适用于需要高度安全性和快速共识的场景，例如金融领域或联盟区块链。</p>
<h4 id="较高容错性"><a href="#较高容错性" class="headerlink" title="较高容错性"></a>较高容错性</h4><p>为了更多的容错性，<code>PBFT</code>算法最大的容错节点数量<code>( n - 1 ) / 3</code>，也就是是说4个节点的集群最多只能容忍一个节点作恶或者故障。</p>
<h4 id="保证集群的可用性-稳定性"><a href="#保证集群的可用性-稳定性" class="headerlink" title="保证集群的可用性&amp;稳定性"></a>保证集群的可用性&amp;稳定性</h4><ul>
<li>具有<strong>视图切换</strong>（View-Change）机制。</li>
</ul>
<p><code>view-change</code>提供了一种当主节点宕机以后依然可以保证集群可用性的机制。<code>view-change</code>通过计时器来进行切换，避免副本长时间的等待请求。<br>当副本收到请求时，就启动一个计时器，如果这个时候刚好有定时器在运行就重置（reset）定时器，但是<code>主节点</code>宕机的时候，副本<code>i</code>就会在当前<code>视图</code>v中超时，这个时候副本<code>i</code>就会触发<code>view-change</code>的操作，将视图切换为<code>v+1</code>。</p>
<ul>
<li><p>副本<code>i</code>会停止接收除了<code>checkpoint</code>,<code>view-change</code>和<code>new view-change</code>以外的请求，同时广播消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;VIEW-CHANGE, v+1, n, C, P, i&gt;</span><br></pre></td></tr></table></figure>

<p>的消息到集群。</p>
<ol>
<li><code>n</code>是节点<code>i</code>知道的最后一个<code>stable checkpoint</code>的消息序号。</li>
<li><code>C</code>是节点<code>i</code>保存的经过<code>2f+1</code>个节点确认<code>stable checkpoint</code>消息的集合。</li>
<li><code>P</code>是一个保存了<code>n</code>之后所有已经达到<code>prepared</code>状态消息的集合。</li>
</ol>
</li>
<li><p>当在视图( v+1 )中的主节点<code>p1</code>接收到<code>2f</code>个有效的将视图变更为<code>v+1</code>的消息以后，<code>p1</code>就会广播一条消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NEW-VIEW, v+1, V, Q&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>V</code>是<code>p1</code>收到的，包括自己发送的<code>view-change</code>的消息集合。</li>
<li><code>Q</code>是<code>PRE-PREPARE</code>状态的消息集合，但是这个<code>PRE-PREPARE</code>消息是从<code>PREPARE</code>状态的消息转换过来的。</li>
</ol>
</li>
<li><p>从节点接收到<code>NEW-VIEW</code>消息后，校验签名，<code>V</code>和<code>Q</code>中的消息是否合法，验证通过，主节点和副本都 进入视图<code>v+1</code>。</p>
</li>
</ul>
<p>  当<code>p1</code>在接收到<code>2f+1</code>个<code>VIEW-CHANGE</code>消息以后，可以确定<code>stable checkpoint</code>之前的消息在视图切换的过程中不会丢，但是当前检查点之后，下一个检查点之前的已经<code>PREPARE</code>可能会被丢弃，在视图切换到<code>v+1</code>后，<code>Pbft</code>会把旧视图中已经<code>PREPARE</code>的消息变为<code>PRE-PREPARE</code>然后新广播。</p>
<ul>
<li>如果集合<code>P</code>为空，广播<code>&lt;PRE-PREPARE, v+1, n, null&gt;</code>，接收节点就什么也不做。</li>
<li>如果集合<code>P</code>不为空，广播<code>&lt;PRE-PREPARE, v+1, n,d&gt;</code></li>
</ul>
<p>  总结一下，在<code>view-change</code>中最为重要的就是<code>C</code>，<code>P</code>，<code>Q</code>三个消息的集合，<code>C</code>确保了视图变更的时候，<code>stable checkpoint</code>之前的状态安全。<code>P</code>确保了视图变更前，已经<code>PREPARE</code>的消息的安全。<code>Q</code>确保了视图变更后<code>P</code>集合中的消息安全。回想一下<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证，同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，而在视图切换过程中的<code>C</code>，<code>P</code>，<code>Q</code>三个集合就是解决这个问题的。</p>
<ul>
<li><strong>视图协商（NegotiateView）机制</strong></li>
</ul>
<p>集群在运行过程中，可能出现网络抖动、磁盘故障等原因，会导致部分节点的执行速度落后大多数节点，在<code>Pbft</code>中采用了<code>视图协商（NegotiateView）</code>的机制来保持同步。</p>
<p>当一个节点多次<code>view-change</code>失败就触发<code>NegotiateView</code>同步集群数据，流程如下：</p>
<p><img src="https://s2.loli.net/2024/12/16/WIfvRk62ZLqwQsr.webp" alt="2.webp"></p>
<ul>
<li>新增节点<code>Replica 4</code>发起<code>NegotiateView</code>消息给其他节点；</li>
<li>其余节点收到消息以后，返回自己的视图信息，节点ID，节点总数N；</li>
<li><code>Replica 4</code>收到<code>2f+1</code>个相同的消息后，如果quorum个视图编号和自己不同，则同步view和N；</li>
<li><code>Replica 4</code>同步完视图后，发送<code>RevoeryToCheckpoint</code>的消息，其中包含自身的<code>checkpoint</code>信息；</li>
<li>其余节点收到<code>RevoeryToCheckpoint</code>后将自身最新的检查点信息返回给<code>Replica 4</code>;</li>
<li><code>Replica 4</code>收到quorum个消息后，更新自己的检查点到最新，更新完成以后向正常节点索要pset、qset和cset的信息（即PBFT算法中pre-prepare阶段、prepare阶段和commit阶段的数据）同步至全网最新状态；</li>
</ul>
<h4 id="遵循线性一致性（-linearizability-）"><a href="#遵循线性一致性（-linearizability-）" class="headerlink" title="遵循线性一致性（ linearizability ）"></a>遵循线性一致性（ linearizability ）</h4><p>（线性一致性的解释：就是在并发编程里，我们进行了一番操作，得到了一个结果。然后这个操作的运行记录，和按照串行顺序一步步来的运行记录相一致，我们就能称其为「线性一致的（linearizable）」）。</p>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>PBFT的实现可能相对复杂，且在大规模网络中可能面临一些挑战。</p>
<p><code>PBFT</code>算法假设的环境比<code>Raft</code>算法更加的’恶劣‘，<code>Raft</code>算法只支持容错故障节点，而<code>PBFT</code>算法除了需要支持容错故障节点之外，还需要容忍作恶节点（作恶节点节点是指可能对接收到的消息作出截然相反的回复，甚至伪造消息）。</p>
<h2 id="PBFT算法的实现与优化"><a href="#PBFT算法的实现与优化" class="headerlink" title="PBFT算法的实现与优化"></a>PBFT算法的实现与优化</h2><p>与传统的Proof of Work（PoW）和Proof of Stake（PoS）等共识算法不同，PBFT通常用于<strong>私有或联盟区块链网络</strong>，其中节点的身份已知，且相互信任。其和 <a target="_blank" rel="noopener" href="https://learnblockchain.cn/2019/07/18/raft-protocol/">Raft算法</a>解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>代码实现：</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyHsiung/Practical-Byzantine-Fault-Tolerance-PBFT-">https://github.com/CyHsiung/Practical-Byzantine-Fault-Tolerance-PBFT-</a></p>
<ol>
<li><strong>联盟链</strong></li>
</ol>
<p>PBFT 是联盟链的常用共识算法，因为它对节点的数量和参与身份有一定限制，适合权限网络。</p>
<ul>
<li><code>Hyperledger Fabric</code>：PBFT 早期被作为 Hyperledger 的共识候选。</li>
<li><code>Tendermint</code>：基于 PBFT 的一种区块链共识实现，注重高性能和低延迟。</li>
</ul>
<ol start="2">
<li><strong>分布式数据库</strong></li>
</ol>
<ul>
<li>在需要高容错性的分布式数据库中，PBFT 可用于确保数据一致性和可用性。</li>
</ul>
<ol start="3">
<li><strong>金融系统</strong></li>
</ol>
<ul>
<li>金融机构常部署 PBFT 来防范节点作恶，从而在跨机构交易或清算网络中提供高安全性。</li>
</ul>
<ol start="4">
<li><strong>物联网（IoT）</strong></li>
</ol>
<ul>
<li>在边缘计算场景，PBFT 被用于提高节点协作的一致性，增强系统的鲁棒性。</li>
</ul>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化：</strong></h4><p>原始 PBFT 的消息复杂度为 O(n2))，针对该问题，以下优化措施被提出：</p>
<ol>
<li><p><strong>分批处理</strong></p>
<p>将节点分为共识节点和候选节点。通过优化一致性协议，以减少共识过程中节点的通信量</p>
</li>
<li><p><strong>使用消息认证码（MAC）</strong></p>
<p>在正常运行时，使用 MAC 替代公钥加密进行节点身份验证，显著提高效率。</p>
</li>
<li><p><strong>快速路径优化</strong></p>
<p>在无故障情况下，跳过某些冗余通信步骤，进一步加快请求处理速度。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PBFT 算法作为分布式共识的基础，推动了区块链和容错技术的发展。随着优化技术的进一步提升，它在金融、物联网和云计算等领域的应用潜力将更加广阔。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>线性一致性解释参考论文：<a target="_blank" rel="noopener" href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf</a></p>
<p>全篇参考论文：<a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/nyu/03sp/sched/bfs.pdf">www.scs.stanford.edu/nyu/03sp/sched/bfs.pdf</a></p>
<p>优化参考：优化PBFT算法实现<a target="_blank" rel="noopener" href="https://github.com/fangvv/SPBFT">https://github.com/fangvv/SPBFT</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io">kizy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">https://kizzy899.github.io/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kizzy899.github.io" target="_blank">EIGHTJIU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></div><div class="post-share"><div class="social-share" data-image="/cover/cover4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" title="链原——共识机制"><img class="cover" src="/cover/cover11.jpg" onerror="onerror=null;src='/img/404page.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">链原——共识机制</div></div><div class="info-2"><div class="info-item-1">区块链共识机制由于各个节点的自身状态和所处网络环境不尽相同，而交易信息的传递又需要时间，并且消息传递本身不可靠，每个节点接收到的需要记录的交易内容和顺序也难以保持一致。因此，区块链系统的共识问题，或者说账本数据一致性问题，是关系着整个区块链系统的正确性和安全性的关键问题。 共识基本原理与问题数据一致性问题区块链系统的分布式账本中，如何确保分散存储于多个不同网络节点的账本数据在任意时刻都是一致与可信的，不会发生数据冲突与错误，这就涉及分布式系统的一致性问题。 在分布式系统中，各个节点数据的一致性与节点数据的可信性并不是一个问题，解决系统一致性问题并不一定能保证系统数据的正确可信，区块链共识机制的关键是需要同时解决好一致性与可信性两个问题 FLP定理FLP定理1：在异步通信的分布式系统中，即使只有一个进程失败，也没有任何算法能保证非故障进程达到一致性。 FLP定理假设的分布式系统模型如下：   (1) 异步通信：异步通信与同步通信的最大区别是没有时钟、不能时间同步、不能使用超时、不能探测失败、消息可任意延迟、消息可乱序；   (2) 通信健壮：只要进程非失败，消息虽会被无限延迟，但最...</div></div></div></a><a class="pagination-related" href="/2024/12/11/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%B3%BB%E7%BB%9F/" title="链原——以太坊系统"><img class="cover" src="/cover/cover9.jpg" onerror="onerror=null;src='/img/404page.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">链原——以太坊系统</div></div><div class="info-2"><div class="info-item-1">以太坊系统以太坊区块链系统架构以太坊区块链系统依然是P2P体系结构，即对等网络结构 以太坊系统每个节点都可以存储完整的区块链与账本数据，每个节点都可以发起和监听以太坊网络上的交易信息，验证每个交易和区块的合法性； 每个节点都可以交易的形式发布智能合约，智能合约将存储于区块链中，加载到每个节点上的以太坊虚拟机EVM中执行 虽然每个以太坊系统节点上都安装了对等的以太坊系统软件，但是每个节点可以自由选择启动以太坊系统的不同功能，从而属于不同的节点类型，在区块链网络中扮演不同的角色。目前，以太坊系统的节点总体上可以分为“全节点”、“轻节点”、“存档节点”等类型，其中发挥核心作用的是全节点。 【1】 系统逻辑架构【2】 以太坊系统的存储层主要采用文件系统和LevelDB Key-Value数据库，为以太坊系统相关的区块链、分布式账本、智能合约、X.509数字证书、日志、配置文件等数据提供高效、可靠持久化存储服务。 以太坊系统的数据层是系统核心功能层级之一，对以太坊系统核心的区块、区块链、交易、账本、账户、地址、状态树、交易树、收据树等关键数据结构进行定义和处理，负责将交易打包进区块，由区块...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/12/DAO/" title="DAO"><img class="cover" src="/cover/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-12</div><div class="info-item-2">DAO</div></div><div class="info-2"><div class="info-item-1">一、DAO 基础概念什么是 DAO（去中心化自治组织）定义：  Decentralized：基于区块链，由利益相关者共同决策。 Autonomous：运行逻辑由智能合约执行，在特定情况下无需人工干预。 DAO 是一个自主存在于网络中的实体，由公开透明的代码编码组织规则，管理组织资产。  特点：  社区治理：以集体方式作出决策（某种方式为自己做决定）。 资产管理：拥有和分配内部资产的能力（包含内部资产，且它有能力将该资产用于奖励某些活动）。  DAO vs 传统公司   特性 DAO 公司    管理结构 自下而上，去中心化 自上而下，层级分明   决策透明度 公开透明 相对封闭   成员参与方式 自主发起，自愿参与 由雇佣关系或股份结构决定   目标 社区共识，长期共赢 股东利润最大化   DAO 的类别 Protocol DAO：Uniswap、MakerDAO   Social DAO：SeedClub、FWB   Venture DAO：CultDAO   Media DAO：Bankless DAO   Grant DAO：Gitcoin   dao究竟在做什么（1）去中...</div></div></div></a><a class="pagination-related" href="/2025/06/07/ERC721/" title="ERC721"><img class="cover" src="/cover/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-07</div><div class="info-item-2">ERC721</div></div><div class="info-2"><div class="info-item-1">12import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;    定义非同质化代币（也称为契约）的标准接口。 每个符合 ERC-721 的合约都必须实现ERC721和ERC165接口  它更大的想象空间在于将物理世界的资产映射到区块链上。  谜恋猫是第一个实现了ERC721 标准的去中心化应用  ERC20代币是可置换的，且可细分为N份（1 &#x3D; 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。    如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。  钱包接口123456789101112131415/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.interface ERC721TokenReceiver &#123;    /// @notice Handle the receipt of an NF...</div></div></div></a><a class="pagination-related" href="/2025/03/29/DEX/" title="DEX&amp;CEX"><img class="cover" src="/cover/cover4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-29</div><div class="info-item-2">DEX&amp;CEX</div></div><div class="info-2"><div class="info-item-1">DEX &amp; CEXCEX vs DEX 核心知识点总结1. CEX（中心化交易所） 托管模式：用户资产由交易所控制，存在平台跑路风险。 透明度低：交易记录不公开，依赖交易所的内部账本。 流动性来源：主要依赖专业做市商提供深度。 KYC要求：必须完成身份认证才能交易（合规要求）。 典型代表：Binance、Coinbase、Kraken。  2. DEX（去中心化交易所） 非托管模式：用户自持私钥，资产存于个人钱包（如MetaMask）。 链上透明：所有交易记录公开可查（如Etherscan）。 流动性来源： AMM 模式（如Uniswap）：依赖流动性池（LP提供）。 订单簿模式（如dYdX）：可能结合做市商。   无需许可：无需KYC，支持匿名交易。 典型代表：Uniswap、SushiSwap、dYdX。  Token的作用？ 作为数字资产在区块链上流通   代表项目权益或使用权   提供激励机制（如质押、治理）   增强生态内流动性   早期融资：帮助项目方（尤其是小团队）筹集启动资金（如通过IDO&#x2F;IEO）。 社区治理：代币持有者可参与DAO投票，影响项...</div></div></div></a><a class="pagination-related" href="/2025/05/24/Foundry%E6%A1%86%E6%9E%B6/" title="Foundry框架"><img class="cover" src="/cover/cover8.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-24</div><div class="info-item-2">Foundry框架</div></div><div class="info-2"><div class="info-item-1">定义Foundry 是一个由 Paradigm开发的智能合约开发工具包，用于在以太坊区块链上开发应用程序。Foundry 基于 Rust 运行，提供多种工具来开发和测试 Solidity 智能合约。Foundry 具有一套 CLI 命令，使创建新项目、编译、部署和与合约交互变得简单。 创建Foundry项目 安装命令：  12curl -L &lt;https://foundry.paradigm.xyz&gt; | bash  //下载foundryupfoundryup   //运行它安装 Foundry   安装后，有三个命令行工具 forge, cast, anvil 组成  forge: 用来执行初始化项目、管理依赖、测试、构建、部署智能合约 ; cast: 执行以太坊 RPC 调用的命令行工具, 进行智能合约调用、发送交易或检索任何类型的链数据 anvil: 创建一个本地测试网节点, 也可以用来分叉其他与 EVM 兼容的网络。    初始化  通过 forge 的 forge init 初始化项目 1forge init &lt;project_name&gt;  i...</div></div></div></a><a class="pagination-related" href="/2025/05/24/Hardhat/" title="Hardhat框架"><img class="cover" src="/cover/cover10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-24</div><div class="info-item-2">Hardhat框架</div></div><div class="info-2"><div class="info-item-1">定义Hardhat 是一个由 Nomiclabs 构建和维护的以太坊智能合约开发环境。它是一个可扩展的 Javascript 框架，提供了一套管理智能合约生命周期的工具和功能，包括编译、部署、测试和调试。 可以用npm直接安装： 12npm install hardhatnpx hardhat init     高度可定制性：Hardhat 的插件系统允许开发者通过自定义插件扩展其功能。  Hardhat 使用 Node 进行包管理，如果你熟悉 Node 及 Javascript， Hardhat 将非常简单上手。 创建Hardhat项目 创建项目目录  12mkdir hardhat-tutorialcd hardhat-tutorial   初始化Node项目  1npm init     安装Hardhat  1npm install --save-dev hardhat   将hatdhat添加到 package.json 的 devDependencies 中，而不是 dependencies 中   在安装Hatdhat的目录下运行 1npx hardhat    使...</div></div></div></a><a class="pagination-related" href="/2024/12/26/FISCOBCOS%E8%81%94%E7%9B%9F%E9%93%BE/" title="FISCO BCOS联盟链"><img class="cover" src="/cover/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">FISCO BCOS联盟链</div></div><div class="info-2"><div class="info-item-1">FISCO BCOS介绍FISCO BCOS 是一个稳定、高效、安全的区块链底层平台。联盟链需要多家机构来组成联盟，所以FISCO BCOS 支持多群组概念，这意味着多个组织可以通过FISCOBCOS的联盟链组成多个联盟，而且联盟中可以允许共同的组织节点。如下图所示，在多群组技术下FISCO BCOS可以支持众多应用领域。 逻辑架构以下是FISCO BCOS 的逻辑架构，分为：基础层、互联核心层、链核心层、管理层和接口层。  基础层 基础层提供区块链的基础数据结构和算法库，包括密码学算法、隐私算法等。 链核心层 链核心层主要实现区块链的链式数据结构和数据存储（分布式存储），采用了不同的数据库（LevelDB、MySQL、Qracle）来存储区块数据。 互联核心层 互联核心层实现了区块链的基础 P2P 网络通信、共识机制和区块同步机制。 管理层 相对于区块链基础架构，FISCO BCOS 细分出了管理层，实现区块链的管理功能，比如说参数配置、账本管理等。 接口层 接口层主要对应的是应用层，面向区块链用户，提供交互式控制台与各类应用接口。同时还包括智能合约与DApp。 区块链交易流程...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/aaaset/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kizy</div><div class="author-info-description">rainbow</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kizzy899"><i class="fab fa-github"></i><span>my github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kizzy899" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Sampre avanti</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">PBFT共识算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PBFT%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">PBFT算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">定义与介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">特点与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AF%B7%E6%B1%82%E9%98%B6%E6%AE%B5%EF%BC%88Request%EF%BC%89"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">1. 请求阶段（Request）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%A2%84%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%88Pre-Prepare%EF%BC%89"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">2. 预准备阶段（Pre-Prepare）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%88Prepare%EF%BC%89"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">3. 准备阶段（Prepare）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5%EF%BC%88Commit%EF%BC%89"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">4. 提交阶段（Commit）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9B%9E%E5%A4%8D%E9%98%B6%E6%AE%B5%EF%BC%88Reply%EF%BC%89"><span class="toc-number">1.1.2.2.5.</span> <span class="toc-text">5. 回复阶段（Reply）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PBFT%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">PBFT算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PBFT-%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">PBFT 算法的优势与挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.1.</span> <span class="toc-text">优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%83%E9%AB%98%E5%AE%B9%E9%94%99%E6%80%A7"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">较高容错性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7-%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">保证集群的可用性&amp;稳定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%B5%E5%BE%AA%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88-linearizability-%EF%BC%89"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">遵循线性一致性（ linearizability ）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%91%E6%88%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PBFT%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">PBFT算法的实现与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">优化：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.5.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/aaaset/title.png);"><div class="footer-other"><div class="footer-copyright"></div><div class="footer_custom_text">-899</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'kizzy899/kizzy899.github.io',
      'data-repo-id': 'R_kgDONCC1iQ',
      'data-category-id': 'DIC_kwDONCC1ic4CtwTu',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="8,9,小,金" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>