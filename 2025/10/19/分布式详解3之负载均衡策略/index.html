<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式详解3之负载均衡策略 | EIGHTJIU</title><meta name="author" content="kizy"><meta name="copyright" content="kizy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 轮询法 原理：将请求按顺序轮流分配到后端服务器。 特点： 均衡对待所有服务器； 不考虑服务器实际负载或连接数。    将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。  即第n个请求对应第n个节点，很不现实，因为实际节点的配置不相同，配置高的节点收到很低的请求量实在浪费，配置低的节点收到过高请求量会崩溃。   2. 加权轮询法">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式详解3之负载均衡策略">
<meta property="og:url" content="https://kizzy899.github.io/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A33%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="EIGHTJIU">
<meta property="og:description" content="1. 轮询法 原理：将请求按顺序轮流分配到后端服务器。 特点： 均衡对待所有服务器； 不考虑服务器实际负载或连接数。    将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。  即第n个请求对应第n个节点，很不现实，因为实际节点的配置不相同，配置高的节点收到很低的请求量实在浪费，配置低的节点收到过高请求量会崩溃。   2. 加权轮询法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kizzy899.github.io/aaaset/cover_9.jpg">
<meta property="article:published_time" content="2025-10-19T07:35:09.000Z">
<meta property="article:modified_time" content="2025-10-19T08:43:43.731Z">
<meta property="article:author" content="kizy">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kizzy899.github.io/aaaset/cover_9.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式详解3之负载均衡策略",
  "url": "https://kizzy899.github.io/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A33%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/",
  "image": "https://kizzy899.github.io/aaaset/cover_9.jpg",
  "datePublished": "2025-10-19T07:35:09.000Z",
  "dateModified": "2025-10-19T08:43:43.731Z",
  "author": [
    {
      "@type": "Person",
      "name": "kizy",
      "url": "https://kizzy899.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/tubiao.png"><link rel="canonical" href="https://kizzy899.github.io/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A33%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式详解3之负载均衡策略',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/_custom/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/aaaset/page.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/aaaset/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> Search</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/aaaset/cover_9.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">EIGHTJIU</span></a><a class="nav-page-title" href="/"><span class="site-name">分布式详解3之负载均衡策略</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> Search</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">分布式详解3之负载均衡策略</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-19T07:35:09.000Z" title="发表于 2025-10-19 15:35:09">2025-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T08:43:43.731Z" title="更新于 2025-10-19 16:43:43">2025-10-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h4 id="1-轮询法"><a href="#1-轮询法" class="headerlink" title="1. 轮询法"></a><strong>1. 轮询法</strong></h4><ul>
<li><strong>原理</strong>：将请求按顺序轮流分配到后端服务器。</li>
<li><strong>特点</strong>：<ul>
<li>均衡对待所有服务器；</li>
<li>不考虑服务器实际负载或连接数。</li>
</ul>
</li>
</ul>
<p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
<blockquote>
<p>即第n个请求对应第n个节点，很不现实，因为实际节点的配置不相同，配置高的节点收到很低的请求量实在浪费，配置低的节点收到过高请求量会崩溃。</p>
</blockquote>
<hr>
<h4 id="2-加权轮询法"><a href="#2-加权轮询法" class="headerlink" title="2. 加权轮询法"></a><strong>2. 加权轮询法</strong></h4><ul>
<li><strong>原理</strong>：在轮询的基础上，为不同性能的服务器分配不同权重。</li>
<li><strong>特点</strong>：<ul>
<li>配置高、负载低的服务器权重更高，处理更多请求；</li>
<li>实现按能力分配负载，更灵活合理。</li>
</ul>
</li>
</ul>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的前端；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<blockquote>
<p>实现：可以设置配置高的节点在轮询表中的节点数不止一个，如A1,A2的表示法，但是A节点的实际物理个数还是一个。</p>
</blockquote>
<hr>
<h4 id="3-随机法"><a href="#3-随机法" class="headerlink" title="3. 随机法"></a><strong>3. 随机法</strong></h4><ul>
<li><strong>原理</strong>：随机从服务器列表中选择一台处理请求。</li>
<li><strong>特点</strong>：<ul>
<li>随着请求次数增加，效果趋近于轮询；</li>
<li>实现简单，适用于服务器性能相近的场景。</li>
</ul>
</li>
</ul>
<p>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务器的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p>
<blockquote>
<p>如果节点数够大，和轮询法效果是差不多的</p>
</blockquote>
<hr>
<h4 id="4-加权随机法"><a href="#4-加权随机法" class="headerlink" title="4. 加权随机法"></a><strong>4. 加权随机法</strong></h4><ul>
<li><strong>原理</strong>：在随机法基础上引入权重，按权重随机选择服务器。</li>
<li><strong>特点</strong>：<ul>
<li>高权重服务器被选中的概率更高；</li>
<li>适用于服务器性能不均的场景。</li>
</ul>
</li>
</ul>
<p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重，不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<hr>
<h4 id="5-源地址哈希法"><a href="#5-源地址哈希法" class="headerlink" title="5. 源地址哈希法"></a><strong>5. 源地址哈希法</strong></h4><ul>
<li><strong>原理</strong>：根据客户端IP地址计算哈希值，映射到固定服务器。</li>
<li><strong>特点</strong>：<ul>
<li>同一IP的请求总是分配到同一服务器；</li>
<li>适用于需要会话保持的应用。</li>
</ul>
</li>
</ul>
<p>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取值运算，得到的结果便是服务器驱动器所用的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
<hr>
<h4 id="6-最小连接数法"><a href="#6-最小连接数法" class="headerlink" title="6. 最小连接数法"></a><strong>6. 最小连接数法</strong></h4><ul>
<li><strong>原理</strong>：动态选择当前连接数最少的服务器处理新请求。</li>
<li><strong>特点</strong>：<ul>
<li>考虑服务器实时负载，更智能；</li>
<li>提高服务器资源利用率，合理分流。</li>
</ul>
</li>
</ul>
<p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前和正连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
<blockquote>
<p>谁的机器相对空闲一点，就把请求分发给谁（提高资源利用率）</p>
</blockquote>
<hr>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table>
<thead>
<tr>
<th align="left">算法名称</th>
<th align="left">核心原则</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">轮询法</td>
<td align="left">顺序分配</td>
<td align="left">服务器性能相近</td>
</tr>
<tr>
<td align="left">加权轮询法</td>
<td align="left">按权重顺序分配</td>
<td align="left">服务器性能差异大</td>
</tr>
<tr>
<td align="left">随机法</td>
<td align="left">随机选择</td>
<td align="left">简单均衡需求</td>
</tr>
<tr>
<td align="left">加权随机法</td>
<td align="left">按权重随机选择</td>
<td align="left">性能不均，无需顺序</td>
</tr>
<tr>
<td align="left">源地址哈希法</td>
<td align="left">根据IP哈希固定服务器</td>
<td align="left">需要会话保持</td>
</tr>
<tr>
<td align="left">最小连接数法</td>
<td align="left">选择连接数最少的服务器</td>
<td align="left">实时负载敏感，高并发</td>
</tr>
</tbody></table>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><h2 id="在源地址哈希负载均衡中，如何解决Session共享问题？"><a href="#在源地址哈希负载均衡中，如何解决Session共享问题？" class="headerlink" title="在源地址哈希负载均衡中，如何解决Session共享问题？"></a>在源地址哈希负载均衡中，如何解决Session共享问题？</h2><blockquote>
<p><strong>Session</strong> 是服务器端用来跟踪用户状态的一种机制。当用户第一次访问网站时，服务器会创建一个唯一的Session ID，并通过Cookie返回给浏览器。后续请求中，浏览器会携带这个Session ID，服务器根据ID找到对应的会话数据。</p>
</blockquote>
<blockquote>
<p>核心目的是：<strong>在分布式环境中，确保用户状态数据的一致性和可用性</strong>，从而提供稳定、连贯的用户体验。</p>
</blockquote>
<h3 id="1-Session集中存储"><a href="#1-Session集中存储" class="headerlink" title="1. Session集中存储"></a>1. Session集中存储</h3><ul>
<li><strong>使用Redis&#x2F;Memcached</strong>：将会话数据存储在分布式缓存中</li>
<li><strong>所有服务器访问同一会话存储</strong>：无论请求被路由到哪台服务器，都能获取到相同的会话数据</li>
<li><strong>优点</strong>：会话数据一致，服务器无状态化</li>
</ul>
<h3 id="2-Session复制"><a href="#2-Session复制" class="headerlink" title="2. Session复制"></a>2. Session复制</h3><ul>
<li><strong>集群内会话同步</strong>：当在一台服务器上创建或更新Session时，自动复制到其他服务器</li>
<li><strong>实现方式</strong>：<ul>
<li>Tomcat Session复制</li>
<li>WebSphere Session复制</li>
<li>基于多播的会话同步</li>
</ul>
</li>
<li><strong>缺点</strong>：网络开销大，扩展性受限</li>
</ul>
<h3 id="3-客户端Session存储"><a href="#3-客户端Session存储" class="headerlink" title="3. 客户端Session存储"></a>3. 客户端Session存储</h3><ul>
<li><strong>Cookie存储</strong>：将会话数据加密后存储在客户端Cookie中</li>
<li><strong>Token方式</strong>：使用JWT等无状态令牌</li>
<li><strong>优点</strong>：完全避免服务器端Session存储</li>
<li><strong>缺点</strong>：安全性要求高，数据大小受限</li>
</ul>
<h3 id="4-粘性Session的优化"><a href="#4-粘性Session的优化" class="headerlink" title="4. 粘性Session的优化"></a>4. 粘性Session的优化</h3><ul>
<li><strong>会话备份</strong>：主服务器会话自动备份到一台或多台备用服务器</li>
<li><strong>故障转移机制</strong>：当主服务器宕机时，能将请求路由到有会话备份的服务器</li>
</ul>
<h3 id="5-数据库存储"><a href="#5-数据库存储" class="headerlink" title="5. 数据库存储"></a>5. 数据库存储</h3><ul>
<li><strong>关系型数据库</strong>：MySQL、PostgreSQL等</li>
<li><strong>NoSQL数据库</strong>：MongoDB、Cassandra等</li>
<li><strong>优点</strong>：数据持久化，可靠性高</li>
<li><strong>缺点</strong>：性能相对缓存方案较差</li>
</ul>
<h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a><strong>推荐方案</strong></h3><p><strong>Redis集中存储</strong>是目前最常用的解决方案，因为：</p>
<ul>
<li>高性能，读写速度快</li>
<li>支持数据持久化</li>
<li>集群模式提供高可用性</li>
<li>与语言和框架无关</li>
</ul>
<p>好的，我将以候选人的身份，系统地回答以上问题，展示对负载均衡和Session管理的深入理解。</p>
<hr>
<h2 id="一、基础理解类问题"><a href="#一、基础理解类问题" class="headerlink" title="一、基础理解类问题"></a><strong>一、基础理解类问题</strong></h2><h3 id="1-除了我们讨论的这6种负载均衡算法，你还了解哪些其他的负载均衡策略？"><a href="#1-除了我们讨论的这6种负载均衡算法，你还了解哪些其他的负载均衡策略？" class="headerlink" title="1. 除了我们讨论的这6种负载均衡算法，你还了解哪些其他的负载均衡策略？"></a><strong>1. 除了我们讨论的这6种负载均衡算法，你还了解哪些其他的负载均衡策略？</strong></h3><p><strong>答：</strong><br>除了经典的六种，还有以下几种策略：</p>
<ul>
<li><strong>一致性哈希算法：</strong> 解决了源地址哈希法在服务器扩容或缩容时大量Session失效的问题。通过构建哈希环，仅影响部分请求。</li>
<li><strong>最少响应时间法：</strong> 结合连接数和响应时间，选择响应最快的服务器。</li>
<li><strong>预测负载法：</strong> 基于历史数据和当前趋势，预测服务器未来负载，选择负载最轻的。</li>
<li><strong>基于地理位置的负载均衡：</strong> 将用户请求调度到地理位置上最近的机房，降低网络延迟。</li>
</ul>
<h3 id="2-在什么场景下你会选择源地址哈希法，而不是最小连接数法？"><a href="#2-在什么场景下你会选择源地址哈希法，而不是最小连接数法？" class="headerlink" title="2. 在什么场景下你会选择源地址哈希法，而不是最小连接数法？"></a><strong>2. 在什么场景下你会选择源地址哈希法，而不是最小连接数法？</strong></h3><p><strong>答：</strong></p>
<ul>
<li><p><strong>选择源地址哈希法的场景：</strong></p>
<ol>
<li><strong>有状态服务：</strong> 需要会话保持（Session Stickiness），且未做Session共享。例如，一些遗留系统或特定中间件。</li>
<li><strong>缓存局部性：</strong> 用户多次访问同一服务器，可以利用该服务器上已缓存的热点数据，提高性能。</li>
<li><strong>依赖本地状态的业务：</strong> 某些业务逻辑在单次会话中与服务器本地状态强绑定。</li>
</ol>
</li>
<li><p><strong>选择最小连接数法的场景：</strong></p>
<ol>
<li><strong>无状态服务：</strong> 服务实例完全无状态，任何请求发往任何实例结果都一样。</li>
<li><strong>长连接场景：</strong> 如WebSocket、FTP等，连接持续时间长，最小连接数能更公平地分配负载。</li>
<li><strong>请求处理时间差异大：</strong> 有些请求是轻量级的，有些是重量级的，最小连接数能更好地平衡服务器实际负载。</li>
</ol>
</li>
</ul>
<p><strong>核心抉择点：</strong> 业务是否强依赖“同一用户请求必须落到同一台服务器”。如果是，且改造成本高，则用源地址哈希；否则，更智能的最小连接数法是更好的选择。</p>
<h3 id="3-你能解释一下Session和Cookie的根本区别是什么吗？"><a href="#3-你能解释一下Session和Cookie的根本区别是什么吗？" class="headerlink" title="3. 你能解释一下Session和Cookie的根本区别是什么吗？"></a><strong>3. 你能解释一下Session和Cookie的根本区别是什么吗？</strong></h3><p><strong>答：</strong><br>根本区别在于<strong>存储位置和安全性</strong>。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Session</th>
<th align="left">Cookie</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>存储位置</strong></td>
<td align="left"><strong>服务器端</strong>（内存、Redis、数据库）</td>
<td align="left"><strong>客户端</strong>（浏览器）</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>较高</strong>，数据存储在服务端，不易被篡改</td>
<td align="left"><strong>较低</strong>，数据在客户端，可能被禁用、查看、篡改</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">通常有失效时间，可主动销毁</td>
<td align="left">可设置过期时间，包括浏览器会话期和持久化</td>
</tr>
<tr>
<td align="left"><strong>存储容量</strong></td>
<td align="left">理论上只受服务器资源限制</td>
<td align="left">每个站点有大小（约4KB）和数量限制</td>
</tr>
<tr>
<td align="left"><strong>网络开销</strong></td>
<td align="left">仅传输Session ID</td>
<td align="left">每次HTTP请求都会携带Cookie数据</td>
</tr>
<tr>
<td align="left"><strong>数据类型</strong></td>
<td align="left">可存储复杂对象（Java&#x2F;Python对象等）</td>
<td align="left">只能存储字符串</td>
</tr>
</tbody></table>
<p><strong>关系：</strong> Session机制通常依赖于Cookie来传递Session ID，但也可以通过URL重写来实现。</p>
<hr>
<h2 id="二、深度技术类问题"><a href="#二、深度技术类问题" class="headerlink" title="二、深度技术类问题"></a><strong>二、深度技术类问题</strong></h2><h3 id="4-在使用Redis做Session集中存储时，如何设计Key的过期策略？"><a href="#4-在使用Redis做Session集中存储时，如何设计Key的过期策略？" class="headerlink" title="4. 在使用Redis做Session集中存储时，如何设计Key的过期策略？"></a><strong>4. 在使用Redis做Session集中存储时，如何设计Key的过期策略？</strong></h3><p><strong>答：</strong><br>这是一个兼顾用户体验和资源清理的问题。</p>
<ol>
<li><p><strong>设置合理的TTL（Time-To-Live）：</strong></p>
<ul>
<li>根据业务场景设置Session过期时间，例如普通网站可设为30分钟，金融类网站可设为15分钟。</li>
<li>在Redis中为每个Session Key设置<code>EXPIRE</code>时间。</li>
</ul>
</li>
<li><p><strong>实现滑动过期：</strong></p>
<ul>
<li>用户每次有活跃请求时，都<strong>刷新</strong>一次Session Key的TTL。这可以通过中间件或AOP切面来实现。</li>
<li>这样，活跃用户的Session会一直存在，而闲置用户的Session会被自动清理。</li>
</ul>
</li>
<li><p><strong>使用Redis的主动淘汰策略：</strong></p>
<ul>
<li>设置<code>maxmemory-policy</code>为 <code>volatile-lru</code> 或 <code>allkeys-lru</code>，当内存不足时，Redis会优先淘汰最近最少使用的Key。</li>
</ul>
</li>
<li><p><strong>后台补偿任务：</strong></p>
<ul>
<li>创建一个定时任务，定期扫描并删除那些已过期但未被Redis自动删除的“僵尸”Session Key，作为第二道保险。</li>
</ul>
</li>
</ol>
<h3 id="5-当Redis集群出现故障时，如何保证Session不会完全丢失？"><a href="#5-当Redis集群出现故障时，如何保证Session不会完全丢失？" class="headerlink" title="5. 当Redis集群出现故障时，如何保证Session不会完全丢失？"></a><strong>5. 当Redis集群出现故障时，如何保证Session不会完全丢失？</strong></h3><p><strong>答：</strong><br>通过<strong>高可用架构</strong>和<strong>降级方案</strong>来保障。</p>
<ol>
<li><p><strong>高可用架构：</strong></p>
<ul>
<li><strong>Redis Sentinel（哨兵）：</strong> 部署主从复制和哨兵集群，实现自动故障转移。当主节点宕机，哨兵会选举一个从节点升级为主节点。</li>
<li><strong>Redis Cluster：</strong> 使用集群模式，数据分片存储在多个节点上，部分节点故障不影响整体服务。</li>
</ul>
</li>
<li><p><strong>数据持久化：</strong></p>
<ul>
<li>开启 <strong>AOF（Append Only File）</strong> 并设置为 <code>everysec</code> 策略。在故障恢复后，可以通过重放AOF文件来恢复大部分数据，最大限度减少Session丢失。</li>
</ul>
</li>
<li><p><strong>多级缓存与降级方案：</strong></p>
<ul>
<li><strong>本地Session降级：</strong> 在应用服务器本地内存中维护一份当前活跃用户的Session副本（短期）。当Redis不可用时，暂时退化为基于本地内存的Session管理，并给用户一个友好提示（如“系统不稳定，请稍后再试”）。待Redis恢复后，再将数据同步回去。</li>
<li><strong>牺牲一致性保可用性：</strong> 在降级期间，不同用户的请求可能会被负载均衡到不同服务器，由于Session是本地化的，会导致数据不一致。这是一种“两害相权取其轻”的权衡。</li>
</ul>
</li>
</ol>
<h3 id="6-在微服务架构中，Session共享方案与Token方案各有什么优缺点？"><a href="#6-在微服务架构中，Session共享方案与Token方案各有什么优缺点？" class="headerlink" title="6. 在微服务架构中，Session共享方案与Token方案各有什么优缺点？"></a><strong>6. 在微服务架构中，Session共享方案与Token方案各有什么优缺点？</strong></h3><p><strong>答：</strong></p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">Session共享</th>
<th align="left">Token（如JWT）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>优点</strong></td>
<td align="left">1. <strong>服务端强控制：</strong> 可随时让某个Session失效。<br>2. <strong>存储信息量大：</strong> 可存复杂状态。<br>3. <strong>成熟方案：</strong> 有现成的框架和库。</td>
<td align="left">1. <strong>无状态：</strong> 服务端无需存储，扩展性极佳。<br>2. <strong>多端支持：</strong> 天然适合APP、小程序等。<br>3. <strong>跨域友好：</strong> 易于实现单点登录（SSO）。</td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left">1. <strong>有状态：</strong> 对存储系统（如Redis）有依赖和性能要求。<br>2. <strong>扩展性挑战：</strong> 存储中心可能成为瓶颈。<br>3. <strong>跨域复杂：</strong> 实现SSO较麻烦。</td>
<td align="left">1. <strong>服务端控制弱：</strong> Token在颁发后无法中途废止，除非引入黑名单机制。<br>2. <strong>信息量受限：</strong> 不宜存储过多信息，影响网络性能。<br>3. <strong>安全性依赖：</strong> 密钥一旦泄露，后果严重。</td>
</tr>
</tbody></table>
<p><strong>选型建议：</strong></p>
<ul>
<li><strong>选择Session共享：</strong> 系统边界清晰，主要是Web端，需要服务端强控制会话（如后台管理系统）。</li>
<li><strong>选择Token：</strong> 微服务数量多，需要严格无状态化；或需要支持多端（Web, App, 第三方接入）。</li>
</ul>
<h3 id="7-源地址哈希法在云原生环境（K8s）中会遇到什么挑战？"><a href="#7-源地址哈希法在云原生环境（K8s）中会遇到什么挑战？" class="headerlink" title="7. 源地址哈希法在云原生环境（K8s）中会遇到什么挑战？"></a><strong>7. 源地址哈希法在云原生环境（K8s）中会遇到什么挑战？</strong></h3><p><strong>答：</strong><br>云原生环境的<strong>动态性</strong>与源地址哈希的<strong>静态假设</strong>存在根本矛盾。</p>
<ol>
<li><strong>Pod动态伸缩：</strong> K8s中的Pod（服务实例）会随着负载自动创建和销毁。源地址哈希依赖一个稳定的服务器列表，而K8s的服务器列表是动态变化的，导致哈希映射混乱，会话保持失效。</li>
<li><strong>Pod漂移：</strong> 同一个Pod在不同时间可能被调度到不同的物理节点，其IP地址会改变。这破坏了源地址哈希的基础。</li>
<li><strong>网络模型：</strong> 在K8s中，通常使用Service进行服务发现和负载均衡。请求的源IP可能是Service的IP或Ingress Controller的IP，而不是真实的用户IP，导致哈希失效。</li>
</ol>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>使用Service的<code>sessionAffinity: ClientIP</code>：</strong> K8s的Service提供了基于客户端IP的会话保持功能，它在内部维护了映射关系，能适应Pod的动态变化。</li>
<li><strong>采用七层负载均衡（Ingress）：</strong> 在Ingress层面（如Nginx Ingress Controller）配置基于Cookie的会话保持，这比基于IP更可靠。</li>
<li><strong>放弃会话保持，拥抱无状态：</strong> 这是云原生推荐的最佳实践。将状态外置到Redis等中间件中，使服务本身无状态，从而可以自由伸缩。</li>
</ul>
<hr>
<h2 id="三、架构设计类问题"><a href="#三、架构设计类问题" class="headerlink" title="三、架构设计类问题"></a><strong>三、架构设计类问题</strong></h2><h3 id="8-如果让你设计一个电商平台的负载均衡和Session管理方案，你会如何考虑？"><a href="#8-如果让你设计一个电商平台的负载均衡和Session管理方案，你会如何考虑？" class="headerlink" title="8. 如果让你设计一个电商平台的负载均衡和Session管理方案，你会如何考虑？"></a><strong>8. 如果让你设计一个电商平台的负载均衡和Session管理方案，你会如何考虑？</strong></h3><p><strong>答：</strong><br>我会采用<strong>分层和分业务</strong>的设计思路。</p>
<ol>
<li><p><strong>负载均衡层：</strong></p>
<ul>
<li><strong>网关&#x2F;入口层：</strong> 使用<strong>加权轮询</strong>或<strong>最小连接数</strong>，将流量分发到多个网关实例。</li>
<li><strong>业务层：</strong> 根据不同业务特性选择算法。<ul>
<li><strong>用户中心、订单服务：</strong> 无状态服务，使用<strong>最小连接数</strong>，保证高并发下的负载均衡。</li>
<li><strong>购物车服务：</strong> 初期若改造困难，可在网关层配置<strong>基于Cookie的会话保持</strong>，定向到同一实例。长期目标应改造为无状态，将购物车数据存入<strong>Redis</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Session管理层：</strong></p>
<ul>
<li><strong>技术选型：</strong> 使用 <strong>Redis Cluster</strong> 作为集中式Session存储。</li>
<li><strong>数据结构：</strong> 使用 <code>String</code> 或 <code>Hash</code> 类型存储Session对象，Key为 <code>session:&#123;sessionId&#125;</code>。</li>
<li><strong>过期策略：</strong> 设置30分钟TTL，并实现滑动过期。</li>
<li><strong>高可用：</strong> 部署Redis哨兵或集群，确保故障自动转移。</li>
</ul>
</li>
<li><p><strong>安全与性能：</strong></p>
<ul>
<li><strong>Session安全：</strong> Session ID使用强随机数生成，HTTPS传输。</li>
<li><strong>缓存性能：</strong> 对频繁读取但不常变的用户信息（如用户名、头像），可在应用本地增加一层缓存，减轻Redis压力。</li>
</ul>
</li>
</ol>
<h3 id="9-在高并发场景下，Session集中存储可能成为瓶颈，你有什么优化思路？"><a href="#9-在高并发场景下，Session集中存储可能成为瓶颈，你有什么优化思路？" class="headerlink" title="9. 在高并发场景下，Session集中存储可能成为瓶颈，你有什么优化思路？"></a><strong>9. 在高并发场景下，Session集中存储可能成为瓶颈，你有什么优化思路？</strong></h3><p><strong>答：</strong></p>
<ol>
<li><p><strong>减少对Session存储的访问：</strong></p>
<ul>
<li><strong>本地缓存：</strong> 将不敏感但频繁使用的Session数据（如用户ID、用户名）在应用服务器本地缓存一小段时间（如几秒钟）。</li>
<li><strong>客户端存储：</strong> 将部分非核心数据（如用户界面偏好）加密后存储在客户端的Cookie或LocalStorage中。</li>
</ul>
</li>
<li><p><strong>优化Redis本身：</strong></p>
<ul>
<li><strong>集群模式：</strong> 使用Redis Cluster进行数据分片，将压力分散到多个节点。</li>
<li><strong>读写分离：</strong> 配置主从复制，将读操作分流到从节点。</li>
<li><strong>连接池：</strong> 使用连接池减少建立和断开连接的开销。</li>
<li><strong>Pipeline：</strong> 如果一次请求需要多个Session操作，使用Pipeline批量执行。</li>
</ul>
</li>
<li><p><strong>架构优化：</strong></p>
<ul>
<li><strong>使用更快的序列化协议：</strong> 比如用Protobuf、MsgPack替代JSON。</li>
<li><strong>分级存储：</strong> 极度活跃的Session放在内存，稍旧的在Redis，设计复杂的归档机制。</li>
</ul>
</li>
<li><p><strong>根本性解决：向无状态演进</strong></p>
<ul>
<li>将系统彻底改造为无状态，使用JWT等Token方案，从根本上消除对中心化Session存储的依赖。</li>
</ul>
</li>
</ol>
<h3 id="10-如何监控和评估你选择的负载均衡算法是否有效？"><a href="#10-如何监控和评估你选择的负载均衡算法是否有效？" class="headerlink" title="10. 如何监控和评估你选择的负载均衡算法是否有效？"></a><strong>10. 如何监控和评估你选择的负载均衡算法是否有效？</strong></h3><p><strong>答：</strong><br>通过<strong>监控关键指标</strong>和<strong>建立评估体系</strong>来判断。</p>
<ol>
<li><p><strong>监控指标：</strong></p>
<ul>
<li><strong>服务器指标：</strong> 各服务器的CPU使用率、内存使用率、网络I&#x2F;O、磁盘I&#x2F;O。理想状态下各实例指标应均衡。</li>
<li><strong>应用指标：</strong><ul>
<li><strong>响应时间（P50, P95, P99）：</strong> 观察是否有个别服务器响应时间明显变长。</li>
<li><strong>错误率：</strong> 是否有某台服务器的错误率（如5xx）异常升高。</li>
<li><strong>QPS（每秒查询率）：</strong> 各服务器处理的请求量是否均衡。</li>
</ul>
</li>
<li><strong>负载均衡器自身指标：</strong> 连接数、吞吐量、健康检查状态。</li>
</ul>
</li>
<li><p><strong>评估方法：</strong></p>
<ul>
<li><strong>对比分析：</strong> 在流量平稳期和高峰期，分别观察上述指标，看算法在不同压力下的表现。</li>
<li><strong>A&#x2F;B测试：</strong> 如果可以，将部分流量切换到另一种负载均衡算法，对比两种算法的核心指标（如平均响应时间、错误率）。</li>
<li><strong>用户反馈：</strong> 关注是否有用户抱怨“卡顿”或“需要重复登录”，这可能与负载不均或Session丢失有关。</li>
</ul>
</li>
</ol>
<p><strong>有效的标志：</strong> 各服务器资源使用率均衡，整体响应时间稳定，错误率低，且能平滑应对流量波动。</p>
<hr>
<h2 id="四、故障处理类问题"><a href="#四、故障处理类问题" class="headerlink" title="四、故障处理类问题"></a><strong>四、故障处理类问题</strong></h2><h3 id="11-当发现某台服务器的Session丢失率很高时，你的排查思路是什么？"><a href="#11-当发现某台服务器的Session丢失率很高时，你的排查思路是什么？" class="headerlink" title="11. 当发现某台服务器的Session丢失率很高时，你的排查思路是什么？"></a><strong>11. 当发现某台服务器的Session丢失率很高时，你的排查思路是什么？</strong></h3><p><strong>答：</strong><br>这是一个典型的“数据不一致”问题，排查思路如下：</p>
<ol>
<li><strong>确认问题范围：</strong> 是个别用户反馈还是监控大盘显示该服务器Session错误率显著高于其他实例？</li>
<li><strong>检查该服务器本身：</strong><ul>
<li><strong>资源瓶颈：</strong> CPU、内存、磁盘是否爆满，导致应用无法正常读写Redis？</li>
<li><strong>网络连通性：</strong> 从该服务器<code>ping</code>&#x2F;<code>telnet</code> Redis集群，检查网络是否稳定，是否有丢包或延迟陡增。</li>
<li><strong>应用日志：</strong> 查看该服务器应用日志，是否有大量的Redis连接超时、序列化&#x2F;反序列化异常？</li>
<li><strong>GC情况：</strong> 是否发生了长时间的Full GC，导致应用暂停，无法及时刷新Session的TTL？</li>
</ul>
</li>
<li><strong>检查Redis集群：</strong><ul>
<li><strong>查看Redis监控：</strong> 该服务器连接的Redis分片是否发生故障转移？该分片的负载是否异常？</li>
<li><strong>查看Redis日志：</strong> 是否有大量键过期或被淘汰的日志？</li>
</ul>
</li>
<li><strong>检查负载均衡配置：</strong><ul>
<li><strong>健康检查：</strong> 负载均衡器对该服务器的健康检查配置是否过于敏感，导致请求还没处理完就被标记为不健康？</li>
<li><strong>会话保持：</strong> 如果使用了会话保持，检查其配置是否正确，是否在维护期内。</li>
</ul>
</li>
</ol>
<h3 id="12-如果用户反映经常被要求重复登录，你觉得可能是什么原因导致的？"><a href="#12-如果用户反映经常被要求重复登录，你觉得可能是什么原因导致的？" class="headerlink" title="12. 如果用户反映经常被要求重复登录，你觉得可能是什么原因导致的？"></a><strong>12. 如果用户反映经常被要求重复登录，你觉得可能是什么原因导致的？</strong></h3><p><strong>答：</strong><br>核心原因是<strong>Session失效或丢失</strong>。</p>
<ol>
<li><p><strong>服务端原因：</strong></p>
<ul>
<li><strong>Session过期时间设置过短。</strong></li>
<li><strong>Redis故障或内存不足，</strong> 导致Session Key被提前淘汰。</li>
<li><strong>服务器重启或扩容，</strong> 而Session存储在本地内存中，未做共享。</li>
<li><strong>负载均衡会话保持失效，</strong> 请求被路由到了没有该用户Session的服务器。</li>
</ul>
</li>
<li><p><strong>客户端原因：</strong></p>
<ul>
<li><strong>浏览器禁用了Cookie，</strong> 导致Session ID无法传递。</li>
<li><strong>浏览器或客户端异常清除了Cookie。</strong></li>
<li><strong>用户使用了不同的终端或浏览器。</strong></li>
</ul>
</li>
<li><p><strong>网络原因：</strong></p>
<ul>
<li><strong>在跨域场景下，前端未正确携带Cookie。</strong></li>
<li><strong>某些网络设备（如代理）过滤或修改了Cookie信息。</strong></li>
</ul>
</li>
</ol>
<p><strong>排查步骤：</strong> 先复现问题，然后检查浏览器开发者工具中的Network面板，看请求是否携带了正确的Cookie，再顺藤摸瓜检查服务端日志和Redis中的Session状态。</p>
<h3 id="13-在服务器扩容时，如何保证源地址哈希法的会话保持不受影响？"><a href="#13-在服务器扩容时，如何保证源地址哈希法的会话保持不受影响？" class="headerlink" title="13. 在服务器扩容时，如何保证源地址哈希法的会话保持不受影响？"></a><strong>13. 在服务器扩容时，如何保证源地址哈希法的会话保持不受影响？</strong></h3><p><strong>答：</strong><br>源地址哈希法在服务器列表变化时，<strong>几乎无法避免</strong>会话中断。但可以采取以下措施<strong>最小化影响</strong>：</p>
<ol>
<li><strong>使用一致性哈希算法替代：</strong> 这是最推荐的解决方案。一致性哈希在扩容时，仅会重定位 <code>K/n</code> 个键（K是键总数，n是服务器数量），大部分会话映射保持不变。</li>
<li><strong>优雅缩容&#x2F;扩容：</strong><ul>
<li><strong>手动操作：</strong> 在流量低峰期进行扩容。</li>
<li><strong>双写策略：</strong> 在扩容期间，一段时间内同时向新老两台服务器写入Session数据。</li>
<li><strong>通知客户端：</strong> 在Session失效时，给客户端返回一个特定的错误码，引导用户重新登录，并提供友好提示。</li>
</ul>
</li>
<li><strong>根本性解决：</strong><ul>
<li><strong>放弃源地址哈希，采用无状态架构。</strong> 这是最一劳永逸的方法。当服务无状态后，扩容缩容对用户完全无感。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="五、扩展思考类问题"><a href="#五、扩展思考类问题" class="headerlink" title="五、扩展思考类问题"></a><strong>五、扩展思考类问题</strong></h2><h3 id="14-除了Session共享，还有哪些方法可以解决无状态服务的数据一致性问题？"><a href="#14-除了Session共享，还有哪些方法可以解决无状态服务的数据一致性问题？" class="headerlink" title="14. 除了Session共享，还有哪些方法可以解决无状态服务的数据一致性问题？"></a><strong>14. 除了Session共享，还有哪些方法可以解决无状态服务的数据一致性问题？</strong></h3><p><strong>答：</strong><br>“数据一致性”在这里更准确地说是“状态管理”问题。</p>
<ol>
<li><strong>Token方案（如JWT）：</strong> 将状态信息（如用户ID、角色）直接编码到Token中，由客户端存储和传递。服务端只需验证Token有效性，无需存储会话状态。</li>
<li><strong>客户端存储：</strong> 将非敏感数据直接存储在客户端（Cookie, LocalStorage），每次请求携带。需要解决安全性和数据量的问题。</li>
<li><strong>分布式缓存&#x2F;数据库：</strong> 这本质上是Session共享的泛化。不仅是Session，任何需要共享的状态（如分布式锁、计数器、全局配置）都可以存入Redis、Etcd、ZooKeeper等中间件。</li>
<li><strong>事件溯源与CQRS：</strong> 在复杂业务场景下，将所有状态变化作为事件序列持久化。通过重放事件来重建状态，保证了状态的最终一致性。</li>
</ol>
<h3 id="15-随着前后端分离和移动端的普及，传统的Session管理方式面临哪些挑战？"><a href="#15-随着前后端分离和移动端的普及，传统的Session管理方式面临哪些挑战？" class="headerlink" title="15. 随着前后端分离和移动端的普及，传统的Session管理方式面临哪些挑战？"></a><strong>15. 随着前后端分离和移动端的普及，传统的Session管理方式面临哪些挑战？</strong></h3><p><strong>答：</strong></p>
<ol>
<li><strong>跨域问题：</strong> 前端域名与后端API域名不同，导致Cookie在默认情况下无法携带，需要配置 <code>CORS</code> 和 <code>withCredentials</code>。</li>
<li><strong>多端支持困难：</strong> Web、iOS App、Android App、小程序等可能使用不同的HTTP客户端，对Cookie的支持和处理方式不一，管理复杂度高。</li>
<li><strong>RESTful API无状态约束：</strong> 纯正的RESTful API倡导无状态，Session机制与之相悖。</li>
<li><strong>扩展性瓶颈：</strong> 移动互联网用户量巨大，中心化的Session存储可能成为性能和单点故障的瓶颈。</li>
<li><strong>安全性：</strong> 移动端环境更复杂，CSRF、Session劫持等安全问题需要更复杂的策略来应对。</li>
</ol>
<p><strong>因此，Token-Based Authentication（如JWT、OAuth 2.0）在现代应用开发中变得越来越流行。</strong></p>
<h3 id="16-如何平衡负载均衡的公平性和业务特殊性之间的关系？"><a href="#16-如何平衡负载均衡的公平性和业务特殊性之间的关系？" class="headerlink" title="16. 如何平衡负载均衡的公平性和业务特殊性之间的关系？"></a><strong>16. 如何平衡负载均衡的公平性和业务特殊性之间的关系？</strong></h3><p><strong>答：</strong><br>这是一个<strong>架构权衡</strong>问题，没有银弹。</p>
<ol>
<li><p><strong>定义“公平性”和“特殊性”：</strong></p>
<ul>
<li><strong>公平性：</strong> 通常指服务器间的负载（CPU、连接数、流量）尽可能均衡。</li>
<li><strong>特殊性：</strong> 指业务上的硬性要求，如会话保持、服务器异构（配置不同）、特定任务必须由特定服务器处理（如有GPU的服务器处理AI任务）。</li>
</ul>
</li>
<li><p><strong>平衡策略：</strong></p>
<ul>
<li><strong>分层与分治：</strong> 在全局负载均衡层使用简单公平的算法（如轮询），在内部服务路由层根据业务特殊性使用特定算法（如加权、哈希）。</li>
<li><strong>使用加权算法：</strong> 这是平衡公平与特殊性的典型例子。它通过给高配服务器更高权重，既承认了“特殊性”（机器配置不同），又实现了基于能力的“公平”。</li>
<li><strong>设置路由规则：</strong> 在API网关或服务网格中，可以配置灵活的路由规则。例如，90%的流量按最小连接数分配，10%带特定标签的流量按源地址哈希分配。</li>
<li><strong>监控与调优：</strong> 持续监控业务指标和系统指标。如果为了业务特殊性（如会话保持）导致了严重的负载不均，就需要重新评估这种特殊性的价值，或者寻找技术方案（如Session共享）来消除它。</li>
</ul>
</li>
</ol>
<p><strong>核心思想：</strong> 技术的选择应服务于业务。优先满足不可妥协的业务需求，再通过其他技术手段来弥补由此带来的副作用（如负载不均），从而在动态中寻求最佳平衡点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io">kizy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A33%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/">https://kizzy899.github.io/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A33%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kizzy899.github.io" target="_blank">EIGHTJIU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><div class="post-share"><div class="social-share" data-image="/aaaset/cover_9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A34/" title="分布式详解4"><img class="cover" src="/aaaset/cover_16.jpg" onerror="onerror=null;src='/img/404page.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">分布式详解4</div></div><div class="info-2"><div class="info-item-1">集群、分布式、SOA、微服务的概念及区别集群不同服务器部署同一套应用服务对外提供访问，实现服务的负载均衡或者互备(热备，主从等)，指向一种组件的多个实例，形成的逻辑上的整体。单个节点可以提供完整服务。集群是物理形态 问题“节点对等”是理想集群的一个核心特征，而“Nginx分发”是实现这一特征的最常用技术手段之一。  集群是一种系统架构的目标和组织形式。  节点对等是实现该目标的一种优秀内部结构和设计原则，它使得集群易于扩展和高可用。  Nginx分发是实现该目标的一个关键外部工具和流量调度机制，它负责将用户请求合理地分配给内部那些对等的节点，是集群能力的“放大器”。   详细解释1. “集群中的节点位置对等”与集群的关系这个概念描述的是集群内部节点的一种理想关系。  什么是对等？ 功能对等：每个节点都运行着完全相同的一份代码或服务（例如，都部署了你的Web应用）。 身份对等：从负载均衡器的角度看，这些节点没有本质区别，任何一个节点都可以处理任何一个请求。它们通常是无状态的。 可替代性：如果其中一个节点宕机，其他节点可以立刻接管它的工作，用户不会感知到任何区别（除了可能的短暂性能波...</div></div></div></a><a class="pagination-related" href="/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%933/" title="基础漏洞总结3"><img class="cover" src="/aaaset/cover_10.jpg" onerror="onerror=null;src='/img/404page.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">基础漏洞总结3</div></div><div class="info-2"><div class="info-item-1">拒绝服务拒绝服务指的是攻击者通过某种方式阻止合约正常执行其预期功能，使得合约无法继续服务合法用户。 简单来说，这是一种”我让你无法正常工作”的攻击方式。在智能合约中，DoS攻击通常通过操纵合约状态或利用执行限制来实现。 示例一个代币分发合约，负责收集投资并向投资者分发回报： 123456789101112131415161718192021contract DistributeTokens &#123;    address public owner; // gets set somewhere    address[] investors; // array of investors    uint[] investorBalances; // the amount investor gets    bool public isFinalized = false;        // ...        function invest() public payable &#123;        investors.push(msg.sender);        inves...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/29/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A31/" title="分布式详解1"><img class="cover" src="/aaaset/cover_14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-29</div><div class="info-item-2">分布式详解1</div></div><div class="info-2"><div class="info-item-1">CAP理论简述CAP理论  **数据一致性 (Consistency)**：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。对调用者而言数据具有强一致性。 **服务可用性 (Availability)**：所有读写请求在一定时间内得到响应，可终止、不会一直等待。 **分区容错性 (Partition Tolerance)**：在网络分区的情况下，被分解的节点仍能正常对外服务。  如果选择了CA而放弃了P，那么当发生分区现象时，为了保证C，系统需要禁止写入，当有写入请求时，系统返回error，这又和A冲突了，因为A要求返回no error和no timeout。因此，分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。 反证：如果CAP三者可同时满足，由于允许P的存在，则一定存在节点之间的丢包，如此则不能保证C。因为允许分区容错，写操作可能在节点1上成功，在节点2上失败，这时候对于Client1（读取节点1）和Client2（读取节点2），就会读取到不一致的值，出现不一致的情况。如果要保持一致性，写操作必...</div></div></div></a><a class="pagination-related" href="/2025/10/04/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A32/" title="分布式详解2"><img class="cover" src="/aaaset/cover_15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-04</div><div class="info-item-2">分布式详解2</div></div><div class="info-2"><div class="info-item-1">ZAB协议ZAB协议定义ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性。 ZAB协议组成部分消息广播 集群中所有的事务请求都由Leader节点来处理，其他服务器为Follower Leader将客户端的事务请求转换为事务Proposal，并且将Proposal分发给集群中其他所有的Follower 完成广播之后，Leader等待Follower反馈，当有过半数的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息 Commit信息就是确认将之前的Proposal提交 Leader节点的写入是一个两步操作：第一步是广播事务操作，第二步是广播提交操作 过半数指的是反馈的节点数 &gt;&#x3D;N&#x2F;2+1，N是全部的Follower节点数量  崩溃恢复 在以下情况下会进入崩溃恢复模式： 初始化集群，刚刚启动的时候 Leader崩溃，因为故障宕机 Leader失去了半数的机器支持，与集群中超过一半的节点断连   此时开启新一轮Leader选举，选举产生的Leader会与过半的...</div></div></div></a><a class="pagination-related" href="/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A34/" title="分布式详解4"><img class="cover" src="/aaaset/cover_16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-19</div><div class="info-item-2">分布式详解4</div></div><div class="info-2"><div class="info-item-1">集群、分布式、SOA、微服务的概念及区别集群不同服务器部署同一套应用服务对外提供访问，实现服务的负载均衡或者互备(热备，主从等)，指向一种组件的多个实例，形成的逻辑上的整体。单个节点可以提供完整服务。集群是物理形态 问题“节点对等”是理想集群的一个核心特征，而“Nginx分发”是实现这一特征的最常用技术手段之一。  集群是一种系统架构的目标和组织形式。  节点对等是实现该目标的一种优秀内部结构和设计原则，它使得集群易于扩展和高可用。  Nginx分发是实现该目标的一个关键外部工具和流量调度机制，它负责将用户请求合理地分配给内部那些对等的节点，是集群能力的“放大器”。   详细解释1. “集群中的节点位置对等”与集群的关系这个概念描述的是集群内部节点的一种理想关系。  什么是对等？ 功能对等：每个节点都运行着完全相同的一份代码或服务（例如，都部署了你的Web应用）。 身份对等：从负载均衡器的角度看，这些节点没有本质区别，任何一个节点都可以处理任何一个请求。它们通常是无状态的。 可替代性：如果其中一个节点宕机，其他节点可以立刻接管它的工作，用户不会感知到任何区别（除了可能的短暂性能波...</div></div></div></a><a class="pagination-related" href="/2025/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E8%A7%A35/" title="分布式详解5"><img class="cover" src="/aaaset/cover_7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-19</div><div class="info-item-2">分布式详解5</div></div><div class="info-2"><div class="info-item-1">分布式事务有哪些解决方案基于XA协议的两阶段提交和三阶段提交，需要数据库层面支持。 XA协议通常不是通过简单的单条SQL命令来完成的，而是通过一组命令&#x2F;API调用来管理一个分布式事务的完整生命周期。这些命令通常由事务管理器 调用，而应用程序则通过高级抽象（如Java JTA）来间接使用。 一些核心命令：    段 命令&#x2F;函数名 说明 常见实现举例    阶段一：准备阶段 xa_start 开启一个分布式事务分支，将其与一个全局事务ID（XID）关联。 C API &#x2F; 数据库驱动内部调用    xa_end 结束当前线程与分布式事务分支的关联。 C API &#x2F; 数据库驱动内部调用    xa_prepare 核心命令。事务管理器向所有参与者发出此命令。参与者将事务内容持久化到日志中，并锁定相关资源，然后返回“就绪”或“失败”状态。 MySQL: XA PREPARE &#39;&lt;xid&gt;&#39;   阶段二：提交&#x2F;回滚阶段 xa_commit 提交命令。如果所有参与者都返回“就绪”，事务管理器向所有参与者发出此命令，要...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/aaaset/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kizy</div><div class="author-info-description">rainbow</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kizzy899"><i class="fab fa-github"></i><span>my github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kizzy899" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Sampre avanti</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AE%E8%AF%A2%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">1. 轮询法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2. 加权轮询法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%8F%E6%9C%BA%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">3. 随机法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4. 加权随机法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">5. 源地址哈希法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">6. 最小连接数法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number"></span> <span class="toc-text">对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-number"></span> <span class="toc-text">问题汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">在源地址哈希负载均衡中，如何解决Session共享问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Session%E9%9B%86%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">1. Session集中存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Session%E5%A4%8D%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">2. Session复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AFSession%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">3. 客户端Session存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B2%98%E6%80%A7Session%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">4. 粘性Session的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">5. 数据库存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">推荐方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">一、基础理解类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%99%A4%E4%BA%86%E6%88%91%E4%BB%AC%E8%AE%A8%E8%AE%BA%E7%9A%84%E8%BF%996%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BD%A0%E8%BF%98%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">1. 除了我们讨论的这6种负载均衡算法，你还了解哪些其他的负载均衡策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%A0%E4%BC%9A%E9%80%89%E6%8B%A9%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%B3%95%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">2. 在什么场景下你会选择源地址哈希法，而不是最小连接数法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BSession%E5%92%8CCookie%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">3. 你能解释一下Session和Cookie的根本区别是什么吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B7%B1%E5%BA%A6%E6%8A%80%E6%9C%AF%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">二、深度技术类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9C%A8%E4%BD%BF%E7%94%A8Redis%E5%81%9ASession%E9%9B%86%E4%B8%AD%E5%AD%98%E5%82%A8%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1Key%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">4. 在使用Redis做Session集中存储时，如何设计Key的过期策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BD%93Redis%E9%9B%86%E7%BE%A4%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Session%E4%B8%8D%E4%BC%9A%E5%AE%8C%E5%85%A8%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">5. 当Redis集群出现故障时，如何保证Session不会完全丢失？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%EF%BC%8CSession%E5%85%B1%E4%BA%AB%E6%96%B9%E6%A1%88%E4%B8%8EToken%E6%96%B9%E6%A1%88%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">6. 在微服务架构中，Session共享方案与Token方案各有什么优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%EF%BC%88K8s%EF%BC%89%E4%B8%AD%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E6%8C%91%E6%88%98%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">7. 源地址哈希法在云原生环境（K8s）中会遇到什么挑战？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">三、架构设计类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8CSession%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">8. 如果让你设计一个电商平台的负载均衡和Session管理方案，你会如何考虑？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8CSession%E9%9B%86%E4%B8%AD%E5%AD%98%E5%82%A8%E5%8F%AF%E8%83%BD%E6%88%90%E4%B8%BA%E7%93%B6%E9%A2%88%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">9. 在高并发场景下，Session集中存储可能成为瓶颈，你有什么优化思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E8%AF%84%E4%BC%B0%E4%BD%A0%E9%80%89%E6%8B%A9%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">10. 如何监控和评估你选择的负载均衡算法是否有效？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">四、故障处理类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%BD%93%E5%8F%91%E7%8E%B0%E6%9F%90%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84Session%E4%B8%A2%E5%A4%B1%E7%8E%87%E5%BE%88%E9%AB%98%E6%97%B6%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">11. 当发现某台服务器的Session丢失率很高时，你的排查思路是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E5%8F%8D%E6%98%A0%E7%BB%8F%E5%B8%B8%E8%A2%AB%E8%A6%81%E6%B1%82%E9%87%8D%E5%A4%8D%E7%99%BB%E5%BD%95%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">12. 如果用户反映经常被要求重复登录，你觉得可能是什么原因导致的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A9%E5%AE%B9%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95%E7%9A%84%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">13. 在服务器扩容时，如何保证源地址哈希法的会话保持不受影响？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%A9%E5%B1%95%E6%80%9D%E8%80%83%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">五、扩展思考类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E9%99%A4%E4%BA%86Session%E5%85%B1%E4%BA%AB%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">14. 除了Session共享，还有哪些方法可以解决无状态服务的数据一致性问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E9%9A%8F%E7%9D%80%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E6%99%AE%E5%8F%8A%EF%BC%8C%E4%BC%A0%E7%BB%9F%E7%9A%84Session%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E9%9D%A2%E4%B8%B4%E5%93%AA%E4%BA%9B%E6%8C%91%E6%88%98%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">15. 随着前后端分离和移动端的普及，传统的Session管理方式面临哪些挑战？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E5%B9%B3%E8%A1%A1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7%E5%92%8C%E4%B8%9A%E5%8A%A1%E7%89%B9%E6%AE%8A%E6%80%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">16. 如何平衡负载均衡的公平性和业务特殊性之间的关系？</span></a></div></div></div></div></main><footer id="footer" style="background-image: url(/img/aaaset/title.png);"><div class="footer-other"><div class="footer-copyright"></div><div class="footer_custom_text">-899</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'kizzy899/kizzy899.github.io',
      'data-repo-id': 'R_kgDONCC1iQ',
      'data-category-id': 'DIC_kwDONCC1ic4CtwTu',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="8,9,小,金" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>